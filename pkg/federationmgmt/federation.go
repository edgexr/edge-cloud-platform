// Copyright 2022 MobiledgeX, Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package federationmgmt

import (
	"context"
	"fmt"
	"strconv"
	"strings"

	"github.com/edgexr/edge-cloud-platform/pkg/log"
	"github.com/edgexr/edge-cloud-platform/pkg/vault"
)

const (
	FederationTypeProvider = "provider"
	FederationTypeConsumer = "consumer"
)

// FedKey uniquely identifies a federation provider or consumer.
// We include the ID generated by postgres to avoid aliasing in caches
// if a provider is deleted and recreated with the same name.
type FedKey struct {
	OperatorId string
	Name       string
	FedType    string
	ID         uint
}

type ApiKey struct {
	Id       string `json:"id"`
	Key      string `json:"key"`
	TokenUrl string `json:"tokenurl"`
}

// Get the username to associate with the api key.
// The username uniquely identifies the federation provider or consumer,
// so we can lookup the provider/consumer based on the username.
func GetFedApiKeyUser(ownerType string, id uint) string {
	return ownerType + "::" + strconv.FormatInt(int64(id), 10)
}

func ParseFedKeyUser(username string) (string, uint, error) {
	kvs := strings.SplitN(username, "::", 2)
	if len(kvs) != 2 {
		return "", 0, fmt.Errorf("unable to split into two by ::")
	}
	id, err := strconv.ParseUint(kvs[1], 10, 64)
	if err != nil {
		return "", 0, fmt.Errorf("failed to parse ID of fedkey username %s: %s", username, err)
	}
	return kvs[0], uint(id), nil
}

func getApiKeyVaultPath(fedKey *FedKey) string {
	return fmt.Sprintf("secret/data/federation/%s/%s/%s", fedKey.OperatorId, fedKey.FedType, fedKey.Name)
}

func GetFederationAPIKey(ctx context.Context, vaultConfig *vault.Config, fedKey *FedKey) (*ApiKey, error) {
	log.SpanLog(ctx, log.DebugLevelInfra, "fetch federation API key", "fedKey", *fedKey)
	vaultPath := getApiKeyVaultPath(fedKey)
	apiKey := &ApiKey{}
	err := vault.GetData(vaultConfig, vaultPath, 0, apiKey)
	if err != nil {
		return nil, fmt.Errorf("Unable to find federation API key from vault path %s, %v", vaultPath, err)
	}
	if apiKey.Key == "" {
		return nil, fmt.Errorf("Unable to find federation API key from vault path %s", vaultPath)
	}
	return apiKey, nil
}

func PutAPIKeyToVault(ctx context.Context, vaultConfig *vault.Config, fedKey *FedKey, apiKey *ApiKey) error {
	log.SpanLog(ctx, log.DebugLevelInfra, "upload federation API key to vault", "fedKey", *fedKey)
	vPath := getApiKeyVaultPath(fedKey)
	err := vault.PutData(vaultConfig, vPath, apiKey)
	if err != nil {
		return fmt.Errorf("Unable to store partner API key in vault: %s", err)
	}
	return nil
}

func DeleteAPIKeyFromVault(ctx context.Context, vaultConfig *vault.Config, fedKey *FedKey) error {
	log.SpanLog(ctx, log.DebugLevelInfra, "delete federation API key rom vault", "fedKey", *fedKey)
	client, err := vaultConfig.Login()
	if err == nil {
		err = vault.DeleteKV(client, getApiKeyVaultPath(fedKey))
		if err != nil {
			return fmt.Errorf("Failed to delete API Key from vault %v, %v", *fedKey, err)
		}
		return nil
	}
	return fmt.Errorf("Failed to login in to vault to delete partner federation API key %v, %v", *fedKey, err)
}
