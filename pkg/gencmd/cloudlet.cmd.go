// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: cloudlet.proto

package gencmd

import (
	"context"
	fmt "fmt"
	_ "github.com/edgexr/edge-cloud-platform/api/distributed_match_engine"
	distributed_match_engine "github.com/edgexr/edge-cloud-platform/api/distributed_match_engine"
	edgeproto "github.com/edgexr/edge-cloud-platform/api/edgeproto"
	"github.com/edgexr/edge-cloud-platform/pkg/cli"
	_ "github.com/edgexr/edge-cloud-platform/tools/protogen"
	_ "github.com/gogo/googleapis/google/api"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	"github.com/spf13/cobra"
	"google.golang.org/grpc/status"
	"io"
	math "math"
	"strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Auto-generated code: DO NOT EDIT
func PlatformConfigHideTags(in *edgeproto.PlatformConfig) {
	if cli.HideTags == "" {
		return
	}
	tags := make(map[string]struct{})
	for _, tag := range strings.Split(cli.HideTags, ",") {
		tags[tag] = struct{}{}
	}
	if _, found := tags["nocmp"]; found {
		in.NotifyCtrlAddrs = ""
	}
	if _, found := tags["nocmp"]; found {
		in.PlatformTag = ""
	}
	if _, found := tags["nocmp"]; found {
		in.Span = ""
	}
	if _, found := tags["nocmp"]; found {
		in.CrmAccessPrivateKey = ""
	}
	if _, found := tags["nocmp"]; found {
		in.AccessApiAddr = ""
	}
	if _, found := tags["nocmp"]; found {
		in.SecondaryCrmAccessPrivateKey = ""
	}
}

func CloudletHideTags(in *edgeproto.Cloudlet) {
	if cli.HideTags == "" {
		return
	}
	tags := make(map[string]struct{})
	for _, tag := range strings.Split(cli.HideTags, ",") {
		tags[tag] = struct{}{}
	}
	if _, found := tags["nocmp"]; found {
		in.Errors = nil
	}
	if _, found := tags["nocmp"]; found {
		in.NotifySrvAddr = ""
	}
	if _, found := tags["nocmp"]; found {
		in.Config.NotifyCtrlAddrs = ""
	}
	if _, found := tags["nocmp"]; found {
		in.Config.PlatformTag = ""
	}
	if _, found := tags["nocmp"]; found {
		in.Config.Span = ""
	}
	if _, found := tags["nocmp"]; found {
		in.Config.CrmAccessPrivateKey = ""
	}
	if _, found := tags["nocmp"]; found {
		in.Config.AccessApiAddr = ""
	}
	if _, found := tags["nocmp"]; found {
		in.Config.SecondaryCrmAccessPrivateKey = ""
	}
	if _, found := tags["nocmp"]; found {
		in.CrmAccessPublicKey = ""
	}
	if _, found := tags["timestamp"]; found {
		in.CreatedAt = distributed_match_engine.Timestamp{}
	}
	if _, found := tags["timestamp"]; found {
		in.UpdatedAt = distributed_match_engine.Timestamp{}
	}
	for i0 := 0; i0 < len(in.ResourceQuotas); i0++ {
	}
	if _, found := tags["nocmp"]; found {
		in.HostController = ""
	}
	if _, found := tags["nocmp"]; found {
		in.SecondaryCrmAccessPublicKey = ""
	}
	if _, found := tags["nocmp"]; found {
		in.SecondaryNotifySrvAddr = ""
	}
	for i0 := 0; i0 < len(in.InfraFlavors); i0++ {
		for i1 := 0; i1 < len(in.InfraFlavors[i0].Gpus); i1++ {
		}
	}
	if _, found := tags["nocmp"]; found {
		in.ObjId = ""
	}
	if _, found := tags["nocmp"]; found {
		in.DbModelId = 0
	}
}

func CloudletInfoHideTags(in *edgeproto.CloudletInfo) {
	if cli.HideTags == "" {
		return
	}
	tags := make(map[string]struct{})
	for _, tag := range strings.Split(cli.HideTags, ",") {
		tags[tag] = struct{}{}
	}
	if _, found := tags["nocmp"]; found {
		in.NotifyId = 0
	}
	if _, found := tags["nocmp"]; found {
		in.Controller = ""
	}
	for i0 := 0; i0 < len(in.Flavors); i0++ {
		for i1 := 0; i1 < len(in.Flavors[i0].Gpus); i1++ {
		}
	}
	if _, found := tags["nocmp"]; found {
		in.Status = edgeproto.StatusInfo{}
	}
	for i0 := 0; i0 < len(in.AvailabilityZones); i0++ {
	}
	for i0 := 0; i0 < len(in.OsImages); i0++ {
	}
	for i1 := 0; i1 < len(in.ResourcesSnapshot.PlatformVms); i1++ {
		for i2 := 0; i2 < len(in.ResourcesSnapshot.PlatformVms[i1].Ipaddresses); i2++ {
		}
		for i2 := 0; i2 < len(in.ResourcesSnapshot.PlatformVms[i1].Containers); i2++ {
		}
	}
	for i1 := 0; i1 < len(in.ResourcesSnapshot.Info); i1++ {
	}
	for i1 := 0; i1 < len(in.ResourcesSnapshot.ClusterInsts); i1++ {
	}
	for i1 := 0; i1 < len(in.ResourcesSnapshot.VmAppInsts); i1++ {
	}
	for i1 := 0; i1 < len(in.ResourcesSnapshot.K8SAppInsts); i1++ {
	}
	if _, found := tags["nocmp"]; found {
		in.CompatibilityVersion = 0
	}
	for i0 := 0; i0 < len(in.NodeInfos); i0++ {
		for i1 := 0; i1 < len(in.NodeInfos[i0].Gpus); i1++ {
		}
	}
	for i0 := 0; i0 < len(in.NodePools); i0++ {
		for i2 := 0; i2 < len(in.NodePools[i0].NodeResources.Gpus); i2++ {
		}
	}
}

var PlatformFeaturesApiCmd edgeproto.PlatformFeaturesApiClient

var ShowPlatformFeaturesCmd = &cli.Command{
	Use:          "ShowPlatformFeatures",
	OptionalArgs: strings.Join(append(PlatformFeaturesRequiredArgs, PlatformFeaturesOptionalArgs...), " "),
	AliasArgs:    strings.Join(PlatformFeaturesAliasArgs, " "),
	SpecialArgs:  &PlatformFeaturesSpecialArgs,
	Comments:     PlatformFeaturesComments,
	ReqData:      &edgeproto.PlatformFeatures{},
	ReplyData:    &edgeproto.PlatformFeatures{},
	Run:          runShowPlatformFeatures,
}

func runShowPlatformFeatures(c *cli.Command, args []string) error {
	if cli.SilenceUsage {
		c.CobraCmd.SilenceUsage = true
	}
	obj := c.ReqData.(*edgeproto.PlatformFeatures)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return ShowPlatformFeatures(c, obj)
}

func ShowPlatformFeatures(c *cli.Command, in *edgeproto.PlatformFeatures) error {
	if PlatformFeaturesApiCmd == nil {
		return fmt.Errorf("PlatformFeaturesApi client not initialized")
	}
	ctx := context.Background()
	stream, err := PlatformFeaturesApiCmd.ShowPlatformFeatures(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("ShowPlatformFeatures failed: %s", errstr)
	}

	objs := make([]*edgeproto.PlatformFeatures, 0)
	for {
		obj, err := stream.Recv()
		if err == io.EOF {
			break
		}
		if err != nil {
			errstr := err.Error()
			st, ok := status.FromError(err)
			if ok {
				errstr = st.Message()
			}
			return fmt.Errorf("ShowPlatformFeatures recv failed: %s", errstr)
		}
		objs = append(objs, obj)
	}
	if len(objs) == 0 {
		return nil
	}
	c.WriteOutput(c.CobraCmd.OutOrStdout(), objs, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func ShowPlatformFeaturess(c *cli.Command, data []edgeproto.PlatformFeatures, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("ShowPlatformFeatures %v\n", data[ii])
		myerr := ShowPlatformFeatures(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var DeletePlatformFeaturesCmd = &cli.Command{
	Use:          "DeletePlatformFeatures",
	RequiredArgs: strings.Join(PlatformFeaturesRequiredArgs, " "),
	OptionalArgs: strings.Join(PlatformFeaturesOptionalArgs, " "),
	AliasArgs:    strings.Join(PlatformFeaturesAliasArgs, " "),
	SpecialArgs:  &PlatformFeaturesSpecialArgs,
	Comments:     PlatformFeaturesComments,
	ReqData:      &edgeproto.PlatformFeatures{},
	ReplyData:    &edgeproto.Result{},
	Run:          runDeletePlatformFeatures,
}

func runDeletePlatformFeatures(c *cli.Command, args []string) error {
	if cli.SilenceUsage {
		c.CobraCmd.SilenceUsage = true
	}
	obj := c.ReqData.(*edgeproto.PlatformFeatures)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return DeletePlatformFeatures(c, obj)
}

func DeletePlatformFeatures(c *cli.Command, in *edgeproto.PlatformFeatures) error {
	if PlatformFeaturesApiCmd == nil {
		return fmt.Errorf("PlatformFeaturesApi client not initialized")
	}
	ctx := context.Background()
	obj, err := PlatformFeaturesApiCmd.DeletePlatformFeatures(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("DeletePlatformFeatures failed: %s", errstr)
	}
	c.WriteOutput(c.CobraCmd.OutOrStdout(), obj, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func DeletePlatformFeaturess(c *cli.Command, data []edgeproto.PlatformFeatures, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("DeletePlatformFeatures %v\n", data[ii])
		myerr := DeletePlatformFeatures(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var ShowPlatformFeaturesForZoneCmd = &cli.Command{
	Use:          "ShowPlatformFeaturesForZone",
	RequiredArgs: strings.Join(ShowPlatformFeaturesForZoneRequiredArgs, " "),
	OptionalArgs: strings.Join(ShowPlatformFeaturesForZoneOptionalArgs, " "),
	AliasArgs:    strings.Join(ZoneKeyAliasArgs, " "),
	SpecialArgs:  &ZoneKeySpecialArgs,
	Comments:     ZoneKeyComments,
	ReqData:      &edgeproto.ZoneKey{},
	ReplyData:    &edgeproto.PlatformFeatures{},
	Run:          runShowPlatformFeaturesForZone,
}

func runShowPlatformFeaturesForZone(c *cli.Command, args []string) error {
	if cli.SilenceUsage {
		c.CobraCmd.SilenceUsage = true
	}
	obj := c.ReqData.(*edgeproto.ZoneKey)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return ShowPlatformFeaturesForZone(c, obj)
}

func ShowPlatformFeaturesForZone(c *cli.Command, in *edgeproto.ZoneKey) error {
	if PlatformFeaturesApiCmd == nil {
		return fmt.Errorf("PlatformFeaturesApi client not initialized")
	}
	ctx := context.Background()
	stream, err := PlatformFeaturesApiCmd.ShowPlatformFeaturesForZone(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("ShowPlatformFeaturesForZone failed: %s", errstr)
	}

	objs := make([]*edgeproto.PlatformFeatures, 0)
	for {
		obj, err := stream.Recv()
		if err == io.EOF {
			break
		}
		if err != nil {
			errstr := err.Error()
			st, ok := status.FromError(err)
			if ok {
				errstr = st.Message()
			}
			return fmt.Errorf("ShowPlatformFeaturesForZone recv failed: %s", errstr)
		}
		if cli.OutputStream {
			c.WriteOutput(c.CobraCmd.OutOrStdout(), obj, cli.OutputFormat)
			continue
		}
		objs = append(objs, obj)
	}
	if len(objs) == 0 {
		return nil
	}
	c.WriteOutput(c.CobraCmd.OutOrStdout(), objs, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func ShowPlatformFeaturesForZones(c *cli.Command, data []edgeproto.ZoneKey, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("ShowPlatformFeaturesForZone %v\n", data[ii])
		myerr := ShowPlatformFeaturesForZone(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var PlatformFeaturesApiCmds = []*cobra.Command{
	ShowPlatformFeaturesCmd.GenCmd(),
	DeletePlatformFeaturesCmd.GenCmd(),
	ShowPlatformFeaturesForZoneCmd.GenCmd(),
}

var GPUDriverApiCmd edgeproto.GPUDriverApiClient

var CreateGPUDriverCmd = &cli.Command{
	Use:          "CreateGPUDriver",
	RequiredArgs: strings.Join(GPUDriverRequiredArgs, " "),
	OptionalArgs: strings.Join(GPUDriverOptionalArgs, " "),
	AliasArgs:    strings.Join(GPUDriverAliasArgs, " "),
	SpecialArgs:  &GPUDriverSpecialArgs,
	Comments:     GPUDriverComments,
	ReqData:      &edgeproto.GPUDriver{},
	ReplyData:    &edgeproto.Result{},
	Run:          runCreateGPUDriver,
}

func runCreateGPUDriver(c *cli.Command, args []string) error {
	if cli.SilenceUsage {
		c.CobraCmd.SilenceUsage = true
	}
	obj := c.ReqData.(*edgeproto.GPUDriver)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return CreateGPUDriver(c, obj)
}

func CreateGPUDriver(c *cli.Command, in *edgeproto.GPUDriver) error {
	if GPUDriverApiCmd == nil {
		return fmt.Errorf("GPUDriverApi client not initialized")
	}
	ctx := context.Background()
	stream, err := GPUDriverApiCmd.CreateGPUDriver(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("CreateGPUDriver failed: %s", errstr)
	}

	objs := make([]*edgeproto.Result, 0)
	for {
		obj, err := stream.Recv()
		if err == io.EOF {
			break
		}
		if err != nil {
			errstr := err.Error()
			st, ok := status.FromError(err)
			if ok {
				errstr = st.Message()
			}
			return fmt.Errorf("CreateGPUDriver recv failed: %s", errstr)
		}
		if cli.OutputStream {
			c.WriteOutput(c.CobraCmd.OutOrStdout(), obj, cli.OutputFormat)
			continue
		}
		objs = append(objs, obj)
	}
	if len(objs) == 0 {
		return nil
	}
	c.WriteOutput(c.CobraCmd.OutOrStdout(), objs, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func CreateGPUDrivers(c *cli.Command, data []edgeproto.GPUDriver, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("CreateGPUDriver %v\n", data[ii])
		myerr := CreateGPUDriver(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var DeleteGPUDriverCmd = &cli.Command{
	Use:          "DeleteGPUDriver",
	RequiredArgs: strings.Join(GPUDriverRequiredArgs, " "),
	OptionalArgs: strings.Join(GPUDriverOptionalArgs, " "),
	AliasArgs:    strings.Join(GPUDriverAliasArgs, " "),
	SpecialArgs:  &GPUDriverSpecialArgs,
	Comments:     GPUDriverComments,
	ReqData:      &edgeproto.GPUDriver{},
	ReplyData:    &edgeproto.Result{},
	Run:          runDeleteGPUDriver,
}

func runDeleteGPUDriver(c *cli.Command, args []string) error {
	if cli.SilenceUsage {
		c.CobraCmd.SilenceUsage = true
	}
	obj := c.ReqData.(*edgeproto.GPUDriver)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return DeleteGPUDriver(c, obj)
}

func DeleteGPUDriver(c *cli.Command, in *edgeproto.GPUDriver) error {
	if GPUDriverApiCmd == nil {
		return fmt.Errorf("GPUDriverApi client not initialized")
	}
	ctx := context.Background()
	stream, err := GPUDriverApiCmd.DeleteGPUDriver(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("DeleteGPUDriver failed: %s", errstr)
	}

	objs := make([]*edgeproto.Result, 0)
	for {
		obj, err := stream.Recv()
		if err == io.EOF {
			break
		}
		if err != nil {
			errstr := err.Error()
			st, ok := status.FromError(err)
			if ok {
				errstr = st.Message()
			}
			return fmt.Errorf("DeleteGPUDriver recv failed: %s", errstr)
		}
		if cli.OutputStream {
			c.WriteOutput(c.CobraCmd.OutOrStdout(), obj, cli.OutputFormat)
			continue
		}
		objs = append(objs, obj)
	}
	if len(objs) == 0 {
		return nil
	}
	c.WriteOutput(c.CobraCmd.OutOrStdout(), objs, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func DeleteGPUDrivers(c *cli.Command, data []edgeproto.GPUDriver, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("DeleteGPUDriver %v\n", data[ii])
		myerr := DeleteGPUDriver(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var UpdateGPUDriverCmd = &cli.Command{
	Use:          "UpdateGPUDriver",
	RequiredArgs: strings.Join(UpdateGPUDriverRequiredArgs, " "),
	OptionalArgs: strings.Join(UpdateGPUDriverOptionalArgs, " "),
	AliasArgs:    strings.Join(GPUDriverAliasArgs, " "),
	SpecialArgs:  &GPUDriverSpecialArgs,
	Comments:     GPUDriverComments,
	ReqData:      &edgeproto.GPUDriver{},
	ReplyData:    &edgeproto.Result{},
	Run:          runUpdateGPUDriver,
}

func runUpdateGPUDriver(c *cli.Command, args []string) error {
	if cli.SilenceUsage {
		c.CobraCmd.SilenceUsage = true
	}
	obj := c.ReqData.(*edgeproto.GPUDriver)
	jsonMap, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	obj.Fields = cli.GetSpecifiedFields(jsonMap, c.ReqData)
	return UpdateGPUDriver(c, obj)
}

func UpdateGPUDriver(c *cli.Command, in *edgeproto.GPUDriver) error {
	if GPUDriverApiCmd == nil {
		return fmt.Errorf("GPUDriverApi client not initialized")
	}
	ctx := context.Background()
	stream, err := GPUDriverApiCmd.UpdateGPUDriver(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("UpdateGPUDriver failed: %s", errstr)
	}

	objs := make([]*edgeproto.Result, 0)
	for {
		obj, err := stream.Recv()
		if err == io.EOF {
			break
		}
		if err != nil {
			errstr := err.Error()
			st, ok := status.FromError(err)
			if ok {
				errstr = st.Message()
			}
			return fmt.Errorf("UpdateGPUDriver recv failed: %s", errstr)
		}
		if cli.OutputStream {
			c.WriteOutput(c.CobraCmd.OutOrStdout(), obj, cli.OutputFormat)
			continue
		}
		objs = append(objs, obj)
	}
	if len(objs) == 0 {
		return nil
	}
	c.WriteOutput(c.CobraCmd.OutOrStdout(), objs, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func UpdateGPUDrivers(c *cli.Command, data []edgeproto.GPUDriver, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("UpdateGPUDriver %v\n", data[ii])
		myerr := UpdateGPUDriver(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var ShowGPUDriverCmd = &cli.Command{
	Use:          "ShowGPUDriver",
	OptionalArgs: strings.Join(append(GPUDriverRequiredArgs, GPUDriverOptionalArgs...), " "),
	AliasArgs:    strings.Join(GPUDriverAliasArgs, " "),
	SpecialArgs:  &GPUDriverSpecialArgs,
	Comments:     GPUDriverComments,
	ReqData:      &edgeproto.GPUDriver{},
	ReplyData:    &edgeproto.GPUDriver{},
	Run:          runShowGPUDriver,
}

func runShowGPUDriver(c *cli.Command, args []string) error {
	if cli.SilenceUsage {
		c.CobraCmd.SilenceUsage = true
	}
	obj := c.ReqData.(*edgeproto.GPUDriver)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return ShowGPUDriver(c, obj)
}

func ShowGPUDriver(c *cli.Command, in *edgeproto.GPUDriver) error {
	if GPUDriverApiCmd == nil {
		return fmt.Errorf("GPUDriverApi client not initialized")
	}
	ctx := context.Background()
	stream, err := GPUDriverApiCmd.ShowGPUDriver(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("ShowGPUDriver failed: %s", errstr)
	}

	objs := make([]*edgeproto.GPUDriver, 0)
	for {
		obj, err := stream.Recv()
		if err == io.EOF {
			break
		}
		if err != nil {
			errstr := err.Error()
			st, ok := status.FromError(err)
			if ok {
				errstr = st.Message()
			}
			return fmt.Errorf("ShowGPUDriver recv failed: %s", errstr)
		}
		if cli.OutputStream {
			c.WriteOutput(c.CobraCmd.OutOrStdout(), obj, cli.OutputFormat)
			continue
		}
		objs = append(objs, obj)
	}
	if len(objs) == 0 {
		return nil
	}
	c.WriteOutput(c.CobraCmd.OutOrStdout(), objs, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func ShowGPUDrivers(c *cli.Command, data []edgeproto.GPUDriver, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("ShowGPUDriver %v\n", data[ii])
		myerr := ShowGPUDriver(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var AddGPUDriverBuildCmd = &cli.Command{
	Use:          "AddGPUDriverBuild",
	RequiredArgs: strings.Join(AddGPUDriverBuildRequiredArgs, " "),
	OptionalArgs: strings.Join(AddGPUDriverBuildOptionalArgs, " "),
	AliasArgs:    strings.Join(GPUDriverBuildMemberAliasArgs, " "),
	SpecialArgs:  &GPUDriverBuildMemberSpecialArgs,
	Comments:     GPUDriverBuildMemberComments,
	ReqData:      &edgeproto.GPUDriverBuildMember{},
	ReplyData:    &edgeproto.Result{},
	Run:          runAddGPUDriverBuild,
}

func runAddGPUDriverBuild(c *cli.Command, args []string) error {
	if cli.SilenceUsage {
		c.CobraCmd.SilenceUsage = true
	}
	obj := c.ReqData.(*edgeproto.GPUDriverBuildMember)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return AddGPUDriverBuild(c, obj)
}

func AddGPUDriverBuild(c *cli.Command, in *edgeproto.GPUDriverBuildMember) error {
	if GPUDriverApiCmd == nil {
		return fmt.Errorf("GPUDriverApi client not initialized")
	}
	ctx := context.Background()
	stream, err := GPUDriverApiCmd.AddGPUDriverBuild(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("AddGPUDriverBuild failed: %s", errstr)
	}

	objs := make([]*edgeproto.Result, 0)
	for {
		obj, err := stream.Recv()
		if err == io.EOF {
			break
		}
		if err != nil {
			errstr := err.Error()
			st, ok := status.FromError(err)
			if ok {
				errstr = st.Message()
			}
			return fmt.Errorf("AddGPUDriverBuild recv failed: %s", errstr)
		}
		if cli.OutputStream {
			c.WriteOutput(c.CobraCmd.OutOrStdout(), obj, cli.OutputFormat)
			continue
		}
		objs = append(objs, obj)
	}
	if len(objs) == 0 {
		return nil
	}
	c.WriteOutput(c.CobraCmd.OutOrStdout(), objs, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func AddGPUDriverBuilds(c *cli.Command, data []edgeproto.GPUDriverBuildMember, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("AddGPUDriverBuild %v\n", data[ii])
		myerr := AddGPUDriverBuild(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var RemoveGPUDriverBuildCmd = &cli.Command{
	Use:          "RemoveGPUDriverBuild",
	RequiredArgs: strings.Join(RemoveGPUDriverBuildRequiredArgs, " "),
	OptionalArgs: strings.Join(RemoveGPUDriverBuildOptionalArgs, " "),
	AliasArgs:    strings.Join(GPUDriverBuildMemberAliasArgs, " "),
	SpecialArgs:  &GPUDriverBuildMemberSpecialArgs,
	Comments:     GPUDriverBuildMemberComments,
	ReqData:      &edgeproto.GPUDriverBuildMember{},
	ReplyData:    &edgeproto.Result{},
	Run:          runRemoveGPUDriverBuild,
}

func runRemoveGPUDriverBuild(c *cli.Command, args []string) error {
	if cli.SilenceUsage {
		c.CobraCmd.SilenceUsage = true
	}
	obj := c.ReqData.(*edgeproto.GPUDriverBuildMember)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return RemoveGPUDriverBuild(c, obj)
}

func RemoveGPUDriverBuild(c *cli.Command, in *edgeproto.GPUDriverBuildMember) error {
	if GPUDriverApiCmd == nil {
		return fmt.Errorf("GPUDriverApi client not initialized")
	}
	ctx := context.Background()
	stream, err := GPUDriverApiCmd.RemoveGPUDriverBuild(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("RemoveGPUDriverBuild failed: %s", errstr)
	}

	objs := make([]*edgeproto.Result, 0)
	for {
		obj, err := stream.Recv()
		if err == io.EOF {
			break
		}
		if err != nil {
			errstr := err.Error()
			st, ok := status.FromError(err)
			if ok {
				errstr = st.Message()
			}
			return fmt.Errorf("RemoveGPUDriverBuild recv failed: %s", errstr)
		}
		if cli.OutputStream {
			c.WriteOutput(c.CobraCmd.OutOrStdout(), obj, cli.OutputFormat)
			continue
		}
		objs = append(objs, obj)
	}
	if len(objs) == 0 {
		return nil
	}
	c.WriteOutput(c.CobraCmd.OutOrStdout(), objs, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func RemoveGPUDriverBuilds(c *cli.Command, data []edgeproto.GPUDriverBuildMember, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("RemoveGPUDriverBuild %v\n", data[ii])
		myerr := RemoveGPUDriverBuild(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var GetGPUDriverBuildURLCmd = &cli.Command{
	Use:          "GetGPUDriverBuildURL",
	RequiredArgs: strings.Join(GetGPUDriverBuildURLRequiredArgs, " "),
	OptionalArgs: strings.Join(GetGPUDriverBuildURLOptionalArgs, " "),
	AliasArgs:    strings.Join(GPUDriverBuildMemberAliasArgs, " "),
	SpecialArgs:  &GPUDriverBuildMemberSpecialArgs,
	Comments:     GPUDriverBuildMemberComments,
	ReqData:      &edgeproto.GPUDriverBuildMember{},
	ReplyData:    &edgeproto.GPUDriverBuildURL{},
	Run:          runGetGPUDriverBuildURL,
}

func runGetGPUDriverBuildURL(c *cli.Command, args []string) error {
	if cli.SilenceUsage {
		c.CobraCmd.SilenceUsage = true
	}
	obj := c.ReqData.(*edgeproto.GPUDriverBuildMember)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return GetGPUDriverBuildURL(c, obj)
}

func GetGPUDriverBuildURL(c *cli.Command, in *edgeproto.GPUDriverBuildMember) error {
	if GPUDriverApiCmd == nil {
		return fmt.Errorf("GPUDriverApi client not initialized")
	}
	ctx := context.Background()
	obj, err := GPUDriverApiCmd.GetGPUDriverBuildURL(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("GetGPUDriverBuildURL failed: %s", errstr)
	}
	c.WriteOutput(c.CobraCmd.OutOrStdout(), obj, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func GetGPUDriverBuildURLs(c *cli.Command, data []edgeproto.GPUDriverBuildMember, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("GetGPUDriverBuildURL %v\n", data[ii])
		myerr := GetGPUDriverBuildURL(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var GetGPUDriverLicenseConfigCmd = &cli.Command{
	Use:          "GetGPUDriverLicenseConfig",
	RequiredArgs: strings.Join(GPUDriverKeyRequiredArgs, " "),
	OptionalArgs: strings.Join(GPUDriverKeyOptionalArgs, " "),
	AliasArgs:    strings.Join(GPUDriverKeyAliasArgs, " "),
	SpecialArgs:  &GPUDriverKeySpecialArgs,
	Comments:     GPUDriverKeyComments,
	ReqData:      &edgeproto.GPUDriverKey{},
	ReplyData:    &edgeproto.Result{},
	Run:          runGetGPUDriverLicenseConfig,
}

func runGetGPUDriverLicenseConfig(c *cli.Command, args []string) error {
	if cli.SilenceUsage {
		c.CobraCmd.SilenceUsage = true
	}
	obj := c.ReqData.(*edgeproto.GPUDriverKey)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return GetGPUDriverLicenseConfig(c, obj)
}

func GetGPUDriverLicenseConfig(c *cli.Command, in *edgeproto.GPUDriverKey) error {
	if GPUDriverApiCmd == nil {
		return fmt.Errorf("GPUDriverApi client not initialized")
	}
	ctx := context.Background()
	obj, err := GPUDriverApiCmd.GetGPUDriverLicenseConfig(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("GetGPUDriverLicenseConfig failed: %s", errstr)
	}
	c.WriteOutput(c.CobraCmd.OutOrStdout(), obj, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func GetGPUDriverLicenseConfigs(c *cli.Command, data []edgeproto.GPUDriverKey, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("GetGPUDriverLicenseConfig %v\n", data[ii])
		myerr := GetGPUDriverLicenseConfig(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var GPUDriverApiCmds = []*cobra.Command{
	CreateGPUDriverCmd.GenCmd(),
	DeleteGPUDriverCmd.GenCmd(),
	UpdateGPUDriverCmd.GenCmd(),
	ShowGPUDriverCmd.GenCmd(),
	AddGPUDriverBuildCmd.GenCmd(),
	RemoveGPUDriverBuildCmd.GenCmd(),
	GetGPUDriverBuildURLCmd.GenCmd(),
	GetGPUDriverLicenseConfigCmd.GenCmd(),
}

var CloudletApiCmd edgeproto.CloudletApiClient

var CreateCloudletCmd = &cli.Command{
	Use:          "CreateCloudlet",
	RequiredArgs: strings.Join(CreateCloudletRequiredArgs, " "),
	OptionalArgs: strings.Join(CreateCloudletOptionalArgs, " "),
	AliasArgs:    strings.Join(CloudletAliasArgs, " "),
	SpecialArgs:  &CloudletSpecialArgs,
	Comments:     CloudletComments,
	ReqData:      &edgeproto.Cloudlet{},
	ReplyData:    &edgeproto.Result{},
	Run:          runCreateCloudlet,
}

func runCreateCloudlet(c *cli.Command, args []string) error {
	if cli.SilenceUsage {
		c.CobraCmd.SilenceUsage = true
	}
	obj := c.ReqData.(*edgeproto.Cloudlet)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return CreateCloudlet(c, obj)
}

func CreateCloudlet(c *cli.Command, in *edgeproto.Cloudlet) error {
	if CloudletApiCmd == nil {
		return fmt.Errorf("CloudletApi client not initialized")
	}
	ctx := context.Background()
	stream, err := CloudletApiCmd.CreateCloudlet(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("CreateCloudlet failed: %s", errstr)
	}

	objs := make([]*edgeproto.Result, 0)
	for {
		obj, err := stream.Recv()
		if err == io.EOF {
			break
		}
		if err != nil {
			errstr := err.Error()
			st, ok := status.FromError(err)
			if ok {
				errstr = st.Message()
			}
			return fmt.Errorf("CreateCloudlet recv failed: %s", errstr)
		}
		if cli.OutputStream {
			c.WriteOutput(c.CobraCmd.OutOrStdout(), obj, cli.OutputFormat)
			continue
		}
		objs = append(objs, obj)
	}
	if len(objs) == 0 {
		return nil
	}
	c.WriteOutput(c.CobraCmd.OutOrStdout(), objs, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func CreateCloudlets(c *cli.Command, data []edgeproto.Cloudlet, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("CreateCloudlet %v\n", data[ii])
		myerr := CreateCloudlet(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var DeleteCloudletCmd = &cli.Command{
	Use:          "DeleteCloudlet",
	RequiredArgs: strings.Join(DeleteCloudletRequiredArgs, " "),
	OptionalArgs: strings.Join(DeleteCloudletOptionalArgs, " "),
	AliasArgs:    strings.Join(CloudletAliasArgs, " "),
	SpecialArgs:  &CloudletSpecialArgs,
	Comments:     CloudletComments,
	ReqData:      &edgeproto.Cloudlet{},
	ReplyData:    &edgeproto.Result{},
	Run:          runDeleteCloudlet,
}

func runDeleteCloudlet(c *cli.Command, args []string) error {
	if cli.SilenceUsage {
		c.CobraCmd.SilenceUsage = true
	}
	obj := c.ReqData.(*edgeproto.Cloudlet)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return DeleteCloudlet(c, obj)
}

func DeleteCloudlet(c *cli.Command, in *edgeproto.Cloudlet) error {
	if CloudletApiCmd == nil {
		return fmt.Errorf("CloudletApi client not initialized")
	}
	ctx := context.Background()
	stream, err := CloudletApiCmd.DeleteCloudlet(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("DeleteCloudlet failed: %s", errstr)
	}

	objs := make([]*edgeproto.Result, 0)
	for {
		obj, err := stream.Recv()
		if err == io.EOF {
			break
		}
		if err != nil {
			errstr := err.Error()
			st, ok := status.FromError(err)
			if ok {
				errstr = st.Message()
			}
			return fmt.Errorf("DeleteCloudlet recv failed: %s", errstr)
		}
		if cli.OutputStream {
			c.WriteOutput(c.CobraCmd.OutOrStdout(), obj, cli.OutputFormat)
			continue
		}
		objs = append(objs, obj)
	}
	if len(objs) == 0 {
		return nil
	}
	c.WriteOutput(c.CobraCmd.OutOrStdout(), objs, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func DeleteCloudlets(c *cli.Command, data []edgeproto.Cloudlet, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("DeleteCloudlet %v\n", data[ii])
		myerr := DeleteCloudlet(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var UpdateCloudletCmd = &cli.Command{
	Use:          "UpdateCloudlet",
	RequiredArgs: strings.Join(UpdateCloudletRequiredArgs, " "),
	OptionalArgs: strings.Join(UpdateCloudletOptionalArgs, " "),
	AliasArgs:    strings.Join(CloudletAliasArgs, " "),
	SpecialArgs:  &CloudletSpecialArgs,
	Comments:     CloudletComments,
	ReqData:      &edgeproto.Cloudlet{},
	ReplyData:    &edgeproto.Result{},
	Run:          runUpdateCloudlet,
}

func runUpdateCloudlet(c *cli.Command, args []string) error {
	if cli.SilenceUsage {
		c.CobraCmd.SilenceUsage = true
	}
	obj := c.ReqData.(*edgeproto.Cloudlet)
	jsonMap, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	obj.Fields = cli.GetSpecifiedFields(jsonMap, c.ReqData)
	return UpdateCloudlet(c, obj)
}

func UpdateCloudlet(c *cli.Command, in *edgeproto.Cloudlet) error {
	if CloudletApiCmd == nil {
		return fmt.Errorf("CloudletApi client not initialized")
	}
	ctx := context.Background()
	stream, err := CloudletApiCmd.UpdateCloudlet(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("UpdateCloudlet failed: %s", errstr)
	}

	objs := make([]*edgeproto.Result, 0)
	for {
		obj, err := stream.Recv()
		if err == io.EOF {
			break
		}
		if err != nil {
			errstr := err.Error()
			st, ok := status.FromError(err)
			if ok {
				errstr = st.Message()
			}
			return fmt.Errorf("UpdateCloudlet recv failed: %s", errstr)
		}
		if cli.OutputStream {
			c.WriteOutput(c.CobraCmd.OutOrStdout(), obj, cli.OutputFormat)
			continue
		}
		objs = append(objs, obj)
	}
	if len(objs) == 0 {
		return nil
	}
	c.WriteOutput(c.CobraCmd.OutOrStdout(), objs, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func UpdateCloudlets(c *cli.Command, data []edgeproto.Cloudlet, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("UpdateCloudlet %v\n", data[ii])
		myerr := UpdateCloudlet(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var ShowCloudletCmd = &cli.Command{
	Use:          "ShowCloudlet",
	OptionalArgs: strings.Join(append(CloudletRequiredArgs, CloudletOptionalArgs...), " "),
	AliasArgs:    strings.Join(CloudletAliasArgs, " "),
	SpecialArgs:  &CloudletSpecialArgs,
	Comments:     CloudletComments,
	ReqData:      &edgeproto.Cloudlet{},
	ReplyData:    &edgeproto.Cloudlet{},
	Run:          runShowCloudlet,
}

func runShowCloudlet(c *cli.Command, args []string) error {
	if cli.SilenceUsage {
		c.CobraCmd.SilenceUsage = true
	}
	obj := c.ReqData.(*edgeproto.Cloudlet)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return ShowCloudlet(c, obj)
}

func ShowCloudlet(c *cli.Command, in *edgeproto.Cloudlet) error {
	if CloudletApiCmd == nil {
		return fmt.Errorf("CloudletApi client not initialized")
	}
	ctx := context.Background()
	stream, err := CloudletApiCmd.ShowCloudlet(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("ShowCloudlet failed: %s", errstr)
	}

	objs := make([]*edgeproto.Cloudlet, 0)
	for {
		obj, err := stream.Recv()
		if err == io.EOF {
			break
		}
		if err != nil {
			errstr := err.Error()
			st, ok := status.FromError(err)
			if ok {
				errstr = st.Message()
			}
			return fmt.Errorf("ShowCloudlet recv failed: %s", errstr)
		}
		CloudletHideTags(obj)
		objs = append(objs, obj)
	}
	if len(objs) == 0 {
		return nil
	}
	c.WriteOutput(c.CobraCmd.OutOrStdout(), objs, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func ShowCloudlets(c *cli.Command, data []edgeproto.Cloudlet, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("ShowCloudlet %v\n", data[ii])
		myerr := ShowCloudlet(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var GetCloudletManifestCmd = &cli.Command{
	Use:          "GetCloudletManifest",
	RequiredArgs: strings.Join(CloudletKeyRequiredArgs, " "),
	OptionalArgs: strings.Join(CloudletKeyOptionalArgs, " "),
	AliasArgs:    strings.Join(CloudletKeyAliasArgs, " "),
	SpecialArgs:  &CloudletKeySpecialArgs,
	Comments:     CloudletKeyComments,
	ReqData:      &edgeproto.CloudletKey{},
	ReplyData:    &edgeproto.CloudletManifest{},
	Run:          runGetCloudletManifest,
}

func runGetCloudletManifest(c *cli.Command, args []string) error {
	if cli.SilenceUsage {
		c.CobraCmd.SilenceUsage = true
	}
	obj := c.ReqData.(*edgeproto.CloudletKey)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return GetCloudletManifest(c, obj)
}

func GetCloudletManifest(c *cli.Command, in *edgeproto.CloudletKey) error {
	if CloudletApiCmd == nil {
		return fmt.Errorf("CloudletApi client not initialized")
	}
	ctx := context.Background()
	obj, err := CloudletApiCmd.GetCloudletManifest(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("GetCloudletManifest failed: %s", errstr)
	}
	c.WriteOutput(c.CobraCmd.OutOrStdout(), obj, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func GetCloudletManifests(c *cli.Command, data []edgeproto.CloudletKey, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("GetCloudletManifest %v\n", data[ii])
		myerr := GetCloudletManifest(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var GetCloudletPropsCmd = &cli.Command{
	Use:          "GetCloudletProps",
	RequiredArgs: strings.Join(GetCloudletPropsRequiredArgs, " "),
	OptionalArgs: strings.Join(GetCloudletPropsOptionalArgs, " "),
	AliasArgs:    strings.Join(CloudletPropsAliasArgs, " "),
	SpecialArgs:  &CloudletPropsSpecialArgs,
	Comments:     CloudletPropsComments,
	ReqData:      &edgeproto.CloudletProps{},
	ReplyData:    &edgeproto.CloudletProps{},
	Run:          runGetCloudletProps,
}

func runGetCloudletProps(c *cli.Command, args []string) error {
	if cli.SilenceUsage {
		c.CobraCmd.SilenceUsage = true
	}
	obj := c.ReqData.(*edgeproto.CloudletProps)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return GetCloudletProps(c, obj)
}

func GetCloudletProps(c *cli.Command, in *edgeproto.CloudletProps) error {
	if CloudletApiCmd == nil {
		return fmt.Errorf("CloudletApi client not initialized")
	}
	ctx := context.Background()
	obj, err := CloudletApiCmd.GetCloudletProps(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("GetCloudletProps failed: %s", errstr)
	}
	c.WriteOutput(c.CobraCmd.OutOrStdout(), obj, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func GetCloudletPropss(c *cli.Command, data []edgeproto.CloudletProps, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("GetCloudletProps %v\n", data[ii])
		myerr := GetCloudletProps(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var GetCloudletResourceQuotaPropsCmd = &cli.Command{
	Use:          "GetCloudletResourceQuotaProps",
	RequiredArgs: strings.Join(GetCloudletResourceQuotaPropsRequiredArgs, " "),
	OptionalArgs: strings.Join(GetCloudletResourceQuotaPropsOptionalArgs, " "),
	AliasArgs:    strings.Join(CloudletResourceQuotaPropsAliasArgs, " "),
	SpecialArgs:  &CloudletResourceQuotaPropsSpecialArgs,
	Comments:     CloudletResourceQuotaPropsComments,
	ReqData:      &edgeproto.CloudletResourceQuotaProps{},
	ReplyData:    &edgeproto.CloudletResourceQuotaProps{},
	Run:          runGetCloudletResourceQuotaProps,
}

func runGetCloudletResourceQuotaProps(c *cli.Command, args []string) error {
	if cli.SilenceUsage {
		c.CobraCmd.SilenceUsage = true
	}
	obj := c.ReqData.(*edgeproto.CloudletResourceQuotaProps)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return GetCloudletResourceQuotaProps(c, obj)
}

func GetCloudletResourceQuotaProps(c *cli.Command, in *edgeproto.CloudletResourceQuotaProps) error {
	if CloudletApiCmd == nil {
		return fmt.Errorf("CloudletApi client not initialized")
	}
	ctx := context.Background()
	obj, err := CloudletApiCmd.GetCloudletResourceQuotaProps(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("GetCloudletResourceQuotaProps failed: %s", errstr)
	}
	c.WriteOutput(c.CobraCmd.OutOrStdout(), obj, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func GetCloudletResourceQuotaPropss(c *cli.Command, data []edgeproto.CloudletResourceQuotaProps, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("GetCloudletResourceQuotaProps %v\n", data[ii])
		myerr := GetCloudletResourceQuotaProps(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var GetCloudletResourceUsageCmd = &cli.Command{
	Use:          "GetCloudletResourceUsage",
	RequiredArgs: strings.Join(GetCloudletResourceUsageRequiredArgs, " "),
	OptionalArgs: strings.Join(GetCloudletResourceUsageOptionalArgs, " "),
	AliasArgs:    strings.Join(CloudletResourceUsageAliasArgs, " "),
	SpecialArgs:  &CloudletResourceUsageSpecialArgs,
	Comments:     CloudletResourceUsageComments,
	ReqData:      &edgeproto.CloudletResourceUsage{},
	ReplyData:    &edgeproto.CloudletResourceUsage{},
	Run:          runGetCloudletResourceUsage,
}

func runGetCloudletResourceUsage(c *cli.Command, args []string) error {
	if cli.SilenceUsage {
		c.CobraCmd.SilenceUsage = true
	}
	obj := c.ReqData.(*edgeproto.CloudletResourceUsage)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return GetCloudletResourceUsage(c, obj)
}

func GetCloudletResourceUsage(c *cli.Command, in *edgeproto.CloudletResourceUsage) error {
	if CloudletApiCmd == nil {
		return fmt.Errorf("CloudletApi client not initialized")
	}
	ctx := context.Background()
	obj, err := CloudletApiCmd.GetCloudletResourceUsage(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("GetCloudletResourceUsage failed: %s", errstr)
	}
	c.WriteOutput(c.CobraCmd.OutOrStdout(), obj, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func GetCloudletResourceUsages(c *cli.Command, data []edgeproto.CloudletResourceUsage, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("GetCloudletResourceUsage %v\n", data[ii])
		myerr := GetCloudletResourceUsage(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var ShowCloudletResourceUsageCmd = &cli.Command{
	Use:          "ShowCloudletResourceUsage",
	RequiredArgs: strings.Join(ShowCloudletResourceUsageRequiredArgs, " "),
	OptionalArgs: strings.Join(ShowCloudletResourceUsageOptionalArgs, " "),
	AliasArgs:    strings.Join(CloudletAliasArgs, " "),
	SpecialArgs:  &CloudletSpecialArgs,
	Comments:     CloudletComments,
	ReqData:      &edgeproto.Cloudlet{},
	ReplyData:    &edgeproto.CloudletResourceUsage{},
	Run:          runShowCloudletResourceUsage,
}

func runShowCloudletResourceUsage(c *cli.Command, args []string) error {
	if cli.SilenceUsage {
		c.CobraCmd.SilenceUsage = true
	}
	obj := c.ReqData.(*edgeproto.Cloudlet)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return ShowCloudletResourceUsage(c, obj)
}

func ShowCloudletResourceUsage(c *cli.Command, in *edgeproto.Cloudlet) error {
	if CloudletApiCmd == nil {
		return fmt.Errorf("CloudletApi client not initialized")
	}
	ctx := context.Background()
	stream, err := CloudletApiCmd.ShowCloudletResourceUsage(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("ShowCloudletResourceUsage failed: %s", errstr)
	}

	objs := make([]*edgeproto.CloudletResourceUsage, 0)
	for {
		obj, err := stream.Recv()
		if err == io.EOF {
			break
		}
		if err != nil {
			errstr := err.Error()
			st, ok := status.FromError(err)
			if ok {
				errstr = st.Message()
			}
			return fmt.Errorf("ShowCloudletResourceUsage recv failed: %s", errstr)
		}
		objs = append(objs, obj)
	}
	if len(objs) == 0 {
		return nil
	}
	c.WriteOutput(c.CobraCmd.OutOrStdout(), objs, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func ShowCloudletResourceUsages(c *cli.Command, data []edgeproto.Cloudlet, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("ShowCloudletResourceUsage %v\n", data[ii])
		myerr := ShowCloudletResourceUsage(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var ShowCloudletGPUUsageCmd = &cli.Command{
	Use:          "ShowCloudletGPUUsage",
	OptionalArgs: strings.Join(append(CloudletRequiredArgs, CloudletOptionalArgs...), " "),
	AliasArgs:    strings.Join(CloudletAliasArgs, " "),
	SpecialArgs:  &CloudletSpecialArgs,
	Comments:     CloudletComments,
	ReqData:      &edgeproto.Cloudlet{},
	ReplyData:    &edgeproto.CloudletGPUUsage{},
	Run:          runShowCloudletGPUUsage,
}

func runShowCloudletGPUUsage(c *cli.Command, args []string) error {
	if cli.SilenceUsage {
		c.CobraCmd.SilenceUsage = true
	}
	obj := c.ReqData.(*edgeproto.Cloudlet)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return ShowCloudletGPUUsage(c, obj)
}

func ShowCloudletGPUUsage(c *cli.Command, in *edgeproto.Cloudlet) error {
	if CloudletApiCmd == nil {
		return fmt.Errorf("CloudletApi client not initialized")
	}
	ctx := context.Background()
	stream, err := CloudletApiCmd.ShowCloudletGPUUsage(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("ShowCloudletGPUUsage failed: %s", errstr)
	}

	objs := make([]*edgeproto.CloudletGPUUsage, 0)
	for {
		obj, err := stream.Recv()
		if err == io.EOF {
			break
		}
		if err != nil {
			errstr := err.Error()
			st, ok := status.FromError(err)
			if ok {
				errstr = st.Message()
			}
			return fmt.Errorf("ShowCloudletGPUUsage recv failed: %s", errstr)
		}
		objs = append(objs, obj)
	}
	if len(objs) == 0 {
		return nil
	}
	c.WriteOutput(c.CobraCmd.OutOrStdout(), objs, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func ShowCloudletGPUUsages(c *cli.Command, data []edgeproto.Cloudlet, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("ShowCloudletGPUUsage %v\n", data[ii])
		myerr := ShowCloudletGPUUsage(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var AddCloudletResMappingCmd = &cli.Command{
	Use:          "AddCloudletResMapping",
	RequiredArgs: strings.Join(CloudletResMapRequiredArgs, " "),
	OptionalArgs: strings.Join(CloudletResMapOptionalArgs, " "),
	AliasArgs:    strings.Join(CloudletResMapAliasArgs, " "),
	SpecialArgs:  &CloudletResMapSpecialArgs,
	Comments:     CloudletResMapComments,
	ReqData:      &edgeproto.CloudletResMap{},
	ReplyData:    &edgeproto.Result{},
	Run:          runAddCloudletResMapping,
}

func runAddCloudletResMapping(c *cli.Command, args []string) error {
	if cli.SilenceUsage {
		c.CobraCmd.SilenceUsage = true
	}
	obj := c.ReqData.(*edgeproto.CloudletResMap)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return AddCloudletResMapping(c, obj)
}

func AddCloudletResMapping(c *cli.Command, in *edgeproto.CloudletResMap) error {
	if CloudletApiCmd == nil {
		return fmt.Errorf("CloudletApi client not initialized")
	}
	ctx := context.Background()
	obj, err := CloudletApiCmd.AddCloudletResMapping(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("AddCloudletResMapping failed: %s", errstr)
	}
	c.WriteOutput(c.CobraCmd.OutOrStdout(), obj, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func AddCloudletResMappings(c *cli.Command, data []edgeproto.CloudletResMap, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("AddCloudletResMapping %v\n", data[ii])
		myerr := AddCloudletResMapping(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var RemoveCloudletResMappingCmd = &cli.Command{
	Use:          "RemoveCloudletResMapping",
	RequiredArgs: strings.Join(CloudletResMapRequiredArgs, " "),
	OptionalArgs: strings.Join(CloudletResMapOptionalArgs, " "),
	AliasArgs:    strings.Join(CloudletResMapAliasArgs, " "),
	SpecialArgs:  &CloudletResMapSpecialArgs,
	Comments:     CloudletResMapComments,
	ReqData:      &edgeproto.CloudletResMap{},
	ReplyData:    &edgeproto.Result{},
	Run:          runRemoveCloudletResMapping,
}

func runRemoveCloudletResMapping(c *cli.Command, args []string) error {
	if cli.SilenceUsage {
		c.CobraCmd.SilenceUsage = true
	}
	obj := c.ReqData.(*edgeproto.CloudletResMap)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return RemoveCloudletResMapping(c, obj)
}

func RemoveCloudletResMapping(c *cli.Command, in *edgeproto.CloudletResMap) error {
	if CloudletApiCmd == nil {
		return fmt.Errorf("CloudletApi client not initialized")
	}
	ctx := context.Background()
	obj, err := CloudletApiCmd.RemoveCloudletResMapping(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("RemoveCloudletResMapping failed: %s", errstr)
	}
	c.WriteOutput(c.CobraCmd.OutOrStdout(), obj, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func RemoveCloudletResMappings(c *cli.Command, data []edgeproto.CloudletResMap, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("RemoveCloudletResMapping %v\n", data[ii])
		myerr := RemoveCloudletResMapping(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var AddCloudletAllianceOrgCmd = &cli.Command{
	Use:          "AddCloudletAllianceOrg",
	RequiredArgs: strings.Join(CloudletAllianceOrgRequiredArgs, " "),
	OptionalArgs: strings.Join(CloudletAllianceOrgOptionalArgs, " "),
	AliasArgs:    strings.Join(CloudletAllianceOrgAliasArgs, " "),
	SpecialArgs:  &CloudletAllianceOrgSpecialArgs,
	Comments:     CloudletAllianceOrgComments,
	ReqData:      &edgeproto.CloudletAllianceOrg{},
	ReplyData:    &edgeproto.Result{},
	Run:          runAddCloudletAllianceOrg,
}

func runAddCloudletAllianceOrg(c *cli.Command, args []string) error {
	if cli.SilenceUsage {
		c.CobraCmd.SilenceUsage = true
	}
	obj := c.ReqData.(*edgeproto.CloudletAllianceOrg)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return AddCloudletAllianceOrg(c, obj)
}

func AddCloudletAllianceOrg(c *cli.Command, in *edgeproto.CloudletAllianceOrg) error {
	if CloudletApiCmd == nil {
		return fmt.Errorf("CloudletApi client not initialized")
	}
	ctx := context.Background()
	obj, err := CloudletApiCmd.AddCloudletAllianceOrg(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("AddCloudletAllianceOrg failed: %s", errstr)
	}
	c.WriteOutput(c.CobraCmd.OutOrStdout(), obj, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func AddCloudletAllianceOrgs(c *cli.Command, data []edgeproto.CloudletAllianceOrg, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("AddCloudletAllianceOrg %v\n", data[ii])
		myerr := AddCloudletAllianceOrg(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var RemoveCloudletAllianceOrgCmd = &cli.Command{
	Use:          "RemoveCloudletAllianceOrg",
	RequiredArgs: strings.Join(CloudletAllianceOrgRequiredArgs, " "),
	OptionalArgs: strings.Join(CloudletAllianceOrgOptionalArgs, " "),
	AliasArgs:    strings.Join(CloudletAllianceOrgAliasArgs, " "),
	SpecialArgs:  &CloudletAllianceOrgSpecialArgs,
	Comments:     CloudletAllianceOrgComments,
	ReqData:      &edgeproto.CloudletAllianceOrg{},
	ReplyData:    &edgeproto.Result{},
	Run:          runRemoveCloudletAllianceOrg,
}

func runRemoveCloudletAllianceOrg(c *cli.Command, args []string) error {
	if cli.SilenceUsage {
		c.CobraCmd.SilenceUsage = true
	}
	obj := c.ReqData.(*edgeproto.CloudletAllianceOrg)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return RemoveCloudletAllianceOrg(c, obj)
}

func RemoveCloudletAllianceOrg(c *cli.Command, in *edgeproto.CloudletAllianceOrg) error {
	if CloudletApiCmd == nil {
		return fmt.Errorf("CloudletApi client not initialized")
	}
	ctx := context.Background()
	obj, err := CloudletApiCmd.RemoveCloudletAllianceOrg(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("RemoveCloudletAllianceOrg failed: %s", errstr)
	}
	c.WriteOutput(c.CobraCmd.OutOrStdout(), obj, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func RemoveCloudletAllianceOrgs(c *cli.Command, data []edgeproto.CloudletAllianceOrg, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("RemoveCloudletAllianceOrg %v\n", data[ii])
		myerr := RemoveCloudletAllianceOrg(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var FindFlavorMatchCmd = &cli.Command{
	Use:          "FindFlavorMatch",
	RequiredArgs: strings.Join(FlavorMatchRequiredArgs, " "),
	OptionalArgs: strings.Join(FlavorMatchOptionalArgs, " "),
	AliasArgs:    strings.Join(FlavorMatchAliasArgs, " "),
	SpecialArgs:  &FlavorMatchSpecialArgs,
	Comments:     FlavorMatchComments,
	ReqData:      &edgeproto.FlavorMatch{},
	ReplyData:    &edgeproto.FlavorMatch{},
	Run:          runFindFlavorMatch,
}

func runFindFlavorMatch(c *cli.Command, args []string) error {
	if cli.SilenceUsage {
		c.CobraCmd.SilenceUsage = true
	}
	obj := c.ReqData.(*edgeproto.FlavorMatch)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return FindFlavorMatch(c, obj)
}

func FindFlavorMatch(c *cli.Command, in *edgeproto.FlavorMatch) error {
	if CloudletApiCmd == nil {
		return fmt.Errorf("CloudletApi client not initialized")
	}
	ctx := context.Background()
	obj, err := CloudletApiCmd.FindFlavorMatch(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("FindFlavorMatch failed: %s", errstr)
	}
	c.WriteOutput(c.CobraCmd.OutOrStdout(), obj, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func FindFlavorMatchs(c *cli.Command, data []edgeproto.FlavorMatch, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("FindFlavorMatch %v\n", data[ii])
		myerr := FindFlavorMatch(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var ShowFlavorsForZoneCmd = &cli.Command{
	Use:          "ShowFlavorsForZone",
	RequiredArgs: strings.Join(ShowFlavorsForZoneRequiredArgs, " "),
	OptionalArgs: strings.Join(ShowFlavorsForZoneOptionalArgs, " "),
	AliasArgs:    strings.Join(ZoneKeyAliasArgs, " "),
	SpecialArgs:  &ZoneKeySpecialArgs,
	Comments:     ZoneKeyComments,
	ReqData:      &edgeproto.ZoneKey{},
	ReplyData:    &edgeproto.FlavorKey{},
	Run:          runShowFlavorsForZone,
}

func runShowFlavorsForZone(c *cli.Command, args []string) error {
	if cli.SilenceUsage {
		c.CobraCmd.SilenceUsage = true
	}
	obj := c.ReqData.(*edgeproto.ZoneKey)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return ShowFlavorsForZone(c, obj)
}

func ShowFlavorsForZone(c *cli.Command, in *edgeproto.ZoneKey) error {
	if CloudletApiCmd == nil {
		return fmt.Errorf("CloudletApi client not initialized")
	}
	ctx := context.Background()
	stream, err := CloudletApiCmd.ShowFlavorsForZone(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("ShowFlavorsForZone failed: %s", errstr)
	}

	objs := make([]*edgeproto.FlavorKey, 0)
	for {
		obj, err := stream.Recv()
		if err == io.EOF {
			break
		}
		if err != nil {
			errstr := err.Error()
			st, ok := status.FromError(err)
			if ok {
				errstr = st.Message()
			}
			return fmt.Errorf("ShowFlavorsForZone recv failed: %s", errstr)
		}
		if cli.OutputStream {
			c.WriteOutput(c.CobraCmd.OutOrStdout(), obj, cli.OutputFormat)
			continue
		}
		objs = append(objs, obj)
	}
	if len(objs) == 0 {
		return nil
	}
	c.WriteOutput(c.CobraCmd.OutOrStdout(), objs, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func ShowFlavorsForZones(c *cli.Command, data []edgeproto.ZoneKey, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("ShowFlavorsForZone %v\n", data[ii])
		myerr := ShowFlavorsForZone(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var GetOrganizationsOnZoneCmd = &cli.Command{
	Use:          "GetOrganizationsOnZone",
	RequiredArgs: strings.Join(ZoneKeyRequiredArgs, " "),
	OptionalArgs: strings.Join(ZoneKeyOptionalArgs, " "),
	AliasArgs:    strings.Join(ZoneKeyAliasArgs, " "),
	SpecialArgs:  &ZoneKeySpecialArgs,
	Comments:     ZoneKeyComments,
	ReqData:      &edgeproto.ZoneKey{},
	ReplyData:    &edgeproto.Organization{},
	Run:          runGetOrganizationsOnZone,
}

func runGetOrganizationsOnZone(c *cli.Command, args []string) error {
	if cli.SilenceUsage {
		c.CobraCmd.SilenceUsage = true
	}
	obj := c.ReqData.(*edgeproto.ZoneKey)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return GetOrganizationsOnZone(c, obj)
}

func GetOrganizationsOnZone(c *cli.Command, in *edgeproto.ZoneKey) error {
	if CloudletApiCmd == nil {
		return fmt.Errorf("CloudletApi client not initialized")
	}
	ctx := context.Background()
	stream, err := CloudletApiCmd.GetOrganizationsOnZone(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("GetOrganizationsOnZone failed: %s", errstr)
	}

	objs := make([]*edgeproto.Organization, 0)
	for {
		obj, err := stream.Recv()
		if err == io.EOF {
			break
		}
		if err != nil {
			errstr := err.Error()
			st, ok := status.FromError(err)
			if ok {
				errstr = st.Message()
			}
			return fmt.Errorf("GetOrganizationsOnZone recv failed: %s", errstr)
		}
		if cli.OutputStream {
			c.WriteOutput(c.CobraCmd.OutOrStdout(), obj, cli.OutputFormat)
			continue
		}
		objs = append(objs, obj)
	}
	if len(objs) == 0 {
		return nil
	}
	c.WriteOutput(c.CobraCmd.OutOrStdout(), objs, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func GetOrganizationsOnZones(c *cli.Command, data []edgeproto.ZoneKey, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("GetOrganizationsOnZone %v\n", data[ii])
		myerr := GetOrganizationsOnZone(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var RevokeAccessKeyCmd = &cli.Command{
	Use:          "RevokeAccessKey",
	RequiredArgs: strings.Join(CloudletKeyRequiredArgs, " "),
	OptionalArgs: strings.Join(CloudletKeyOptionalArgs, " "),
	AliasArgs:    strings.Join(CloudletKeyAliasArgs, " "),
	SpecialArgs:  &CloudletKeySpecialArgs,
	Comments:     CloudletKeyComments,
	ReqData:      &edgeproto.CloudletKey{},
	ReplyData:    &edgeproto.Result{},
	Run:          runRevokeAccessKey,
}

func runRevokeAccessKey(c *cli.Command, args []string) error {
	if cli.SilenceUsage {
		c.CobraCmd.SilenceUsage = true
	}
	obj := c.ReqData.(*edgeproto.CloudletKey)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return RevokeAccessKey(c, obj)
}

func RevokeAccessKey(c *cli.Command, in *edgeproto.CloudletKey) error {
	if CloudletApiCmd == nil {
		return fmt.Errorf("CloudletApi client not initialized")
	}
	ctx := context.Background()
	obj, err := CloudletApiCmd.RevokeAccessKey(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("RevokeAccessKey failed: %s", errstr)
	}
	c.WriteOutput(c.CobraCmd.OutOrStdout(), obj, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func RevokeAccessKeys(c *cli.Command, data []edgeproto.CloudletKey, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("RevokeAccessKey %v\n", data[ii])
		myerr := RevokeAccessKey(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var GenerateAccessKeyCmd = &cli.Command{
	Use:          "GenerateAccessKey",
	RequiredArgs: strings.Join(CloudletKeyRequiredArgs, " "),
	OptionalArgs: strings.Join(CloudletKeyOptionalArgs, " "),
	AliasArgs:    strings.Join(CloudletKeyAliasArgs, " "),
	SpecialArgs:  &CloudletKeySpecialArgs,
	Comments:     CloudletKeyComments,
	ReqData:      &edgeproto.CloudletKey{},
	ReplyData:    &edgeproto.Result{},
	Run:          runGenerateAccessKey,
}

func runGenerateAccessKey(c *cli.Command, args []string) error {
	if cli.SilenceUsage {
		c.CobraCmd.SilenceUsage = true
	}
	obj := c.ReqData.(*edgeproto.CloudletKey)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return GenerateAccessKey(c, obj)
}

func GenerateAccessKey(c *cli.Command, in *edgeproto.CloudletKey) error {
	if CloudletApiCmd == nil {
		return fmt.Errorf("CloudletApi client not initialized")
	}
	ctx := context.Background()
	obj, err := CloudletApiCmd.GenerateAccessKey(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("GenerateAccessKey failed: %s", errstr)
	}
	c.WriteOutput(c.CobraCmd.OutOrStdout(), obj, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func GenerateAccessKeys(c *cli.Command, data []edgeproto.CloudletKey, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("GenerateAccessKey %v\n", data[ii])
		myerr := GenerateAccessKey(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var GetCloudletGPUDriverLicenseConfigCmd = &cli.Command{
	Use:          "GetCloudletGPUDriverLicenseConfig",
	RequiredArgs: strings.Join(CloudletKeyRequiredArgs, " "),
	OptionalArgs: strings.Join(CloudletKeyOptionalArgs, " "),
	AliasArgs:    strings.Join(CloudletKeyAliasArgs, " "),
	SpecialArgs:  &CloudletKeySpecialArgs,
	Comments:     CloudletKeyComments,
	ReqData:      &edgeproto.CloudletKey{},
	ReplyData:    &edgeproto.Result{},
	Run:          runGetCloudletGPUDriverLicenseConfig,
}

func runGetCloudletGPUDriverLicenseConfig(c *cli.Command, args []string) error {
	if cli.SilenceUsage {
		c.CobraCmd.SilenceUsage = true
	}
	obj := c.ReqData.(*edgeproto.CloudletKey)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return GetCloudletGPUDriverLicenseConfig(c, obj)
}

func GetCloudletGPUDriverLicenseConfig(c *cli.Command, in *edgeproto.CloudletKey) error {
	if CloudletApiCmd == nil {
		return fmt.Errorf("CloudletApi client not initialized")
	}
	ctx := context.Background()
	obj, err := CloudletApiCmd.GetCloudletGPUDriverLicenseConfig(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("GetCloudletGPUDriverLicenseConfig failed: %s", errstr)
	}
	c.WriteOutput(c.CobraCmd.OutOrStdout(), obj, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func GetCloudletGPUDriverLicenseConfigs(c *cli.Command, data []edgeproto.CloudletKey, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("GetCloudletGPUDriverLicenseConfig %v\n", data[ii])
		myerr := GetCloudletGPUDriverLicenseConfig(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var ChangeCloudletDNSCmd = &cli.Command{
	Use:          "ChangeCloudletDNS",
	RequiredArgs: strings.Join(CloudletKeyRequiredArgs, " "),
	OptionalArgs: strings.Join(CloudletKeyOptionalArgs, " "),
	AliasArgs:    strings.Join(CloudletKeyAliasArgs, " "),
	SpecialArgs:  &CloudletKeySpecialArgs,
	Comments:     CloudletKeyComments,
	ReqData:      &edgeproto.CloudletKey{},
	ReplyData:    &edgeproto.Result{},
	Run:          runChangeCloudletDNS,
}

func runChangeCloudletDNS(c *cli.Command, args []string) error {
	if cli.SilenceUsage {
		c.CobraCmd.SilenceUsage = true
	}
	obj := c.ReqData.(*edgeproto.CloudletKey)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return ChangeCloudletDNS(c, obj)
}

func ChangeCloudletDNS(c *cli.Command, in *edgeproto.CloudletKey) error {
	if CloudletApiCmd == nil {
		return fmt.Errorf("CloudletApi client not initialized")
	}
	ctx := context.Background()
	stream, err := CloudletApiCmd.ChangeCloudletDNS(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("ChangeCloudletDNS failed: %s", errstr)
	}

	objs := make([]*edgeproto.Result, 0)
	for {
		obj, err := stream.Recv()
		if err == io.EOF {
			break
		}
		if err != nil {
			errstr := err.Error()
			st, ok := status.FromError(err)
			if ok {
				errstr = st.Message()
			}
			return fmt.Errorf("ChangeCloudletDNS recv failed: %s", errstr)
		}
		if cli.OutputStream {
			c.WriteOutput(c.CobraCmd.OutOrStdout(), obj, cli.OutputFormat)
			continue
		}
		objs = append(objs, obj)
	}
	if len(objs) == 0 {
		return nil
	}
	c.WriteOutput(c.CobraCmd.OutOrStdout(), objs, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func ChangeCloudletDNSs(c *cli.Command, data []edgeproto.CloudletKey, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("ChangeCloudletDNS %v\n", data[ii])
		myerr := ChangeCloudletDNS(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var RefreshCertsCmd = &cli.Command{
	Use:          "RefreshCerts",
	RequiredArgs: strings.Join(RefreshCertsRequiredArgs, " "),
	OptionalArgs: strings.Join(RefreshCertsOptionalArgs, " "),
	AliasArgs:    strings.Join(CloudletKeyAliasArgs, " "),
	SpecialArgs:  &CloudletKeySpecialArgs,
	Comments:     CloudletKeyComments,
	ReqData:      &edgeproto.CloudletKey{},
	ReplyData:    &edgeproto.Result{},
	Run:          runRefreshCerts,
}

func runRefreshCerts(c *cli.Command, args []string) error {
	if cli.SilenceUsage {
		c.CobraCmd.SilenceUsage = true
	}
	obj := c.ReqData.(*edgeproto.CloudletKey)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return RefreshCerts(c, obj)
}

func RefreshCerts(c *cli.Command, in *edgeproto.CloudletKey) error {
	if CloudletApiCmd == nil {
		return fmt.Errorf("CloudletApi client not initialized")
	}
	ctx := context.Background()
	stream, err := CloudletApiCmd.RefreshCerts(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("RefreshCerts failed: %s", errstr)
	}

	objs := make([]*edgeproto.Result, 0)
	for {
		obj, err := stream.Recv()
		if err == io.EOF {
			break
		}
		if err != nil {
			errstr := err.Error()
			st, ok := status.FromError(err)
			if ok {
				errstr = st.Message()
			}
			return fmt.Errorf("RefreshCerts recv failed: %s", errstr)
		}
		if cli.OutputStream {
			c.WriteOutput(c.CobraCmd.OutOrStdout(), obj, cli.OutputFormat)
			continue
		}
		objs = append(objs, obj)
	}
	if len(objs) == 0 {
		return nil
	}
	c.WriteOutput(c.CobraCmd.OutOrStdout(), objs, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func RefreshCertss(c *cli.Command, data []edgeproto.CloudletKey, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("RefreshCerts %v\n", data[ii])
		myerr := RefreshCerts(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var CloudletApiCmds = []*cobra.Command{
	CreateCloudletCmd.GenCmd(),
	DeleteCloudletCmd.GenCmd(),
	UpdateCloudletCmd.GenCmd(),
	ShowCloudletCmd.GenCmd(),
	GetCloudletManifestCmd.GenCmd(),
	GetCloudletPropsCmd.GenCmd(),
	GetCloudletResourceQuotaPropsCmd.GenCmd(),
	GetCloudletResourceUsageCmd.GenCmd(),
	ShowCloudletResourceUsageCmd.GenCmd(),
	ShowCloudletGPUUsageCmd.GenCmd(),
	AddCloudletResMappingCmd.GenCmd(),
	RemoveCloudletResMappingCmd.GenCmd(),
	AddCloudletAllianceOrgCmd.GenCmd(),
	RemoveCloudletAllianceOrgCmd.GenCmd(),
	FindFlavorMatchCmd.GenCmd(),
	ShowFlavorsForZoneCmd.GenCmd(),
	GetOrganizationsOnZoneCmd.GenCmd(),
	RevokeAccessKeyCmd.GenCmd(),
	GenerateAccessKeyCmd.GenCmd(),
	GetCloudletGPUDriverLicenseConfigCmd.GenCmd(),
	ChangeCloudletDNSCmd.GenCmd(),
	RefreshCertsCmd.GenCmd(),
}

var CloudletInfoApiCmd edgeproto.CloudletInfoApiClient

var ShowCloudletInfoCmd = &cli.Command{
	Use:          "ShowCloudletInfo",
	OptionalArgs: strings.Join(append(CloudletInfoRequiredArgs, CloudletInfoOptionalArgs...), " "),
	AliasArgs:    strings.Join(CloudletInfoAliasArgs, " "),
	SpecialArgs:  &CloudletInfoSpecialArgs,
	Comments:     CloudletInfoComments,
	ReqData:      &edgeproto.CloudletInfo{},
	ReplyData:    &edgeproto.CloudletInfo{},
	Run:          runShowCloudletInfo,
}

func runShowCloudletInfo(c *cli.Command, args []string) error {
	if cli.SilenceUsage {
		c.CobraCmd.SilenceUsage = true
	}
	obj := c.ReqData.(*edgeproto.CloudletInfo)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return ShowCloudletInfo(c, obj)
}

func ShowCloudletInfo(c *cli.Command, in *edgeproto.CloudletInfo) error {
	if CloudletInfoApiCmd == nil {
		return fmt.Errorf("CloudletInfoApi client not initialized")
	}
	ctx := context.Background()
	stream, err := CloudletInfoApiCmd.ShowCloudletInfo(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("ShowCloudletInfo failed: %s", errstr)
	}

	objs := make([]*edgeproto.CloudletInfo, 0)
	for {
		obj, err := stream.Recv()
		if err == io.EOF {
			break
		}
		if err != nil {
			errstr := err.Error()
			st, ok := status.FromError(err)
			if ok {
				errstr = st.Message()
			}
			return fmt.Errorf("ShowCloudletInfo recv failed: %s", errstr)
		}
		CloudletInfoHideTags(obj)
		objs = append(objs, obj)
	}
	if len(objs) == 0 {
		return nil
	}
	c.WriteOutput(c.CobraCmd.OutOrStdout(), objs, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func ShowCloudletInfos(c *cli.Command, data []edgeproto.CloudletInfo, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("ShowCloudletInfo %v\n", data[ii])
		myerr := ShowCloudletInfo(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var InjectCloudletInfoCmd = &cli.Command{
	Use:          "InjectCloudletInfo",
	RequiredArgs: strings.Join(CloudletInfoRequiredArgs, " "),
	OptionalArgs: strings.Join(CloudletInfoOptionalArgs, " "),
	AliasArgs:    strings.Join(CloudletInfoAliasArgs, " "),
	SpecialArgs:  &CloudletInfoSpecialArgs,
	Comments:     CloudletInfoComments,
	ReqData:      &edgeproto.CloudletInfo{},
	ReplyData:    &edgeproto.Result{},
	Run:          runInjectCloudletInfo,
}

func runInjectCloudletInfo(c *cli.Command, args []string) error {
	if cli.SilenceUsage {
		c.CobraCmd.SilenceUsage = true
	}
	obj := c.ReqData.(*edgeproto.CloudletInfo)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return InjectCloudletInfo(c, obj)
}

func InjectCloudletInfo(c *cli.Command, in *edgeproto.CloudletInfo) error {
	if CloudletInfoApiCmd == nil {
		return fmt.Errorf("CloudletInfoApi client not initialized")
	}
	ctx := context.Background()
	obj, err := CloudletInfoApiCmd.InjectCloudletInfo(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("InjectCloudletInfo failed: %s", errstr)
	}
	c.WriteOutput(c.CobraCmd.OutOrStdout(), obj, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func InjectCloudletInfos(c *cli.Command, data []edgeproto.CloudletInfo, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("InjectCloudletInfo %v\n", data[ii])
		myerr := InjectCloudletInfo(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var EvictCloudletInfoCmd = &cli.Command{
	Use:          "EvictCloudletInfo",
	RequiredArgs: strings.Join(CloudletInfoRequiredArgs, " "),
	OptionalArgs: strings.Join(CloudletInfoOptionalArgs, " "),
	AliasArgs:    strings.Join(CloudletInfoAliasArgs, " "),
	SpecialArgs:  &CloudletInfoSpecialArgs,
	Comments:     CloudletInfoComments,
	ReqData:      &edgeproto.CloudletInfo{},
	ReplyData:    &edgeproto.Result{},
	Run:          runEvictCloudletInfo,
}

func runEvictCloudletInfo(c *cli.Command, args []string) error {
	if cli.SilenceUsage {
		c.CobraCmd.SilenceUsage = true
	}
	obj := c.ReqData.(*edgeproto.CloudletInfo)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return EvictCloudletInfo(c, obj)
}

func EvictCloudletInfo(c *cli.Command, in *edgeproto.CloudletInfo) error {
	if CloudletInfoApiCmd == nil {
		return fmt.Errorf("CloudletInfoApi client not initialized")
	}
	ctx := context.Background()
	obj, err := CloudletInfoApiCmd.EvictCloudletInfo(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("EvictCloudletInfo failed: %s", errstr)
	}
	c.WriteOutput(c.CobraCmd.OutOrStdout(), obj, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func EvictCloudletInfos(c *cli.Command, data []edgeproto.CloudletInfo, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("EvictCloudletInfo %v\n", data[ii])
		myerr := EvictCloudletInfo(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var CloudletInfoApiCmds = []*cobra.Command{
	ShowCloudletInfoCmd.GenCmd(),
	InjectCloudletInfoCmd.GenCmd(),
	EvictCloudletInfoCmd.GenCmd(),
}

var CloudletMetricsApiCmd edgeproto.CloudletMetricsApiClient

var ShowCloudletMetricsCmd = &cli.Command{
	Use:          "ShowCloudletMetrics",
	OptionalArgs: strings.Join(append(CloudletMetricsRequiredArgs, CloudletMetricsOptionalArgs...), " "),
	AliasArgs:    strings.Join(CloudletMetricsAliasArgs, " "),
	SpecialArgs:  &CloudletMetricsSpecialArgs,
	Comments:     CloudletMetricsComments,
	ReqData:      &edgeproto.CloudletMetrics{},
	ReplyData:    &edgeproto.CloudletMetrics{},
	Run:          runShowCloudletMetrics,
}

func runShowCloudletMetrics(c *cli.Command, args []string) error {
	if cli.SilenceUsage {
		c.CobraCmd.SilenceUsage = true
	}
	obj := c.ReqData.(*edgeproto.CloudletMetrics)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return ShowCloudletMetrics(c, obj)
}

func ShowCloudletMetrics(c *cli.Command, in *edgeproto.CloudletMetrics) error {
	if CloudletMetricsApiCmd == nil {
		return fmt.Errorf("CloudletMetricsApi client not initialized")
	}
	ctx := context.Background()
	stream, err := CloudletMetricsApiCmd.ShowCloudletMetrics(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("ShowCloudletMetrics failed: %s", errstr)
	}

	objs := make([]*edgeproto.CloudletMetrics, 0)
	for {
		obj, err := stream.Recv()
		if err == io.EOF {
			break
		}
		if err != nil {
			errstr := err.Error()
			st, ok := status.FromError(err)
			if ok {
				errstr = st.Message()
			}
			return fmt.Errorf("ShowCloudletMetrics recv failed: %s", errstr)
		}
		objs = append(objs, obj)
	}
	if len(objs) == 0 {
		return nil
	}
	c.WriteOutput(c.CobraCmd.OutOrStdout(), objs, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func ShowCloudletMetricss(c *cli.Command, data []edgeproto.CloudletMetrics, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("ShowCloudletMetrics %v\n", data[ii])
		myerr := ShowCloudletMetrics(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var CloudletMetricsApiCmds = []*cobra.Command{
	ShowCloudletMetricsCmd.GenCmd(),
}

var CloudletManagedClusterApiCmd edgeproto.CloudletManagedClusterApiClient

var ShowCloudletManagedClusterCmd = &cli.Command{
	Use:          "ShowCloudletManagedCluster",
	OptionalArgs: strings.Join(append(CloudletManagedClusterRequiredArgs, CloudletManagedClusterOptionalArgs...), " "),
	AliasArgs:    strings.Join(CloudletManagedClusterAliasArgs, " "),
	SpecialArgs:  &CloudletManagedClusterSpecialArgs,
	Comments:     CloudletManagedClusterComments,
	ReqData:      &edgeproto.CloudletManagedCluster{},
	ReplyData:    &edgeproto.CloudletManagedCluster{},
	Run:          runShowCloudletManagedCluster,
}

func runShowCloudletManagedCluster(c *cli.Command, args []string) error {
	if cli.SilenceUsage {
		c.CobraCmd.SilenceUsage = true
	}
	obj := c.ReqData.(*edgeproto.CloudletManagedCluster)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return ShowCloudletManagedCluster(c, obj)
}

func ShowCloudletManagedCluster(c *cli.Command, in *edgeproto.CloudletManagedCluster) error {
	if CloudletManagedClusterApiCmd == nil {
		return fmt.Errorf("CloudletManagedClusterApi client not initialized")
	}
	ctx := context.Background()
	stream, err := CloudletManagedClusterApiCmd.ShowCloudletManagedCluster(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("ShowCloudletManagedCluster failed: %s", errstr)
	}

	objs := make([]*edgeproto.CloudletManagedCluster, 0)
	for {
		obj, err := stream.Recv()
		if err == io.EOF {
			break
		}
		if err != nil {
			errstr := err.Error()
			st, ok := status.FromError(err)
			if ok {
				errstr = st.Message()
			}
			return fmt.Errorf("ShowCloudletManagedCluster recv failed: %s", errstr)
		}
		objs = append(objs, obj)
	}
	if len(objs) == 0 {
		return nil
	}
	c.WriteOutput(c.CobraCmd.OutOrStdout(), objs, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func ShowCloudletManagedClusters(c *cli.Command, data []edgeproto.CloudletManagedCluster, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("ShowCloudletManagedCluster %v\n", data[ii])
		myerr := ShowCloudletManagedCluster(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var RegisterCloudletManagedClusterCmd = &cli.Command{
	Use:          "RegisterCloudletManagedCluster",
	RequiredArgs: strings.Join(CloudletManagedClusterRequiredArgs, " "),
	OptionalArgs: strings.Join(CloudletManagedClusterOptionalArgs, " "),
	AliasArgs:    strings.Join(CloudletManagedClusterAliasArgs, " "),
	SpecialArgs:  &CloudletManagedClusterSpecialArgs,
	Comments:     CloudletManagedClusterComments,
	ReqData:      &edgeproto.CloudletManagedCluster{},
	ReplyData:    &edgeproto.Result{},
	Run:          runRegisterCloudletManagedCluster,
}

func runRegisterCloudletManagedCluster(c *cli.Command, args []string) error {
	if cli.SilenceUsage {
		c.CobraCmd.SilenceUsage = true
	}
	obj := c.ReqData.(*edgeproto.CloudletManagedCluster)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return RegisterCloudletManagedCluster(c, obj)
}

func RegisterCloudletManagedCluster(c *cli.Command, in *edgeproto.CloudletManagedCluster) error {
	if CloudletManagedClusterApiCmd == nil {
		return fmt.Errorf("CloudletManagedClusterApi client not initialized")
	}
	ctx := context.Background()
	stream, err := CloudletManagedClusterApiCmd.RegisterCloudletManagedCluster(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("RegisterCloudletManagedCluster failed: %s", errstr)
	}

	objs := make([]*edgeproto.Result, 0)
	for {
		obj, err := stream.Recv()
		if err == io.EOF {
			break
		}
		if err != nil {
			errstr := err.Error()
			st, ok := status.FromError(err)
			if ok {
				errstr = st.Message()
			}
			return fmt.Errorf("RegisterCloudletManagedCluster recv failed: %s", errstr)
		}
		if cli.OutputStream {
			c.WriteOutput(c.CobraCmd.OutOrStdout(), obj, cli.OutputFormat)
			continue
		}
		objs = append(objs, obj)
	}
	if len(objs) == 0 {
		return nil
	}
	c.WriteOutput(c.CobraCmd.OutOrStdout(), objs, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func RegisterCloudletManagedClusters(c *cli.Command, data []edgeproto.CloudletManagedCluster, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("RegisterCloudletManagedCluster %v\n", data[ii])
		myerr := RegisterCloudletManagedCluster(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var DeregisterCloudletManagedClusterCmd = &cli.Command{
	Use:          "DeregisterCloudletManagedCluster",
	RequiredArgs: strings.Join(CloudletManagedClusterRequiredArgs, " "),
	OptionalArgs: strings.Join(CloudletManagedClusterOptionalArgs, " "),
	AliasArgs:    strings.Join(CloudletManagedClusterAliasArgs, " "),
	SpecialArgs:  &CloudletManagedClusterSpecialArgs,
	Comments:     CloudletManagedClusterComments,
	ReqData:      &edgeproto.CloudletManagedCluster{},
	ReplyData:    &edgeproto.Result{},
	Run:          runDeregisterCloudletManagedCluster,
}

func runDeregisterCloudletManagedCluster(c *cli.Command, args []string) error {
	if cli.SilenceUsage {
		c.CobraCmd.SilenceUsage = true
	}
	obj := c.ReqData.(*edgeproto.CloudletManagedCluster)
	_, err := c.ParseInput(args)
	if err != nil {
		return err
	}
	return DeregisterCloudletManagedCluster(c, obj)
}

func DeregisterCloudletManagedCluster(c *cli.Command, in *edgeproto.CloudletManagedCluster) error {
	if CloudletManagedClusterApiCmd == nil {
		return fmt.Errorf("CloudletManagedClusterApi client not initialized")
	}
	ctx := context.Background()
	stream, err := CloudletManagedClusterApiCmd.DeregisterCloudletManagedCluster(ctx, in)
	if err != nil {
		errstr := err.Error()
		st, ok := status.FromError(err)
		if ok {
			errstr = st.Message()
		}
		return fmt.Errorf("DeregisterCloudletManagedCluster failed: %s", errstr)
	}

	objs := make([]*edgeproto.Result, 0)
	for {
		obj, err := stream.Recv()
		if err == io.EOF {
			break
		}
		if err != nil {
			errstr := err.Error()
			st, ok := status.FromError(err)
			if ok {
				errstr = st.Message()
			}
			return fmt.Errorf("DeregisterCloudletManagedCluster recv failed: %s", errstr)
		}
		if cli.OutputStream {
			c.WriteOutput(c.CobraCmd.OutOrStdout(), obj, cli.OutputFormat)
			continue
		}
		objs = append(objs, obj)
	}
	if len(objs) == 0 {
		return nil
	}
	c.WriteOutput(c.CobraCmd.OutOrStdout(), objs, cli.OutputFormat)
	return nil
}

// this supports "Create" and "Delete" commands on ApplicationData
func DeregisterCloudletManagedClusters(c *cli.Command, data []edgeproto.CloudletManagedCluster, err *error) {
	if *err != nil {
		return
	}
	for ii, _ := range data {
		fmt.Printf("DeregisterCloudletManagedCluster %v\n", data[ii])
		myerr := DeregisterCloudletManagedCluster(c, &data[ii])
		if myerr != nil {
			*err = myerr
			break
		}
	}
}

var CloudletManagedClusterApiCmds = []*cobra.Command{
	ShowCloudletManagedClusterCmd.GenCmd(),
	RegisterCloudletManagedClusterCmd.GenCmd(),
	DeregisterCloudletManagedClusterCmd.GenCmd(),
}

var OperationTimeLimitsRequiredArgs = []string{}
var OperationTimeLimitsOptionalArgs = []string{
	"createclusterinsttimeout",
	"updateclusterinsttimeout",
	"deleteclusterinsttimeout",
	"createappinsttimeout",
	"updateappinsttimeout",
	"deleteappinsttimeout",
}
var OperationTimeLimitsAliasArgs = []string{}
var OperationTimeLimitsComments = map[string]string{
	"createclusterinsttimeout": "Override default max time to create a cluster instance (duration)",
	"updateclusterinsttimeout": "Override default max time to update a cluster instance (duration)",
	"deleteclusterinsttimeout": "Override default max time to delete a cluster instance (duration)",
	"createappinsttimeout":     "Override default max time to create an app instance (duration)",
	"updateappinsttimeout":     "Override default max time to update an app instance (duration)",
	"deleteappinsttimeout":     "Override default max time to delete an app instance (duration)",
}
var OperationTimeLimitsSpecialArgs = map[string]string{}
var CloudletInternalRequiredArgs = []string{
	"key.organization",
	"key.name",
	"key.federatedorganization",
}
var CloudletInternalOptionalArgs = []string{
	"props",
}
var CloudletInternalAliasArgs = []string{}
var CloudletInternalComments = map[string]string{
	"fields":                    "Fields are used for the Update API to specify which fields to apply.",
	"key.organization":          "Organization of the cloudlet site",
	"key.name":                  "Name of the cloudlet",
	"key.federatedorganization": "Federated operator organization who shared this cloudlet",
	"props":                     "Map of key value pairs for data exchanged between components",
}
var CloudletInternalSpecialArgs = map[string]string{
	"fields": "StringArray",
	"props":  "StringToString",
}
var PlatformConfigRequiredArgs = []string{}
var PlatformConfigOptionalArgs = []string{
	"containerregistrypath",
	"cloudletvmimagepath",
	"notifyctrladdrs",
	"tlscertfile",
	"tlskeyfile",
	"tlscafile",
	"envvar",
	"platformtag",
	"testmode",
	"span",
	"cleanupmode",
	"region",
	"commercialcerts",
	"usevaultpki",
	"appdnsroot",
	"deploymenttag",
	"crmaccessprivatekey",
	"accessapiaddr",
	"cachedir",
	"secondarycrmaccessprivatekey",
	"thanosrecvaddr",
	"ansiblepublicaddr",
	"envoywithcurlimage",
	"nginxwithcurlimage",
}
var PlatformConfigAliasArgs = []string{}
var PlatformConfigComments = map[string]string{
	"containerregistrypath":        "Path to Docker registry holding edge-cloud image",
	"cloudletvmimagepath":          "Path to platform base image",
	"notifyctrladdrs":              "Address of controller notify port (can be multiple of these)",
	"tlscertfile":                  "TLS cert file",
	"tlskeyfile":                   "TLS key file",
	"tlscafile":                    "TLS ca file",
	"envvar":                       "Environment variables",
	"platformtag":                  "Tag of edge-cloud image",
	"testmode":                     "Internal Test flag",
	"span":                         "Span string",
	"cleanupmode":                  "Internal cleanup flag",
	"region":                       "Region",
	"commercialcerts":              "Get certs from vault or generate your own for the root load balancer",
	"usevaultpki":                  "Use Vault certs and CAs for internal TLS communication",
	"appdnsroot":                   "App domain name root",
	"deploymenttag":                "Deployment Tag",
	"crmaccessprivatekey":          "crm access private key",
	"accessapiaddr":                "controller access API address",
	"cachedir":                     "cache dir",
	"secondarycrmaccessprivatekey": "secondary crm access private key",
	"thanosrecvaddr":               "Thanos Receive remote write address",
	"ansiblepublicaddr":            "Ansible public address for CRM to connect to CCRM",
	"envoywithcurlimage":           "docker image path for envoy with curl",
	"nginxwithcurlimage":           "docker image path for nginx with curl",
}
var PlatformConfigSpecialArgs = map[string]string{
	"envvar": "StringToString",
}
var FederationConfigRequiredArgs = []string{}
var FederationConfigOptionalArgs = []string{
	"federationcontextid",
	"partnerfederationaddr",
	"federationdbid",
	"federationname",
}
var FederationConfigAliasArgs = []string{}
var FederationConfigComments = map[string]string{
	"federationcontextid":   "Federation context id",
	"partnerfederationaddr": "Partner federation address",
	"federationdbid":        "Federation database id",
	"federationname":        "Federation Name",
}
var FederationConfigSpecialArgs = map[string]string{}
var PlatformFeaturesRequiredArgs = []string{}
var PlatformFeaturesOptionalArgs = []string{
	"platformtype",
	"nodetype",
	"supportsmultitenantcluster",
	"supportssharedvolume",
	"supportstrustpolicy",
	"supportskubernetesonly",
	"kubernetesrequiresworkernodes",
	"cloudletserviceslocal",
	"ipallocatedperservice",
	"supportsimagetypeovf",
	"supportsimagetypeova",
	"isvmpool",
	"isfake",
	"ismock",
	"supportsadditionalnetworks",
	"issinglekubernetescluster",
	"supportsappinstdedicatedip",
	"supportsplatformhighavailabilityonk8s",
	"supportsplatformhighavailabilityondocker",
	"nokubernetesclusterautoscale",
	"isprebuiltkubernetescluster",
	"noclustersupport",
	"isedgebox",
	"supportsipv6",
	"requirescrmonedge",
	"requirescrmoffedge",
	"requirescertrefresh",
	"supportsmultiplenodepools",
	"managesk8scontrolnodes",
	"usesingress",
	"requiresgpudriver",
	"usesrootlb",
	"supportscloudletmanagedclusters",
	"requireslbipallocation",
	"resourcequotaproperties:#.name",
	"resourcequotaproperties:#.value",
	"resourcequotaproperties:#.inframaxvalue",
	"resourcequotaproperties:#.quotamaxvalue",
	"resourcequotaproperties:#.description",
	"resourcequotaproperties:#.units",
	"resourcequotaproperties:#.type",
	"resourcequotaproperties:#.alertthreshold",
	"deleteprepare",
}
var PlatformFeaturesAliasArgs = []string{}
var PlatformFeaturesComments = map[string]string{
	"platformtype":                             "Platform type",
	"nodetype":                                 "Node type that supports this platform",
	"supportsmultitenantcluster":               "Platform supports multi tenant kubernetes clusters",
	"supportssharedvolume":                     "Platform supports shared volumes",
	"supportstrustpolicy":                      "Platform supports trust policies",
	"supportskubernetesonly":                   "Platform only supports kubernetes deployments",
	"kubernetesrequiresworkernodes":            "Kubernetes clusters requires worker nodes and cannot be master only",
	"cloudletserviceslocal":                    "Cloudlet servicess run local to the controller",
	"ipallocatedperservice":                    "Every kubernetes services gets a public IP (public cloud)",
	"supportsimagetypeovf":                     "Platform supports OVF images for VM deployments",
	"supportsimagetypeova":                     "Platform supports OVA images for VM deployments",
	"isvmpool":                                 "Platform is a a pool of pre-existing virtual machines",
	"isfake":                                   "Platform is a fake platform for unit/e2e testing",
	"ismock":                                   "Platform is a mock platform for developer/regression testing",
	"supportsadditionalnetworks":               "Platform supports adding networks",
	"issinglekubernetescluster":                "The entire platform is a single kubernetes cluster",
	"supportsappinstdedicatedip":               "Platform supports per AppInst dedicated IPs",
	"supportsplatformhighavailabilityonk8s":    "Supports high availability with two CRMs on kubernetes",
	"supportsplatformhighavailabilityondocker": "Supports high availability with two CRMs on docker",
	"nokubernetesclusterautoscale":             "No support for kubernetes cluster auto-scale",
	"isprebuiltkubernetescluster":              "Kubernetes cluster is created externally and already exists",
	"noclustersupport":                         "No cluster support. Some platforms, like Federation, do not support clusters.",
	"isedgebox":                                "Edgebox platforms are for user-hosted cloudlets, and must use public images and do not get DNS mapping, as they do not get access to sensitive data.",
	"supportsipv6":                             "Supports IPv6",
	"requirescrmonedge":                        "Requires on-edge-site CRM",
	"requirescrmoffedge":                       "Requires off-edge-site CRM, i.e. CCRM",
	"requirescertrefresh":                      "Requires certificate refresh (deprecated, not used)",
	"supportsmultiplenodepools":                "Kubernetes clusters support more than one node pool",
	"managesk8scontrolnodes":                   "Platform manages Kubernetes control nodes",
	"usesingress":                              "Platform uses ingress for inbound Kubernetes HTTP traffic",
	"requiresgpudriver":                        "Platform requires GPU Driver to be managed by Edge Cloud for installation onto new VMs or nodes with the license provided by the operator.",
	"usesrootlb":                               "Platform users a shared root load balancer",
	"supportscloudletmanagedclusters":          "Platform supports cloudlet managed clusters",
	"requireslbipallocation":                   "Platform uses requires load balancer IP allocation, typically for bare-metal with reservable floating IPs. Supported values are kube-vip.",
	"resourcequotaproperties:#.name":           "Resource name",
	"resourcequotaproperties:#.value":          "Resource value",
	"resourcequotaproperties:#.inframaxvalue":  "Resource infra max value",
	"resourcequotaproperties:#.quotamaxvalue":  "Resource quota max value",
	"resourcequotaproperties:#.description":    "Resource description",
	"resourcequotaproperties:#.units":          "Resource units",
	"resourcequotaproperties:#.type":           "Resource type category, i.e. gpu",
	"resourcequotaproperties:#.alertthreshold": "Generate alert when more than threshold percentage of resource is used",
	"deleteprepare":                            "Preparing to be deleted",
}
var PlatformFeaturesSpecialArgs = map[string]string{}
var CloudletResMapRequiredArgs = []string{
	"cloudletorg",
	"cloudlet",
	"mapping",
}
var CloudletResMapOptionalArgs = []string{
	"federatedorg",
}
var CloudletResMapAliasArgs = []string{
	"cloudletorg=key.organization",
	"cloudlet=key.name",
	"federatedorg=key.federatedorganization",
}
var CloudletResMapComments = map[string]string{
	"cloudletorg":  "Organization of the cloudlet site",
	"cloudlet":     "Name of the cloudlet",
	"federatedorg": "Federated operator organization who shared this cloudlet",
	"mapping":      "Resource mapping info",
}
var CloudletResMapSpecialArgs = map[string]string{
	"mapping": "StringToString",
}
var InfraConfigRequiredArgs = []string{}
var InfraConfigOptionalArgs = []string{
	"externalnetworkname",
	"flavorname",
}
var InfraConfigAliasArgs = []string{}
var InfraConfigComments = map[string]string{
	"externalnetworkname": "Infra specific external network name",
	"flavorname":          "Infra specific flavor name",
}
var InfraConfigSpecialArgs = map[string]string{}
var ResourceQuotaRequiredArgs = []string{}
var ResourceQuotaOptionalArgs = []string{
	"name",
	"value",
	"alertthreshold",
	"resourcetype",
}
var ResourceQuotaAliasArgs = []string{}
var ResourceQuotaComments = map[string]string{
	"name":           "Resource name on which to set quota",
	"value":          "Quota value of the resource",
	"alertthreshold": "Generate alert when more than threshold percentage of resource is used",
	"resourcetype":   "Resource type if non-generic resource, i.e. gpu",
}
var ResourceQuotaSpecialArgs = map[string]string{}
var GPUDriverKeyRequiredArgs = []string{}
var GPUDriverKeyOptionalArgs = []string{
	"name",
	"organization",
}
var GPUDriverKeyAliasArgs = []string{}
var GPUDriverKeyComments = map[string]string{
	"name":         "Name of the driver",
	"organization": "Organization to which the driver belongs to",
}
var GPUDriverKeySpecialArgs = map[string]string{}
var GPUDriverBuildRequiredArgs = []string{}
var GPUDriverBuildOptionalArgs = []string{
	"name",
	"driverpath",
	"driverpathcreds",
	"operatingsystem",
	"kernelversion",
	"hypervisorinfo",
	"md5sum",
}
var GPUDriverBuildAliasArgs = []string{}
var GPUDriverBuildComments = map[string]string{
	"name":            "Unique identifier key",
	"driverpath":      "Path where the driver package is located, must be either a public path or the URL to the driver uploaded to the internal artifact registry.",
	"driverpathcreds": "(deprecated) Optional credentials (username:password) to access driver path",
	"operatingsystem": "Operator System supported by GPU driver build, one of Linux, Windows, Others",
	"kernelversion":   "Kernel Version supported by GPU driver build",
	"hypervisorinfo":  "Info on hypervisor supported by vGPU driver",
	"md5sum":          "Driver package md5sum to ensure package is not corrupted",
	"storagepath":     "GPU driver build storage path",
}
var GPUDriverBuildSpecialArgs = map[string]string{}
var GPUDriverBuildMemberRequiredArgs = []string{
	"gpudrivername",
	"gpudriverorg",
}
var GPUDriverBuildMemberOptionalArgs = []string{
	"build.name",
	"build.driverpath",
	"build.driverpathcreds",
	"build.operatingsystem",
	"build.kernelversion",
	"build.hypervisorinfo",
	"build.md5sum",
	"build.storagepath",
	"ignorestate",
}
var GPUDriverBuildMemberAliasArgs = []string{
	"gpudrivername=key.name",
	"gpudriverorg=key.organization",
}
var GPUDriverBuildMemberComments = map[string]string{
	"gpudrivername":         "Name of the driver",
	"gpudriverorg":          "Organization to which the driver belongs to",
	"build.name":            "Unique identifier key",
	"build.driverpath":      "Path where the driver package is located, must be either a public path or the URL to the driver uploaded to the internal artifact registry.",
	"build.driverpathcreds": "(deprecated) Optional credentials (username:password) to access driver path",
	"build.operatingsystem": "Operator System supported by GPU driver build, one of Linux, Windows, Others",
	"build.kernelversion":   "Kernel Version supported by GPU driver build",
	"build.hypervisorinfo":  "Info on hypervisor supported by vGPU driver",
	"build.md5sum":          "Driver package md5sum to ensure package is not corrupted",
	"build.storagepath":     "GPU driver build storage path",
	"ignorestate":           "Ignore state will ignore any action in-progress on the GPU driver",
}
var GPUDriverBuildMemberSpecialArgs = map[string]string{}
var GPUDriverBuildURLRequiredArgs = []string{}
var GPUDriverBuildURLOptionalArgs = []string{
	"buildurlpath",
	"validity",
}
var GPUDriverBuildURLAliasArgs = []string{}
var GPUDriverBuildURLComments = map[string]string{
	"buildurlpath": "Build URL path",
	"validity":     "Build URL path validity",
}
var GPUDriverBuildURLSpecialArgs = map[string]string{}
var GPUDriverRequiredArgs = []string{
	"gpudrivername",
}
var GPUDriverOptionalArgs = []string{
	"gpudriverorg",
	"builds:empty",
	"builds:#.name",
	"builds:#.driverpath",
	"builds:#.driverpathcreds",
	"builds:#.operatingsystem",
	"builds:#.kernelversion",
	"builds:#.hypervisorinfo",
	"builds:#.md5sum",
	"builds:#.storagepath",
	"licenseconfig",
	"properties",
	"ignorestate",
}
var GPUDriverAliasArgs = []string{
	"gpudrivername=key.name",
	"gpudriverorg=key.organization",
}
var GPUDriverComments = map[string]string{
	"fields":                   "Fields are used for the Update API to specify which fields to apply",
	"gpudrivername":            "Name of the driver",
	"gpudriverorg":             "Organization to which the driver belongs to",
	"builds:empty":             "List of GPU driver build, specify builds:empty=true to clear",
	"builds:#.name":            "Unique identifier key",
	"builds:#.driverpath":      "Path where the driver package is located, must be either a public path or the URL to the driver uploaded to the internal artifact registry.",
	"builds:#.driverpathcreds": "(deprecated) Optional credentials (username:password) to access driver path",
	"builds:#.operatingsystem": "Operator System supported by GPU driver build, one of Linux, Windows, Others",
	"builds:#.kernelversion":   "Kernel Version supported by GPU driver build",
	"builds:#.hypervisorinfo":  "Info on hypervisor supported by vGPU driver",
	"builds:#.md5sum":          "Driver package md5sum to ensure package is not corrupted",
	"builds:#.storagepath":     "GPU driver build storage path",
	"licenseconfig":            "URL to license config file to setup license",
	"licenseconfigmd5sum":      "License config md5sum, to ensure integrity of license config",
	"properties":               "Additional properties associated with GPU driver build For example: license server information, driver release date, etc, specify properties:empty=true to clear",
	"state":                    "State to figure out if any action on the GPU driver is in-progress",
	"ignorestate":              "Ignore state will ignore any action in-progress on the GPU driver",
	"deleteprepare":            "Preparing to be deleted",
	"storagebucketname":        "(deprecated) GPU driver storage bucket name",
	"licenseconfigstoragepath": "GPU driver license config storage path",
}
var GPUDriverSpecialArgs = map[string]string{
	"fields":     "StringArray",
	"properties": "StringToString",
}
var GPUConfigRequiredArgs = []string{}
var GPUConfigOptionalArgs = []string{
	"driver.name",
	"driver.organization",
	"properties",
	"licenseconfig",
}
var GPUConfigAliasArgs = []string{}
var GPUConfigComments = map[string]string{
	"driver.name":         "Name of the driver",
	"driver.organization": "Organization to which the driver belongs to",
	"properties":          "Properties to identify specifics of GPU",
	"licenseconfig":       "Cloudlet specific license config to setup license",
	"licenseconfigmd5sum": "Cloudlet specific license config md5sum, to ensure integrity of license config",
}
var GPUConfigSpecialArgs = map[string]string{
	"properties": "StringToString",
}
var CloudletRequiredArgs = []string{
	"cloudletorg",
	"cloudlet",
}
var CloudletOptionalArgs = []string{
	"federatedorg",
	"location.latitude",
	"location.longitude",
	"location.altitude",
	"zone",
	"ipsupport",
	"staticips",
	"numdynamicips",
	"timelimits.createclusterinsttimeout",
	"timelimits.updateclusterinsttimeout",
	"timelimits.deleteclusterinsttimeout",
	"timelimits.createappinsttimeout",
	"timelimits.updateappinsttimeout",
	"timelimits.deleteappinsttimeout",
	"crmoverride",
	"deploymentlocal",
	"platformtype",
	"notifysrvaddr",
	"flavor.name",
	"physicalname",
	"envvar",
	"containerversion",
	"accessvars",
	"vmimageversion",
	"deployment",
	"infraapiaccess",
	"infraconfig.externalnetworkname",
	"infraconfig.flavorname",
	"maintenancestate",
	"overridepolicycontainerversion",
	"vmpool",
	"trustpolicy",
	"resourcequotas:empty",
	"resourcequotas:#.name",
	"resourcequotas:#.value",
	"resourcequotas:#.alertthreshold",
	"resourcequotas:#.resourcetype",
	"defaultresourcealertthreshold",
	"kafkacluster",
	"kafkauser",
	"kafkapassword",
	"gpuconfig.driver.name",
	"gpuconfig.driver.organization",
	"gpuconfig.properties",
	"gpuconfig.licenseconfig",
	"enabledefaultserverlesscluster",
	"allianceorgs",
	"singlekubernetesclusterowner",
	"singlekubernetesnamespace",
	"platformhighavailability",
	"secondarynotifysrvaddr",
	"federationconfig.federationcontextid",
	"federationconfig.partnerfederationaddr",
	"federationconfig.federationdbid",
	"federationconfig.federationname",
	"infraflavors:empty",
	"infraflavors:#.name",
	"infraflavors:#.vcpus",
	"infraflavors:#.ram",
	"infraflavors:#.disk",
	"infraflavors:#.gpus:empty",
	"infraflavors:#.gpus:#.modelid",
	"infraflavors:#.gpus:#.count",
	"infraflavors:#.gpus:#.vendor",
	"infraflavors:#.gpus:#.memory",
	"infraflavors:#.gpus:#.inuse",
	"infraflavors:#.propmap",
	"edgeboxonly",
	"crmonedge",
	"objid",
	"annotations",
	"dbmodelid",
}
var CloudletAliasArgs = []string{
	"cloudletorg=key.organization",
	"cloudlet=key.name",
	"federatedorg=key.federatedorganization",
}
var CloudletComments = map[string]string{
	"fields":                                 "Fields are used for the Update API to specify which fields to apply",
	"cloudletorg":                            "Organization of the cloudlet site",
	"cloudlet":                               "Name of the cloudlet",
	"federatedorg":                           "Federated operator organization who shared this cloudlet",
	"location.latitude":                      "Latitude in WGS 84 coordinates",
	"location.longitude":                     "Longitude in WGS 84 coordinates",
	"location.horizontalaccuracy":            "Horizontal accuracy (radius in meters)",
	"location.verticalaccuracy":              "Vertical accuracy (meters)",
	"location.altitude":                      "On android only lat and long are guaranteed to be supplied Altitude in meters",
	"location.course":                        "Course (IOS) / bearing (Android) (degrees east relative to true north)",
	"location.speed":                         "Speed (IOS) / velocity (Android) (meters/sec)",
	"location.timestamp":                     "Timestamp",
	"zone":                                   "Zone assignment, must be set to allow deployment to cloudlet",
	"ipsupport":                              "Type of IP support provided by Cloudlet (see IpSupport), one of Unknown, Static, Dynamic",
	"staticips":                              "List of static IPs for static IP support",
	"numdynamicips":                          "Number of dynamic IPs available for dynamic IP support",
	"timelimits.createclusterinsttimeout":    "Override default max time to create a cluster instance (duration)",
	"timelimits.updateclusterinsttimeout":    "Override default max time to update a cluster instance (duration)",
	"timelimits.deleteclusterinsttimeout":    "Override default max time to delete a cluster instance (duration)",
	"timelimits.createappinsttimeout":        "Override default max time to create an app instance (duration)",
	"timelimits.updateappinsttimeout":        "Override default max time to update an app instance (duration)",
	"timelimits.deleteappinsttimeout":        "Override default max time to delete an app instance (duration)",
	"errors":                                 "Any errors trying to create, update, or delete the Cloudlet., specify errors:empty=true to clear",
	"state":                                  "Current state of the crm, one of TrackedStateUnknown, NotPresent, CreateRequested, Creating, CreateError, Ready, UpdateRequested, Updating, UpdateError, DeleteRequested, Deleting, DeleteError, DeletePrepare, CrmInitok, CreatingDependencies, DeleteDone",
	"crmoverride":                            "Override actions to CRM, one of NoOverride, IgnoreCrmErrors, IgnoreCrm, IgnoreTransientState, IgnoreCrmAndTransientState",
	"deploymentlocal":                        "Deploy cloudlet services locally for testing purposes",
	"platformtype":                           "Platform type",
	"notifysrvaddr":                          "Address for the CRM notify listener to run on",
	"flavor.name":                            "Flavor name",
	"physicalname":                           "Physical infrastructure cloudlet name",
	"envvar":                                 "Single Key-Value pair of env var to be passed to CRM, specify envvar:empty=true to clear",
	"containerversion":                       "Cloudlet container version",
	"config.containerregistrypath":           "Path to Docker registry holding edge-cloud image",
	"config.cloudletvmimagepath":             "Path to platform base image",
	"config.notifyctrladdrs":                 "Address of controller notify port (can be multiple of these)",
	"config.tlscertfile":                     "TLS cert file",
	"config.tlskeyfile":                      "TLS key file",
	"config.tlscafile":                       "TLS ca file",
	"config.envvar":                          "Environment variables, specify config.envvar:empty=true to clear",
	"config.platformtag":                     "Tag of edge-cloud image",
	"config.testmode":                        "Internal Test flag",
	"config.span":                            "Span string",
	"config.cleanupmode":                     "Internal cleanup flag",
	"config.region":                          "Region",
	"config.commercialcerts":                 "Get certs from vault or generate your own for the root load balancer",
	"config.usevaultpki":                     "Use Vault certs and CAs for internal TLS communication",
	"config.appdnsroot":                      "App domain name root",
	"config.deploymenttag":                   "Deployment Tag",
	"config.crmaccessprivatekey":             "crm access private key",
	"config.accessapiaddr":                   "controller access API address",
	"config.cachedir":                        "cache dir",
	"config.secondarycrmaccessprivatekey":    "secondary crm access private key",
	"config.thanosrecvaddr":                  "Thanos Receive remote write address",
	"config.ansiblepublicaddr":               "Ansible public address for CRM to connect to CCRM",
	"config.envoywithcurlimage":              "docker image path for envoy with curl",
	"config.nginxwithcurlimage":              "docker image path for nginx with curl",
	"accessvars":                             "Secrets required to access cloudlet, will be saved in encrypted storage, and cleared on the cloudlet object, specify accessvars:empty=true to clear",
	"vmimageversion":                         "EdgeCloud baseimage version where CRM services reside",
	"deployment":                             "Deployment type to bring up CRM services (docker, kubernetes)",
	"infraapiaccess":                         "Infra Access Type is the type of access available to Infra API Endpoint, one of DirectAccess, RestrictedAccess",
	"infraconfig.externalnetworkname":        "Infra specific external network name",
	"infraconfig.flavorname":                 "Infra specific flavor name",
	"maintenancestate":                       "State for maintenance, one of NormalOperation, MaintenanceStart, MaintenanceStartNoFailover",
	"overridepolicycontainerversion":         "Override container version from policy file",
	"vmpool":                                 "VM Pool",
	"crmaccesspublickey":                     "CRM access public key",
	"crmaccesskeyupgraderequired":            "CRM access key upgrade required",
	"createdat":                              "Created at time",
	"updatedat":                              "Updated at time",
	"trustpolicy":                            "Optional Trust Policy",
	"trustpolicystate":                       "State of trust policy, one of TrackedStateUnknown, NotPresent, CreateRequested, Creating, CreateError, Ready, UpdateRequested, Updating, UpdateError, DeleteRequested, Deleting, DeleteError, DeletePrepare, CrmInitok, CreatingDependencies, DeleteDone",
	"resourcequotas:empty":                   "Resource quotas, specify resourcequotas:empty=true to clear",
	"resourcequotas:#.name":                  "Resource name on which to set quota",
	"resourcequotas:#.value":                 "Quota value of the resource",
	"resourcequotas:#.alertthreshold":        "Generate alert when more than threshold percentage of resource is used",
	"resourcequotas:#.resourcetype":          "Resource type if non-generic resource, i.e. gpu",
	"defaultresourcealertthreshold":          "Default resource alert threshold percentage",
	"hostcontroller":                         "Address of the controller hosting the cloudlet services if it is running locally",
	"kafkacluster":                           "Operator provided kafka cluster endpoint to push events to",
	"kafkauser":                              "Username for kafka SASL/PLAIN authentification, stored securely in secret storage and never visible externally",
	"kafkapassword":                          "Password for kafka SASL/PLAIN authentification, stored securely in secret storage and never visible externally",
	"gpuconfig.driver.name":                  "Name of the driver",
	"gpuconfig.driver.organization":          "Organization to which the driver belongs to",
	"gpuconfig.properties":                   "Properties to identify specifics of GPU, specify gpuconfig.properties:empty=true to clear",
	"gpuconfig.licenseconfig":                "Cloudlet specific license config to setup license",
	"gpuconfig.licenseconfigmd5sum":          "Cloudlet specific license config md5sum, to ensure integrity of license config",
	"enabledefaultserverlesscluster":         "Enable experimental default multitenant (serverless) cluster",
	"allianceorgs":                           "This cloudlet will be treated as directly connected to these additional operator organizations for the purposes of FindCloudlet, specify allianceorgs:empty=true to clear",
	"singlekubernetesclusterowner":           "For single kubernetes cluster cloudlet platforms, cluster is owned by this organization instead of multi-tenant",
	"singlekubernetesnamespace":              "For single kubernetes cluster cloudlet platforms, deployments are limited to the specified namespace.",
	"deleteprepare":                          "Preparing to be deleted",
	"platformhighavailability":               "Enable platform H/A",
	"secondarycrmaccesspublickey":            "CRM secondary access public key for H/A",
	"secondarycrmaccesskeyupgraderequired":   "CRM secondary access key upgrade required for H/A",
	"secondarynotifysrvaddr":                 "Address for the secondary CRM notify listener to run on",
	"dnslabel":                               "DNS label that is unique within the region",
	"rootlbfqdn":                             "Root LB FQDN which is globally unique",
	"staticrootlbfqdn":                       "Static Root LB FQDN gets set when the object is created and cannot be changed",
	"federationconfig.federationcontextid":   "Federation context id",
	"federationconfig.partnerfederationaddr": "Partner federation address",
	"federationconfig.federationdbid":        "Federation database id",
	"federationconfig.federationname":        "Federation Name",
	"licenseconfigstoragepath":               "GPU driver license config storage path",
	"infraflavors:empty":                     "Cloudlet-specific flavors, specify infraflavors:empty=true to clear",
	"infraflavors:#.name":                    "Name of the infra flavor",
	"infraflavors:#.vcpus":                   "Number of VCPU cores on the infra flavor",
	"infraflavors:#.ram":                     "Ram in MB on the infra flavor",
	"infraflavors:#.disk":                    "Amount of disk in GB on the infra flavor",
	"infraflavors:#.gpus:empty":              "GPUs for the infra flavor, specify infraflavors:#.gpus:empty=true to clear",
	"infraflavors:#.gpus:#.modelid":          "GPU model unique identifier",
	"infraflavors:#.gpus:#.count":            "Count of how many of this GPU are required/present",
	"infraflavors:#.gpus:#.vendor":           "GPU vendor (nvidia, amd, etc)",
	"infraflavors:#.gpus:#.memory":           "Memory in GB",
	"infraflavors:#.gpus:#.inuse":            "Read-only indication of how many GPUs are in use by tenants for usage APIs",
	"infraflavors:#.propmap":                 "Infra flavor Properties, if any, specify infraflavors:#.propmap:empty=true to clear",
	"edgeboxonly":                            "Edgebox only cloudlets allow for developers to set up cloudlets anywhere (laptop, etc) but can only use public images and do not support DNS mapping.",
	"crmonedge":                              "CRM shall run on the edge site if true (required for restricted cloudlets), otherwise runs centrally (default)",
	"objid":                                  "Universally unique object ID",
	"annotations":                            "Annotations, specify annotations:empty=true to clear",
	"dbmodelid":                              "database version model ID",
}
var CloudletSpecialArgs = map[string]string{
	"accessvars":             "StringToString",
	"allianceorgs":           "StringArray",
	"annotations":            "StringToString",
	"config.envvar":          "StringToString",
	"envvar":                 "StringToString",
	"errors":                 "StringArray",
	"fields":                 "StringArray",
	"gpuconfig.properties":   "StringToString",
	"infraflavors:#.propmap": "StringToString",
}
var FlavorMatchRequiredArgs = []string{
	"cloudletorg",
	"cloudlet",
	"flavor",
}
var FlavorMatchOptionalArgs = []string{
	"federatedorg",
	"availabilityzone",
}
var FlavorMatchAliasArgs = []string{
	"cloudletorg=key.organization",
	"cloudlet=key.name",
	"federatedorg=key.federatedorganization",
	"flavor=flavorname",
}
var FlavorMatchComments = map[string]string{
	"cloudletorg":      "Organization of the cloudlet site",
	"cloudlet":         "Name of the cloudlet",
	"federatedorg":     "Federated operator organization who shared this cloudlet",
	"flavor":           "Flavor name to lookup",
	"availabilityzone": "availability zone for optional resources if any",
}
var FlavorMatchSpecialArgs = map[string]string{}
var CloudletManifestRequiredArgs = []string{}
var CloudletManifestOptionalArgs = []string{
	"manifest",
}
var CloudletManifestAliasArgs = []string{}
var CloudletManifestComments = map[string]string{
	"manifest": "Manifest to bringup cloudlet VM and services.",
}
var CloudletManifestSpecialArgs = map[string]string{}
var PropertyInfoRequiredArgs = []string{}
var PropertyInfoOptionalArgs = []string{
	"name",
	"description",
	"value",
	"secret",
	"mandatory",
	"internal",
	"totpsecret",
}
var PropertyInfoAliasArgs = []string{}
var PropertyInfoComments = map[string]string{
	"name":        "Name of the property",
	"description": "Description of the property",
	"value":       "Default value of the property",
	"secret":      "Is the property a secret value, will be hidden",
	"mandatory":   "Is the property mandatory",
	"internal":    "Is the property internal, not to be set by Operator",
	"totpsecret":  "The property is a time-based one-time password (TOTP, RFC 6238) secret key that will be used to generate TOTP codes, and never leaves Vault.",
}
var PropertyInfoSpecialArgs = map[string]string{}
var CloudletPropsRequiredArgs = []string{}
var CloudletPropsOptionalArgs = []string{
	"platformtype",
	"organization",
}
var CloudletPropsAliasArgs = []string{}
var CloudletPropsComments = map[string]string{
	"platformtype": "Platform type",
	"organization": "Organization",
}
var CloudletPropsSpecialArgs = map[string]string{}
var CloudletResourceQuotaPropsRequiredArgs = []string{}
var CloudletResourceQuotaPropsOptionalArgs = []string{
	"platformtype",
	"properties:#.name",
	"properties:#.value",
	"properties:#.inframaxvalue",
	"properties:#.quotamaxvalue",
	"properties:#.description",
	"properties:#.units",
	"properties:#.type",
	"properties:#.alertthreshold",
	"organization",
}
var CloudletResourceQuotaPropsAliasArgs = []string{}
var CloudletResourceQuotaPropsComments = map[string]string{
	"platformtype":                "Platform type",
	"properties:#.name":           "Resource name",
	"properties:#.value":          "Resource value",
	"properties:#.inframaxvalue":  "Resource infra max value",
	"properties:#.quotamaxvalue":  "Resource quota max value",
	"properties:#.description":    "Resource description",
	"properties:#.units":          "Resource units",
	"properties:#.type":           "Resource type category, i.e. gpu",
	"properties:#.alertthreshold": "Generate alert when more than threshold percentage of resource is used",
	"organization":                "Organization",
}
var CloudletResourceQuotaPropsSpecialArgs = map[string]string{}
var CloudletResourceUsageRequiredArgs = []string{
	"cloudletorg",
	"cloudlet",
}
var CloudletResourceUsageOptionalArgs = []string{
	"federatedorg",
	"infrausage",
	"info:#.name",
	"info:#.value",
	"info:#.inframaxvalue",
	"info:#.quotamaxvalue",
	"info:#.description",
	"info:#.units",
	"info:#.type",
	"info:#.alertthreshold",
	"resourcescore",
}
var CloudletResourceUsageAliasArgs = []string{
	"cloudletorg=key.organization",
	"cloudlet=key.name",
	"federatedorg=key.federatedorganization",
}
var CloudletResourceUsageComments = map[string]string{
	"cloudletorg":           "Organization of the cloudlet site",
	"cloudlet":              "Name of the cloudlet",
	"federatedorg":          "Federated operator organization who shared this cloudlet",
	"infrausage":            "Show Infra based usage",
	"info:#.name":           "Resource name",
	"info:#.value":          "Resource value",
	"info:#.inframaxvalue":  "Resource infra max value",
	"info:#.quotamaxvalue":  "Resource quota max value",
	"info:#.description":    "Resource description",
	"info:#.units":          "Resource units",
	"info:#.type":           "Resource type category, i.e. gpu",
	"info:#.alertthreshold": "Generate alert when more than threshold percentage of resource is used",
	"resourcescore":         "Resouce score, higher score means more available resources",
}
var CloudletResourceUsageSpecialArgs = map[string]string{}
var CloudletGPUUsageRequiredArgs = []string{
	"key.organization",
	"key.name",
	"key.federatedorganization",
}
var CloudletGPUUsageOptionalArgs = []string{
	"gpus:#.gpu.modelid",
	"gpus:#.gpu.count",
	"gpus:#.gpu.vendor",
	"gpus:#.gpu.memory",
	"gpus:#.gpu.inuse",
	"gpus:#.usage.name",
	"gpus:#.usage.value",
	"gpus:#.usage.inframaxvalue",
	"gpus:#.usage.quotamaxvalue",
	"gpus:#.usage.description",
	"gpus:#.usage.units",
	"gpus:#.usage.type",
	"gpus:#.usage.alertthreshold",
}
var CloudletGPUUsageAliasArgs = []string{}
var CloudletGPUUsageComments = map[string]string{
	"key.organization":            "Organization of the cloudlet site",
	"key.name":                    "Name of the cloudlet",
	"key.federatedorganization":   "Federated operator organization who shared this cloudlet",
	"gpus:#.gpu.modelid":          "GPU model unique identifier",
	"gpus:#.gpu.count":            "Count of how many of this GPU are required/present",
	"gpus:#.gpu.vendor":           "GPU vendor (nvidia, amd, etc)",
	"gpus:#.gpu.memory":           "Memory in GB",
	"gpus:#.gpu.inuse":            "Read-only indication of how many GPUs are in use by tenants for usage APIs",
	"gpus:#.usage.name":           "Resource name",
	"gpus:#.usage.value":          "Resource value",
	"gpus:#.usage.inframaxvalue":  "Resource infra max value",
	"gpus:#.usage.quotamaxvalue":  "Resource quota max value",
	"gpus:#.usage.description":    "Resource description",
	"gpus:#.usage.units":          "Resource units",
	"gpus:#.usage.type":           "Resource type category, i.e. gpu",
	"gpus:#.usage.alertthreshold": "Generate alert when more than threshold percentage of resource is used",
}
var CloudletGPUUsageSpecialArgs = map[string]string{}
var CloudletAllianceOrgRequiredArgs = []string{
	"cloudletorg",
	"cloudlet",
	"organization",
}
var CloudletAllianceOrgOptionalArgs = []string{
	"federatedorg",
}
var CloudletAllianceOrgAliasArgs = []string{
	"cloudletorg=key.organization",
	"cloudlet=key.name",
	"federatedorg=key.federatedorganization",
}
var CloudletAllianceOrgComments = map[string]string{
	"cloudletorg":  "Organization of the cloudlet site",
	"cloudlet":     "Name of the cloudlet",
	"federatedorg": "Federated operator organization who shared this cloudlet",
	"organization": "Alliance organization",
}
var CloudletAllianceOrgSpecialArgs = map[string]string{}
var FlavorInfoRequiredArgs = []string{}
var FlavorInfoOptionalArgs = []string{
	"name",
	"vcpus",
	"ram",
	"disk",
	"gpus:#.modelid",
	"gpus:#.count",
	"gpus:#.vendor",
	"gpus:#.memory",
	"gpus:#.inuse",
	"propmap",
}
var FlavorInfoAliasArgs = []string{}
var FlavorInfoComments = map[string]string{
	"name":           "Name of the infra flavor",
	"vcpus":          "Number of VCPU cores on the infra flavor",
	"ram":            "Ram in MB on the infra flavor",
	"disk":           "Amount of disk in GB on the infra flavor",
	"gpus:#.modelid": "GPU model unique identifier",
	"gpus:#.count":   "Count of how many of this GPU are required/present",
	"gpus:#.vendor":  "GPU vendor (nvidia, amd, etc)",
	"gpus:#.memory":  "Memory in GB",
	"gpus:#.inuse":   "Read-only indication of how many GPUs are in use by tenants for usage APIs",
	"propmap":        "Infra flavor Properties, if any",
}
var FlavorInfoSpecialArgs = map[string]string{
	"propmap": "StringToString",
}
var OSAZoneRequiredArgs = []string{}
var OSAZoneOptionalArgs = []string{
	"name",
	"status",
}
var OSAZoneAliasArgs = []string{}
var OSAZoneComments = map[string]string{
	"name":   "OpenStack availability zone name",
	"status": "OpenStack availability zone status",
}
var OSAZoneSpecialArgs = map[string]string{}
var OSImageRequiredArgs = []string{}
var OSImageOptionalArgs = []string{
	"name",
	"tags",
	"properties",
	"diskformat",
}
var OSImageAliasArgs = []string{}
var OSImageComments = map[string]string{
	"name":       "image name",
	"tags":       "optional tags present on image",
	"properties": "image properties/metadata",
	"diskformat": "format qcow2, img, etc",
}
var OSImageSpecialArgs = map[string]string{}
var CloudletInfoRequiredArgs = []string{
	"cloudletorg",
	"cloudlet",
}
var CloudletInfoOptionalArgs = []string{
	"federatedorg",
	"state",
	"notifyid",
	"controller",
	"osmaxram",
	"osmaxvcores",
	"osmaxvolgb",
	"errors",
	"flavors:#.name",
	"flavors:#.vcpus",
	"flavors:#.ram",
	"flavors:#.disk",
	"flavors:#.gpus:#.modelid",
	"flavors:#.gpus:#.count",
	"flavors:#.gpus:#.vendor",
	"flavors:#.gpus:#.memory",
	"flavors:#.gpus:#.inuse",
	"flavors:#.propmap",
	"containerversion",
	"availabilityzones:#.name",
	"availabilityzones:#.status",
	"osimages:#.name",
	"osimages:#.tags",
	"osimages:#.properties",
	"osimages:#.diskformat",
	"controllercachereceived",
	"maintenancestate",
	"resourcessnapshot.platformvms:#.name",
	"resourcessnapshot.platformvms:#.type",
	"resourcessnapshot.platformvms:#.status",
	"resourcessnapshot.platformvms:#.infraflavor",
	"resourcessnapshot.platformvms:#.ipaddresses:#.externalip",
	"resourcessnapshot.platformvms:#.ipaddresses:#.internalip",
	"resourcessnapshot.platformvms:#.containers:#.name",
	"resourcessnapshot.platformvms:#.containers:#.type",
	"resourcessnapshot.platformvms:#.containers:#.status",
	"resourcessnapshot.platformvms:#.containers:#.clusterip",
	"resourcessnapshot.platformvms:#.containers:#.restarts",
	"resourcessnapshot.info:#.name",
	"resourcessnapshot.info:#.value",
	"resourcessnapshot.info:#.inframaxvalue",
	"resourcessnapshot.info:#.quotamaxvalue",
	"resourcessnapshot.info:#.description",
	"resourcessnapshot.info:#.units",
	"resourcessnapshot.info:#.type",
	"resourcessnapshot.info:#.alertthreshold",
	"resourcessnapshot.clusterinsts:#.name",
	"resourcessnapshot.clusterinsts:#.organization",
	"resourcessnapshot.vmappinsts:#.name",
	"resourcessnapshot.vmappinsts:#.organization",
	"resourcessnapshot.k8sappinsts:#.name",
	"resourcessnapshot.k8sappinsts:#.organization",
	"trustpolicystate",
	"compatibilityversion",
	"properties",
	"nodeinfos:#.name",
	"nodeinfos:#.gpus:#.modelid",
	"nodeinfos:#.gpus:#.count",
	"nodeinfos:#.gpus:#.vendor",
	"nodeinfos:#.gpus:#.memory",
	"nodeinfos:#.gpus:#.inuse",
	"nodeinfos:#.gpusoftware.driverversion",
	"nodeinfos:#.gpusoftware.runtimeversion",
	"activecrminstance",
	"standbycrm",
	"releaseversion",
	"nodepools:#.name",
	"nodepools:#.numnodes",
	"nodepools:#.noderesources.vcpus",
	"nodepools:#.noderesources.ram",
	"nodepools:#.noderesources.disk",
	"nodepools:#.noderesources.gpus:#.modelid",
	"nodepools:#.noderesources.gpus:#.count",
	"nodepools:#.noderesources.gpus:#.vendor",
	"nodepools:#.noderesources.gpus:#.memory",
	"nodepools:#.noderesources.gpus:#.inuse",
	"nodepools:#.noderesources.optresmap",
	"nodepools:#.noderesources.infranodeflavor",
	"nodepools:#.noderesources.externalvolumesize",
	"nodepools:#.scalable",
	"nodepools:#.controlplane",
}
var CloudletInfoAliasArgs = []string{
	"cloudletorg=key.organization",
	"cloudlet=key.name",
	"federatedorg=key.federatedorganization",
}
var CloudletInfoComments = map[string]string{
	"fields":                                 "Fields are used for the Update API to specify which fields to apply",
	"cloudletorg":                            "Organization of the cloudlet site",
	"cloudlet":                               "Name of the cloudlet",
	"federatedorg":                           "Federated operator organization who shared this cloudlet",
	"state":                                  "State of cloudlet, one of Unknown, Errors, Ready, Offline, NotPresent, Init, Upgrade, NeedSync",
	"notifyid":                               "Id of client assigned by server (internal use only)",
	"controller":                             "Connected controller unique id",
	"osmaxram":                               "Maximum Ram in MB on the Cloudlet",
	"osmaxvcores":                            "Maximum number of VCPU cores on the Cloudlet",
	"osmaxvolgb":                             "Maximum amount of disk in GB on the Cloudlet",
	"errors":                                 "Any errors encountered while making changes to the Cloudlet",
	"flavors:#.name":                         "Name of the infra flavor",
	"flavors:#.vcpus":                        "Number of VCPU cores on the infra flavor",
	"flavors:#.ram":                          "Ram in MB on the infra flavor",
	"flavors:#.disk":                         "Amount of disk in GB on the infra flavor",
	"flavors:#.gpus:#.modelid":               "GPU model unique identifier",
	"flavors:#.gpus:#.count":                 "Count of how many of this GPU are required/present",
	"flavors:#.gpus:#.vendor":                "GPU vendor (nvidia, amd, etc)",
	"flavors:#.gpus:#.memory":                "Memory in GB",
	"flavors:#.gpus:#.inuse":                 "Read-only indication of how many GPUs are in use by tenants for usage APIs",
	"flavors:#.propmap":                      "Infra flavor Properties, if any",
	"status.tasknumber":                      "Task number",
	"status.maxtasks":                        "Max tasks",
	"status.taskname":                        "Task name",
	"status.stepname":                        "Step name",
	"status.msgcount":                        "Message count",
	"status.msgs":                            "Messages",
	"containerversion":                       "Cloudlet container version",
	"availabilityzones:#.name":               "OpenStack availability zone name",
	"availabilityzones:#.status":             "OpenStack availability zone status",
	"osimages:#.name":                        "image name",
	"osimages:#.tags":                        "optional tags present on image",
	"osimages:#.properties":                  "image properties/metadata",
	"osimages:#.diskformat":                  "format qcow2, img, etc",
	"controllercachereceived":                "Indicates all controller data has been sent to CRM",
	"maintenancestate":                       "State for maintenance, one of NormalOperation, MaintenanceStart, MaintenanceStartNoFailover",
	"resourcessnapshot.platformvms:#.name":   "Virtual machine name",
	"resourcessnapshot.platformvms:#.type":   "Type can be platformvm, platform-cluster-master, platform-cluster-primary-node, platform-cluster-secondary-node, sharedrootlb, dedicatedrootlb, cluster-master, cluster-k8s-node, cluster-docker-node, appvm",
	"resourcessnapshot.platformvms:#.status": "Runtime status of the VM",
	"resourcessnapshot.platformvms:#.infraflavor":              "Flavor allocated within the cloudlet infrastructure, distinct from the control plane flavor",
	"resourcessnapshot.platformvms:#.ipaddresses:#.externalip": "External IP address",
	"resourcessnapshot.platformvms:#.ipaddresses:#.internalip": "Internal IP address",
	"resourcessnapshot.platformvms:#.containers:#.name":        "Name of the container",
	"resourcessnapshot.platformvms:#.containers:#.type":        "Type can be docker or kubernetes",
	"resourcessnapshot.platformvms:#.containers:#.status":      "Runtime status of the container",
	"resourcessnapshot.platformvms:#.containers:#.clusterip":   "IP within the CNI and is applicable to kubernetes only",
	"resourcessnapshot.platformvms:#.containers:#.restarts":    "Restart count, applicable to kubernetes only",
	"resourcessnapshot.info:#.name":                            "Resource name",
	"resourcessnapshot.info:#.value":                           "Resource value",
	"resourcessnapshot.info:#.inframaxvalue":                   "Resource infra max value",
	"resourcessnapshot.info:#.quotamaxvalue":                   "Resource quota max value",
	"resourcessnapshot.info:#.description":                     "Resource description",
	"resourcessnapshot.info:#.units":                           "Resource units",
	"resourcessnapshot.info:#.type":                            "Resource type category, i.e. gpu",
	"resourcessnapshot.info:#.alertthreshold":                  "Generate alert when more than threshold percentage of resource is used",
	"resourcessnapshot.clusterinsts:#.name":                    "Cluster name",
	"resourcessnapshot.clusterinsts:#.organization":            "Name of the organization that this cluster belongs to",
	"resourcessnapshot.vmappinsts:#.name":                      "App Instance name",
	"resourcessnapshot.vmappinsts:#.organization":              "App Instance organization",
	"resourcessnapshot.k8sappinsts:#.name":                     "App Instance name",
	"resourcessnapshot.k8sappinsts:#.organization":             "App Instance organization",
	"trustpolicystate":                                         "Trust Policy State, one of TrackedStateUnknown, NotPresent, CreateRequested, Creating, CreateError, Ready, UpdateRequested, Updating, UpdateError, DeleteRequested, Deleting, DeleteError, DeletePrepare, CrmInitok, CreatingDependencies, DeleteDone",
	"compatibilityversion":                                     "Version for compatibility tracking",
	"properties":                                               "Cloudlet properties",
	"nodeinfos:#.name":                                         "Node name",
	"nodeinfos:#.gpus:#.modelid":                               "GPU model unique identifier",
	"nodeinfos:#.gpus:#.count":                                 "Count of how many of this GPU are required/present",
	"nodeinfos:#.gpus:#.vendor":                                "GPU vendor (nvidia, amd, etc)",
	"nodeinfos:#.gpus:#.memory":                                "Memory in GB",
	"nodeinfos:#.gpus:#.inuse":                                 "Read-only indication of how many GPUs are in use by tenants for usage APIs",
	"nodeinfos:#.gpusoftware.driverversion":                    "driver version",
	"nodeinfos:#.gpusoftware.runtimeversion":                   "Runtime version",
	"activecrminstance":                                        "Active HA instance",
	"standbycrm":                                               "Denotes if info was reported by inactive",
	"releaseversion":                                           "Cloudlet release version",
	"nodepools:#.name":                                         "Node pool name",
	"nodepools:#.numnodes":                                     "Number of nodes in the pool",
	"nodepools:#.noderesources.vcpus":                          "Vcpus to be allocated to the VM, must be either 1 or an even number",
	"nodepools:#.noderesources.ram":                            "Total RAM in megabytes to be allocated to the VM",
	"nodepools:#.noderesources.disk":                           "Total disk space in gigabytes to be allocated to the VMs root partition",
	"nodepools:#.noderesources.gpus:#.modelid":                 "GPU model unique identifier",
	"nodepools:#.noderesources.gpus:#.count":                   "Count of how many of this GPU are required/present",
	"nodepools:#.noderesources.gpus:#.vendor":                  "GPU vendor (nvidia, amd, etc)",
	"nodepools:#.noderesources.gpus:#.memory":                  "Memory in GB",
	"nodepools:#.noderesources.gpus:#.inuse":                   "Read-only indication of how many GPUs are in use by tenants for usage APIs",
	"nodepools:#.noderesources.optresmap":                      "Optional resources request, i.e. optresmap=restype=resname:1",
	"nodepools:#.noderesources.infranodeflavor":                "Infrastructure specific node flavor",
	"nodepools:#.noderesources.externalvolumesize":             "Size of external volume to be attached to nodes. This is for the root partition",
	"nodepools:#.scalable":                                     "Scalable indicates the system may scale the number of nodes",
	"nodepools:#.controlplane":                                 "Node pool hosts the kubernetes control plane",
}
var CloudletInfoSpecialArgs = map[string]string{
	"errors":                              "StringArray",
	"fields":                              "StringArray",
	"flavors:#.propmap":                   "StringToString",
	"nodepools:#.noderesources.optresmap": "StringToString",
	"properties":                          "StringToString",
	"status.msgs":                         "StringArray",
}
var CloudletMetricsRequiredArgs = []string{}
var CloudletMetricsOptionalArgs = []string{
	"foo",
}
var CloudletMetricsAliasArgs = []string{}
var CloudletMetricsComments = map[string]string{
	"foo": "what goes here?",
}
var CloudletMetricsSpecialArgs = map[string]string{}
var CloudletManagedClusterKeyRequiredArgs = []string{}
var CloudletManagedClusterKeyOptionalArgs = []string{
	"name",
	"id",
}
var CloudletManagedClusterKeyAliasArgs = []string{}
var CloudletManagedClusterKeyComments = map[string]string{
	"name": "Infra specific cluster name",
	"id":   "Infra specific cluster ID",
}
var CloudletManagedClusterKeySpecialArgs = map[string]string{}
var CloudletManagedClusterRequiredArgs = []string{}
var CloudletManagedClusterOptionalArgs = []string{
	"name",
	"id",
	"cloudletorg",
	"cloudlet",
	"federatedorg",
	"cluster",
	"clusterorg",
	"reservable",
	"multitenant",
	"kubernetesversion",
	"regionorlocation",
	"resourcegroup",
	"state",
	"operationalstate",
}
var CloudletManagedClusterAliasArgs = []string{
	"name=key.name",
	"id=key.id",
	"cloudletorg=cloudletkey.organization",
	"cloudlet=cloudletkey.name",
	"federatedorg=cloudletkey.federatedorganization",
	"cluster=clusterkey.name",
	"clusterorg=clusterkey.organization",
}
var CloudletManagedClusterComments = map[string]string{
	"fields":            "Fields are used for the Update API to specify which fields to apply",
	"name":              "Infra specific cluster name",
	"id":                "Infra specific cluster ID",
	"cloudletorg":       "Organization of the cloudlet site",
	"cloudlet":          "Name of the cloudlet",
	"federatedorg":      "Federated operator organization who shared this cloudlet",
	"cluster":           "Cluster name",
	"clusterorg":        "Name of the organization that this cluster belongs to",
	"reservable":        "Set to true if cluster shall be reservable by users",
	"multitenant":       "Set to true if cluster shall be multi-tenant",
	"kubernetesversion": "Kubernetes version reported by infra",
	"regionorlocation":  "Region or location information",
	"resourcegroup":     "Resource group reported by infra",
	"state":             "State of the cluster",
	"operationalstate":  "Power or operating state of the cluster",
}
var CloudletManagedClusterSpecialArgs = map[string]string{
	"fields": "StringArray",
}
var ShowPlatformFeaturesForZoneRequiredArgs = []string{}
var ShowPlatformFeaturesForZoneOptionalArgs = []string{
	"zoneorg",
	"zone",
	"federatororg",
}
var UpdateGPUDriverRequiredArgs = []string{
	"gpudrivername",
}
var UpdateGPUDriverOptionalArgs = []string{
	"gpudriverorg",
	"licenseconfig",
	"properties",
}
var AddGPUDriverBuildRequiredArgs = []string{
	"gpudrivername",
	"gpudriverorg",
	"build.name",
	"build.driverpath",
	"build.operatingsystem",
	"build.md5sum",
}
var AddGPUDriverBuildOptionalArgs = []string{
	"build.driverpathcreds",
	"build.kernelversion",
	"build.hypervisorinfo",
	"build.storagepath",
	"ignorestate",
}
var RemoveGPUDriverBuildRequiredArgs = []string{
	"gpudrivername",
	"gpudriverorg",
	"build.name",
}
var RemoveGPUDriverBuildOptionalArgs = []string{
	"build.driverpathcreds",
	"build.md5sum",
	"build.storagepath",
	"ignorestate",
}
var GetGPUDriverBuildURLRequiredArgs = []string{
	"gpudrivername",
	"gpudriverorg",
	"build.name",
}
var GetGPUDriverBuildURLOptionalArgs = []string{
	"build.storagepath",
	"ignorestate",
}
var CreateCloudletRequiredArgs = []string{
	"cloudletorg",
	"cloudlet",
	"location.latitude",
	"location.longitude",
	"numdynamicips",
}
var CreateCloudletOptionalArgs = []string{
	"federatedorg",
	"location.altitude",
	"zone",
	"ipsupport",
	"staticips",
	"timelimits.createclusterinsttimeout",
	"timelimits.updateclusterinsttimeout",
	"timelimits.deleteclusterinsttimeout",
	"timelimits.createappinsttimeout",
	"timelimits.updateappinsttimeout",
	"timelimits.deleteappinsttimeout",
	"crmoverride",
	"deploymentlocal",
	"platformtype",
	"notifysrvaddr",
	"flavor.name",
	"physicalname",
	"envvar",
	"containerversion",
	"accessvars",
	"vmimageversion",
	"deployment",
	"infraapiaccess",
	"infraconfig.externalnetworkname",
	"infraconfig.flavorname",
	"maintenancestate",
	"overridepolicycontainerversion",
	"vmpool",
	"trustpolicy",
	"resourcequotas:#.name",
	"resourcequotas:#.value",
	"resourcequotas:#.alertthreshold",
	"resourcequotas:#.resourcetype",
	"defaultresourcealertthreshold",
	"kafkacluster",
	"kafkauser",
	"kafkapassword",
	"gpuconfig.driver.name",
	"gpuconfig.driver.organization",
	"gpuconfig.properties",
	"gpuconfig.licenseconfig",
	"enabledefaultserverlesscluster",
	"allianceorgs",
	"singlekubernetesclusterowner",
	"singlekubernetesnamespace",
	"platformhighavailability",
	"secondarynotifysrvaddr",
	"federationconfig.federationcontextid",
	"federationconfig.partnerfederationaddr",
	"federationconfig.federationdbid",
	"federationconfig.federationname",
	"infraflavors:#.name",
	"infraflavors:#.vcpus",
	"infraflavors:#.ram",
	"infraflavors:#.disk",
	"infraflavors:#.gpus:#.modelid",
	"infraflavors:#.gpus:#.count",
	"infraflavors:#.gpus:#.vendor",
	"infraflavors:#.gpus:#.memory",
	"infraflavors:#.gpus:#.inuse",
	"infraflavors:#.propmap",
	"edgeboxonly",
	"crmonedge",
	"objid",
	"annotations",
	"dbmodelid",
}
var DeleteCloudletRequiredArgs = []string{
	"cloudletorg",
	"cloudlet",
}
var DeleteCloudletOptionalArgs = []string{
	"federatedorg",
	"location.latitude",
	"location.longitude",
	"location.altitude",
	"zone",
	"ipsupport",
	"staticips",
	"numdynamicips",
	"timelimits.createclusterinsttimeout",
	"timelimits.updateclusterinsttimeout",
	"timelimits.deleteclusterinsttimeout",
	"timelimits.createappinsttimeout",
	"timelimits.updateappinsttimeout",
	"timelimits.deleteappinsttimeout",
	"crmoverride",
	"deploymentlocal",
	"platformtype",
	"notifysrvaddr",
	"flavor.name",
	"physicalname",
	"envvar",
	"containerversion",
	"accessvars",
	"vmimageversion",
	"deployment",
	"infraapiaccess",
	"infraconfig.externalnetworkname",
	"infraconfig.flavorname",
	"maintenancestate",
	"overridepolicycontainerversion",
	"vmpool",
	"trustpolicy",
	"resourcequotas:#.name",
	"resourcequotas:#.value",
	"resourcequotas:#.alertthreshold",
	"resourcequotas:#.resourcetype",
	"defaultresourcealertthreshold",
	"kafkacluster",
	"kafkauser",
	"kafkapassword",
	"gpuconfig.driver.name",
	"gpuconfig.driver.organization",
	"gpuconfig.properties",
	"gpuconfig.licenseconfig",
	"enabledefaultserverlesscluster",
	"allianceorgs",
	"singlekubernetesclusterowner",
	"singlekubernetesnamespace",
	"platformhighavailability",
	"secondarynotifysrvaddr",
	"federationconfig.federationcontextid",
	"federationconfig.partnerfederationaddr",
	"federationconfig.federationdbid",
	"federationconfig.federationname",
	"infraflavors:#.name",
	"infraflavors:#.vcpus",
	"infraflavors:#.ram",
	"infraflavors:#.disk",
	"infraflavors:#.gpus:#.modelid",
	"infraflavors:#.gpus:#.count",
	"infraflavors:#.gpus:#.vendor",
	"infraflavors:#.gpus:#.memory",
	"infraflavors:#.gpus:#.inuse",
	"infraflavors:#.propmap",
	"edgeboxonly",
	"crmonedge",
	"objid",
	"annotations",
	"dbmodelid",
}
var UpdateCloudletRequiredArgs = []string{
	"cloudletorg",
	"cloudlet",
}
var UpdateCloudletOptionalArgs = []string{
	"federatedorg",
	"location.latitude",
	"location.longitude",
	"location.altitude",
	"zone",
	"ipsupport",
	"staticips",
	"numdynamicips",
	"timelimits.createclusterinsttimeout",
	"timelimits.updateclusterinsttimeout",
	"timelimits.deleteclusterinsttimeout",
	"timelimits.createappinsttimeout",
	"timelimits.updateappinsttimeout",
	"timelimits.deleteappinsttimeout",
	"crmoverride",
	"notifysrvaddr",
	"envvar",
	"accessvars",
	"maintenancestate",
	"trustpolicy",
	"resourcequotas:empty",
	"resourcequotas:#.name",
	"resourcequotas:#.value",
	"resourcequotas:#.alertthreshold",
	"resourcequotas:#.resourcetype",
	"defaultresourcealertthreshold",
	"kafkacluster",
	"kafkauser",
	"kafkapassword",
	"gpuconfig.driver.name",
	"gpuconfig.driver.organization",
	"gpuconfig.properties",
	"gpuconfig.licenseconfig",
	"enabledefaultserverlesscluster",
	"allianceorgs",
	"singlekubernetesclusterowner",
	"singlekubernetesnamespace",
	"platformhighavailability",
	"secondarynotifysrvaddr",
	"federationconfig.federationcontextid",
	"federationconfig.partnerfederationaddr",
	"federationconfig.federationdbid",
	"federationconfig.federationname",
	"infraflavors:empty",
	"infraflavors:#.name",
	"infraflavors:#.vcpus",
	"infraflavors:#.ram",
	"infraflavors:#.disk",
	"infraflavors:#.gpus:empty",
	"infraflavors:#.gpus:#.modelid",
	"infraflavors:#.gpus:#.count",
	"infraflavors:#.gpus:#.vendor",
	"infraflavors:#.gpus:#.memory",
	"infraflavors:#.gpus:#.inuse",
	"infraflavors:#.propmap",
	"crmonedge",
	"objid",
	"annotations",
	"dbmodelid",
}
var ShowCloudletRequiredArgs = []string{
	"cloudletorg",
	"cloudlet",
}
var ShowCloudletOptionalArgs = []string{
	"federatedorg",
	"location.latitude",
	"location.longitude",
	"location.altitude",
	"zone",
	"ipsupport",
	"staticips",
	"numdynamicips",
	"timelimits.createclusterinsttimeout",
	"timelimits.updateclusterinsttimeout",
	"timelimits.deleteclusterinsttimeout",
	"timelimits.createappinsttimeout",
	"timelimits.updateappinsttimeout",
	"timelimits.deleteappinsttimeout",
	"crmoverride",
	"deploymentlocal",
	"platformtype",
	"notifysrvaddr",
	"flavor.name",
	"physicalname",
	"envvar",
	"containerversion",
	"accessvars",
	"vmimageversion",
	"deployment",
	"infraapiaccess",
	"infraconfig.externalnetworkname",
	"infraconfig.flavorname",
	"maintenancestate",
	"overridepolicycontainerversion",
	"vmpool",
	"trustpolicy",
	"resourcequotas:#.name",
	"resourcequotas:#.value",
	"resourcequotas:#.alertthreshold",
	"resourcequotas:#.resourcetype",
	"defaultresourcealertthreshold",
	"kafkacluster",
	"kafkauser",
	"kafkapassword",
	"gpuconfig.driver.name",
	"gpuconfig.driver.organization",
	"gpuconfig.properties",
	"gpuconfig.licenseconfig",
	"enabledefaultserverlesscluster",
	"allianceorgs",
	"singlekubernetesclusterowner",
	"singlekubernetesnamespace",
	"platformhighavailability",
	"secondarynotifysrvaddr",
	"federationconfig.federationcontextid",
	"federationconfig.partnerfederationaddr",
	"federationconfig.federationdbid",
	"federationconfig.federationname",
	"infraflavors:#.name",
	"infraflavors:#.vcpus",
	"infraflavors:#.ram",
	"infraflavors:#.disk",
	"infraflavors:#.gpus:#.modelid",
	"infraflavors:#.gpus:#.count",
	"infraflavors:#.gpus:#.vendor",
	"infraflavors:#.gpus:#.memory",
	"infraflavors:#.gpus:#.inuse",
	"infraflavors:#.propmap",
	"edgeboxonly",
	"crmonedge",
	"objid",
	"annotations",
	"dbmodelid",
}
var GetCloudletPropsRequiredArgs = []string{
	"platformtype",
}
var GetCloudletPropsOptionalArgs = []string{
	"organization",
}
var GetCloudletResourceQuotaPropsRequiredArgs = []string{
	"platformtype",
}
var GetCloudletResourceQuotaPropsOptionalArgs = []string{
	"organization",
}
var GetCloudletResourceUsageRequiredArgs = []string{
	"cloudletorg",
	"cloudlet",
}
var GetCloudletResourceUsageOptionalArgs = []string{
	"federatedorg",
	"infrausage",
}
var ShowCloudletResourceUsageRequiredArgs = []string{}
var ShowCloudletResourceUsageOptionalArgs = []string{
	"cloudletorg",
	"cloudlet",
	"federatedorg",
	"location.latitude",
	"location.longitude",
	"location.altitude",
	"zone",
	"ipsupport",
	"staticips",
	"numdynamicips",
	"timelimits.createclusterinsttimeout",
	"timelimits.updateclusterinsttimeout",
	"timelimits.deleteclusterinsttimeout",
	"timelimits.createappinsttimeout",
	"timelimits.updateappinsttimeout",
	"timelimits.deleteappinsttimeout",
	"crmoverride",
	"deploymentlocal",
	"platformtype",
	"notifysrvaddr",
	"flavor.name",
	"physicalname",
	"envvar",
	"containerversion",
	"accessvars",
	"vmimageversion",
	"deployment",
	"infraapiaccess",
	"infraconfig.externalnetworkname",
	"infraconfig.flavorname",
	"maintenancestate",
	"overridepolicycontainerversion",
	"vmpool",
	"trustpolicy",
	"resourcequotas:#.name",
	"resourcequotas:#.value",
	"resourcequotas:#.alertthreshold",
	"resourcequotas:#.resourcetype",
	"defaultresourcealertthreshold",
	"kafkacluster",
	"kafkauser",
	"kafkapassword",
	"gpuconfig.driver.name",
	"gpuconfig.driver.organization",
	"gpuconfig.properties",
	"gpuconfig.licenseconfig",
	"enabledefaultserverlesscluster",
	"allianceorgs",
	"singlekubernetesclusterowner",
	"singlekubernetesnamespace",
	"platformhighavailability",
	"secondarynotifysrvaddr",
	"federationconfig.federationcontextid",
	"federationconfig.partnerfederationaddr",
	"federationconfig.federationdbid",
	"federationconfig.federationname",
	"infraflavors:#.name",
	"infraflavors:#.vcpus",
	"infraflavors:#.ram",
	"infraflavors:#.disk",
	"infraflavors:#.gpus:#.modelid",
	"infraflavors:#.gpus:#.count",
	"infraflavors:#.gpus:#.vendor",
	"infraflavors:#.gpus:#.memory",
	"infraflavors:#.gpus:#.inuse",
	"infraflavors:#.propmap",
	"edgeboxonly",
	"crmonedge",
	"objid",
	"annotations",
	"dbmodelid",
}
var ShowCloudletGPUUsageRequiredArgs = []string{}
var ShowCloudletGPUUsageOptionalArgs = []string{
	"cloudletorg",
	"cloudlet",
	"federatedorg",
	"location.latitude",
	"location.longitude",
	"location.altitude",
	"zone",
	"ipsupport",
	"staticips",
	"numdynamicips",
	"timelimits.createclusterinsttimeout",
	"timelimits.updateclusterinsttimeout",
	"timelimits.deleteclusterinsttimeout",
	"timelimits.createappinsttimeout",
	"timelimits.updateappinsttimeout",
	"timelimits.deleteappinsttimeout",
	"crmoverride",
	"deploymentlocal",
	"platformtype",
	"notifysrvaddr",
	"flavor.name",
	"physicalname",
	"envvar",
	"containerversion",
	"accessvars",
	"vmimageversion",
	"deployment",
	"infraapiaccess",
	"infraconfig.externalnetworkname",
	"infraconfig.flavorname",
	"maintenancestate",
	"overridepolicycontainerversion",
	"vmpool",
	"trustpolicy",
	"resourcequotas:#.name",
	"resourcequotas:#.value",
	"resourcequotas:#.alertthreshold",
	"resourcequotas:#.resourcetype",
	"defaultresourcealertthreshold",
	"kafkacluster",
	"kafkauser",
	"kafkapassword",
	"gpuconfig.driver.name",
	"gpuconfig.driver.organization",
	"gpuconfig.properties",
	"gpuconfig.licenseconfig",
	"enabledefaultserverlesscluster",
	"allianceorgs",
	"singlekubernetesclusterowner",
	"singlekubernetesnamespace",
	"platformhighavailability",
	"secondarynotifysrvaddr",
	"federationconfig.federationcontextid",
	"federationconfig.partnerfederationaddr",
	"federationconfig.federationdbid",
	"federationconfig.federationname",
	"infraflavors:#.name",
	"infraflavors:#.vcpus",
	"infraflavors:#.ram",
	"infraflavors:#.disk",
	"infraflavors:#.gpus:#.modelid",
	"infraflavors:#.gpus:#.count",
	"infraflavors:#.gpus:#.vendor",
	"infraflavors:#.gpus:#.memory",
	"infraflavors:#.gpus:#.inuse",
	"infraflavors:#.propmap",
	"edgeboxonly",
	"crmonedge",
	"objid",
	"annotations",
	"dbmodelid",
}
var ShowFlavorsForZoneRequiredArgs = []string{}
var ShowFlavorsForZoneOptionalArgs = []string{
	"zoneorg",
	"zone",
	"federatororg",
}
var RefreshCertsRequiredArgs = []string{}
var RefreshCertsOptionalArgs = []string{
	"cloudletorg",
	"cloudlet",
	"federatororg",
}
