// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: cloudlet.proto

package notify

import (
	"context"
	fmt "fmt"
	_ "github.com/edgexr/edge-cloud-platform/api/distributed_match_engine"
	edgeproto "github.com/edgexr/edge-cloud-platform/api/edgeproto"
	"github.com/edgexr/edge-cloud-platform/pkg/log"
	_ "github.com/edgexr/edge-cloud-platform/tools/protogen"
	_ "github.com/gogo/googleapis/google/api"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	"github.com/gogo/protobuf/types"
	opentracing "github.com/opentracing/opentracing-go"
	math "math"
	"sync"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Auto-generated code: DO NOT EDIT

type SendCloudletInternalHandler interface {
	GetAllLocked(ctx context.Context, cb func(key *edgeproto.CloudletInternal, modRev int64))
	GetWithRev(key *edgeproto.CloudletKey, buf *edgeproto.CloudletInternal, modRev *int64) bool
}

type RecvCloudletInternalHandler interface {
	Update(ctx context.Context, in *edgeproto.CloudletInternal, rev int64)
	Delete(ctx context.Context, in *edgeproto.CloudletInternal, rev int64)
	Prune(ctx context.Context, keys map[edgeproto.CloudletKey]struct{})
	Flush(ctx context.Context, notifyId int64)
}

type CloudletInternalCacheHandler interface {
	SendCloudletInternalHandler
	RecvCloudletInternalHandler
	AddNotifyCb(fn func(ctx context.Context, obj *edgeproto.CloudletInternal, modRev int64))
}

type CloudletInternalSend struct {
	Name        string
	MessageName string
	handler     SendCloudletInternalHandler
	Keys        map[edgeproto.CloudletKey]CloudletInternalSendContext
	keysToSend  map[edgeproto.CloudletKey]CloudletInternalSendContext
	notifyId    int64
	Mux         sync.Mutex
	buf         edgeproto.CloudletInternal
	SendCount   uint64
	sendrecv    *SendRecv
}

type CloudletInternalSendContext struct {
	ctx         context.Context
	modRev      int64
	forceDelete bool
}

func NewCloudletInternalSend(handler SendCloudletInternalHandler) *CloudletInternalSend {
	send := &CloudletInternalSend{}
	send.Name = "CloudletInternal"
	send.MessageName = proto.MessageName((*edgeproto.CloudletInternal)(nil))
	send.handler = handler
	send.Keys = make(map[edgeproto.CloudletKey]CloudletInternalSendContext)
	return send
}

func (s *CloudletInternalSend) SetSendRecv(sendrecv *SendRecv) {
	s.sendrecv = sendrecv
}

func (s *CloudletInternalSend) GetMessageName() string {
	return s.MessageName
}

func (s *CloudletInternalSend) GetName() string {
	return s.Name
}

func (s *CloudletInternalSend) GetSendCount() uint64 {
	return s.SendCount
}

func (s *CloudletInternalSend) GetNotifyId() int64 {
	return s.notifyId
}
func (s *CloudletInternalSend) UpdateAll(ctx context.Context) {
	if !s.sendrecv.isRemoteWanted(s.MessageName) {
		return
	}
	s.Mux.Lock()
	s.handler.GetAllLocked(ctx, func(obj *edgeproto.CloudletInternal, modRev int64) {
		s.Keys[*obj.GetKey()] = CloudletInternalSendContext{
			ctx:    ctx,
			modRev: modRev,
		}
	})
	s.Mux.Unlock()
}

func (s *CloudletInternalSend) Update(ctx context.Context, obj *edgeproto.CloudletInternal, modRev int64) {
	if !s.sendrecv.isRemoteWanted(s.MessageName) {
		return
	}
	forceDelete := false
	s.updateInternal(ctx, obj.GetKey(), modRev, forceDelete)
}

func (s *CloudletInternalSend) ForceDelete(ctx context.Context, key *edgeproto.CloudletKey, modRev int64) {
	forceDelete := true
	s.updateInternal(ctx, key, modRev, forceDelete)
}

func (s *CloudletInternalSend) updateInternal(ctx context.Context, key *edgeproto.CloudletKey, modRev int64, forceDelete bool) {
	s.Mux.Lock()
	log.SpanLog(ctx, log.DebugLevelNotify, "updateInternal CloudletInternal", "key", key, "modRev", modRev)
	s.Keys[*key] = CloudletInternalSendContext{
		ctx:         ctx,
		modRev:      modRev,
		forceDelete: forceDelete,
	}
	s.Mux.Unlock()
	s.sendrecv.wakeup()
}

func (s *CloudletInternalSend) SendForCloudlet(ctx context.Context, action edgeproto.NoticeAction, cloudlet *edgeproto.Cloudlet) {
}

func (s *CloudletInternalSend) Send(stream StreamNotify, notice *edgeproto.Notice, peer string) error {
	s.Mux.Lock()
	keys := s.keysToSend
	s.keysToSend = nil
	s.Mux.Unlock()
	for key, sendContext := range keys {
		ctx := sendContext.ctx
		found := s.handler.GetWithRev(&key, &s.buf, &notice.ModRev)
		if found && !sendContext.forceDelete {
			notice.Action = edgeproto.NoticeAction_UPDATE
		} else {
			notice.Action = edgeproto.NoticeAction_DELETE
			notice.ModRev = sendContext.modRev
			s.buf.Reset()
			s.buf.SetKey(&key)
		}
		any, err := types.MarshalAny(&s.buf)
		if err != nil {
			s.sendrecv.stats.MarshalErrors++
			err = nil
			continue
		}
		notice.Any = *any
		notice.Span = log.SpanToString(ctx)
		log.SpanLog(ctx, log.DebugLevelNotify,
			fmt.Sprintf("%s send CloudletInternal", s.sendrecv.cliserv),
			"peerAddr", peer,
			"peer", s.sendrecv.peer,
			"local", s.sendrecv.name,
			"action", notice.Action,
			"key", key,
			"modRev", notice.ModRev)
		err = stream.Send(notice)
		if err != nil {
			s.sendrecv.stats.SendErrors++
			return err
		}
		s.sendrecv.stats.Send++
		// object specific counter
		s.SendCount++
	}
	return nil
}

func (s *CloudletInternalSend) PrepData() bool {
	s.Mux.Lock()
	defer s.Mux.Unlock()
	if len(s.Keys) > 0 {
		s.keysToSend = s.Keys
		s.Keys = make(map[edgeproto.CloudletKey]CloudletInternalSendContext)
		return true
	}
	return false
}

// Server accepts multiple clients so needs to track multiple
// peers to send to.
type CloudletInternalSendMany struct {
	handler SendCloudletInternalHandler
	Mux     sync.Mutex
	sends   map[string]*CloudletInternalSend
}

func NewCloudletInternalSendMany(handler SendCloudletInternalHandler) *CloudletInternalSendMany {
	s := &CloudletInternalSendMany{}
	s.handler = handler
	s.sends = make(map[string]*CloudletInternalSend)
	return s
}

func (s *CloudletInternalSendMany) NewSend(peerAddr string, notifyId int64) NotifySend {
	send := NewCloudletInternalSend(s.handler)
	send.notifyId = notifyId
	s.Mux.Lock()
	s.sends[peerAddr] = send
	s.Mux.Unlock()
	return send
}

func (s *CloudletInternalSendMany) DoneSend(peerAddr string, send NotifySend) {
	asend, ok := send.(*CloudletInternalSend)
	if !ok {
		return
	}
	// another connection may come from the same client so remove
	// only if it matches
	s.Mux.Lock()
	if remove, _ := s.sends[peerAddr]; remove == asend {
		delete(s.sends, peerAddr)
	}
	s.Mux.Unlock()
}
func (s *CloudletInternalSendMany) Update(ctx context.Context, obj *edgeproto.CloudletInternal, modRev int64) {
	s.Mux.Lock()
	defer s.Mux.Unlock()
	for _, send := range s.sends {
		send.Update(ctx, obj, modRev)
	}
}

func (s *CloudletInternalSendMany) GetTypeString() string {
	return "CloudletInternal"
}

type CloudletInternalRecv struct {
	Name        string
	MessageName string
	handler     RecvCloudletInternalHandler
	sendAllKeys map[edgeproto.CloudletKey]struct{}
	Mux         sync.Mutex
	buf         edgeproto.CloudletInternal
	RecvCount   uint64
	sendrecv    *SendRecv
}

func NewCloudletInternalRecv(handler RecvCloudletInternalHandler) *CloudletInternalRecv {
	recv := &CloudletInternalRecv{}
	recv.Name = "CloudletInternal"
	recv.MessageName = proto.MessageName((*edgeproto.CloudletInternal)(nil))
	recv.handler = handler
	return recv
}

func (s *CloudletInternalRecv) SetSendRecv(sendrecv *SendRecv) {
	s.sendrecv = sendrecv
}

func (s *CloudletInternalRecv) GetMessageName() string {
	return s.MessageName
}

func (s *CloudletInternalRecv) GetName() string {
	return s.Name
}

func (s *CloudletInternalRecv) GetRecvCount() uint64 {
	return s.RecvCount
}

func (s *CloudletInternalRecv) Recv(ctx context.Context, notice *edgeproto.Notice, notifyId int64, peerAddr string) {
	span := opentracing.SpanFromContext(ctx)
	if span != nil {
		span.SetTag("objtype", "CloudletInternal")
	}

	buf := &edgeproto.CloudletInternal{}
	err := types.UnmarshalAny(&notice.Any, buf)
	if err != nil {
		s.sendrecv.stats.UnmarshalErrors++
		log.SpanLog(ctx, log.DebugLevelNotify, "Unmarshal Error", "err", err)
		return
	}
	if span != nil {
		log.SetTags(span, buf.GetKey().GetTags())
	}
	log.SpanLog(ctx, log.DebugLevelNotify,
		fmt.Sprintf("%s recv CloudletInternal", s.sendrecv.cliserv),
		"peerAddr", peerAddr,
		"peer", s.sendrecv.peer,
		"local", s.sendrecv.name,
		"action", notice.Action,
		"key", buf.GetKeyVal(),
		"modRev", notice.ModRev)
	if notice.Action == edgeproto.NoticeAction_UPDATE {
		s.handler.Update(ctx, buf, notice.ModRev)
		s.Mux.Lock()
		if s.sendAllKeys != nil {
			s.sendAllKeys[buf.GetKeyVal()] = struct{}{}
		}
		s.Mux.Unlock()
	} else if notice.Action == edgeproto.NoticeAction_DELETE {
		s.handler.Delete(ctx, buf, notice.ModRev)
	}
	s.sendrecv.stats.Recv++
	// object specific counter
	s.RecvCount++
}

func (s *CloudletInternalRecv) RecvAllStart() {
	s.Mux.Lock()
	defer s.Mux.Unlock()
	s.sendAllKeys = make(map[edgeproto.CloudletKey]struct{})
}

func (s *CloudletInternalRecv) RecvAllEnd(ctx context.Context, cleanup Cleanup) {
	s.Mux.Lock()
	validKeys := s.sendAllKeys
	s.sendAllKeys = nil
	s.Mux.Unlock()
	if cleanup == CleanupPrune {
		s.handler.Prune(ctx, validKeys)
	}
}
func (s *CloudletInternalRecv) Flush(ctx context.Context, notifyId int64) {
	s.handler.Flush(ctx, notifyId)
}

type CloudletInternalRecvMany struct {
	handler RecvCloudletInternalHandler
}

func NewCloudletInternalRecvMany(handler RecvCloudletInternalHandler) *CloudletInternalRecvMany {
	s := &CloudletInternalRecvMany{}
	s.handler = handler
	return s
}

func (s *CloudletInternalRecvMany) NewRecv() NotifyRecv {
	recv := NewCloudletInternalRecv(s.handler)
	return recv
}

func (s *CloudletInternalRecvMany) Flush(ctx context.Context, notifyId int64) {
	s.handler.Flush(ctx, notifyId)
}
func (mgr *ServerMgr) RegisterSendCloudletInternalCache(cache CloudletInternalCacheHandler) {
	send := NewCloudletInternalSendMany(cache)
	mgr.RegisterSend(send)
	cache.AddNotifyCb(send.Update)
}

func (mgr *ServerMgr) RegisterRecvCloudletInternalCache(cache CloudletInternalCacheHandler) {
	recv := NewCloudletInternalRecvMany(cache)
	mgr.RegisterRecv(recv)
}

func (s *Client) RegisterSendCloudletInternalCache(cache CloudletInternalCacheHandler) {
	send := NewCloudletInternalSend(cache)
	s.RegisterSend(send)
	cache.AddNotifyCb(send.Update)
}

func (s *Client) RegisterRecvCloudletInternalCache(cache CloudletInternalCacheHandler) {
	recv := NewCloudletInternalRecv(cache)
	s.RegisterRecv(recv)
}

type SendPlatformFeaturesHandler interface {
	GetAllLocked(ctx context.Context, cb func(key *edgeproto.PlatformFeatures, modRev int64))
	GetWithRev(key *edgeproto.PlatformFeaturesKey, buf *edgeproto.PlatformFeatures, modRev *int64) bool
}

type RecvPlatformFeaturesHandler interface {
	Update(ctx context.Context, in *edgeproto.PlatformFeatures, rev int64)
	Delete(ctx context.Context, in *edgeproto.PlatformFeatures, rev int64)
	Prune(ctx context.Context, keys map[edgeproto.PlatformFeaturesKey]struct{})
	Flush(ctx context.Context, notifyId int64)
}

type PlatformFeaturesCacheHandler interface {
	SendPlatformFeaturesHandler
	RecvPlatformFeaturesHandler
	AddNotifyCb(fn func(ctx context.Context, obj *edgeproto.PlatformFeatures, modRev int64))
}

type PlatformFeaturesSend struct {
	Name        string
	MessageName string
	handler     SendPlatformFeaturesHandler
	Keys        map[edgeproto.PlatformFeaturesKey]PlatformFeaturesSendContext
	keysToSend  map[edgeproto.PlatformFeaturesKey]PlatformFeaturesSendContext
	notifyId    int64
	Mux         sync.Mutex
	buf         edgeproto.PlatformFeatures
	SendCount   uint64
	sendrecv    *SendRecv
}

type PlatformFeaturesSendContext struct {
	ctx         context.Context
	modRev      int64
	forceDelete bool
}

func NewPlatformFeaturesSend(handler SendPlatformFeaturesHandler) *PlatformFeaturesSend {
	send := &PlatformFeaturesSend{}
	send.Name = "PlatformFeatures"
	send.MessageName = proto.MessageName((*edgeproto.PlatformFeatures)(nil))
	send.handler = handler
	send.Keys = make(map[edgeproto.PlatformFeaturesKey]PlatformFeaturesSendContext)
	return send
}

func (s *PlatformFeaturesSend) SetSendRecv(sendrecv *SendRecv) {
	s.sendrecv = sendrecv
}

func (s *PlatformFeaturesSend) GetMessageName() string {
	return s.MessageName
}

func (s *PlatformFeaturesSend) GetName() string {
	return s.Name
}

func (s *PlatformFeaturesSend) GetSendCount() uint64 {
	return s.SendCount
}

func (s *PlatformFeaturesSend) GetNotifyId() int64 {
	return s.notifyId
}
func (s *PlatformFeaturesSend) UpdateAll(ctx context.Context) {
	if !s.sendrecv.isRemoteWanted(s.MessageName) {
		return
	}
	s.Mux.Lock()
	s.handler.GetAllLocked(ctx, func(obj *edgeproto.PlatformFeatures, modRev int64) {
		s.Keys[*obj.GetKey()] = PlatformFeaturesSendContext{
			ctx:    ctx,
			modRev: modRev,
		}
	})
	s.Mux.Unlock()
}

func (s *PlatformFeaturesSend) Update(ctx context.Context, obj *edgeproto.PlatformFeatures, modRev int64) {
	if !s.sendrecv.isRemoteWanted(s.MessageName) {
		return
	}
	forceDelete := false
	s.updateInternal(ctx, obj.GetKey(), modRev, forceDelete)
}

func (s *PlatformFeaturesSend) ForceDelete(ctx context.Context, key *edgeproto.PlatformFeaturesKey, modRev int64) {
	forceDelete := true
	s.updateInternal(ctx, key, modRev, forceDelete)
}

func (s *PlatformFeaturesSend) updateInternal(ctx context.Context, key *edgeproto.PlatformFeaturesKey, modRev int64, forceDelete bool) {
	s.Mux.Lock()
	log.SpanLog(ctx, log.DebugLevelNotify, "updateInternal PlatformFeatures", "key", key, "modRev", modRev)
	s.Keys[*key] = PlatformFeaturesSendContext{
		ctx:         ctx,
		modRev:      modRev,
		forceDelete: forceDelete,
	}
	s.Mux.Unlock()
	s.sendrecv.wakeup()
}

func (s *PlatformFeaturesSend) SendForCloudlet(ctx context.Context, action edgeproto.NoticeAction, cloudlet *edgeproto.Cloudlet) {
}

func (s *PlatformFeaturesSend) Send(stream StreamNotify, notice *edgeproto.Notice, peer string) error {
	s.Mux.Lock()
	keys := s.keysToSend
	s.keysToSend = nil
	s.Mux.Unlock()
	for key, sendContext := range keys {
		ctx := sendContext.ctx
		found := s.handler.GetWithRev(&key, &s.buf, &notice.ModRev)
		if found && !sendContext.forceDelete {
			notice.Action = edgeproto.NoticeAction_UPDATE
		} else {
			notice.Action = edgeproto.NoticeAction_DELETE
			notice.ModRev = sendContext.modRev
			s.buf.Reset()
			s.buf.SetKey(&key)
		}
		any, err := types.MarshalAny(&s.buf)
		if err != nil {
			s.sendrecv.stats.MarshalErrors++
			err = nil
			continue
		}
		notice.Any = *any
		notice.Span = log.SpanToString(ctx)
		log.SpanLog(ctx, log.DebugLevelNotify,
			fmt.Sprintf("%s send PlatformFeatures", s.sendrecv.cliserv),
			"peerAddr", peer,
			"peer", s.sendrecv.peer,
			"local", s.sendrecv.name,
			"action", notice.Action,
			"key", key,
			"modRev", notice.ModRev)
		err = stream.Send(notice)
		if err != nil {
			s.sendrecv.stats.SendErrors++
			return err
		}
		s.sendrecv.stats.Send++
		// object specific counter
		s.SendCount++
	}
	return nil
}

func (s *PlatformFeaturesSend) PrepData() bool {
	s.Mux.Lock()
	defer s.Mux.Unlock()
	if len(s.Keys) > 0 {
		s.keysToSend = s.Keys
		s.Keys = make(map[edgeproto.PlatformFeaturesKey]PlatformFeaturesSendContext)
		return true
	}
	return false
}

// Server accepts multiple clients so needs to track multiple
// peers to send to.
type PlatformFeaturesSendMany struct {
	handler SendPlatformFeaturesHandler
	Mux     sync.Mutex
	sends   map[string]*PlatformFeaturesSend
}

func NewPlatformFeaturesSendMany(handler SendPlatformFeaturesHandler) *PlatformFeaturesSendMany {
	s := &PlatformFeaturesSendMany{}
	s.handler = handler
	s.sends = make(map[string]*PlatformFeaturesSend)
	return s
}

func (s *PlatformFeaturesSendMany) NewSend(peerAddr string, notifyId int64) NotifySend {
	send := NewPlatformFeaturesSend(s.handler)
	send.notifyId = notifyId
	s.Mux.Lock()
	s.sends[peerAddr] = send
	s.Mux.Unlock()
	return send
}

func (s *PlatformFeaturesSendMany) DoneSend(peerAddr string, send NotifySend) {
	asend, ok := send.(*PlatformFeaturesSend)
	if !ok {
		return
	}
	// another connection may come from the same client so remove
	// only if it matches
	s.Mux.Lock()
	if remove, _ := s.sends[peerAddr]; remove == asend {
		delete(s.sends, peerAddr)
	}
	s.Mux.Unlock()
}
func (s *PlatformFeaturesSendMany) Update(ctx context.Context, obj *edgeproto.PlatformFeatures, modRev int64) {
	s.Mux.Lock()
	defer s.Mux.Unlock()
	for _, send := range s.sends {
		send.Update(ctx, obj, modRev)
	}
}

func (s *PlatformFeaturesSendMany) GetTypeString() string {
	return "PlatformFeatures"
}

type PlatformFeaturesRecv struct {
	Name        string
	MessageName string
	handler     RecvPlatformFeaturesHandler
	sendAllKeys map[edgeproto.PlatformFeaturesKey]struct{}
	Mux         sync.Mutex
	buf         edgeproto.PlatformFeatures
	RecvCount   uint64
	sendrecv    *SendRecv
}

func NewPlatformFeaturesRecv(handler RecvPlatformFeaturesHandler) *PlatformFeaturesRecv {
	recv := &PlatformFeaturesRecv{}
	recv.Name = "PlatformFeatures"
	recv.MessageName = proto.MessageName((*edgeproto.PlatformFeatures)(nil))
	recv.handler = handler
	return recv
}

func (s *PlatformFeaturesRecv) SetSendRecv(sendrecv *SendRecv) {
	s.sendrecv = sendrecv
}

func (s *PlatformFeaturesRecv) GetMessageName() string {
	return s.MessageName
}

func (s *PlatformFeaturesRecv) GetName() string {
	return s.Name
}

func (s *PlatformFeaturesRecv) GetRecvCount() uint64 {
	return s.RecvCount
}

func (s *PlatformFeaturesRecv) Recv(ctx context.Context, notice *edgeproto.Notice, notifyId int64, peerAddr string) {
	span := opentracing.SpanFromContext(ctx)
	if span != nil {
		span.SetTag("objtype", "PlatformFeatures")
	}

	buf := &edgeproto.PlatformFeatures{}
	err := types.UnmarshalAny(&notice.Any, buf)
	if err != nil {
		s.sendrecv.stats.UnmarshalErrors++
		log.SpanLog(ctx, log.DebugLevelNotify, "Unmarshal Error", "err", err)
		return
	}
	if span != nil {
		log.SetTags(span, buf.GetKey().GetTags())
	}
	log.SpanLog(ctx, log.DebugLevelNotify,
		fmt.Sprintf("%s recv PlatformFeatures", s.sendrecv.cliserv),
		"peerAddr", peerAddr,
		"peer", s.sendrecv.peer,
		"local", s.sendrecv.name,
		"action", notice.Action,
		"key", buf.GetKeyVal(),
		"modRev", notice.ModRev)
	if notice.Action == edgeproto.NoticeAction_UPDATE {
		s.handler.Update(ctx, buf, notice.ModRev)
		s.Mux.Lock()
		if s.sendAllKeys != nil {
			s.sendAllKeys[buf.GetKeyVal()] = struct{}{}
		}
		s.Mux.Unlock()
	} else if notice.Action == edgeproto.NoticeAction_DELETE {
		s.handler.Delete(ctx, buf, notice.ModRev)
	}
	s.sendrecv.stats.Recv++
	// object specific counter
	s.RecvCount++
}

func (s *PlatformFeaturesRecv) RecvAllStart() {
	s.Mux.Lock()
	defer s.Mux.Unlock()
	s.sendAllKeys = make(map[edgeproto.PlatformFeaturesKey]struct{})
}

func (s *PlatformFeaturesRecv) RecvAllEnd(ctx context.Context, cleanup Cleanup) {
	s.Mux.Lock()
	validKeys := s.sendAllKeys
	s.sendAllKeys = nil
	s.Mux.Unlock()
	if cleanup == CleanupPrune {
		s.handler.Prune(ctx, validKeys)
	}
}
func (s *PlatformFeaturesRecv) Flush(ctx context.Context, notifyId int64) {
	s.handler.Flush(ctx, notifyId)
}

type PlatformFeaturesRecvMany struct {
	handler RecvPlatformFeaturesHandler
}

func NewPlatformFeaturesRecvMany(handler RecvPlatformFeaturesHandler) *PlatformFeaturesRecvMany {
	s := &PlatformFeaturesRecvMany{}
	s.handler = handler
	return s
}

func (s *PlatformFeaturesRecvMany) NewRecv() NotifyRecv {
	recv := NewPlatformFeaturesRecv(s.handler)
	return recv
}

func (s *PlatformFeaturesRecvMany) Flush(ctx context.Context, notifyId int64) {
	s.handler.Flush(ctx, notifyId)
}
func (mgr *ServerMgr) RegisterSendPlatformFeaturesCache(cache PlatformFeaturesCacheHandler) {
	send := NewPlatformFeaturesSendMany(cache)
	mgr.RegisterSend(send)
	cache.AddNotifyCb(send.Update)
}

func (mgr *ServerMgr) RegisterRecvPlatformFeaturesCache(cache PlatformFeaturesCacheHandler) {
	recv := NewPlatformFeaturesRecvMany(cache)
	mgr.RegisterRecv(recv)
}

func (s *Client) RegisterSendPlatformFeaturesCache(cache PlatformFeaturesCacheHandler) {
	send := NewPlatformFeaturesSend(cache)
	s.RegisterSend(send)
	cache.AddNotifyCb(send.Update)
}

func (s *Client) RegisterRecvPlatformFeaturesCache(cache PlatformFeaturesCacheHandler) {
	recv := NewPlatformFeaturesRecv(cache)
	s.RegisterRecv(recv)
}

type SendGPUDriverHandler interface {
	GetAllLocked(ctx context.Context, cb func(key *edgeproto.GPUDriver, modRev int64))
	GetWithRev(key *edgeproto.GPUDriverKey, buf *edgeproto.GPUDriver, modRev *int64) bool
	GetForCloudlet(cloudlet *edgeproto.Cloudlet, cb func(data *edgeproto.GPUDriverCacheData))
}

type RecvGPUDriverHandler interface {
	Update(ctx context.Context, in *edgeproto.GPUDriver, rev int64)
	Delete(ctx context.Context, in *edgeproto.GPUDriver, rev int64)
	Prune(ctx context.Context, keys map[edgeproto.GPUDriverKey]struct{})
	Flush(ctx context.Context, notifyId int64)
}

type GPUDriverCacheHandler interface {
	SendGPUDriverHandler
	RecvGPUDriverHandler
	AddNotifyCb(fn func(ctx context.Context, obj *edgeproto.GPUDriver, modRev int64))
}

type GPUDriverSend struct {
	Name        string
	MessageName string
	handler     SendGPUDriverHandler
	Keys        map[edgeproto.GPUDriverKey]GPUDriverSendContext
	keysToSend  map[edgeproto.GPUDriverKey]GPUDriverSendContext
	notifyId    int64
	Mux         sync.Mutex
	buf         edgeproto.GPUDriver
	SendCount   uint64
	sendrecv    *SendRecv
}

type GPUDriverSendContext struct {
	ctx         context.Context
	modRev      int64
	forceDelete bool
}

func NewGPUDriverSend(handler SendGPUDriverHandler) *GPUDriverSend {
	send := &GPUDriverSend{}
	send.Name = "GPUDriver"
	send.MessageName = proto.MessageName((*edgeproto.GPUDriver)(nil))
	send.handler = handler
	send.Keys = make(map[edgeproto.GPUDriverKey]GPUDriverSendContext)
	return send
}

func (s *GPUDriverSend) SetSendRecv(sendrecv *SendRecv) {
	s.sendrecv = sendrecv
}

func (s *GPUDriverSend) GetMessageName() string {
	return s.MessageName
}

func (s *GPUDriverSend) GetName() string {
	return s.Name
}

func (s *GPUDriverSend) GetSendCount() uint64 {
	return s.SendCount
}

func (s *GPUDriverSend) GetNotifyId() int64 {
	return s.notifyId
}
func (s *GPUDriverSend) UpdateAll(ctx context.Context) {
	if !s.sendrecv.isRemoteWanted(s.MessageName) {
		return
	}
	s.Mux.Lock()
	s.handler.GetAllLocked(ctx, func(obj *edgeproto.GPUDriver, modRev int64) {
		if !s.UpdateAllOkLocked(obj) { // to be implemented by hand
			return
		}
		s.Keys[*obj.GetKey()] = GPUDriverSendContext{
			ctx:    ctx,
			modRev: modRev,
		}
	})
	s.Mux.Unlock()
}

func (s *GPUDriverSend) Update(ctx context.Context, obj *edgeproto.GPUDriver, modRev int64) {
	if !s.sendrecv.isRemoteWanted(s.MessageName) {
		return
	}
	if !s.UpdateOk(ctx, obj) { // to be implemented by hand
		return
	}
	forceDelete := false
	s.updateInternal(ctx, obj.GetKey(), modRev, forceDelete)
}

func (s *GPUDriverSend) ForceDelete(ctx context.Context, key *edgeproto.GPUDriverKey, modRev int64) {
	forceDelete := true
	s.updateInternal(ctx, key, modRev, forceDelete)
}

func (s *GPUDriverSend) updateInternal(ctx context.Context, key *edgeproto.GPUDriverKey, modRev int64, forceDelete bool) {
	s.Mux.Lock()
	log.SpanLog(ctx, log.DebugLevelNotify, "updateInternal GPUDriver", "key", key, "modRev", modRev)
	s.Keys[*key] = GPUDriverSendContext{
		ctx:         ctx,
		modRev:      modRev,
		forceDelete: forceDelete,
	}
	s.Mux.Unlock()
	s.sendrecv.wakeup()
}

func (s *GPUDriverSend) SendForCloudlet(ctx context.Context, action edgeproto.NoticeAction, cloudlet *edgeproto.Cloudlet) {
	keys := make(map[edgeproto.GPUDriverKey]*edgeproto.GPUDriverCacheData)
	s.handler.GetForCloudlet(cloudlet, func(data *edgeproto.GPUDriverCacheData) {
		if data.Obj == nil {
			return
		}
		keys[*data.Obj.GetKey()] = data
	})
	for k, data := range keys {
		if action == edgeproto.NoticeAction_UPDATE {
			s.Update(ctx, data.Obj, data.ModRev)
		} else if action == edgeproto.NoticeAction_DELETE {
			s.ForceDelete(ctx, &k, data.ModRev)
		}
	}
}

func (s *GPUDriverSend) Send(stream StreamNotify, notice *edgeproto.Notice, peer string) error {
	s.Mux.Lock()
	keys := s.keysToSend
	s.keysToSend = nil
	s.Mux.Unlock()
	for key, sendContext := range keys {
		ctx := sendContext.ctx
		found := s.handler.GetWithRev(&key, &s.buf, &notice.ModRev)
		if found && !sendContext.forceDelete {
			notice.Action = edgeproto.NoticeAction_UPDATE
		} else {
			notice.Action = edgeproto.NoticeAction_DELETE
			notice.ModRev = sendContext.modRev
			s.buf.Reset()
			s.buf.SetKey(&key)
		}
		any, err := types.MarshalAny(&s.buf)
		if err != nil {
			s.sendrecv.stats.MarshalErrors++
			err = nil
			continue
		}
		notice.Any = *any
		notice.Span = log.SpanToString(ctx)
		log.SpanLog(ctx, log.DebugLevelNotify,
			fmt.Sprintf("%s send GPUDriver", s.sendrecv.cliserv),
			"peerAddr", peer,
			"peer", s.sendrecv.peer,
			"local", s.sendrecv.name,
			"action", notice.Action,
			"key", key,
			"modRev", notice.ModRev)
		err = stream.Send(notice)
		if err != nil {
			s.sendrecv.stats.SendErrors++
			return err
		}
		s.sendrecv.stats.Send++
		// object specific counter
		s.SendCount++
	}
	return nil
}

func (s *GPUDriverSend) PrepData() bool {
	s.Mux.Lock()
	defer s.Mux.Unlock()
	if len(s.Keys) > 0 {
		s.keysToSend = s.Keys
		s.Keys = make(map[edgeproto.GPUDriverKey]GPUDriverSendContext)
		return true
	}
	return false
}

// Server accepts multiple clients so needs to track multiple
// peers to send to.
type GPUDriverSendMany struct {
	handler SendGPUDriverHandler
	Mux     sync.Mutex
	sends   map[string]*GPUDriverSend
}

func NewGPUDriverSendMany(handler SendGPUDriverHandler) *GPUDriverSendMany {
	s := &GPUDriverSendMany{}
	s.handler = handler
	s.sends = make(map[string]*GPUDriverSend)
	return s
}

func (s *GPUDriverSendMany) NewSend(peerAddr string, notifyId int64) NotifySend {
	send := NewGPUDriverSend(s.handler)
	send.notifyId = notifyId
	s.Mux.Lock()
	s.sends[peerAddr] = send
	s.Mux.Unlock()
	return send
}

func (s *GPUDriverSendMany) DoneSend(peerAddr string, send NotifySend) {
	asend, ok := send.(*GPUDriverSend)
	if !ok {
		return
	}
	// another connection may come from the same client so remove
	// only if it matches
	s.Mux.Lock()
	if remove, _ := s.sends[peerAddr]; remove == asend {
		delete(s.sends, peerAddr)
	}
	s.Mux.Unlock()
}
func (s *GPUDriverSendMany) Update(ctx context.Context, obj *edgeproto.GPUDriver, modRev int64) {
	s.Mux.Lock()
	defer s.Mux.Unlock()
	for _, send := range s.sends {
		send.Update(ctx, obj, modRev)
	}
}

func (s *GPUDriverSendMany) GetTypeString() string {
	return "GPUDriver"
}

type GPUDriverRecv struct {
	Name        string
	MessageName string
	handler     RecvGPUDriverHandler
	sendAllKeys map[edgeproto.GPUDriverKey]struct{}
	Mux         sync.Mutex
	buf         edgeproto.GPUDriver
	RecvCount   uint64
	sendrecv    *SendRecv
}

func NewGPUDriverRecv(handler RecvGPUDriverHandler) *GPUDriverRecv {
	recv := &GPUDriverRecv{}
	recv.Name = "GPUDriver"
	recv.MessageName = proto.MessageName((*edgeproto.GPUDriver)(nil))
	recv.handler = handler
	return recv
}

func (s *GPUDriverRecv) SetSendRecv(sendrecv *SendRecv) {
	s.sendrecv = sendrecv
}

func (s *GPUDriverRecv) GetMessageName() string {
	return s.MessageName
}

func (s *GPUDriverRecv) GetName() string {
	return s.Name
}

func (s *GPUDriverRecv) GetRecvCount() uint64 {
	return s.RecvCount
}

func (s *GPUDriverRecv) Recv(ctx context.Context, notice *edgeproto.Notice, notifyId int64, peerAddr string) {
	span := opentracing.SpanFromContext(ctx)
	if span != nil {
		span.SetTag("objtype", "GPUDriver")
	}

	buf := &edgeproto.GPUDriver{}
	err := types.UnmarshalAny(&notice.Any, buf)
	if err != nil {
		s.sendrecv.stats.UnmarshalErrors++
		log.SpanLog(ctx, log.DebugLevelNotify, "Unmarshal Error", "err", err)
		return
	}
	if span != nil {
		log.SetTags(span, buf.GetKey().GetTags())
	}
	log.SpanLog(ctx, log.DebugLevelNotify,
		fmt.Sprintf("%s recv GPUDriver", s.sendrecv.cliserv),
		"peerAddr", peerAddr,
		"peer", s.sendrecv.peer,
		"local", s.sendrecv.name,
		"action", notice.Action,
		"key", buf.GetKeyVal(),
		"modRev", notice.ModRev)
	if notice.Action == edgeproto.NoticeAction_UPDATE {
		s.handler.Update(ctx, buf, notice.ModRev)
		s.Mux.Lock()
		if s.sendAllKeys != nil {
			s.sendAllKeys[buf.GetKeyVal()] = struct{}{}
		}
		s.Mux.Unlock()
	} else if notice.Action == edgeproto.NoticeAction_DELETE {
		s.handler.Delete(ctx, buf, notice.ModRev)
	}
	s.sendrecv.stats.Recv++
	// object specific counter
	s.RecvCount++
}

func (s *GPUDriverRecv) RecvAllStart() {
	s.Mux.Lock()
	defer s.Mux.Unlock()
	s.sendAllKeys = make(map[edgeproto.GPUDriverKey]struct{})
}

func (s *GPUDriverRecv) RecvAllEnd(ctx context.Context, cleanup Cleanup) {
	s.Mux.Lock()
	validKeys := s.sendAllKeys
	s.sendAllKeys = nil
	s.Mux.Unlock()
	if cleanup == CleanupPrune {
		s.handler.Prune(ctx, validKeys)
	}
}
func (s *GPUDriverRecv) Flush(ctx context.Context, notifyId int64) {
	s.handler.Flush(ctx, notifyId)
}

type GPUDriverRecvMany struct {
	handler RecvGPUDriverHandler
}

func NewGPUDriverRecvMany(handler RecvGPUDriverHandler) *GPUDriverRecvMany {
	s := &GPUDriverRecvMany{}
	s.handler = handler
	return s
}

func (s *GPUDriverRecvMany) NewRecv() NotifyRecv {
	recv := NewGPUDriverRecv(s.handler)
	return recv
}

func (s *GPUDriverRecvMany) Flush(ctx context.Context, notifyId int64) {
	s.handler.Flush(ctx, notifyId)
}
func (mgr *ServerMgr) RegisterSendGPUDriverCache(cache GPUDriverCacheHandler) {
	send := NewGPUDriverSendMany(cache)
	mgr.RegisterSend(send)
	cache.AddNotifyCb(send.Update)
}

func (mgr *ServerMgr) RegisterRecvGPUDriverCache(cache GPUDriverCacheHandler) {
	recv := NewGPUDriverRecvMany(cache)
	mgr.RegisterRecv(recv)
}

func (s *Client) RegisterSendGPUDriverCache(cache GPUDriverCacheHandler) {
	send := NewGPUDriverSend(cache)
	s.RegisterSend(send)
	cache.AddNotifyCb(send.Update)
}

func (s *Client) RegisterRecvGPUDriverCache(cache GPUDriverCacheHandler) {
	recv := NewGPUDriverRecv(cache)
	s.RegisterRecv(recv)
}

type SendCloudletHandler interface {
	GetAllLocked(ctx context.Context, cb func(key *edgeproto.Cloudlet, modRev int64))
	GetWithRev(key *edgeproto.CloudletKey, buf *edgeproto.Cloudlet, modRev *int64) bool
}

type RecvCloudletHandler interface {
	Update(ctx context.Context, in *edgeproto.Cloudlet, rev int64)
	Delete(ctx context.Context, in *edgeproto.Cloudlet, rev int64)
	Prune(ctx context.Context, keys map[edgeproto.CloudletKey]struct{})
	Flush(ctx context.Context, notifyId int64)
}

type CloudletCacheHandler interface {
	SendCloudletHandler
	RecvCloudletHandler
	AddNotifyCb(fn func(ctx context.Context, obj *edgeproto.Cloudlet, modRev int64))
}

type CloudletSend struct {
	Name        string
	MessageName string
	handler     SendCloudletHandler
	Keys        map[edgeproto.CloudletKey]CloudletSendContext
	keysToSend  map[edgeproto.CloudletKey]CloudletSendContext
	notifyId    int64
	Mux         sync.Mutex
	buf         edgeproto.Cloudlet
	SendCount   uint64
	sendrecv    *SendRecv
}

type CloudletSendContext struct {
	ctx         context.Context
	modRev      int64
	forceDelete bool
}

func NewCloudletSend(handler SendCloudletHandler) *CloudletSend {
	send := &CloudletSend{}
	send.Name = "Cloudlet"
	send.MessageName = proto.MessageName((*edgeproto.Cloudlet)(nil))
	send.handler = handler
	send.Keys = make(map[edgeproto.CloudletKey]CloudletSendContext)
	return send
}

func (s *CloudletSend) SetSendRecv(sendrecv *SendRecv) {
	s.sendrecv = sendrecv
}

func (s *CloudletSend) GetMessageName() string {
	return s.MessageName
}

func (s *CloudletSend) GetName() string {
	return s.Name
}

func (s *CloudletSend) GetSendCount() uint64 {
	return s.SendCount
}

func (s *CloudletSend) GetNotifyId() int64 {
	return s.notifyId
}
func (s *CloudletSend) UpdateAll(ctx context.Context) {
	if !s.sendrecv.isRemoteWanted(s.MessageName) {
		return
	}
	s.Mux.Lock()
	s.handler.GetAllLocked(ctx, func(obj *edgeproto.Cloudlet, modRev int64) {
		if !s.UpdateAllOkLocked(obj) { // to be implemented by hand
			return
		}
		s.Keys[*obj.GetKey()] = CloudletSendContext{
			ctx:    ctx,
			modRev: modRev,
		}
	})
	s.Mux.Unlock()
}

func (s *CloudletSend) Update(ctx context.Context, obj *edgeproto.Cloudlet, modRev int64) {
	if !s.sendrecv.isRemoteWanted(s.MessageName) {
		return
	}
	if !s.UpdateOk(ctx, obj) { // to be implemented by hand
		return
	}
	forceDelete := false
	s.updateInternal(ctx, obj.GetKey(), modRev, forceDelete)
}

func (s *CloudletSend) ForceDelete(ctx context.Context, key *edgeproto.CloudletKey, modRev int64) {
	forceDelete := true
	s.updateInternal(ctx, key, modRev, forceDelete)
}

func (s *CloudletSend) updateInternal(ctx context.Context, key *edgeproto.CloudletKey, modRev int64, forceDelete bool) {
	s.Mux.Lock()
	log.SpanLog(ctx, log.DebugLevelNotify, "updateInternal Cloudlet", "key", key, "modRev", modRev)
	s.Keys[*key] = CloudletSendContext{
		ctx:         ctx,
		modRev:      modRev,
		forceDelete: forceDelete,
	}
	s.Mux.Unlock()
	s.sendrecv.wakeup()
}

func (s *CloudletSend) SendForCloudlet(ctx context.Context, action edgeproto.NoticeAction, cloudlet *edgeproto.Cloudlet) {
}

func (s *CloudletSend) Send(stream StreamNotify, notice *edgeproto.Notice, peer string) error {
	s.Mux.Lock()
	keys := s.keysToSend
	s.keysToSend = nil
	s.Mux.Unlock()
	for key, sendContext := range keys {
		ctx := sendContext.ctx
		found := s.handler.GetWithRev(&key, &s.buf, &notice.ModRev)
		if found && !sendContext.forceDelete {
			notice.Action = edgeproto.NoticeAction_UPDATE
		} else {
			notice.Action = edgeproto.NoticeAction_DELETE
			notice.ModRev = sendContext.modRev
			s.buf.Reset()
			s.buf.SetKey(&key)
		}
		any, err := types.MarshalAny(&s.buf)
		if err != nil {
			s.sendrecv.stats.MarshalErrors++
			err = nil
			continue
		}
		notice.Any = *any
		notice.Span = log.SpanToString(ctx)
		log.SpanLog(ctx, log.DebugLevelNotify,
			fmt.Sprintf("%s send Cloudlet", s.sendrecv.cliserv),
			"peerAddr", peer,
			"peer", s.sendrecv.peer,
			"local", s.sendrecv.name,
			"action", notice.Action,
			"key", key,
			"modRev", notice.ModRev)
		err = stream.Send(notice)
		if err != nil {
			s.sendrecv.stats.SendErrors++
			return err
		}
		s.sendrecv.stats.Send++
		// object specific counter
		s.SendCount++
	}
	return nil
}

func (s *CloudletSend) PrepData() bool {
	s.Mux.Lock()
	defer s.Mux.Unlock()
	if len(s.Keys) > 0 {
		s.keysToSend = s.Keys
		s.Keys = make(map[edgeproto.CloudletKey]CloudletSendContext)
		return true
	}
	return false
}

// Server accepts multiple clients so needs to track multiple
// peers to send to.
type CloudletSendMany struct {
	handler SendCloudletHandler
	Mux     sync.Mutex
	sends   map[string]*CloudletSend
}

func NewCloudletSendMany(handler SendCloudletHandler) *CloudletSendMany {
	s := &CloudletSendMany{}
	s.handler = handler
	s.sends = make(map[string]*CloudletSend)
	return s
}

func (s *CloudletSendMany) NewSend(peerAddr string, notifyId int64) NotifySend {
	send := NewCloudletSend(s.handler)
	send.notifyId = notifyId
	s.Mux.Lock()
	s.sends[peerAddr] = send
	s.Mux.Unlock()
	return send
}

func (s *CloudletSendMany) DoneSend(peerAddr string, send NotifySend) {
	asend, ok := send.(*CloudletSend)
	if !ok {
		return
	}
	// another connection may come from the same client so remove
	// only if it matches
	s.Mux.Lock()
	if remove, _ := s.sends[peerAddr]; remove == asend {
		delete(s.sends, peerAddr)
	}
	s.Mux.Unlock()
}
func (s *CloudletSendMany) Update(ctx context.Context, obj *edgeproto.Cloudlet, modRev int64) {
	s.Mux.Lock()
	defer s.Mux.Unlock()
	for _, send := range s.sends {
		send.Update(ctx, obj, modRev)
	}
}

func (s *CloudletSendMany) GetTypeString() string {
	return "Cloudlet"
}

type CloudletRecv struct {
	Name        string
	MessageName string
	handler     RecvCloudletHandler
	sendAllKeys map[edgeproto.CloudletKey]struct{}
	Mux         sync.Mutex
	buf         edgeproto.Cloudlet
	RecvCount   uint64
	sendrecv    *SendRecv
}

func NewCloudletRecv(handler RecvCloudletHandler) *CloudletRecv {
	recv := &CloudletRecv{}
	recv.Name = "Cloudlet"
	recv.MessageName = proto.MessageName((*edgeproto.Cloudlet)(nil))
	recv.handler = handler
	return recv
}

func (s *CloudletRecv) SetSendRecv(sendrecv *SendRecv) {
	s.sendrecv = sendrecv
}

func (s *CloudletRecv) GetMessageName() string {
	return s.MessageName
}

func (s *CloudletRecv) GetName() string {
	return s.Name
}

func (s *CloudletRecv) GetRecvCount() uint64 {
	return s.RecvCount
}

func (s *CloudletRecv) Recv(ctx context.Context, notice *edgeproto.Notice, notifyId int64, peerAddr string) {
	span := opentracing.SpanFromContext(ctx)
	if span != nil {
		span.SetTag("objtype", "Cloudlet")
	}

	buf := &edgeproto.Cloudlet{}
	err := types.UnmarshalAny(&notice.Any, buf)
	if err != nil {
		s.sendrecv.stats.UnmarshalErrors++
		log.SpanLog(ctx, log.DebugLevelNotify, "Unmarshal Error", "err", err)
		return
	}
	if span != nil {
		log.SetTags(span, buf.GetKey().GetTags())
	}
	log.SpanLog(ctx, log.DebugLevelNotify,
		fmt.Sprintf("%s recv Cloudlet", s.sendrecv.cliserv),
		"peerAddr", peerAddr,
		"peer", s.sendrecv.peer,
		"local", s.sendrecv.name,
		"action", notice.Action,
		"key", buf.GetKeyVal(),
		"modRev", notice.ModRev)
	if notice.Action == edgeproto.NoticeAction_UPDATE {
		s.handler.Update(ctx, buf, notice.ModRev)
		s.Mux.Lock()
		if s.sendAllKeys != nil {
			s.sendAllKeys[buf.GetKeyVal()] = struct{}{}
		}
		s.Mux.Unlock()
	} else if notice.Action == edgeproto.NoticeAction_DELETE {
		s.handler.Delete(ctx, buf, notice.ModRev)
	}
	s.sendrecv.stats.Recv++
	// object specific counter
	s.RecvCount++
	s.RecvHook(ctx, notice, buf, peerAddr) // to be implemented by hand
}

func (s *CloudletRecv) RecvAllStart() {
	s.Mux.Lock()
	defer s.Mux.Unlock()
	s.sendAllKeys = make(map[edgeproto.CloudletKey]struct{})
}

func (s *CloudletRecv) RecvAllEnd(ctx context.Context, cleanup Cleanup) {
	s.Mux.Lock()
	validKeys := s.sendAllKeys
	s.sendAllKeys = nil
	s.Mux.Unlock()
	if cleanup == CleanupPrune {
		s.handler.Prune(ctx, validKeys)
	}
}
func (s *CloudletRecv) Flush(ctx context.Context, notifyId int64) {
	s.handler.Flush(ctx, notifyId)
}

type CloudletRecvMany struct {
	handler RecvCloudletHandler
}

func NewCloudletRecvMany(handler RecvCloudletHandler) *CloudletRecvMany {
	s := &CloudletRecvMany{}
	s.handler = handler
	return s
}

func (s *CloudletRecvMany) NewRecv() NotifyRecv {
	recv := NewCloudletRecv(s.handler)
	return recv
}

func (s *CloudletRecvMany) Flush(ctx context.Context, notifyId int64) {
	s.handler.Flush(ctx, notifyId)
}
func (mgr *ServerMgr) RegisterSendCloudletCache(cache CloudletCacheHandler) {
	send := NewCloudletSendMany(cache)
	mgr.RegisterSend(send)
	cache.AddNotifyCb(send.Update)
}

func (mgr *ServerMgr) RegisterRecvCloudletCache(cache CloudletCacheHandler) {
	recv := NewCloudletRecvMany(cache)
	mgr.RegisterRecv(recv)
}

func (s *Client) RegisterSendCloudletCache(cache CloudletCacheHandler) {
	send := NewCloudletSend(cache)
	s.RegisterSend(send)
	cache.AddNotifyCb(send.Update)
}

func (s *Client) RegisterRecvCloudletCache(cache CloudletCacheHandler) {
	recv := NewCloudletRecv(cache)
	s.RegisterRecv(recv)
}

type RecvCloudletOnboardingInfoHandler interface {
	RecvCloudletOnboardingInfo(ctx context.Context, msg *edgeproto.CloudletOnboardingInfo)
}

type CloudletOnboardingInfoSend struct {
	Name        string
	MessageName string
	Data        []*edgeproto.CloudletOnboardingInfo
	dataToSend  []*edgeproto.CloudletOnboardingInfo
	Ctxs        []context.Context
	ctxsToSend  []context.Context
	notifyId    int64
	Mux         sync.Mutex
	buf         edgeproto.CloudletOnboardingInfo
	SendCount   uint64
	sendrecv    *SendRecv
}

type CloudletOnboardingInfoSendContext struct {
	ctx         context.Context
	modRev      int64
	forceDelete bool
}

func NewCloudletOnboardingInfoSend() *CloudletOnboardingInfoSend {
	send := &CloudletOnboardingInfoSend{}
	send.Name = "CloudletOnboardingInfo"
	send.MessageName = proto.MessageName((*edgeproto.CloudletOnboardingInfo)(nil))
	send.Data = make([]*edgeproto.CloudletOnboardingInfo, 0)
	return send
}

func (s *CloudletOnboardingInfoSend) SetSendRecv(sendrecv *SendRecv) {
	s.sendrecv = sendrecv
}

func (s *CloudletOnboardingInfoSend) GetMessageName() string {
	return s.MessageName
}

func (s *CloudletOnboardingInfoSend) GetName() string {
	return s.Name
}

func (s *CloudletOnboardingInfoSend) GetSendCount() uint64 {
	return s.SendCount
}

func (s *CloudletOnboardingInfoSend) GetNotifyId() int64 {
	return s.notifyId
}
func (s *CloudletOnboardingInfoSend) UpdateAll(ctx context.Context) {}

func (s *CloudletOnboardingInfoSend) Update(ctx context.Context, msg *edgeproto.CloudletOnboardingInfo) bool {
	if !s.sendrecv.isRemoteWanted(s.MessageName) {
		return false
	}
	s.Mux.Lock()
	s.Data = append(s.Data, msg)
	s.Ctxs = append(s.Ctxs, ctx)
	s.Mux.Unlock()
	s.sendrecv.wakeup()
	return true
}

func (s *CloudletOnboardingInfoSend) SendForCloudlet(ctx context.Context, action edgeproto.NoticeAction, cloudlet *edgeproto.Cloudlet) {
}

func (s *CloudletOnboardingInfoSend) Send(stream StreamNotify, notice *edgeproto.Notice, peer string) error {
	s.Mux.Lock()
	data := s.dataToSend
	s.dataToSend = nil
	ctxs := s.ctxsToSend
	s.ctxsToSend = nil
	s.Mux.Unlock()
	for ii, msg := range data {
		any, err := types.MarshalAny(msg)
		ctx := ctxs[ii]
		if err != nil {
			s.sendrecv.stats.MarshalErrors++
			err = nil
			continue
		}
		notice.Any = *any
		notice.Span = log.SpanToString(ctx)
		log.SpanLog(ctx, log.DebugLevelNotify,
			fmt.Sprintf("%s send CloudletOnboardingInfo", s.sendrecv.cliserv),
			"peerAddr", peer,
			"peer", s.sendrecv.peer,
			"local", s.sendrecv.name,
			"message", msg)
		err = stream.Send(notice)
		if err != nil {
			s.sendrecv.stats.SendErrors++
			return err
		}
		s.sendrecv.stats.Send++
		// object specific counter
		s.SendCount++
	}
	return nil
}

func (s *CloudletOnboardingInfoSend) PrepData() bool {
	s.Mux.Lock()
	defer s.Mux.Unlock()
	if len(s.Data) > 0 {
		s.dataToSend = s.Data
		s.Data = make([]*edgeproto.CloudletOnboardingInfo, 0)
		s.ctxsToSend = s.Ctxs
		s.Ctxs = make([]context.Context, 0)
		return true
	}
	return false
}

// Server accepts multiple clients so needs to track multiple
// peers to send to.
type CloudletOnboardingInfoSendMany struct {
	Mux   sync.Mutex
	sends map[string]*CloudletOnboardingInfoSend
}

func NewCloudletOnboardingInfoSendMany() *CloudletOnboardingInfoSendMany {
	s := &CloudletOnboardingInfoSendMany{}
	s.sends = make(map[string]*CloudletOnboardingInfoSend)
	return s
}

func (s *CloudletOnboardingInfoSendMany) NewSend(peerAddr string, notifyId int64) NotifySend {
	send := NewCloudletOnboardingInfoSend()
	send.notifyId = notifyId
	s.Mux.Lock()
	s.sends[peerAddr] = send
	s.Mux.Unlock()
	return send
}

func (s *CloudletOnboardingInfoSendMany) DoneSend(peerAddr string, send NotifySend) {
	asend, ok := send.(*CloudletOnboardingInfoSend)
	if !ok {
		return
	}
	// another connection may come from the same client so remove
	// only if it matches
	s.Mux.Lock()
	if remove, _ := s.sends[peerAddr]; remove == asend {
		delete(s.sends, peerAddr)
	}
	s.Mux.Unlock()
}
func (s *CloudletOnboardingInfoSendMany) Update(ctx context.Context, msg *edgeproto.CloudletOnboardingInfo) int {
	s.Mux.Lock()
	defer s.Mux.Unlock()
	count := 0
	for _, send := range s.sends {
		if send.Update(ctx, msg) {
			count++
		}
	}
	return count
}

func (s *CloudletOnboardingInfoSendMany) UpdateFiltered(ctx context.Context, msg *edgeproto.CloudletOnboardingInfo, sendOk func(ctx context.Context, send *CloudletOnboardingInfoSend, msg *edgeproto.CloudletOnboardingInfo) bool) int {
	s.Mux.Lock()
	defer s.Mux.Unlock()
	count := 0
	for _, send := range s.sends {
		if !sendOk(ctx, send, msg) {
			continue
		}
		if send.Update(ctx, msg) {
			count++
		}
	}
	return count
}

func (s *CloudletOnboardingInfoSendMany) GetTypeString() string {
	return "CloudletOnboardingInfo"
}

type CloudletOnboardingInfoRecv struct {
	Name        string
	MessageName string
	handler     RecvCloudletOnboardingInfoHandler
	Mux         sync.Mutex
	buf         edgeproto.CloudletOnboardingInfo
	RecvCount   uint64
	sendrecv    *SendRecv
}

func NewCloudletOnboardingInfoRecv(handler RecvCloudletOnboardingInfoHandler) *CloudletOnboardingInfoRecv {
	recv := &CloudletOnboardingInfoRecv{}
	recv.Name = "CloudletOnboardingInfo"
	recv.MessageName = proto.MessageName((*edgeproto.CloudletOnboardingInfo)(nil))
	recv.handler = handler
	return recv
}

func (s *CloudletOnboardingInfoRecv) SetSendRecv(sendrecv *SendRecv) {
	s.sendrecv = sendrecv
}

func (s *CloudletOnboardingInfoRecv) GetMessageName() string {
	return s.MessageName
}

func (s *CloudletOnboardingInfoRecv) GetName() string {
	return s.Name
}

func (s *CloudletOnboardingInfoRecv) GetRecvCount() uint64 {
	return s.RecvCount
}

func (s *CloudletOnboardingInfoRecv) Recv(ctx context.Context, notice *edgeproto.Notice, notifyId int64, peerAddr string) {
	span := opentracing.SpanFromContext(ctx)
	if span != nil {
		span.SetTag("objtype", "CloudletOnboardingInfo")
	}

	buf := &edgeproto.CloudletOnboardingInfo{}
	err := types.UnmarshalAny(&notice.Any, buf)
	if err != nil {
		s.sendrecv.stats.UnmarshalErrors++
		log.SpanLog(ctx, log.DebugLevelNotify, "Unmarshal Error", "err", err)
		return
	}
	if span != nil {
		span.SetTag("msg", buf)
	}
	log.SpanLog(ctx, log.DebugLevelNotify,
		fmt.Sprintf("%s recv CloudletOnboardingInfo", s.sendrecv.cliserv),
		"peerAddr", peerAddr,
		"peer", s.sendrecv.peer,
		"local", s.sendrecv.name,
		"message", buf)
	s.handler.RecvCloudletOnboardingInfo(ctx, buf)
	s.sendrecv.stats.Recv++
	// object specific counter
	s.RecvCount++
}

func (s *CloudletOnboardingInfoRecv) RecvAllStart() {
}

func (s *CloudletOnboardingInfoRecv) RecvAllEnd(ctx context.Context, cleanup Cleanup) {
}

type CloudletOnboardingInfoRecvMany struct {
	handler RecvCloudletOnboardingInfoHandler
}

func NewCloudletOnboardingInfoRecvMany(handler RecvCloudletOnboardingInfoHandler) *CloudletOnboardingInfoRecvMany {
	s := &CloudletOnboardingInfoRecvMany{}
	s.handler = handler
	return s
}

func (s *CloudletOnboardingInfoRecvMany) NewRecv() NotifyRecv {
	recv := NewCloudletOnboardingInfoRecv(s.handler)
	return recv
}

func (s *CloudletOnboardingInfoRecvMany) Flush(ctx context.Context, notifyId int64) {
}

type SendCloudletInfoHandler interface {
	GetAllLocked(ctx context.Context, cb func(key *edgeproto.CloudletInfo, modRev int64))
	GetWithRev(key *edgeproto.CloudletKey, buf *edgeproto.CloudletInfo, modRev *int64) bool
}

type RecvCloudletInfoHandler interface {
	Update(ctx context.Context, in *edgeproto.CloudletInfo, rev int64)
	Delete(ctx context.Context, in *edgeproto.CloudletInfo, rev int64)
	Prune(ctx context.Context, keys map[edgeproto.CloudletKey]struct{})
	Flush(ctx context.Context, notifyId int64)
}

type CloudletInfoCacheHandler interface {
	SendCloudletInfoHandler
	RecvCloudletInfoHandler
	AddNotifyCb(fn func(ctx context.Context, obj *edgeproto.CloudletInfo, modRev int64))
}

type CloudletInfoSend struct {
	Name        string
	MessageName string
	handler     SendCloudletInfoHandler
	Keys        map[edgeproto.CloudletKey]CloudletInfoSendContext
	keysToSend  map[edgeproto.CloudletKey]CloudletInfoSendContext
	notifyId    int64
	Mux         sync.Mutex
	buf         edgeproto.CloudletInfo
	SendCount   uint64
	sendrecv    *SendRecv
}

type CloudletInfoSendContext struct {
	ctx         context.Context
	modRev      int64
	forceDelete bool
}

func NewCloudletInfoSend(handler SendCloudletInfoHandler) *CloudletInfoSend {
	send := &CloudletInfoSend{}
	send.Name = "CloudletInfo"
	send.MessageName = proto.MessageName((*edgeproto.CloudletInfo)(nil))
	send.handler = handler
	send.Keys = make(map[edgeproto.CloudletKey]CloudletInfoSendContext)
	return send
}

func (s *CloudletInfoSend) SetSendRecv(sendrecv *SendRecv) {
	s.sendrecv = sendrecv
}

func (s *CloudletInfoSend) GetMessageName() string {
	return s.MessageName
}

func (s *CloudletInfoSend) GetName() string {
	return s.Name
}

func (s *CloudletInfoSend) GetSendCount() uint64 {
	return s.SendCount
}

func (s *CloudletInfoSend) GetNotifyId() int64 {
	return s.notifyId
}
func (s *CloudletInfoSend) UpdateAll(ctx context.Context) {
	if !s.sendrecv.isRemoteWanted(s.MessageName) {
		return
	}
	s.Mux.Lock()
	s.handler.GetAllLocked(ctx, func(obj *edgeproto.CloudletInfo, modRev int64) {
		s.Keys[*obj.GetKey()] = CloudletInfoSendContext{
			ctx:    ctx,
			modRev: modRev,
		}
	})
	s.Mux.Unlock()
}

func (s *CloudletInfoSend) Update(ctx context.Context, obj *edgeproto.CloudletInfo, modRev int64) {
	if !s.sendrecv.isRemoteWanted(s.MessageName) {
		return
	}
	forceDelete := false
	s.updateInternal(ctx, obj.GetKey(), modRev, forceDelete)
}

func (s *CloudletInfoSend) ForceDelete(ctx context.Context, key *edgeproto.CloudletKey, modRev int64) {
	forceDelete := true
	s.updateInternal(ctx, key, modRev, forceDelete)
}

func (s *CloudletInfoSend) updateInternal(ctx context.Context, key *edgeproto.CloudletKey, modRev int64, forceDelete bool) {
	s.Mux.Lock()
	log.SpanLog(ctx, log.DebugLevelNotify, "updateInternal CloudletInfo", "key", key, "modRev", modRev)
	s.Keys[*key] = CloudletInfoSendContext{
		ctx:         ctx,
		modRev:      modRev,
		forceDelete: forceDelete,
	}
	s.Mux.Unlock()
	s.sendrecv.wakeup()
}

func (s *CloudletInfoSend) SendForCloudlet(ctx context.Context, action edgeproto.NoticeAction, cloudlet *edgeproto.Cloudlet) {
}

func (s *CloudletInfoSend) Send(stream StreamNotify, notice *edgeproto.Notice, peer string) error {
	s.Mux.Lock()
	keys := s.keysToSend
	s.keysToSend = nil
	s.Mux.Unlock()
	for key, sendContext := range keys {
		ctx := sendContext.ctx
		found := s.handler.GetWithRev(&key, &s.buf, &notice.ModRev)
		if found && !sendContext.forceDelete {
			notice.Action = edgeproto.NoticeAction_UPDATE
		} else {
			notice.Action = edgeproto.NoticeAction_DELETE
			notice.ModRev = sendContext.modRev
			s.buf.Reset()
			s.buf.SetKey(&key)
		}
		any, err := types.MarshalAny(&s.buf)
		if err != nil {
			s.sendrecv.stats.MarshalErrors++
			err = nil
			continue
		}
		notice.Any = *any
		notice.Span = log.SpanToString(ctx)
		log.SpanLog(ctx, log.DebugLevelNotify,
			fmt.Sprintf("%s send CloudletInfo", s.sendrecv.cliserv),
			"peerAddr", peer,
			"peer", s.sendrecv.peer,
			"local", s.sendrecv.name,
			"action", notice.Action,
			"key", key,
			"modRev", notice.ModRev)
		err = stream.Send(notice)
		if err != nil {
			s.sendrecv.stats.SendErrors++
			return err
		}
		s.sendrecv.stats.Send++
		// object specific counter
		s.SendCount++
	}
	return nil
}

func (s *CloudletInfoSend) PrepData() bool {
	s.Mux.Lock()
	defer s.Mux.Unlock()
	if len(s.Keys) > 0 {
		s.keysToSend = s.Keys
		s.Keys = make(map[edgeproto.CloudletKey]CloudletInfoSendContext)
		return true
	}
	return false
}

// Server accepts multiple clients so needs to track multiple
// peers to send to.
type CloudletInfoSendMany struct {
	handler SendCloudletInfoHandler
	Mux     sync.Mutex
	sends   map[string]*CloudletInfoSend
}

func NewCloudletInfoSendMany(handler SendCloudletInfoHandler) *CloudletInfoSendMany {
	s := &CloudletInfoSendMany{}
	s.handler = handler
	s.sends = make(map[string]*CloudletInfoSend)
	return s
}

func (s *CloudletInfoSendMany) NewSend(peerAddr string, notifyId int64) NotifySend {
	send := NewCloudletInfoSend(s.handler)
	send.notifyId = notifyId
	s.Mux.Lock()
	s.sends[peerAddr] = send
	s.Mux.Unlock()
	return send
}

func (s *CloudletInfoSendMany) DoneSend(peerAddr string, send NotifySend) {
	asend, ok := send.(*CloudletInfoSend)
	if !ok {
		return
	}
	// another connection may come from the same client so remove
	// only if it matches
	s.Mux.Lock()
	if remove, _ := s.sends[peerAddr]; remove == asend {
		delete(s.sends, peerAddr)
	}
	s.Mux.Unlock()
}
func (s *CloudletInfoSendMany) Update(ctx context.Context, obj *edgeproto.CloudletInfo, modRev int64) {
	s.Mux.Lock()
	defer s.Mux.Unlock()
	for _, send := range s.sends {
		send.Update(ctx, obj, modRev)
	}
}

func (s *CloudletInfoSendMany) GetTypeString() string {
	return "CloudletInfo"
}

type CloudletInfoRecv struct {
	Name        string
	MessageName string
	handler     RecvCloudletInfoHandler
	sendAllKeys map[edgeproto.CloudletKey]struct{}
	Mux         sync.Mutex
	buf         edgeproto.CloudletInfo
	RecvCount   uint64
	sendrecv    *SendRecv
}

func NewCloudletInfoRecv(handler RecvCloudletInfoHandler) *CloudletInfoRecv {
	recv := &CloudletInfoRecv{}
	recv.Name = "CloudletInfo"
	recv.MessageName = proto.MessageName((*edgeproto.CloudletInfo)(nil))
	recv.handler = handler
	return recv
}

func (s *CloudletInfoRecv) SetSendRecv(sendrecv *SendRecv) {
	s.sendrecv = sendrecv
}

func (s *CloudletInfoRecv) GetMessageName() string {
	return s.MessageName
}

func (s *CloudletInfoRecv) GetName() string {
	return s.Name
}

func (s *CloudletInfoRecv) GetRecvCount() uint64 {
	return s.RecvCount
}

func (s *CloudletInfoRecv) Recv(ctx context.Context, notice *edgeproto.Notice, notifyId int64, peerAddr string) {
	span := opentracing.SpanFromContext(ctx)
	if span != nil {
		span.SetTag("objtype", "CloudletInfo")
	}

	buf := &edgeproto.CloudletInfo{}
	err := types.UnmarshalAny(&notice.Any, buf)
	if err != nil {
		s.sendrecv.stats.UnmarshalErrors++
		log.SpanLog(ctx, log.DebugLevelNotify, "Unmarshal Error", "err", err)
		return
	}
	buf.NotifyId = notifyId
	if span != nil {
		log.SetTags(span, buf.GetKey().GetTags())
	}
	log.SpanLog(ctx, log.DebugLevelNotify,
		fmt.Sprintf("%s recv CloudletInfo", s.sendrecv.cliserv),
		"peerAddr", peerAddr,
		"peer", s.sendrecv.peer,
		"local", s.sendrecv.name,
		"action", notice.Action,
		"key", buf.GetKeyVal(),
		"modRev", notice.ModRev)
	if notice.Action == edgeproto.NoticeAction_UPDATE {
		s.handler.Update(ctx, buf, notice.ModRev)
		s.Mux.Lock()
		if s.sendAllKeys != nil {
			s.sendAllKeys[buf.GetKeyVal()] = struct{}{}
		}
		s.Mux.Unlock()
	} else if notice.Action == edgeproto.NoticeAction_DELETE {
		s.handler.Delete(ctx, buf, notice.ModRev)
	}
	s.sendrecv.stats.Recv++
	// object specific counter
	s.RecvCount++
	s.RecvHook(ctx, notice, buf, peerAddr) // to be implemented by hand
}

func (s *CloudletInfoRecv) RecvAllStart() {
	s.Mux.Lock()
	defer s.Mux.Unlock()
	s.sendAllKeys = make(map[edgeproto.CloudletKey]struct{})
}

func (s *CloudletInfoRecv) RecvAllEnd(ctx context.Context, cleanup Cleanup) {
	s.Mux.Lock()
	validKeys := s.sendAllKeys
	s.sendAllKeys = nil
	s.Mux.Unlock()
	if cleanup == CleanupPrune {
		s.handler.Prune(ctx, validKeys)
	}
}
func (s *CloudletInfoRecv) Flush(ctx context.Context, notifyId int64) {
	s.handler.Flush(ctx, notifyId)
}

type CloudletInfoRecvMany struct {
	handler RecvCloudletInfoHandler
}

func NewCloudletInfoRecvMany(handler RecvCloudletInfoHandler) *CloudletInfoRecvMany {
	s := &CloudletInfoRecvMany{}
	s.handler = handler
	return s
}

func (s *CloudletInfoRecvMany) NewRecv() NotifyRecv {
	recv := NewCloudletInfoRecv(s.handler)
	return recv
}

func (s *CloudletInfoRecvMany) Flush(ctx context.Context, notifyId int64) {
	s.handler.Flush(ctx, notifyId)
}
func (mgr *ServerMgr) RegisterSendCloudletInfoCache(cache CloudletInfoCacheHandler) {
	send := NewCloudletInfoSendMany(cache)
	mgr.RegisterSend(send)
	cache.AddNotifyCb(send.Update)
}

func (mgr *ServerMgr) RegisterRecvCloudletInfoCache(cache CloudletInfoCacheHandler) {
	recv := NewCloudletInfoRecvMany(cache)
	mgr.RegisterRecv(recv)
}

func (s *Client) RegisterSendCloudletInfoCache(cache CloudletInfoCacheHandler) {
	send := NewCloudletInfoSend(cache)
	s.RegisterSend(send)
	cache.AddNotifyCb(send.Update)
}

func (s *Client) RegisterRecvCloudletInfoCache(cache CloudletInfoCacheHandler) {
	recv := NewCloudletInfoRecv(cache)
	s.RegisterRecv(recv)
}

type RecvStreamStatusHandler interface {
	RecvStreamStatus(ctx context.Context, msg *edgeproto.StreamStatus)
}

type StreamStatusSend struct {
	Name        string
	MessageName string
	Data        []*edgeproto.StreamStatus
	dataToSend  []*edgeproto.StreamStatus
	Ctxs        []context.Context
	ctxsToSend  []context.Context
	notifyId    int64
	Mux         sync.Mutex
	buf         edgeproto.StreamStatus
	SendCount   uint64
	sendrecv    *SendRecv
}

type StreamStatusSendContext struct {
	ctx         context.Context
	modRev      int64
	forceDelete bool
}

func NewStreamStatusSend() *StreamStatusSend {
	send := &StreamStatusSend{}
	send.Name = "StreamStatus"
	send.MessageName = proto.MessageName((*edgeproto.StreamStatus)(nil))
	send.Data = make([]*edgeproto.StreamStatus, 0)
	return send
}

func (s *StreamStatusSend) SetSendRecv(sendrecv *SendRecv) {
	s.sendrecv = sendrecv
}

func (s *StreamStatusSend) GetMessageName() string {
	return s.MessageName
}

func (s *StreamStatusSend) GetName() string {
	return s.Name
}

func (s *StreamStatusSend) GetSendCount() uint64 {
	return s.SendCount
}

func (s *StreamStatusSend) GetNotifyId() int64 {
	return s.notifyId
}
func (s *StreamStatusSend) UpdateAll(ctx context.Context) {}

func (s *StreamStatusSend) Update(ctx context.Context, msg *edgeproto.StreamStatus) bool {
	if !s.sendrecv.isRemoteWanted(s.MessageName) {
		return false
	}
	s.Mux.Lock()
	s.Data = append(s.Data, msg)
	s.Ctxs = append(s.Ctxs, ctx)
	s.Mux.Unlock()
	s.sendrecv.wakeup()
	return true
}

func (s *StreamStatusSend) SendForCloudlet(ctx context.Context, action edgeproto.NoticeAction, cloudlet *edgeproto.Cloudlet) {
}

func (s *StreamStatusSend) Send(stream StreamNotify, notice *edgeproto.Notice, peer string) error {
	s.Mux.Lock()
	data := s.dataToSend
	s.dataToSend = nil
	ctxs := s.ctxsToSend
	s.ctxsToSend = nil
	s.Mux.Unlock()
	for ii, msg := range data {
		any, err := types.MarshalAny(msg)
		ctx := ctxs[ii]
		if err != nil {
			s.sendrecv.stats.MarshalErrors++
			err = nil
			continue
		}
		notice.Any = *any
		notice.Span = log.SpanToString(ctx)
		log.SpanLog(ctx, log.DebugLevelNotify,
			fmt.Sprintf("%s send StreamStatus", s.sendrecv.cliserv),
			"peerAddr", peer,
			"peer", s.sendrecv.peer,
			"local", s.sendrecv.name,
			"message", msg)
		err = stream.Send(notice)
		if err != nil {
			s.sendrecv.stats.SendErrors++
			return err
		}
		s.sendrecv.stats.Send++
		// object specific counter
		s.SendCount++
	}
	return nil
}

func (s *StreamStatusSend) PrepData() bool {
	s.Mux.Lock()
	defer s.Mux.Unlock()
	if len(s.Data) > 0 {
		s.dataToSend = s.Data
		s.Data = make([]*edgeproto.StreamStatus, 0)
		s.ctxsToSend = s.Ctxs
		s.Ctxs = make([]context.Context, 0)
		return true
	}
	return false
}

// Server accepts multiple clients so needs to track multiple
// peers to send to.
type StreamStatusSendMany struct {
	Mux   sync.Mutex
	sends map[string]*StreamStatusSend
}

func NewStreamStatusSendMany() *StreamStatusSendMany {
	s := &StreamStatusSendMany{}
	s.sends = make(map[string]*StreamStatusSend)
	return s
}

func (s *StreamStatusSendMany) NewSend(peerAddr string, notifyId int64) NotifySend {
	send := NewStreamStatusSend()
	send.notifyId = notifyId
	s.Mux.Lock()
	s.sends[peerAddr] = send
	s.Mux.Unlock()
	return send
}

func (s *StreamStatusSendMany) DoneSend(peerAddr string, send NotifySend) {
	asend, ok := send.(*StreamStatusSend)
	if !ok {
		return
	}
	// another connection may come from the same client so remove
	// only if it matches
	s.Mux.Lock()
	if remove, _ := s.sends[peerAddr]; remove == asend {
		delete(s.sends, peerAddr)
	}
	s.Mux.Unlock()
}
func (s *StreamStatusSendMany) Update(ctx context.Context, msg *edgeproto.StreamStatus) int {
	s.Mux.Lock()
	defer s.Mux.Unlock()
	count := 0
	for _, send := range s.sends {
		if send.Update(ctx, msg) {
			count++
		}
	}
	return count
}

func (s *StreamStatusSendMany) UpdateFiltered(ctx context.Context, msg *edgeproto.StreamStatus, sendOk func(ctx context.Context, send *StreamStatusSend, msg *edgeproto.StreamStatus) bool) int {
	s.Mux.Lock()
	defer s.Mux.Unlock()
	count := 0
	for _, send := range s.sends {
		if !sendOk(ctx, send, msg) {
			continue
		}
		if send.Update(ctx, msg) {
			count++
		}
	}
	return count
}

func (s *StreamStatusSendMany) GetTypeString() string {
	return "StreamStatus"
}

type StreamStatusRecv struct {
	Name        string
	MessageName string
	handler     RecvStreamStatusHandler
	Mux         sync.Mutex
	buf         edgeproto.StreamStatus
	RecvCount   uint64
	sendrecv    *SendRecv
}

func NewStreamStatusRecv(handler RecvStreamStatusHandler) *StreamStatusRecv {
	recv := &StreamStatusRecv{}
	recv.Name = "StreamStatus"
	recv.MessageName = proto.MessageName((*edgeproto.StreamStatus)(nil))
	recv.handler = handler
	return recv
}

func (s *StreamStatusRecv) SetSendRecv(sendrecv *SendRecv) {
	s.sendrecv = sendrecv
}

func (s *StreamStatusRecv) GetMessageName() string {
	return s.MessageName
}

func (s *StreamStatusRecv) GetName() string {
	return s.Name
}

func (s *StreamStatusRecv) GetRecvCount() uint64 {
	return s.RecvCount
}

func (s *StreamStatusRecv) Recv(ctx context.Context, notice *edgeproto.Notice, notifyId int64, peerAddr string) {
	span := opentracing.SpanFromContext(ctx)
	if span != nil {
		span.SetTag("objtype", "StreamStatus")
	}

	buf := &edgeproto.StreamStatus{}
	err := types.UnmarshalAny(&notice.Any, buf)
	if err != nil {
		s.sendrecv.stats.UnmarshalErrors++
		log.SpanLog(ctx, log.DebugLevelNotify, "Unmarshal Error", "err", err)
		return
	}
	if span != nil {
		span.SetTag("msg", buf)
	}
	log.SpanLog(ctx, log.DebugLevelNotify,
		fmt.Sprintf("%s recv StreamStatus", s.sendrecv.cliserv),
		"peerAddr", peerAddr,
		"peer", s.sendrecv.peer,
		"local", s.sendrecv.name,
		"message", buf)
	s.handler.RecvStreamStatus(ctx, buf)
	s.sendrecv.stats.Recv++
	// object specific counter
	s.RecvCount++
}

func (s *StreamStatusRecv) RecvAllStart() {
}

func (s *StreamStatusRecv) RecvAllEnd(ctx context.Context, cleanup Cleanup) {
}

type StreamStatusRecvMany struct {
	handler RecvStreamStatusHandler
}

func NewStreamStatusRecvMany(handler RecvStreamStatusHandler) *StreamStatusRecvMany {
	s := &StreamStatusRecvMany{}
	s.handler = handler
	return s
}

func (s *StreamStatusRecvMany) NewRecv() NotifyRecv {
	recv := NewStreamStatusRecv(s.handler)
	return recv
}

func (s *StreamStatusRecvMany) Flush(ctx context.Context, notifyId int64) {
}
