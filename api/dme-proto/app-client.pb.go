// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: app-client.proto

package distributed_match_engine

import (
	context "context"
	encoding_binary "encoding/binary"
	"encoding/json"
	"errors"
	fmt "fmt"
	"github.com/edgexr/edge-cloud-platform/pkg/util"
	_ "github.com/gogo/googleapis/google/api"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	"strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type IDTypes int32

const (
	IDTypes_ID_UNDEFINED IDTypes = 0
	IDTypes_IMEI         IDTypes = 1
	IDTypes_MSISDN       IDTypes = 2
	IDTypes_IPADDR       IDTypes = 3
)

var IDTypes_name = map[int32]string{
	0: "ID_UNDEFINED",
	1: "IMEI",
	2: "MSISDN",
	3: "IPADDR",
}

var IDTypes_value = map[string]int32{
	"ID_UNDEFINED": 0,
	"IMEI":         1,
	"MSISDN":       2,
	"IPADDR":       3,
}

func (x IDTypes) String() string {
	return proto.EnumName(IDTypes_name, int32(x))
}

func (IDTypes) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bb90079a337be67f, []int{0}
}

type FindCloudletReply_FindStatus int32

const (
	FindCloudletReply_FIND_UNKNOWN  FindCloudletReply_FindStatus = 0
	FindCloudletReply_FIND_FOUND    FindCloudletReply_FindStatus = 1
	FindCloudletReply_FIND_NOTFOUND FindCloudletReply_FindStatus = 2
)

var FindCloudletReply_FindStatus_name = map[int32]string{
	0: "FIND_UNKNOWN",
	1: "FIND_FOUND",
	2: "FIND_NOTFOUND",
}

var FindCloudletReply_FindStatus_value = map[string]int32{
	"FIND_UNKNOWN":  0,
	"FIND_FOUND":    1,
	"FIND_NOTFOUND": 2,
}

func (x FindCloudletReply_FindStatus) String() string {
	return proto.EnumName(FindCloudletReply_FindStatus_name, int32(x))
}

func (FindCloudletReply_FindStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bb90079a337be67f, []int{1, 0}
}

type FindCloudletReply_QosSessionResult int32

const (
	FindCloudletReply_QOS_NOT_ATTEMPTED   FindCloudletReply_QosSessionResult = 0
	FindCloudletReply_QOS_SESSION_CREATED FindCloudletReply_QosSessionResult = 1
	FindCloudletReply_QOS_SESSION_FAILED  FindCloudletReply_QosSessionResult = 2
)

var FindCloudletReply_QosSessionResult_name = map[int32]string{
	0: "QOS_NOT_ATTEMPTED",
	1: "QOS_SESSION_CREATED",
	2: "QOS_SESSION_FAILED",
}

var FindCloudletReply_QosSessionResult_value = map[string]int32{
	"QOS_NOT_ATTEMPTED":   0,
	"QOS_SESSION_CREATED": 1,
	"QOS_SESSION_FAILED":  2,
}

func (x FindCloudletReply_QosSessionResult) String() string {
	return proto.EnumName(FindCloudletReply_QosSessionResult_name, int32(x))
}

func (FindCloudletReply_QosSessionResult) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bb90079a337be67f, []int{1, 1}
}

// Status of the reply
type AppInstListReply_AIStatus int32

const (
	AppInstListReply_AI_UNDEFINED AppInstListReply_AIStatus = 0
	AppInstListReply_AI_SUCCESS   AppInstListReply_AIStatus = 1
	AppInstListReply_AI_FAIL      AppInstListReply_AIStatus = 2
)

var AppInstListReply_AIStatus_name = map[int32]string{
	0: "AI_UNDEFINED",
	1: "AI_SUCCESS",
	2: "AI_FAIL",
}

var AppInstListReply_AIStatus_value = map[string]int32{
	"AI_UNDEFINED": 0,
	"AI_SUCCESS":   1,
	"AI_FAIL":      2,
}

func (x AppInstListReply_AIStatus) String() string {
	return proto.EnumName(AppInstListReply_AIStatus_name, int32(x))
}

func (AppInstListReply_AIStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bb90079a337be67f, []int{5, 0}
}

type AppOfficialFqdnReply_AOFStatus int32

const (
	AppOfficialFqdnReply_AOF_UNDEFINED AppOfficialFqdnReply_AOFStatus = 0
	AppOfficialFqdnReply_AOF_SUCCESS   AppOfficialFqdnReply_AOFStatus = 1
	AppOfficialFqdnReply_AOF_FAIL      AppOfficialFqdnReply_AOFStatus = 2
)

var AppOfficialFqdnReply_AOFStatus_name = map[int32]string{
	0: "AOF_UNDEFINED",
	1: "AOF_SUCCESS",
	2: "AOF_FAIL",
}

var AppOfficialFqdnReply_AOFStatus_value = map[string]int32{
	"AOF_UNDEFINED": 0,
	"AOF_SUCCESS":   1,
	"AOF_FAIL":      2,
}

func (x AppOfficialFqdnReply_AOFStatus) String() string {
	return proto.EnumName(AppOfficialFqdnReply_AOFStatus_name, int32(x))
}

func (AppOfficialFqdnReply_AOFStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bb90079a337be67f, []int{7, 0}
}

type ClientEdgeEvent_ClientEventType int32

const (
	ClientEdgeEvent_EVENT_UNKNOWN              ClientEdgeEvent_ClientEventType = 0
	ClientEdgeEvent_EVENT_INIT_CONNECTION      ClientEdgeEvent_ClientEventType = 1
	ClientEdgeEvent_EVENT_TERMINATE_CONNECTION ClientEdgeEvent_ClientEventType = 2
	ClientEdgeEvent_EVENT_LATENCY_SAMPLES      ClientEdgeEvent_ClientEventType = 3
	ClientEdgeEvent_EVENT_LOCATION_UPDATE      ClientEdgeEvent_ClientEventType = 4
	ClientEdgeEvent_EVENT_CUSTOM_EVENT         ClientEdgeEvent_ClientEventType = 5
)

var ClientEdgeEvent_ClientEventType_name = map[int32]string{
	0: "EVENT_UNKNOWN",
	1: "EVENT_INIT_CONNECTION",
	2: "EVENT_TERMINATE_CONNECTION",
	3: "EVENT_LATENCY_SAMPLES",
	4: "EVENT_LOCATION_UPDATE",
	5: "EVENT_CUSTOM_EVENT",
}

var ClientEdgeEvent_ClientEventType_value = map[string]int32{
	"EVENT_UNKNOWN":              0,
	"EVENT_INIT_CONNECTION":      1,
	"EVENT_TERMINATE_CONNECTION": 2,
	"EVENT_LATENCY_SAMPLES":      3,
	"EVENT_LOCATION_UPDATE":      4,
	"EVENT_CUSTOM_EVENT":         5,
}

func (x ClientEdgeEvent_ClientEventType) String() string {
	return proto.EnumName(ClientEdgeEvent_ClientEventType_name, int32(x))
}

func (ClientEdgeEvent_ClientEventType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bb90079a337be67f, []int{8, 0}
}

type ServerEdgeEvent_ServerEventType int32

const (
	ServerEdgeEvent_EVENT_UNKNOWN              ServerEdgeEvent_ServerEventType = 0
	ServerEdgeEvent_EVENT_INIT_CONNECTION      ServerEdgeEvent_ServerEventType = 1
	ServerEdgeEvent_EVENT_LATENCY_REQUEST      ServerEdgeEvent_ServerEventType = 2
	ServerEdgeEvent_EVENT_LATENCY_PROCESSED    ServerEdgeEvent_ServerEventType = 3
	ServerEdgeEvent_EVENT_CLOUDLET_STATE       ServerEdgeEvent_ServerEventType = 4
	ServerEdgeEvent_EVENT_CLOUDLET_MAINTENANCE ServerEdgeEvent_ServerEventType = 5
	ServerEdgeEvent_EVENT_APPINST_HEALTH       ServerEdgeEvent_ServerEventType = 6
	ServerEdgeEvent_EVENT_CLOUDLET_UPDATE      ServerEdgeEvent_ServerEventType = 7
	ServerEdgeEvent_EVENT_ERROR                ServerEdgeEvent_ServerEventType = 8
)

var ServerEdgeEvent_ServerEventType_name = map[int32]string{
	0: "EVENT_UNKNOWN",
	1: "EVENT_INIT_CONNECTION",
	2: "EVENT_LATENCY_REQUEST",
	3: "EVENT_LATENCY_PROCESSED",
	4: "EVENT_CLOUDLET_STATE",
	5: "EVENT_CLOUDLET_MAINTENANCE",
	6: "EVENT_APPINST_HEALTH",
	7: "EVENT_CLOUDLET_UPDATE",
	8: "EVENT_ERROR",
}

var ServerEdgeEvent_ServerEventType_value = map[string]int32{
	"EVENT_UNKNOWN":              0,
	"EVENT_INIT_CONNECTION":      1,
	"EVENT_LATENCY_REQUEST":      2,
	"EVENT_LATENCY_PROCESSED":    3,
	"EVENT_CLOUDLET_STATE":       4,
	"EVENT_CLOUDLET_MAINTENANCE": 5,
	"EVENT_APPINST_HEALTH":       6,
	"EVENT_CLOUDLET_UPDATE":      7,
	"EVENT_ERROR":                8,
}

func (x ServerEdgeEvent_ServerEventType) String() string {
	return proto.EnumName(ServerEdgeEvent_ServerEventType_name, int32(x))
}

func (ServerEdgeEvent_ServerEventType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bb90079a337be67f, []int{9, 0}
}

type FindCloudletRequest struct {
	//
	// API version
	//
	// _(hidden)_ Reserved for future use
	Ver uint32 `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	//
	// Session Cookie
	//
	// Session Cookie from RegisterClientRequest
	SessionCookie string `protobuf:"bytes,2,opt,name=session_cookie,json=sessionCookie,proto3" json:"session_cookie,omitempty"`
	//
	// Carrier Name
	//
	// _(optional)_ By default, all SDKs will automatically fill in this parameter with the MCC+MNC of your current provider. Only override this parameter if you need to filter for a specific carrier on the DME. The DME will filter for App instances that are associated with the specified carrier.
	// If you wish to search for any App Instance on the DME regardless of carrier name, you can input “” to consider all carriers as “Any”.
	CarrierName string `protobuf:"bytes,3,opt,name=carrier_name,json=carrierName,proto3" json:"carrier_name,omitempty"`
	//
	// GPS Location
	//
	// The GPS location of the user
	GpsLocation *Loc `protobuf:"bytes,4,opt,name=gps_location,json=gpsLocation,proto3" json:"gps_location,omitempty"`
	//
	// Tags
	//
	// _(optional)_ Vendor specific data
	Tags                 map[string]string `protobuf:"bytes,100,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *FindCloudletRequest) Reset()         { *m = FindCloudletRequest{} }
func (m *FindCloudletRequest) String() string { return proto.CompactTextString(m) }
func (*FindCloudletRequest) ProtoMessage()    {}
func (*FindCloudletRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb90079a337be67f, []int{0}
}
func (m *FindCloudletRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FindCloudletRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FindCloudletRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FindCloudletRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FindCloudletRequest.Merge(m, src)
}
func (m *FindCloudletRequest) XXX_Size() int {
	return m.Size()
}
func (m *FindCloudletRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FindCloudletRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FindCloudletRequest proto.InternalMessageInfo

type FindCloudletReply struct {
	//
	// API version
	//
	// _(hidden)_ Reserved for future use
	Ver uint32 `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	// Status return
	Status FindCloudletReply_FindStatus `protobuf:"varint,2,opt,name=status,proto3,enum=distributed_match_engine.FindCloudletReply_FindStatus" json:"status,omitempty"`
	// Fully Qualified Domain Name of the Closest App instance
	Fqdn string `protobuf:"bytes,3,opt,name=fqdn,proto3" json:"fqdn,omitempty"`
	// List of Service Endpoints for AppInst
	Ports []*AppPort `protobuf:"bytes,4,rep,name=ports,proto3" json:"ports,omitempty"`
	// Location of the cloudlet
	CloudletLocation *Loc `protobuf:"bytes,5,opt,name=cloudlet_location,json=cloudletLocation,proto3" json:"cloudlet_location,omitempty"`
	// Session Cookie for specific EdgeEvents for specific AppInst
	EdgeEventsCookie string `protobuf:"bytes,6,opt,name=edge_events_cookie,json=edgeEventsCookie,proto3" json:"edge_events_cookie,omitempty"`
	// Result of QOS priority session creation attempt
	QosResult FindCloudletReply_QosSessionResult `protobuf:"varint,7,opt,name=qos_result,json=qosResult,proto3,enum=distributed_match_engine.FindCloudletReply_QosSessionResult" json:"qos_result,omitempty"`
	// Error message in case of QOS_SESSION_FAILED
	QosErrorMsg string `protobuf:"bytes,8,opt,name=qos_error_msg,json=qosErrorMsg,proto3" json:"qos_error_msg,omitempty"`
	// _(optional)_ Vendor specific data
	Tags                 map[string]string `protobuf:"bytes,100,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *FindCloudletReply) Reset()         { *m = FindCloudletReply{} }
func (m *FindCloudletReply) String() string { return proto.CompactTextString(m) }
func (*FindCloudletReply) ProtoMessage()    {}
func (*FindCloudletReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb90079a337be67f, []int{1}
}
func (m *FindCloudletReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FindCloudletReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FindCloudletReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FindCloudletReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FindCloudletReply.Merge(m, src)
}
func (m *FindCloudletReply) XXX_Size() int {
	return m.Size()
}
func (m *FindCloudletReply) XXX_DiscardUnknown() {
	xxx_messageInfo_FindCloudletReply.DiscardUnknown(m)
}

var xxx_messageInfo_FindCloudletReply proto.InternalMessageInfo

type AppInstListRequest struct {
	//
	// API version
	//
	// _(hidden)_ Reserved for future use
	Ver uint32 `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	// Session Cookie from RegisterClientRequest
	SessionCookie string `protobuf:"bytes,2,opt,name=session_cookie,json=sessionCookie,proto3" json:"session_cookie,omitempty"`
	//
	// Carrier Name
	//
	// _(optional)_ By default, all SDKs will automatically fill in this parameter with the MCC+MNC of your current provider. Only override this parameter if you need to filter for a specific carrier on the DME. The DME will filter for App instances that are associated with the specified carrier.
	// If you wish to search for any App Instance on the DME regardless of carrier name, you can input “” to consider all carriers as “Any”.
	CarrierName string `protobuf:"bytes,3,opt,name=carrier_name,json=carrierName,proto3" json:"carrier_name,omitempty"`
	// The GPS location of the user
	GpsLocation *Loc `protobuf:"bytes,4,opt,name=gps_location,json=gpsLocation,proto3" json:"gps_location,omitempty"`
	// _(optional)_ Limit the number of results, defaults to 3
	Limit uint32 `protobuf:"varint,6,opt,name=limit,proto3" json:"limit,omitempty"`
	// _(optional)_ Vendor specific data
	Tags                 map[string]string `protobuf:"bytes,100,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *AppInstListRequest) Reset()         { *m = AppInstListRequest{} }
func (m *AppInstListRequest) String() string { return proto.CompactTextString(m) }
func (*AppInstListRequest) ProtoMessage()    {}
func (*AppInstListRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb90079a337be67f, []int{2}
}
func (m *AppInstListRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppInstListRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppInstListRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppInstListRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppInstListRequest.Merge(m, src)
}
func (m *AppInstListRequest) XXX_Size() int {
	return m.Size()
}
func (m *AppInstListRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AppInstListRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AppInstListRequest proto.InternalMessageInfo

type Appinstance struct {
	// App Instance Name
	AppName string `protobuf:"bytes,1,opt,name=app_name,json=appName,proto3" json:"app_name,omitempty"`
	// App Instance Version
	AppVers string `protobuf:"bytes,2,opt,name=app_vers,json=appVers,proto3" json:"app_vers,omitempty"`
	// App Instance FQDN
	Fqdn string `protobuf:"bytes,3,opt,name=fqdn,proto3" json:"fqdn,omitempty"`
	// ports to access app
	Ports []*AppPort `protobuf:"bytes,4,rep,name=ports,proto3" json:"ports,omitempty"`
	// App Organization Name
	OrgName string `protobuf:"bytes,5,opt,name=org_name,json=orgName,proto3" json:"org_name,omitempty"`
	// Session Cookie for specific EdgeEvents for specific AppInst
	EdgeEventsCookie     string   `protobuf:"bytes,6,opt,name=edge_events_cookie,json=edgeEventsCookie,proto3" json:"edge_events_cookie,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Appinstance) Reset()         { *m = Appinstance{} }
func (m *Appinstance) String() string { return proto.CompactTextString(m) }
func (*Appinstance) ProtoMessage()    {}
func (*Appinstance) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb90079a337be67f, []int{3}
}
func (m *Appinstance) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Appinstance) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Appinstance.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Appinstance) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Appinstance.Merge(m, src)
}
func (m *Appinstance) XXX_Size() int {
	return m.Size()
}
func (m *Appinstance) XXX_DiscardUnknown() {
	xxx_messageInfo_Appinstance.DiscardUnknown(m)
}

var xxx_messageInfo_Appinstance proto.InternalMessageInfo

type CloudletLocation struct {
	// Cloudlet Organization Name
	CarrierName string `protobuf:"bytes,1,opt,name=carrier_name,json=carrierName,proto3" json:"carrier_name,omitempty"`
	// Cloudlet Name
	CloudletName string `protobuf:"bytes,2,opt,name=cloudlet_name,json=cloudletName,proto3" json:"cloudlet_name,omitempty"`
	// The GPS Location of the cloudlet
	GpsLocation *Loc `protobuf:"bytes,3,opt,name=gps_location,json=gpsLocation,proto3" json:"gps_location,omitempty"`
	// Distance of cloudlet vs loc in request
	Distance float64 `protobuf:"fixed64,4,opt,name=distance,proto3" json:"distance,omitempty"`
	// App instances
	Appinstances         []*Appinstance `protobuf:"bytes,5,rep,name=appinstances,proto3" json:"appinstances,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *CloudletLocation) Reset()         { *m = CloudletLocation{} }
func (m *CloudletLocation) String() string { return proto.CompactTextString(m) }
func (*CloudletLocation) ProtoMessage()    {}
func (*CloudletLocation) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb90079a337be67f, []int{4}
}
func (m *CloudletLocation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CloudletLocation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CloudletLocation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CloudletLocation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloudletLocation.Merge(m, src)
}
func (m *CloudletLocation) XXX_Size() int {
	return m.Size()
}
func (m *CloudletLocation) XXX_DiscardUnknown() {
	xxx_messageInfo_CloudletLocation.DiscardUnknown(m)
}

var xxx_messageInfo_CloudletLocation proto.InternalMessageInfo

type AppInstListReply struct {
	//
	// API version
	//
	// _(hidden)_ Reserved for future use
	Ver       uint32                    `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	Status    AppInstListReply_AIStatus `protobuf:"varint,2,opt,name=status,proto3,enum=distributed_match_engine.AppInstListReply_AIStatus" json:"status,omitempty"`
	Cloudlets []*CloudletLocation       `protobuf:"bytes,3,rep,name=cloudlets,proto3" json:"cloudlets,omitempty"`
	// _(optional)_ Vendor specific data
	Tags                 map[string]string `protobuf:"bytes,100,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *AppInstListReply) Reset()         { *m = AppInstListReply{} }
func (m *AppInstListReply) String() string { return proto.CompactTextString(m) }
func (*AppInstListReply) ProtoMessage()    {}
func (*AppInstListReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb90079a337be67f, []int{5}
}
func (m *AppInstListReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppInstListReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppInstListReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppInstListReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppInstListReply.Merge(m, src)
}
func (m *AppInstListReply) XXX_Size() int {
	return m.Size()
}
func (m *AppInstListReply) XXX_DiscardUnknown() {
	xxx_messageInfo_AppInstListReply.DiscardUnknown(m)
}

var xxx_messageInfo_AppInstListReply proto.InternalMessageInfo

type AppOfficialFqdnRequest struct {
	//
	// API version
	//
	// _(hidden)_ Reserved for future use
	Ver uint32 `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	// Session Cookie from RegisterClientRequest
	SessionCookie string `protobuf:"bytes,2,opt,name=session_cookie,json=sessionCookie,proto3" json:"session_cookie,omitempty"`
	// The GPS location of the user
	GpsLocation *Loc `protobuf:"bytes,3,opt,name=gps_location,json=gpsLocation,proto3" json:"gps_location,omitempty"`
	// _(optional)_ Vendor specific data
	Tags                 map[string]string `protobuf:"bytes,100,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *AppOfficialFqdnRequest) Reset()         { *m = AppOfficialFqdnRequest{} }
func (m *AppOfficialFqdnRequest) String() string { return proto.CompactTextString(m) }
func (*AppOfficialFqdnRequest) ProtoMessage()    {}
func (*AppOfficialFqdnRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb90079a337be67f, []int{6}
}
func (m *AppOfficialFqdnRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppOfficialFqdnRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppOfficialFqdnRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppOfficialFqdnRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppOfficialFqdnRequest.Merge(m, src)
}
func (m *AppOfficialFqdnRequest) XXX_Size() int {
	return m.Size()
}
func (m *AppOfficialFqdnRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AppOfficialFqdnRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AppOfficialFqdnRequest proto.InternalMessageInfo

type AppOfficialFqdnReply struct {
	//
	// API version
	//
	// _(hidden)_ Reserved for future use
	Ver uint32 `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	// The FQDN to which the app is reached independent of the edge
	AppOfficialFqdn string `protobuf:"bytes,2,opt,name=app_official_fqdn,json=appOfficialFqdn,proto3" json:"app_official_fqdn,omitempty"`
	// Tokenized client data
	ClientToken string `protobuf:"bytes,3,opt,name=client_token,json=clientToken,proto3" json:"client_token,omitempty"`
	// Status of the reply
	Status AppOfficialFqdnReply_AOFStatus `protobuf:"varint,4,opt,name=status,proto3,enum=distributed_match_engine.AppOfficialFqdnReply_AOFStatus" json:"status,omitempty"`
	// List of Service Endpoints for AppInst
	Ports []*AppPort `protobuf:"bytes,5,rep,name=ports,proto3" json:"ports,omitempty"`
	// _(optional)_ Vendor specific data
	Tags                 map[string]string `protobuf:"bytes,100,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *AppOfficialFqdnReply) Reset()         { *m = AppOfficialFqdnReply{} }
func (m *AppOfficialFqdnReply) String() string { return proto.CompactTextString(m) }
func (*AppOfficialFqdnReply) ProtoMessage()    {}
func (*AppOfficialFqdnReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb90079a337be67f, []int{7}
}
func (m *AppOfficialFqdnReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppOfficialFqdnReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppOfficialFqdnReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppOfficialFqdnReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppOfficialFqdnReply.Merge(m, src)
}
func (m *AppOfficialFqdnReply) XXX_Size() int {
	return m.Size()
}
func (m *AppOfficialFqdnReply) XXX_DiscardUnknown() {
	xxx_messageInfo_AppOfficialFqdnReply.DiscardUnknown(m)
}

var xxx_messageInfo_AppOfficialFqdnReply proto.InternalMessageInfo

// Messages from SDK to DME
type ClientEdgeEvent struct {
	// Session Cookie from RegisterClientReply
	SessionCookie string `protobuf:"bytes,1,opt,name=session_cookie,json=sessionCookie,proto3" json:"session_cookie,omitempty"`
	// Session Cookie from FindCloudletReply
	EdgeEventsCookie string                          `protobuf:"bytes,2,opt,name=edge_events_cookie,json=edgeEventsCookie,proto3" json:"edge_events_cookie,omitempty"`
	EventType        ClientEdgeEvent_ClientEventType `protobuf:"varint,3,opt,name=event_type,json=eventType,proto3,enum=distributed_match_engine.ClientEdgeEvent_ClientEventType" json:"event_type,omitempty"`
	// GPS Location info if event_type is EVENT_LOCATION_UPDATE or EVENT_LATENCY_SAMPLES
	GpsLocation *Loc `protobuf:"bytes,4,opt,name=gps_location,json=gpsLocation,proto3" json:"gps_location,omitempty"`
	// Latency Samples if event_type is EVENT_LATENCY_SAMPLES or EVENT_CUSTOM_EVENT
	Samples []*Sample `protobuf:"bytes,5,rep,name=samples,proto3" json:"samples,omitempty"`
	//
	// _(optional)_ Static device information for latency and deviceinfo stats
	// Send on EVENT_INIT_CONNECTION to get this information in latency stats and deviceinfo stats
	DeviceInfoStatic *DeviceInfoStatic `protobuf:"bytes,6,opt,name=device_info_static,json=deviceInfoStatic,proto3" json:"device_info_static,omitempty"`
	//
	// _(optional)_ Dynamic device information for latency and deviceinfo stats
	// Send on EVENT_INIT_CONNECTION to get this information in first deviceinfo stat
	// Send on EVENT_LOCATION_UPDATE to get this information in dynamic deviceinfo stats
	// Send on EVENT_LATENCY_SAMPLES to get this information in latency stats
	DeviceInfoDynamic *DeviceInfoDynamic `protobuf:"bytes,7,opt,name=device_info_dynamic,json=deviceInfoDynamic,proto3" json:"device_info_dynamic,omitempty"`
	// Custom event specified by the application
	CustomEvent string `protobuf:"bytes,8,opt,name=custom_event,json=customEvent,proto3" json:"custom_event,omitempty"`
	// _(optional)_ Vendor specific data
	Tags                 map[string]string `protobuf:"bytes,100,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *ClientEdgeEvent) Reset()         { *m = ClientEdgeEvent{} }
func (m *ClientEdgeEvent) String() string { return proto.CompactTextString(m) }
func (*ClientEdgeEvent) ProtoMessage()    {}
func (*ClientEdgeEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb90079a337be67f, []int{8}
}
func (m *ClientEdgeEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientEdgeEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientEdgeEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClientEdgeEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientEdgeEvent.Merge(m, src)
}
func (m *ClientEdgeEvent) XXX_Size() int {
	return m.Size()
}
func (m *ClientEdgeEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientEdgeEvent.DiscardUnknown(m)
}

var xxx_messageInfo_ClientEdgeEvent proto.InternalMessageInfo

// Message from DME to SDK
type ServerEdgeEvent struct {
	EventType ServerEdgeEvent_ServerEventType `protobuf:"varint,1,opt,name=event_type,json=eventType,proto3,enum=distributed_match_engine.ServerEdgeEvent_ServerEventType" json:"event_type,omitempty"`
	// Cloudlet state information if cloudlet state is not CLOUDLET_STATE_READY
	CloudletState CloudletState `protobuf:"varint,2,opt,name=cloudlet_state,json=cloudletState,proto3,enum=distributed_match_engine.CloudletState" json:"cloudlet_state,omitempty"`
	// Cloudlet maintenance state information if maintenance state is not NORMAL_OPERATION
	MaintenanceState MaintenanceState `protobuf:"varint,3,opt,name=maintenance_state,json=maintenanceState,proto3,enum=distributed_match_engine.MaintenanceState" json:"maintenance_state,omitempty"`
	// AppInst health state information if health check is not HEALTH_CHECK_OK
	HealthCheck HealthCheck `protobuf:"varint,4,opt,name=health_check,json=healthCheck,proto3,enum=distributed_match_engine.HealthCheck" json:"health_check,omitempty"`
	// Summarized RTT Latency stats from samples provided from client if event_type is EVENT_LATENCY
	Statistics *Statistics `protobuf:"bytes,5,opt,name=statistics,proto3" json:"statistics,omitempty"`
	//
	// New and closer cloudlet if event_type is EVENT_CLOUDLET_UPDATE.
	// (EVENT_CLOUDLET_UPDATE occurs if the client is closer to a different cloudlet, or a new closer appinst is created, or a previously down appinst/cloudlet that is closest to the client is now operational)
	// Also sent on EVENT_CLOUDLET_STATE if another cloudlet is available
	// Also sent on EVENT_CLOUDLET_MAINTENANCE, if another cloudlet is available and maintenance_state == UNDER_MAINTENANCE
	// Also sent on EVENT_APPINST_HEALTH, if another cloudlet is available and health_check != HEALTH_CHECK_UNKNOWN
	NewCloudlet *FindCloudletReply `protobuf:"bytes,6,opt,name=new_cloudlet,json=newCloudlet,proto3" json:"new_cloudlet,omitempty"`
	// Error message if event_type is EVENT_ERROR
	ErrorMsg string `protobuf:"bytes,7,opt,name=error_msg,json=errorMsg,proto3" json:"error_msg,omitempty"`
	// _(optional)_ Vendor specific data
	Tags                 map[string]string `protobuf:"bytes,100,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *ServerEdgeEvent) Reset()         { *m = ServerEdgeEvent{} }
func (m *ServerEdgeEvent) String() string { return proto.CompactTextString(m) }
func (*ServerEdgeEvent) ProtoMessage()    {}
func (*ServerEdgeEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb90079a337be67f, []int{9}
}
func (m *ServerEdgeEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServerEdgeEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServerEdgeEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServerEdgeEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServerEdgeEvent.Merge(m, src)
}
func (m *ServerEdgeEvent) XXX_Size() int {
	return m.Size()
}
func (m *ServerEdgeEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_ServerEdgeEvent.DiscardUnknown(m)
}

var xxx_messageInfo_ServerEdgeEvent proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("distributed_match_engine.IDTypes", IDTypes_name, IDTypes_value)
	proto.RegisterEnum("distributed_match_engine.FindCloudletReply_FindStatus", FindCloudletReply_FindStatus_name, FindCloudletReply_FindStatus_value)
	proto.RegisterEnum("distributed_match_engine.FindCloudletReply_QosSessionResult", FindCloudletReply_QosSessionResult_name, FindCloudletReply_QosSessionResult_value)
	proto.RegisterEnum("distributed_match_engine.AppInstListReply_AIStatus", AppInstListReply_AIStatus_name, AppInstListReply_AIStatus_value)
	proto.RegisterEnum("distributed_match_engine.AppOfficialFqdnReply_AOFStatus", AppOfficialFqdnReply_AOFStatus_name, AppOfficialFqdnReply_AOFStatus_value)
	proto.RegisterEnum("distributed_match_engine.ClientEdgeEvent_ClientEventType", ClientEdgeEvent_ClientEventType_name, ClientEdgeEvent_ClientEventType_value)
	proto.RegisterEnum("distributed_match_engine.ServerEdgeEvent_ServerEventType", ServerEdgeEvent_ServerEventType_name, ServerEdgeEvent_ServerEventType_value)
	proto.RegisterType((*FindCloudletRequest)(nil), "distributed_match_engine.FindCloudletRequest")
	proto.RegisterMapType((map[string]string)(nil), "distributed_match_engine.FindCloudletRequest.TagsEntry")
	proto.RegisterType((*FindCloudletReply)(nil), "distributed_match_engine.FindCloudletReply")
	proto.RegisterMapType((map[string]string)(nil), "distributed_match_engine.FindCloudletReply.TagsEntry")
	proto.RegisterType((*AppInstListRequest)(nil), "distributed_match_engine.AppInstListRequest")
	proto.RegisterMapType((map[string]string)(nil), "distributed_match_engine.AppInstListRequest.TagsEntry")
	proto.RegisterType((*Appinstance)(nil), "distributed_match_engine.Appinstance")
	proto.RegisterType((*CloudletLocation)(nil), "distributed_match_engine.CloudletLocation")
	proto.RegisterType((*AppInstListReply)(nil), "distributed_match_engine.AppInstListReply")
	proto.RegisterMapType((map[string]string)(nil), "distributed_match_engine.AppInstListReply.TagsEntry")
	proto.RegisterType((*AppOfficialFqdnRequest)(nil), "distributed_match_engine.AppOfficialFqdnRequest")
	proto.RegisterMapType((map[string]string)(nil), "distributed_match_engine.AppOfficialFqdnRequest.TagsEntry")
	proto.RegisterType((*AppOfficialFqdnReply)(nil), "distributed_match_engine.AppOfficialFqdnReply")
	proto.RegisterMapType((map[string]string)(nil), "distributed_match_engine.AppOfficialFqdnReply.TagsEntry")
	proto.RegisterType((*ClientEdgeEvent)(nil), "distributed_match_engine.ClientEdgeEvent")
	proto.RegisterMapType((map[string]string)(nil), "distributed_match_engine.ClientEdgeEvent.TagsEntry")
	proto.RegisterType((*ServerEdgeEvent)(nil), "distributed_match_engine.ServerEdgeEvent")
	proto.RegisterMapType((map[string]string)(nil), "distributed_match_engine.ServerEdgeEvent.TagsEntry")
}

func init() { proto.RegisterFile("app-client.proto", fileDescriptor_bb90079a337be67f) }

var fileDescriptor_bb90079a337be67f = []byte{
	// 1732 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x58, 0x4b, 0x8f, 0xe3, 0xc6,
	0x11, 0x5e, 0xea, 0xad, 0x92, 0x46, 0x4b, 0xf5, 0xbe, 0xb4, 0xda, 0x78, 0x30, 0xcb, 0xc4, 0xc8,
	0x78, 0x6c, 0xcf, 0x3a, 0xb3, 0x89, 0xd7, 0x1e, 0xc4, 0x40, 0x18, 0x89, 0xf2, 0x70, 0x57, 0xa2,
	0xb4, 0x24, 0x65, 0x3b, 0xf1, 0x81, 0xa0, 0xa9, 0x1e, 0x0d, 0xb1, 0x14, 0xc9, 0x61, 0x73, 0xc6,
	0x98, 0x6b, 0x72, 0x08, 0x82, 0x20, 0xa7, 0x9c, 0x02, 0xe4, 0x2f, 0xe4, 0x7f, 0x2c, 0x72, 0x32,
	0x90, 0x53, 0x80, 0x1c, 0x9c, 0x45, 0xfe, 0x43, 0x90, 0x5b, 0xd0, 0xcd, 0x87, 0x1e, 0xab, 0x91,
	0xa5, 0xac, 0x2e, 0xbe, 0x75, 0x57, 0x77, 0x55, 0x57, 0x57, 0x7d, 0xf5, 0x75, 0x91, 0xc0, 0x9b,
	0xbe, 0xff, 0xbe, 0xe5, 0xd8, 0xd8, 0x0d, 0x0f, 0xfd, 0xc0, 0x0b, 0x3d, 0xd4, 0x18, 0xd9, 0x24,
	0x0c, 0xec, 0xaf, 0x2e, 0x42, 0x3c, 0x32, 0x26, 0x66, 0x68, 0x9d, 0x19, 0xd8, 0x1d, 0xdb, 0x2e,
	0x6e, 0xfe, 0x60, 0xec, 0x79, 0x63, 0x07, 0x3f, 0x32, 0x7d, 0xfb, 0x91, 0xe9, 0xba, 0x5e, 0x68,
	0x86, 0xb6, 0xe7, 0x92, 0x48, 0xaf, 0x59, 0x76, 0x3c, 0x2b, 0x1e, 0xde, 0x34, 0x7d, 0xdf, 0xf2,
	0x26, 0x13, 0xcf, 0x8d, 0x04, 0xc2, 0xcb, 0x0c, 0xdc, 0xea, 0xd8, 0xee, 0xa8, 0xe5, 0x78, 0x17,
	0x23, 0x07, 0x87, 0x2a, 0x3e, 0xbf, 0xc0, 0x24, 0x44, 0x3c, 0x64, 0x2f, 0x71, 0xd0, 0xe0, 0xf6,
	0xb8, 0xfd, 0x1d, 0x95, 0x0e, 0xd1, 0xdb, 0x50, 0x23, 0x98, 0x10, 0xdb, 0x73, 0x0d, 0xcb, 0xf3,
	0x5e, 0xd8, 0xb8, 0x91, 0xd9, 0xe3, 0xf6, 0xcb, 0xea, 0x4e, 0x2c, 0x6d, 0x31, 0x21, 0x7a, 0x08,
	0x55, 0xcb, 0x0c, 0x02, 0x1b, 0x07, 0x86, 0x6b, 0x4e, 0x70, 0x23, 0xcb, 0x36, 0x55, 0x62, 0x99,
	0x62, 0x4e, 0x30, 0xfa, 0x05, 0x54, 0xc7, 0x3e, 0x31, 0x1c, 0xcf, 0x62, 0x6e, 0x36, 0x72, 0x7b,
	0xdc, 0x7e, 0xe5, 0xe8, 0xad, 0xc3, 0xeb, 0xae, 0x77, 0xd8, 0xf5, 0x2c, 0xb5, 0x32, 0xf6, 0x49,
	0x37, 0xd6, 0x40, 0xcf, 0x20, 0x17, 0x9a, 0x63, 0xd2, 0x18, 0xed, 0x65, 0xf7, 0x2b, 0x47, 0x4f,
	0xae, 0xd7, 0x5c, 0x72, 0xb5, 0x43, 0xdd, 0x1c, 0x13, 0xc9, 0x0d, 0x83, 0x2b, 0x95, 0x19, 0x69,
	0x3e, 0x81, 0x72, 0x2a, 0xa2, 0xf7, 0x7e, 0x81, 0xaf, 0xd8, 0xbd, 0xcb, 0x2a, 0x1d, 0xa2, 0xdb,
	0x90, 0xbf, 0x34, 0x9d, 0x8b, 0xe4, 0xba, 0xd1, 0xe4, 0x38, 0xf3, 0x11, 0xf7, 0x34, 0x57, 0x2a,
	0xf1, 0x65, 0xb5, 0x68, 0x61, 0xc7, 0x31, 0xec, 0x91, 0xf0, 0x6d, 0x1e, 0xea, 0xf3, 0xe7, 0xf9,
	0xce, 0xd5, 0x92, 0x40, 0x2a, 0x50, 0x20, 0xa1, 0x19, 0x5e, 0x10, 0x66, 0xb1, 0x76, 0xf4, 0xe1,
	0xba, 0xee, 0xfb, 0xce, 0x15, 0x93, 0x68, 0x4c, 0x5b, 0x8d, 0xad, 0x20, 0x04, 0xb9, 0xd3, 0xf3,
	0x91, 0x1b, 0x47, 0x9a, 0x8d, 0xd1, 0x13, 0xc8, 0xfb, 0x5e, 0x10, 0x92, 0x46, 0x8e, 0x45, 0xe8,
	0xe1, 0xf5, 0x47, 0x88, 0xbe, 0x3f, 0xf0, 0x82, 0x50, 0x8d, 0xf6, 0xa3, 0xa7, 0x50, 0xb7, 0xe2,
	0x03, 0xa7, 0x09, 0xca, 0xaf, 0x93, 0x20, 0x3e, 0xd1, 0x4b, 0xb3, 0xf4, 0x1e, 0x20, 0x3c, 0x1a,
	0x63, 0x03, 0x5f, 0x62, 0x37, 0x24, 0x09, 0x6a, 0x0a, 0xcc, 0x4d, 0x9e, 0xae, 0x48, 0x6c, 0x21,
	0x06, 0xce, 0x97, 0x00, 0xe7, 0x1e, 0x31, 0x02, 0x4c, 0x2e, 0x9c, 0xb0, 0x51, 0x64, 0xa1, 0xf9,
	0xf9, 0x26, 0xa1, 0x79, 0xee, 0x11, 0x2d, 0x82, 0xa2, 0xca, 0x6c, 0xa8, 0xe5, 0x73, 0x8f, 0x44,
	0x43, 0x24, 0xc0, 0x0e, 0x35, 0x8e, 0x83, 0xc0, 0x0b, 0x8c, 0x09, 0x19, 0x37, 0x4a, 0x11, 0x2c,
	0xcf, 0x3d, 0x22, 0x51, 0x59, 0x8f, 0x8c, 0x91, 0x3c, 0x07, 0xaa, 0x9f, 0x6d, 0x72, 0xf4, 0xb6,
	0x20, 0x25, 0x88, 0x00, 0xd3, 0x0c, 0x23, 0x1e, 0xaa, 0x1d, 0x59, 0x69, 0x1b, 0x43, 0xe5, 0x99,
	0xd2, 0xff, 0x5c, 0xe1, 0x6f, 0xa0, 0x1a, 0x00, 0x93, 0x74, 0xfa, 0x43, 0xa5, 0xcd, 0x73, 0xa8,
	0x0e, 0x3b, 0x6c, 0xae, 0xf4, 0xf5, 0x48, 0x94, 0x11, 0x7e, 0x0d, 0xfc, 0x62, 0x24, 0xd0, 0x1d,
	0xa8, 0x3f, 0xef, 0x6b, 0x74, 0x97, 0x21, 0xea, 0xba, 0xd4, 0x1b, 0xe8, 0x52, 0x9b, 0xbf, 0x81,
	0xee, 0xc1, 0x2d, 0x2a, 0xd6, 0x24, 0x4d, 0x93, 0xfb, 0x8a, 0xd1, 0x52, 0x25, 0x91, 0x2e, 0x70,
	0xe8, 0x2e, 0xa0, 0xd9, 0x85, 0x8e, 0x28, 0x77, 0x25, 0x6a, 0xfb, 0x9f, 0x19, 0x40, 0xa2, 0xef,
	0xcb, 0x2e, 0x09, 0xbb, 0x36, 0xf9, 0x9e, 0x90, 0xc5, 0x6d, 0xc8, 0x3b, 0xf6, 0xc4, 0x0e, 0x19,
	0xf2, 0x76, 0xd4, 0x68, 0x82, 0x9e, 0xce, 0x65, 0xfb, 0xc3, 0x95, 0x05, 0xb2, 0x70, 0xdf, 0x6d,
	0x32, 0x48, 0x9e, 0x2f, 0x4c, 0x19, 0xe4, 0x1f, 0x1c, 0x54, 0x44, 0xdf, 0xb7, 0x5d, 0x12, 0x9a,
	0xae, 0x85, 0xd1, 0x7d, 0x28, 0x99, 0xbe, 0x1f, 0x85, 0x26, 0xb2, 0x57, 0x34, 0x7d, 0x9f, 0x85,
	0x25, 0x5e, 0xba, 0xc4, 0x01, 0x89, 0xcd, 0xd2, 0xa5, 0xcf, 0x70, 0xb0, 0x65, 0x3e, 0xb8, 0x0f,
	0x25, 0x2f, 0x18, 0x47, 0x2e, 0xe4, 0xa3, 0x73, 0xbc, 0x60, 0xcc, 0x5c, 0xd8, 0xa8, 0xbc, 0x85,
	0xdf, 0x66, 0x80, 0x6f, 0x2d, 0x32, 0xc4, 0x62, 0xfe, 0xb9, 0xd7, 0xf3, 0xff, 0x43, 0xd8, 0x49,
	0x09, 0x89, 0xed, 0x89, 0x6e, 0x5b, 0x4d, 0x84, 0x4b, 0x41, 0x92, 0xdd, 0x18, 0x24, 0x4d, 0x28,
	0xd1, 0xcd, 0x34, 0xec, 0x0c, 0x62, 0x9c, 0x9a, 0xce, 0x91, 0x0c, 0x55, 0x73, 0x9a, 0x15, 0xd2,
	0xc8, 0xb3, 0x18, 0xbe, 0xbd, 0x32, 0x86, 0xc9, 0x6e, 0x75, 0x4e, 0x55, 0xf8, 0x6f, 0x06, 0xf8,
	0x39, 0x40, 0x2d, 0x7f, 0x22, 0x9e, 0x2d, 0x3c, 0x11, 0x8f, 0xd7, 0x84, 0x27, 0xe5, 0x22, 0x51,
	0x5e, 0x78, 0x1f, 0x4e, 0xa0, 0x9c, 0x04, 0x8b, 0x34, 0xb2, 0xcc, 0xf7, 0x83, 0xeb, 0xed, 0x2d,
	0xe6, 0x48, 0x9d, 0x2a, 0xa3, 0x93, 0xb9, 0x9a, 0xf9, 0xe9, 0x06, 0x4e, 0x6d, 0x8d, 0x20, 0x3f,
	0x86, 0x52, 0x72, 0x41, 0x4a, 0x8f, 0xa2, 0x6c, 0x0c, 0x95, 0xb6, 0xd4, 0x91, 0x15, 0x46, 0x68,
	0x35, 0x00, 0x51, 0x36, 0xb4, 0x61, 0xab, 0x25, 0x69, 0x1a, 0xcf, 0xa1, 0x0a, 0x14, 0x45, 0x99,
	0xd1, 0x17, 0x9f, 0x11, 0xfe, 0x92, 0x81, 0xbb, 0xa2, 0xef, 0xf7, 0x4f, 0x4f, 0x6d, 0xcb, 0x36,
	0x9d, 0xce, 0xf9, 0xc8, 0x7d, 0x63, 0x02, 0x7b, 0x73, 0xe0, 0x29, 0x73, 0x31, 0x3d, 0x5e, 0x19,
	0xd3, 0x25, 0xae, 0x6f, 0x2f, 0xb2, 0x2f, 0xb3, 0x70, 0xfb, 0xb5, 0x33, 0x96, 0xc3, 0xf3, 0x00,
	0xea, 0x94, 0x7c, 0xbc, 0x78, 0xab, 0xc1, 0xe8, 0x26, 0x32, 0x48, 0x1b, 0xcc, 0x59, 0x13, 0xac,
	0xc4, 0x59, 0x13, 0x6b, 0x84, 0xde, 0x0b, 0xec, 0xa6, 0x14, 0xcf, 0x64, 0x3a, 0x15, 0xa1, 0x41,
	0x8a, 0xf6, 0x1c, 0x43, 0xfb, 0x47, 0x1b, 0x04, 0x81, 0x21, 0xbe, 0xdf, 0x59, 0x80, 0x7c, 0x4a,
	0x77, 0xf9, 0x0d, 0xe9, 0xae, 0x3b, 0x97, 0x8d, 0x4d, 0x1d, 0xd9, 0x5a, 0x2e, 0x3e, 0x81, 0x72,
	0x7a, 0x29, 0xfa, 0xc6, 0x8b, 0xfd, 0xce, 0x1c, 0xce, 0x6f, 0x42, 0x85, 0x8a, 0xa6, 0x40, 0xaf,
	0x42, 0x89, 0x0a, 0x62, 0xa4, 0xff, 0xad, 0x00, 0x37, 0x5b, 0x2c, 0xc0, 0x52, 0x42, 0xc3, 0x4b,
	0x00, 0xcd, 0x2d, 0x03, 0xf4, 0x72, 0x52, 0xcf, 0x5c, 0xd3, 0xb3, 0x7d, 0x01, 0xc0, 0x36, 0x1a,
	0xe1, 0x95, 0x1f, 0xbd, 0xde, 0xb5, 0xa3, 0x8f, 0x57, 0x71, 0xcb, 0x9c, 0x4f, 0xc9, 0x9c, 0x8e,
	0xf5, 0x2b, 0x1f, 0xab, 0x65, 0x9c, 0x0c, 0xb7, 0xf0, 0xec, 0x1f, 0x43, 0x91, 0x98, 0x13, 0xdf,
	0x49, 0x09, 0x7b, 0xef, 0x7a, 0x65, 0x8d, 0x6d, 0x54, 0x13, 0x05, 0xf4, 0x05, 0xa0, 0x11, 0xbe,
	0xb4, 0x2d, 0x6c, 0xd8, 0xee, 0xa9, 0x67, 0x50, 0x54, 0xd9, 0x16, 0x7b, 0xda, 0x56, 0x72, 0x67,
	0x9b, 0xe9, 0xc8, 0xee, 0xa9, 0xa7, 0x31, 0x0d, 0x95, 0x1f, 0x2d, 0x48, 0xd0, 0x97, 0x70, 0x6b,
	0xd6, 0xf2, 0xe8, 0xca, 0x35, 0x27, 0xb6, 0xc5, 0xda, 0xdd, 0xca, 0xd1, 0xbb, 0xeb, 0x98, 0x6e,
	0x47, 0x2a, 0x6a, 0x7d, 0xb4, 0x28, 0x62, 0xb5, 0x76, 0x41, 0x42, 0x6f, 0x12, 0xa5, 0x2f, 0x69,
	0x72, 0x23, 0x59, 0x04, 0x83, 0x4f, 0xe7, 0x00, 0xfe, 0x78, 0xfd, 0x5c, 0x6d, 0x0d, 0xdb, 0x7f,
	0xe5, 0x52, 0x70, 0xa6, 0xd9, 0xae, 0xc3, 0x8e, 0xf4, 0x99, 0xa4, 0xe8, 0x33, 0x9d, 0xee, 0x7d,
	0xb8, 0x13, 0x89, 0x64, 0x45, 0xd6, 0x8d, 0x56, 0x5f, 0x51, 0xa4, 0x96, 0x2e, 0xf7, 0x15, 0x9e,
	0x43, 0xbb, 0xd0, 0x8c, 0x96, 0x74, 0x49, 0xed, 0xc9, 0x8a, 0xa8, 0x4b, 0xb3, 0xeb, 0x99, 0xa9,
	0x6a, 0x57, 0xd4, 0x25, 0xa5, 0xf5, 0x2b, 0x43, 0x13, 0x7b, 0x83, 0xae, 0xa4, 0xf1, 0xd9, 0x99,
	0xa5, 0x7e, 0x4b, 0xa4, 0xdb, 0x8d, 0xe1, 0xa0, 0x2d, 0xea, 0x12, 0x9f, 0xa3, 0x3d, 0x6f, 0xb4,
	0xd4, 0x1a, 0x6a, 0x7a, 0xbf, 0x67, 0xb0, 0x09, 0x9f, 0x17, 0xfe, 0x58, 0x84, 0x9b, 0x1a, 0x0e,
	0x2e, 0x71, 0x30, 0x2d, 0xa6, 0x79, 0xdc, 0x73, 0xdf, 0x85, 0xfb, 0x05, 0xf5, 0x64, 0xbe, 0x0c,
	0xf7, 0x0a, 0xd4, 0xd2, 0x76, 0x87, 0xc2, 0x0e, 0xc7, 0x1d, 0xc0, 0x8f, 0xbf, 0xfb, 0xc5, 0xa6,
	0x08, 0xc3, 0x6a, 0xda, 0x2d, 0xb1, 0x29, 0xfa, 0x1c, 0xea, 0x13, 0xd3, 0x76, 0x43, 0xec, 0xd2,
	0x06, 0x24, 0x36, 0x19, 0x15, 0xea, 0x0a, 0x20, 0xf7, 0xa6, 0x2a, 0x91, 0x55, 0x7e, 0xb2, 0x20,
	0x41, 0x27, 0x50, 0x3d, 0xc3, 0xa6, 0x13, 0x9e, 0x19, 0xd6, 0x19, 0xb6, 0x5e, 0xc4, 0xd4, 0xbd,
	0xa2, 0x29, 0x3a, 0x61, 0xbb, 0x5b, 0x74, 0xb3, 0x5a, 0x39, 0x9b, 0x4e, 0x50, 0x1b, 0x80, 0x15,
	0x18, 0x09, 0x6d, 0x8b, 0xc4, 0xdf, 0x9a, 0x3f, 0x5a, 0x11, 0xcc, 0x74, 0xaf, 0x3a, 0xa3, 0x87,
	0x14, 0xa8, 0xba, 0xf8, 0x6b, 0x23, 0xb9, 0x7d, 0x5c, 0xac, 0xef, 0x6e, 0xf0, 0x15, 0xa7, 0x56,
	0x5c, 0xfc, 0x75, 0x22, 0x41, 0x0f, 0xa0, 0x3c, 0xfd, 0x5a, 0x2c, 0x32, 0x10, 0x97, 0x70, 0xf2,
	0xa9, 0xb8, 0x76, 0x15, 0x2d, 0x66, 0x7e, 0x6b, 0x55, 0xf4, 0x1f, 0x2e, 0x45, 0xe5, 0xff, 0x59,
	0x45, 0xaf, 0x55, 0x89, 0x2a, 0x3d, 0x1f, 0x4a, 0x9a, 0xce, 0x67, 0xd0, 0x03, 0xb8, 0x37, 0xbf,
	0x34, 0x50, 0xfb, 0xf4, 0xa1, 0x91, 0xda, 0x7c, 0x16, 0x35, 0xe0, 0x76, 0x5c, 0x27, 0xdd, 0xfe,
	0xb0, 0xdd, 0x95, 0x74, 0x43, 0xd3, 0xa3, 0x0a, 0x4a, 0xeb, 0x32, 0x5d, 0xe9, 0x89, 0xb2, 0xa2,
	0x4b, 0x8a, 0xa8, 0xb4, 0x24, 0x3e, 0x3f, 0xd5, 0x14, 0x07, 0x03, 0x59, 0xd1, 0x74, 0xe3, 0x44,
	0x12, 0xbb, 0xfa, 0x09, 0x5f, 0x98, 0xfa, 0x92, 0x6a, 0xc6, 0x65, 0x59, 0xa4, 0x4f, 0x5d, 0xb4,
	0x24, 0xa9, 0x6a, 0x5f, 0xe5, 0x4b, 0x07, 0x9f, 0x40, 0x51, 0x6e, 0xd3, 0xfb, 0xb2, 0x06, 0x50,
	0x6e, 0xcf, 0x3d, 0x8c, 0x25, 0xc8, 0xc9, 0x3d, 0x49, 0xe6, 0x39, 0x04, 0x50, 0xe8, 0x69, 0xb2,
	0xd6, 0xa6, 0x84, 0x00, 0x50, 0x90, 0x07, 0x62, 0xbb, 0xad, 0xf2, 0xd9, 0xa3, 0x6f, 0x72, 0x50,
	0xeb, 0xd1, 0x14, 0x49, 0x2c, 0x43, 0xa2, 0x6f, 0xa3, 0xdf, 0x71, 0x50, 0x9d, 0x45, 0x03, 0x7a,
	0x7f, 0xa3, 0x1f, 0x4a, 0xcd, 0x4d, 0x40, 0x26, 0x3c, 0xf8, 0xcd, 0xdf, 0xff, 0xfd, 0xa7, 0xcc,
	0x1d, 0x81, 0x7f, 0x74, 0xf9, 0x93, 0x47, 0xa7, 0xb6, 0x3b, 0x4a, 0x10, 0x7b, 0xcc, 0x1d, 0xa0,
	0xdf, 0x73, 0x50, 0xfb, 0x14, 0x87, 0x33, 0xed, 0x33, 0x7a, 0x6f, 0x93, 0x2f, 0xd3, 0xe6, 0xc1,
	0xfa, 0x3d, 0xb9, 0xf0, 0x16, 0xf3, 0xe4, 0x9e, 0x80, 0xa8, 0x27, 0x63, 0x1c, 0xc6, 0x1f, 0x2a,
	0x8e, 0x4d, 0x98, 0x2f, 0x7f, 0xe6, 0x00, 0x45, 0xbe, 0xcc, 0xf5, 0x73, 0x1f, 0x6c, 0xda, 0xa1,
	0x36, 0x0f, 0x37, 0xeb, 0xa2, 0x84, 0x87, 0xcc, 0xaf, 0x07, 0xc2, 0xdd, 0xa9, 0x5f, 0x49, 0xa7,
	0x49, 0x1b, 0x4d, 0xea, 0xdb, 0x1f, 0x28, 0xfa, 0xc3, 0x00, 0x9b, 0x93, 0x29, 0x27, 0xbf, 0xb3,
	0xf6, 0x5b, 0xd6, 0x7c, 0x67, 0xed, 0x82, 0x15, 0x76, 0x99, 0x33, 0x0d, 0xe1, 0x16, 0x75, 0x86,
	0xb0, 0x23, 0x69, 0x17, 0xc4, 0x08, 0xfb, 0x98, 0x3b, 0xd8, 0xe7, 0x3e, 0xe0, 0x7e, 0xc9, 0xbf,
	0xfc, 0xd7, 0xee, 0x8d, 0x97, 0xaf, 0x76, 0xb9, 0x6f, 0x5e, 0xed, 0x72, 0xdf, 0xbe, 0xda, 0xe5,
	0xbe, 0x2a, 0xb0, 0x9f, 0xab, 0x8f, 0xff, 0x17, 0x00, 0x00, 0xff, 0xff, 0xd7, 0x76, 0xf9, 0x56,
	0xc4, 0x15, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MatchEngineApiClient is the client API for MatchEngineApi service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MatchEngineApiClient interface {
	//
	// FindCloudlet
	//
	// Find the best application service running on a cloudlet in the
	// Edge Cloud for the client to use, based on proximity and other policies.
	FindCloudlet(ctx context.Context, in *FindCloudletRequest, opts ...grpc.CallOption) (*FindCloudletReply, error)
	//
	// GetAppInstList
	//
	// Like FindCloudlet, but returns a short list of the best instances
	// instead of a single result, allowing the client to choose based on
	// its own criteria, or maintain several parallel connections to
	// different sites.
	GetAppInstList(ctx context.Context, in *AppInstListRequest, opts ...grpc.CallOption) (*AppInstListReply, error)
	//
	// GetAppOfficialFqdn
	//
	// Get an App's official FQDN if configured, which points to a default
	// public cloud instance of the application service that can be
	// used if no Edge Cloud application instances are available.
	GetAppOfficialFqdn(ctx context.Context, in *AppOfficialFqdnRequest, opts ...grpc.CallOption) (*AppOfficialFqdnReply, error)
	//
	// StreamEdgeEvent
	//
	// Streams events bidirectionally between device client and the
	// Edge Cloud platform for notifications.
	StreamEdgeEvent(ctx context.Context, opts ...grpc.CallOption) (MatchEngineApi_StreamEdgeEventClient, error)
}

type matchEngineApiClient struct {
	cc *grpc.ClientConn
}

func NewMatchEngineApiClient(cc *grpc.ClientConn) MatchEngineApiClient {
	return &matchEngineApiClient{cc}
}

func (c *matchEngineApiClient) FindCloudlet(ctx context.Context, in *FindCloudletRequest, opts ...grpc.CallOption) (*FindCloudletReply, error) {
	out := new(FindCloudletReply)
	err := c.cc.Invoke(ctx, "/distributed_match_engine.MatchEngineApi/FindCloudlet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchEngineApiClient) GetAppInstList(ctx context.Context, in *AppInstListRequest, opts ...grpc.CallOption) (*AppInstListReply, error) {
	out := new(AppInstListReply)
	err := c.cc.Invoke(ctx, "/distributed_match_engine.MatchEngineApi/GetAppInstList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchEngineApiClient) GetAppOfficialFqdn(ctx context.Context, in *AppOfficialFqdnRequest, opts ...grpc.CallOption) (*AppOfficialFqdnReply, error) {
	out := new(AppOfficialFqdnReply)
	err := c.cc.Invoke(ctx, "/distributed_match_engine.MatchEngineApi/GetAppOfficialFqdn", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchEngineApiClient) StreamEdgeEvent(ctx context.Context, opts ...grpc.CallOption) (MatchEngineApi_StreamEdgeEventClient, error) {
	stream, err := c.cc.NewStream(ctx, &_MatchEngineApi_serviceDesc.Streams[0], "/distributed_match_engine.MatchEngineApi/StreamEdgeEvent", opts...)
	if err != nil {
		return nil, err
	}
	x := &matchEngineApiStreamEdgeEventClient{stream}
	return x, nil
}

type MatchEngineApi_StreamEdgeEventClient interface {
	Send(*ClientEdgeEvent) error
	Recv() (*ServerEdgeEvent, error)
	grpc.ClientStream
}

type matchEngineApiStreamEdgeEventClient struct {
	grpc.ClientStream
}

func (x *matchEngineApiStreamEdgeEventClient) Send(m *ClientEdgeEvent) error {
	return x.ClientStream.SendMsg(m)
}

func (x *matchEngineApiStreamEdgeEventClient) Recv() (*ServerEdgeEvent, error) {
	m := new(ServerEdgeEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// MatchEngineApiServer is the server API for MatchEngineApi service.
type MatchEngineApiServer interface {
	//
	// FindCloudlet
	//
	// Find the best application service running on a cloudlet in the
	// Edge Cloud for the client to use, based on proximity and other policies.
	FindCloudlet(context.Context, *FindCloudletRequest) (*FindCloudletReply, error)
	//
	// GetAppInstList
	//
	// Like FindCloudlet, but returns a short list of the best instances
	// instead of a single result, allowing the client to choose based on
	// its own criteria, or maintain several parallel connections to
	// different sites.
	GetAppInstList(context.Context, *AppInstListRequest) (*AppInstListReply, error)
	//
	// GetAppOfficialFqdn
	//
	// Get an App's official FQDN if configured, which points to a default
	// public cloud instance of the application service that can be
	// used if no Edge Cloud application instances are available.
	GetAppOfficialFqdn(context.Context, *AppOfficialFqdnRequest) (*AppOfficialFqdnReply, error)
	//
	// StreamEdgeEvent
	//
	// Streams events bidirectionally between device client and the
	// Edge Cloud platform for notifications.
	StreamEdgeEvent(MatchEngineApi_StreamEdgeEventServer) error
}

// UnimplementedMatchEngineApiServer can be embedded to have forward compatible implementations.
type UnimplementedMatchEngineApiServer struct {
}

func (*UnimplementedMatchEngineApiServer) FindCloudlet(ctx context.Context, req *FindCloudletRequest) (*FindCloudletReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindCloudlet not implemented")
}
func (*UnimplementedMatchEngineApiServer) GetAppInstList(ctx context.Context, req *AppInstListRequest) (*AppInstListReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAppInstList not implemented")
}
func (*UnimplementedMatchEngineApiServer) GetAppOfficialFqdn(ctx context.Context, req *AppOfficialFqdnRequest) (*AppOfficialFqdnReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAppOfficialFqdn not implemented")
}
func (*UnimplementedMatchEngineApiServer) StreamEdgeEvent(srv MatchEngineApi_StreamEdgeEventServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamEdgeEvent not implemented")
}

func RegisterMatchEngineApiServer(s *grpc.Server, srv MatchEngineApiServer) {
	s.RegisterService(&_MatchEngineApi_serviceDesc, srv)
}

func _MatchEngineApi_FindCloudlet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FindCloudletRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MatchEngineApiServer).FindCloudlet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/distributed_match_engine.MatchEngineApi/FindCloudlet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MatchEngineApiServer).FindCloudlet(ctx, req.(*FindCloudletRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MatchEngineApi_GetAppInstList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppInstListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MatchEngineApiServer).GetAppInstList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/distributed_match_engine.MatchEngineApi/GetAppInstList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MatchEngineApiServer).GetAppInstList(ctx, req.(*AppInstListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MatchEngineApi_GetAppOfficialFqdn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppOfficialFqdnRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MatchEngineApiServer).GetAppOfficialFqdn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/distributed_match_engine.MatchEngineApi/GetAppOfficialFqdn",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MatchEngineApiServer).GetAppOfficialFqdn(ctx, req.(*AppOfficialFqdnRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MatchEngineApi_StreamEdgeEvent_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(MatchEngineApiServer).StreamEdgeEvent(&matchEngineApiStreamEdgeEventServer{stream})
}

type MatchEngineApi_StreamEdgeEventServer interface {
	Send(*ServerEdgeEvent) error
	Recv() (*ClientEdgeEvent, error)
	grpc.ServerStream
}

type matchEngineApiStreamEdgeEventServer struct {
	grpc.ServerStream
}

func (x *matchEngineApiStreamEdgeEventServer) Send(m *ServerEdgeEvent) error {
	return x.ServerStream.SendMsg(m)
}

func (x *matchEngineApiStreamEdgeEventServer) Recv() (*ClientEdgeEvent, error) {
	m := new(ClientEdgeEvent)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _MatchEngineApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "distributed_match_engine.MatchEngineApi",
	HandlerType: (*MatchEngineApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "FindCloudlet",
			Handler:    _MatchEngineApi_FindCloudlet_Handler,
		},
		{
			MethodName: "GetAppInstList",
			Handler:    _MatchEngineApi_GetAppInstList_Handler,
		},
		{
			MethodName: "GetAppOfficialFqdn",
			Handler:    _MatchEngineApi_GetAppOfficialFqdn_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamEdgeEvent",
			Handler:       _MatchEngineApi_StreamEdgeEvent_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "app-client.proto",
}

func (m *FindCloudletRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FindCloudletRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FindCloudletRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Tags) > 0 {
		for k := range m.Tags {
			v := m.Tags[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAppClient(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAppClient(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAppClient(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa2
		}
	}
	if m.GpsLocation != nil {
		{
			size, err := m.GpsLocation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAppClient(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.CarrierName) > 0 {
		i -= len(m.CarrierName)
		copy(dAtA[i:], m.CarrierName)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.CarrierName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SessionCookie) > 0 {
		i -= len(m.SessionCookie)
		copy(dAtA[i:], m.SessionCookie)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.SessionCookie)))
		i--
		dAtA[i] = 0x12
	}
	if m.Ver != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FindCloudletReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FindCloudletReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FindCloudletReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Tags) > 0 {
		for k := range m.Tags {
			v := m.Tags[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAppClient(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAppClient(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAppClient(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.QosErrorMsg) > 0 {
		i -= len(m.QosErrorMsg)
		copy(dAtA[i:], m.QosErrorMsg)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.QosErrorMsg)))
		i--
		dAtA[i] = 0x42
	}
	if m.QosResult != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.QosResult))
		i--
		dAtA[i] = 0x38
	}
	if len(m.EdgeEventsCookie) > 0 {
		i -= len(m.EdgeEventsCookie)
		copy(dAtA[i:], m.EdgeEventsCookie)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.EdgeEventsCookie)))
		i--
		dAtA[i] = 0x32
	}
	if m.CloudletLocation != nil {
		{
			size, err := m.CloudletLocation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAppClient(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Ports) > 0 {
		for iNdEx := len(m.Ports) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ports[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAppClient(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Fqdn) > 0 {
		i -= len(m.Fqdn)
		copy(dAtA[i:], m.Fqdn)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.Fqdn)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Status != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if m.Ver != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AppInstListRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppInstListRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppInstListRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Tags) > 0 {
		for k := range m.Tags {
			v := m.Tags[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAppClient(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAppClient(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAppClient(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa2
		}
	}
	if m.Limit != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x30
	}
	if m.GpsLocation != nil {
		{
			size, err := m.GpsLocation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAppClient(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.CarrierName) > 0 {
		i -= len(m.CarrierName)
		copy(dAtA[i:], m.CarrierName)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.CarrierName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SessionCookie) > 0 {
		i -= len(m.SessionCookie)
		copy(dAtA[i:], m.SessionCookie)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.SessionCookie)))
		i--
		dAtA[i] = 0x12
	}
	if m.Ver != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Appinstance) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Appinstance) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Appinstance) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.EdgeEventsCookie) > 0 {
		i -= len(m.EdgeEventsCookie)
		copy(dAtA[i:], m.EdgeEventsCookie)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.EdgeEventsCookie)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.OrgName) > 0 {
		i -= len(m.OrgName)
		copy(dAtA[i:], m.OrgName)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.OrgName)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Ports) > 0 {
		for iNdEx := len(m.Ports) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ports[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAppClient(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Fqdn) > 0 {
		i -= len(m.Fqdn)
		copy(dAtA[i:], m.Fqdn)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.Fqdn)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AppVers) > 0 {
		i -= len(m.AppVers)
		copy(dAtA[i:], m.AppVers)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.AppVers)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AppName) > 0 {
		i -= len(m.AppName)
		copy(dAtA[i:], m.AppName)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.AppName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CloudletLocation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloudletLocation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudletLocation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Appinstances) > 0 {
		for iNdEx := len(m.Appinstances) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Appinstances[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAppClient(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Distance != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Distance))))
		i--
		dAtA[i] = 0x21
	}
	if m.GpsLocation != nil {
		{
			size, err := m.GpsLocation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAppClient(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.CloudletName) > 0 {
		i -= len(m.CloudletName)
		copy(dAtA[i:], m.CloudletName)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.CloudletName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.CarrierName) > 0 {
		i -= len(m.CarrierName)
		copy(dAtA[i:], m.CarrierName)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.CarrierName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AppInstListReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppInstListReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppInstListReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Tags) > 0 {
		for k := range m.Tags {
			v := m.Tags[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAppClient(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAppClient(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAppClient(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.Cloudlets) > 0 {
		for iNdEx := len(m.Cloudlets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Cloudlets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAppClient(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Status != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if m.Ver != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AppOfficialFqdnRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppOfficialFqdnRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppOfficialFqdnRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Tags) > 0 {
		for k := range m.Tags {
			v := m.Tags[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAppClient(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAppClient(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAppClient(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa2
		}
	}
	if m.GpsLocation != nil {
		{
			size, err := m.GpsLocation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAppClient(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SessionCookie) > 0 {
		i -= len(m.SessionCookie)
		copy(dAtA[i:], m.SessionCookie)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.SessionCookie)))
		i--
		dAtA[i] = 0x12
	}
	if m.Ver != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AppOfficialFqdnReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppOfficialFqdnReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppOfficialFqdnReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Tags) > 0 {
		for k := range m.Tags {
			v := m.Tags[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAppClient(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAppClient(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAppClient(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.Ports) > 0 {
		for iNdEx := len(m.Ports) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ports[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAppClient(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Status != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x20
	}
	if len(m.ClientToken) > 0 {
		i -= len(m.ClientToken)
		copy(dAtA[i:], m.ClientToken)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.ClientToken)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AppOfficialFqdn) > 0 {
		i -= len(m.AppOfficialFqdn)
		copy(dAtA[i:], m.AppOfficialFqdn)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.AppOfficialFqdn)))
		i--
		dAtA[i] = 0x12
	}
	if m.Ver != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.Ver))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ClientEdgeEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientEdgeEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientEdgeEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Tags) > 0 {
		for k := range m.Tags {
			v := m.Tags[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAppClient(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAppClient(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAppClient(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.CustomEvent) > 0 {
		i -= len(m.CustomEvent)
		copy(dAtA[i:], m.CustomEvent)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.CustomEvent)))
		i--
		dAtA[i] = 0x42
	}
	if m.DeviceInfoDynamic != nil {
		{
			size, err := m.DeviceInfoDynamic.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAppClient(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.DeviceInfoStatic != nil {
		{
			size, err := m.DeviceInfoStatic.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAppClient(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.Samples) > 0 {
		for iNdEx := len(m.Samples) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Samples[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAppClient(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.GpsLocation != nil {
		{
			size, err := m.GpsLocation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAppClient(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.EventType != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.EventType))
		i--
		dAtA[i] = 0x18
	}
	if len(m.EdgeEventsCookie) > 0 {
		i -= len(m.EdgeEventsCookie)
		copy(dAtA[i:], m.EdgeEventsCookie)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.EdgeEventsCookie)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SessionCookie) > 0 {
		i -= len(m.SessionCookie)
		copy(dAtA[i:], m.SessionCookie)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.SessionCookie)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ServerEdgeEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServerEdgeEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServerEdgeEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Tags) > 0 {
		for k := range m.Tags {
			v := m.Tags[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAppClient(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAppClient(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAppClient(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.ErrorMsg) > 0 {
		i -= len(m.ErrorMsg)
		copy(dAtA[i:], m.ErrorMsg)
		i = encodeVarintAppClient(dAtA, i, uint64(len(m.ErrorMsg)))
		i--
		dAtA[i] = 0x3a
	}
	if m.NewCloudlet != nil {
		{
			size, err := m.NewCloudlet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAppClient(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Statistics != nil {
		{
			size, err := m.Statistics.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAppClient(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.HealthCheck != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.HealthCheck))
		i--
		dAtA[i] = 0x20
	}
	if m.MaintenanceState != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.MaintenanceState))
		i--
		dAtA[i] = 0x18
	}
	if m.CloudletState != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.CloudletState))
		i--
		dAtA[i] = 0x10
	}
	if m.EventType != 0 {
		i = encodeVarintAppClient(dAtA, i, uint64(m.EventType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintAppClient(dAtA []byte, offset int, v uint64) int {
	offset -= sovAppClient(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *FindCloudletRequest) CopyInFields(src *FindCloudletRequest) int {
	changed := 0
	if m.Ver != src.Ver {
		m.Ver = src.Ver
		changed++
	}
	if m.SessionCookie != src.SessionCookie {
		m.SessionCookie = src.SessionCookie
		changed++
	}
	if m.CarrierName != src.CarrierName {
		m.CarrierName = src.CarrierName
		changed++
	}
	if src.GpsLocation != nil {
		if m.GpsLocation == nil {
			m.GpsLocation = &Loc{}
		}
		if m.GpsLocation.Latitude != src.GpsLocation.Latitude {
			m.GpsLocation.Latitude = src.GpsLocation.Latitude
			changed++
		}
		if m.GpsLocation.Longitude != src.GpsLocation.Longitude {
			m.GpsLocation.Longitude = src.GpsLocation.Longitude
			changed++
		}
		if m.GpsLocation.HorizontalAccuracy != src.GpsLocation.HorizontalAccuracy {
			m.GpsLocation.HorizontalAccuracy = src.GpsLocation.HorizontalAccuracy
			changed++
		}
		if m.GpsLocation.VerticalAccuracy != src.GpsLocation.VerticalAccuracy {
			m.GpsLocation.VerticalAccuracy = src.GpsLocation.VerticalAccuracy
			changed++
		}
		if m.GpsLocation.Altitude != src.GpsLocation.Altitude {
			m.GpsLocation.Altitude = src.GpsLocation.Altitude
			changed++
		}
		if m.GpsLocation.Course != src.GpsLocation.Course {
			m.GpsLocation.Course = src.GpsLocation.Course
			changed++
		}
		if m.GpsLocation.Speed != src.GpsLocation.Speed {
			m.GpsLocation.Speed = src.GpsLocation.Speed
			changed++
		}
		if src.GpsLocation.Timestamp != nil {
			if m.GpsLocation.Timestamp == nil {
				m.GpsLocation.Timestamp = &Timestamp{}
			}
			if m.GpsLocation.Timestamp.Seconds != src.GpsLocation.Timestamp.Seconds {
				m.GpsLocation.Timestamp.Seconds = src.GpsLocation.Timestamp.Seconds
				changed++
			}
			if m.GpsLocation.Timestamp.Nanos != src.GpsLocation.Timestamp.Nanos {
				m.GpsLocation.Timestamp.Nanos = src.GpsLocation.Timestamp.Nanos
				changed++
			}
		} else if m.GpsLocation.Timestamp != nil {
			m.GpsLocation.Timestamp = nil
			changed++
		}
	} else if m.GpsLocation != nil {
		m.GpsLocation = nil
		changed++
	}
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k0, _ := range src.Tags {
			m.Tags[k0] = src.Tags[k0]
			changed++
		}
	} else if m.Tags != nil {
		m.Tags = nil
		changed++
	}
	return changed
}

func (m *FindCloudletRequest) DeepCopyIn(src *FindCloudletRequest) {
	m.Ver = src.Ver
	m.SessionCookie = src.SessionCookie
	m.CarrierName = src.CarrierName
	if src.GpsLocation != nil {
		var tmp_GpsLocation Loc
		tmp_GpsLocation.DeepCopyIn(src.GpsLocation)
		m.GpsLocation = &tmp_GpsLocation
	} else {
		m.GpsLocation = nil
	}
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k, v := range src.Tags {
			m.Tags[k] = v
		}
	} else {
		m.Tags = nil
	}
}

// Helper method to check that enums have valid values
func (m *FindCloudletRequest) ValidateEnums() error {
	if m.GpsLocation != nil {
		if err := m.GpsLocation.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (s *FindCloudletRequest) ClearTagged(tags map[string]struct{}) {
	if s.GpsLocation != nil {
		s.GpsLocation.ClearTagged(tags)
	}
}

func (m *FindCloudletReply) CopyInFields(src *FindCloudletReply) int {
	changed := 0
	if m.Ver != src.Ver {
		m.Ver = src.Ver
		changed++
	}
	if m.Status != src.Status {
		m.Status = src.Status
		changed++
	}
	if m.Fqdn != src.Fqdn {
		m.Fqdn = src.Fqdn
		changed++
	}
	if src.Ports != nil {
		m.Ports = src.Ports
		changed++
	} else if m.Ports != nil {
		m.Ports = nil
		changed++
	}
	if src.CloudletLocation != nil {
		if m.CloudletLocation == nil {
			m.CloudletLocation = &Loc{}
		}
		if m.CloudletLocation.Latitude != src.CloudletLocation.Latitude {
			m.CloudletLocation.Latitude = src.CloudletLocation.Latitude
			changed++
		}
		if m.CloudletLocation.Longitude != src.CloudletLocation.Longitude {
			m.CloudletLocation.Longitude = src.CloudletLocation.Longitude
			changed++
		}
		if m.CloudletLocation.HorizontalAccuracy != src.CloudletLocation.HorizontalAccuracy {
			m.CloudletLocation.HorizontalAccuracy = src.CloudletLocation.HorizontalAccuracy
			changed++
		}
		if m.CloudletLocation.VerticalAccuracy != src.CloudletLocation.VerticalAccuracy {
			m.CloudletLocation.VerticalAccuracy = src.CloudletLocation.VerticalAccuracy
			changed++
		}
		if m.CloudletLocation.Altitude != src.CloudletLocation.Altitude {
			m.CloudletLocation.Altitude = src.CloudletLocation.Altitude
			changed++
		}
		if m.CloudletLocation.Course != src.CloudletLocation.Course {
			m.CloudletLocation.Course = src.CloudletLocation.Course
			changed++
		}
		if m.CloudletLocation.Speed != src.CloudletLocation.Speed {
			m.CloudletLocation.Speed = src.CloudletLocation.Speed
			changed++
		}
		if src.CloudletLocation.Timestamp != nil {
			if m.CloudletLocation.Timestamp == nil {
				m.CloudletLocation.Timestamp = &Timestamp{}
			}
			if m.CloudletLocation.Timestamp.Seconds != src.CloudletLocation.Timestamp.Seconds {
				m.CloudletLocation.Timestamp.Seconds = src.CloudletLocation.Timestamp.Seconds
				changed++
			}
			if m.CloudletLocation.Timestamp.Nanos != src.CloudletLocation.Timestamp.Nanos {
				m.CloudletLocation.Timestamp.Nanos = src.CloudletLocation.Timestamp.Nanos
				changed++
			}
		} else if m.CloudletLocation.Timestamp != nil {
			m.CloudletLocation.Timestamp = nil
			changed++
		}
	} else if m.CloudletLocation != nil {
		m.CloudletLocation = nil
		changed++
	}
	if m.EdgeEventsCookie != src.EdgeEventsCookie {
		m.EdgeEventsCookie = src.EdgeEventsCookie
		changed++
	}
	if m.QosResult != src.QosResult {
		m.QosResult = src.QosResult
		changed++
	}
	if m.QosErrorMsg != src.QosErrorMsg {
		m.QosErrorMsg = src.QosErrorMsg
		changed++
	}
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k0, _ := range src.Tags {
			m.Tags[k0] = src.Tags[k0]
			changed++
		}
	} else if m.Tags != nil {
		m.Tags = nil
		changed++
	}
	return changed
}

func (m *FindCloudletReply) DeepCopyIn(src *FindCloudletReply) {
	m.Ver = src.Ver
	m.Status = src.Status
	m.Fqdn = src.Fqdn
	if src.Ports != nil {
		m.Ports = make([]*AppPort, len(src.Ports), len(src.Ports))
		for ii, s := range src.Ports {
			var tmp_s AppPort
			tmp_s.DeepCopyIn(s)
			m.Ports[ii] = &tmp_s
		}
	} else {
		m.Ports = nil
	}
	if src.CloudletLocation != nil {
		var tmp_CloudletLocation Loc
		tmp_CloudletLocation.DeepCopyIn(src.CloudletLocation)
		m.CloudletLocation = &tmp_CloudletLocation
	} else {
		m.CloudletLocation = nil
	}
	m.EdgeEventsCookie = src.EdgeEventsCookie
	m.QosResult = src.QosResult
	m.QosErrorMsg = src.QosErrorMsg
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k, v := range src.Tags {
			m.Tags[k] = v
		}
	} else {
		m.Tags = nil
	}
}

// Helper method to check that enums have valid values
func (m *FindCloudletReply) ValidateEnums() error {
	if _, ok := FindCloudletReply_FindStatus_name[int32(m.Status)]; !ok {
		return errors.New("invalid Status")
	}
	for _, e := range m.Ports {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	if m.CloudletLocation != nil {
		if err := m.CloudletLocation.ValidateEnums(); err != nil {
			return err
		}
	}
	if _, ok := FindCloudletReply_QosSessionResult_name[int32(m.QosResult)]; !ok {
		return errors.New("invalid QosResult")
	}
	return nil
}

func (s *FindCloudletReply) ClearTagged(tags map[string]struct{}) {
	if s.Ports != nil {
		for ii := 0; ii < len(s.Ports); ii++ {
			s.Ports[ii].ClearTagged(tags)
		}
	}
	if s.CloudletLocation != nil {
		s.CloudletLocation.ClearTagged(tags)
	}
}

func (m *AppInstListRequest) CopyInFields(src *AppInstListRequest) int {
	changed := 0
	if m.Ver != src.Ver {
		m.Ver = src.Ver
		changed++
	}
	if m.SessionCookie != src.SessionCookie {
		m.SessionCookie = src.SessionCookie
		changed++
	}
	if m.CarrierName != src.CarrierName {
		m.CarrierName = src.CarrierName
		changed++
	}
	if src.GpsLocation != nil {
		if m.GpsLocation == nil {
			m.GpsLocation = &Loc{}
		}
		if m.GpsLocation.Latitude != src.GpsLocation.Latitude {
			m.GpsLocation.Latitude = src.GpsLocation.Latitude
			changed++
		}
		if m.GpsLocation.Longitude != src.GpsLocation.Longitude {
			m.GpsLocation.Longitude = src.GpsLocation.Longitude
			changed++
		}
		if m.GpsLocation.HorizontalAccuracy != src.GpsLocation.HorizontalAccuracy {
			m.GpsLocation.HorizontalAccuracy = src.GpsLocation.HorizontalAccuracy
			changed++
		}
		if m.GpsLocation.VerticalAccuracy != src.GpsLocation.VerticalAccuracy {
			m.GpsLocation.VerticalAccuracy = src.GpsLocation.VerticalAccuracy
			changed++
		}
		if m.GpsLocation.Altitude != src.GpsLocation.Altitude {
			m.GpsLocation.Altitude = src.GpsLocation.Altitude
			changed++
		}
		if m.GpsLocation.Course != src.GpsLocation.Course {
			m.GpsLocation.Course = src.GpsLocation.Course
			changed++
		}
		if m.GpsLocation.Speed != src.GpsLocation.Speed {
			m.GpsLocation.Speed = src.GpsLocation.Speed
			changed++
		}
		if src.GpsLocation.Timestamp != nil {
			if m.GpsLocation.Timestamp == nil {
				m.GpsLocation.Timestamp = &Timestamp{}
			}
			if m.GpsLocation.Timestamp.Seconds != src.GpsLocation.Timestamp.Seconds {
				m.GpsLocation.Timestamp.Seconds = src.GpsLocation.Timestamp.Seconds
				changed++
			}
			if m.GpsLocation.Timestamp.Nanos != src.GpsLocation.Timestamp.Nanos {
				m.GpsLocation.Timestamp.Nanos = src.GpsLocation.Timestamp.Nanos
				changed++
			}
		} else if m.GpsLocation.Timestamp != nil {
			m.GpsLocation.Timestamp = nil
			changed++
		}
	} else if m.GpsLocation != nil {
		m.GpsLocation = nil
		changed++
	}
	if m.Limit != src.Limit {
		m.Limit = src.Limit
		changed++
	}
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k0, _ := range src.Tags {
			m.Tags[k0] = src.Tags[k0]
			changed++
		}
	} else if m.Tags != nil {
		m.Tags = nil
		changed++
	}
	return changed
}

func (m *AppInstListRequest) DeepCopyIn(src *AppInstListRequest) {
	m.Ver = src.Ver
	m.SessionCookie = src.SessionCookie
	m.CarrierName = src.CarrierName
	if src.GpsLocation != nil {
		var tmp_GpsLocation Loc
		tmp_GpsLocation.DeepCopyIn(src.GpsLocation)
		m.GpsLocation = &tmp_GpsLocation
	} else {
		m.GpsLocation = nil
	}
	m.Limit = src.Limit
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k, v := range src.Tags {
			m.Tags[k] = v
		}
	} else {
		m.Tags = nil
	}
}

// Helper method to check that enums have valid values
func (m *AppInstListRequest) ValidateEnums() error {
	if m.GpsLocation != nil {
		if err := m.GpsLocation.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (s *AppInstListRequest) ClearTagged(tags map[string]struct{}) {
	if s.GpsLocation != nil {
		s.GpsLocation.ClearTagged(tags)
	}
}

func (m *Appinstance) CopyInFields(src *Appinstance) int {
	changed := 0
	if m.AppName != src.AppName {
		m.AppName = src.AppName
		changed++
	}
	if m.AppVers != src.AppVers {
		m.AppVers = src.AppVers
		changed++
	}
	if m.Fqdn != src.Fqdn {
		m.Fqdn = src.Fqdn
		changed++
	}
	if src.Ports != nil {
		m.Ports = src.Ports
		changed++
	} else if m.Ports != nil {
		m.Ports = nil
		changed++
	}
	if m.OrgName != src.OrgName {
		m.OrgName = src.OrgName
		changed++
	}
	if m.EdgeEventsCookie != src.EdgeEventsCookie {
		m.EdgeEventsCookie = src.EdgeEventsCookie
		changed++
	}
	return changed
}

func (m *Appinstance) DeepCopyIn(src *Appinstance) {
	m.AppName = src.AppName
	m.AppVers = src.AppVers
	m.Fqdn = src.Fqdn
	if src.Ports != nil {
		m.Ports = make([]*AppPort, len(src.Ports), len(src.Ports))
		for ii, s := range src.Ports {
			var tmp_s AppPort
			tmp_s.DeepCopyIn(s)
			m.Ports[ii] = &tmp_s
		}
	} else {
		m.Ports = nil
	}
	m.OrgName = src.OrgName
	m.EdgeEventsCookie = src.EdgeEventsCookie
}

// Helper method to check that enums have valid values
func (m *Appinstance) ValidateEnums() error {
	for _, e := range m.Ports {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (s *Appinstance) ClearTagged(tags map[string]struct{}) {
	if s.Ports != nil {
		for ii := 0; ii < len(s.Ports); ii++ {
			s.Ports[ii].ClearTagged(tags)
		}
	}
}

func (m *CloudletLocation) CopyInFields(src *CloudletLocation) int {
	changed := 0
	if m.CarrierName != src.CarrierName {
		m.CarrierName = src.CarrierName
		changed++
	}
	if m.CloudletName != src.CloudletName {
		m.CloudletName = src.CloudletName
		changed++
	}
	if src.GpsLocation != nil {
		if m.GpsLocation == nil {
			m.GpsLocation = &Loc{}
		}
		if m.GpsLocation.Latitude != src.GpsLocation.Latitude {
			m.GpsLocation.Latitude = src.GpsLocation.Latitude
			changed++
		}
		if m.GpsLocation.Longitude != src.GpsLocation.Longitude {
			m.GpsLocation.Longitude = src.GpsLocation.Longitude
			changed++
		}
		if m.GpsLocation.HorizontalAccuracy != src.GpsLocation.HorizontalAccuracy {
			m.GpsLocation.HorizontalAccuracy = src.GpsLocation.HorizontalAccuracy
			changed++
		}
		if m.GpsLocation.VerticalAccuracy != src.GpsLocation.VerticalAccuracy {
			m.GpsLocation.VerticalAccuracy = src.GpsLocation.VerticalAccuracy
			changed++
		}
		if m.GpsLocation.Altitude != src.GpsLocation.Altitude {
			m.GpsLocation.Altitude = src.GpsLocation.Altitude
			changed++
		}
		if m.GpsLocation.Course != src.GpsLocation.Course {
			m.GpsLocation.Course = src.GpsLocation.Course
			changed++
		}
		if m.GpsLocation.Speed != src.GpsLocation.Speed {
			m.GpsLocation.Speed = src.GpsLocation.Speed
			changed++
		}
		if src.GpsLocation.Timestamp != nil {
			if m.GpsLocation.Timestamp == nil {
				m.GpsLocation.Timestamp = &Timestamp{}
			}
			if m.GpsLocation.Timestamp.Seconds != src.GpsLocation.Timestamp.Seconds {
				m.GpsLocation.Timestamp.Seconds = src.GpsLocation.Timestamp.Seconds
				changed++
			}
			if m.GpsLocation.Timestamp.Nanos != src.GpsLocation.Timestamp.Nanos {
				m.GpsLocation.Timestamp.Nanos = src.GpsLocation.Timestamp.Nanos
				changed++
			}
		} else if m.GpsLocation.Timestamp != nil {
			m.GpsLocation.Timestamp = nil
			changed++
		}
	} else if m.GpsLocation != nil {
		m.GpsLocation = nil
		changed++
	}
	if m.Distance != src.Distance {
		m.Distance = src.Distance
		changed++
	}
	if src.Appinstances != nil {
		m.Appinstances = src.Appinstances
		changed++
	} else if m.Appinstances != nil {
		m.Appinstances = nil
		changed++
	}
	return changed
}

func (m *CloudletLocation) DeepCopyIn(src *CloudletLocation) {
	m.CarrierName = src.CarrierName
	m.CloudletName = src.CloudletName
	if src.GpsLocation != nil {
		var tmp_GpsLocation Loc
		tmp_GpsLocation.DeepCopyIn(src.GpsLocation)
		m.GpsLocation = &tmp_GpsLocation
	} else {
		m.GpsLocation = nil
	}
	m.Distance = src.Distance
	if src.Appinstances != nil {
		m.Appinstances = make([]*Appinstance, len(src.Appinstances), len(src.Appinstances))
		for ii, s := range src.Appinstances {
			var tmp_s Appinstance
			tmp_s.DeepCopyIn(s)
			m.Appinstances[ii] = &tmp_s
		}
	} else {
		m.Appinstances = nil
	}
}

// Helper method to check that enums have valid values
func (m *CloudletLocation) ValidateEnums() error {
	if m.GpsLocation != nil {
		if err := m.GpsLocation.ValidateEnums(); err != nil {
			return err
		}
	}
	for _, e := range m.Appinstances {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (s *CloudletLocation) ClearTagged(tags map[string]struct{}) {
	if s.GpsLocation != nil {
		s.GpsLocation.ClearTagged(tags)
	}
	if s.Appinstances != nil {
		for ii := 0; ii < len(s.Appinstances); ii++ {
			s.Appinstances[ii].ClearTagged(tags)
		}
	}
}

func (m *AppInstListReply) CopyInFields(src *AppInstListReply) int {
	changed := 0
	if m.Ver != src.Ver {
		m.Ver = src.Ver
		changed++
	}
	if m.Status != src.Status {
		m.Status = src.Status
		changed++
	}
	if src.Cloudlets != nil {
		m.Cloudlets = src.Cloudlets
		changed++
	} else if m.Cloudlets != nil {
		m.Cloudlets = nil
		changed++
	}
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k0, _ := range src.Tags {
			m.Tags[k0] = src.Tags[k0]
			changed++
		}
	} else if m.Tags != nil {
		m.Tags = nil
		changed++
	}
	return changed
}

func (m *AppInstListReply) DeepCopyIn(src *AppInstListReply) {
	m.Ver = src.Ver
	m.Status = src.Status
	if src.Cloudlets != nil {
		m.Cloudlets = make([]*CloudletLocation, len(src.Cloudlets), len(src.Cloudlets))
		for ii, s := range src.Cloudlets {
			var tmp_s CloudletLocation
			tmp_s.DeepCopyIn(s)
			m.Cloudlets[ii] = &tmp_s
		}
	} else {
		m.Cloudlets = nil
	}
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k, v := range src.Tags {
			m.Tags[k] = v
		}
	} else {
		m.Tags = nil
	}
}

// Helper method to check that enums have valid values
func (m *AppInstListReply) ValidateEnums() error {
	if _, ok := AppInstListReply_AIStatus_name[int32(m.Status)]; !ok {
		return errors.New("invalid Status")
	}
	for _, e := range m.Cloudlets {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (s *AppInstListReply) ClearTagged(tags map[string]struct{}) {
	if s.Cloudlets != nil {
		for ii := 0; ii < len(s.Cloudlets); ii++ {
			s.Cloudlets[ii].ClearTagged(tags)
		}
	}
}

func (m *AppOfficialFqdnRequest) CopyInFields(src *AppOfficialFqdnRequest) int {
	changed := 0
	if m.Ver != src.Ver {
		m.Ver = src.Ver
		changed++
	}
	if m.SessionCookie != src.SessionCookie {
		m.SessionCookie = src.SessionCookie
		changed++
	}
	if src.GpsLocation != nil {
		if m.GpsLocation == nil {
			m.GpsLocation = &Loc{}
		}
		if m.GpsLocation.Latitude != src.GpsLocation.Latitude {
			m.GpsLocation.Latitude = src.GpsLocation.Latitude
			changed++
		}
		if m.GpsLocation.Longitude != src.GpsLocation.Longitude {
			m.GpsLocation.Longitude = src.GpsLocation.Longitude
			changed++
		}
		if m.GpsLocation.HorizontalAccuracy != src.GpsLocation.HorizontalAccuracy {
			m.GpsLocation.HorizontalAccuracy = src.GpsLocation.HorizontalAccuracy
			changed++
		}
		if m.GpsLocation.VerticalAccuracy != src.GpsLocation.VerticalAccuracy {
			m.GpsLocation.VerticalAccuracy = src.GpsLocation.VerticalAccuracy
			changed++
		}
		if m.GpsLocation.Altitude != src.GpsLocation.Altitude {
			m.GpsLocation.Altitude = src.GpsLocation.Altitude
			changed++
		}
		if m.GpsLocation.Course != src.GpsLocation.Course {
			m.GpsLocation.Course = src.GpsLocation.Course
			changed++
		}
		if m.GpsLocation.Speed != src.GpsLocation.Speed {
			m.GpsLocation.Speed = src.GpsLocation.Speed
			changed++
		}
		if src.GpsLocation.Timestamp != nil {
			if m.GpsLocation.Timestamp == nil {
				m.GpsLocation.Timestamp = &Timestamp{}
			}
			if m.GpsLocation.Timestamp.Seconds != src.GpsLocation.Timestamp.Seconds {
				m.GpsLocation.Timestamp.Seconds = src.GpsLocation.Timestamp.Seconds
				changed++
			}
			if m.GpsLocation.Timestamp.Nanos != src.GpsLocation.Timestamp.Nanos {
				m.GpsLocation.Timestamp.Nanos = src.GpsLocation.Timestamp.Nanos
				changed++
			}
		} else if m.GpsLocation.Timestamp != nil {
			m.GpsLocation.Timestamp = nil
			changed++
		}
	} else if m.GpsLocation != nil {
		m.GpsLocation = nil
		changed++
	}
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k0, _ := range src.Tags {
			m.Tags[k0] = src.Tags[k0]
			changed++
		}
	} else if m.Tags != nil {
		m.Tags = nil
		changed++
	}
	return changed
}

func (m *AppOfficialFqdnRequest) DeepCopyIn(src *AppOfficialFqdnRequest) {
	m.Ver = src.Ver
	m.SessionCookie = src.SessionCookie
	if src.GpsLocation != nil {
		var tmp_GpsLocation Loc
		tmp_GpsLocation.DeepCopyIn(src.GpsLocation)
		m.GpsLocation = &tmp_GpsLocation
	} else {
		m.GpsLocation = nil
	}
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k, v := range src.Tags {
			m.Tags[k] = v
		}
	} else {
		m.Tags = nil
	}
}

// Helper method to check that enums have valid values
func (m *AppOfficialFqdnRequest) ValidateEnums() error {
	if m.GpsLocation != nil {
		if err := m.GpsLocation.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (s *AppOfficialFqdnRequest) ClearTagged(tags map[string]struct{}) {
	if s.GpsLocation != nil {
		s.GpsLocation.ClearTagged(tags)
	}
}

func (m *AppOfficialFqdnReply) CopyInFields(src *AppOfficialFqdnReply) int {
	changed := 0
	if m.Ver != src.Ver {
		m.Ver = src.Ver
		changed++
	}
	if m.AppOfficialFqdn != src.AppOfficialFqdn {
		m.AppOfficialFqdn = src.AppOfficialFqdn
		changed++
	}
	if m.ClientToken != src.ClientToken {
		m.ClientToken = src.ClientToken
		changed++
	}
	if m.Status != src.Status {
		m.Status = src.Status
		changed++
	}
	if src.Ports != nil {
		m.Ports = src.Ports
		changed++
	} else if m.Ports != nil {
		m.Ports = nil
		changed++
	}
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k0, _ := range src.Tags {
			m.Tags[k0] = src.Tags[k0]
			changed++
		}
	} else if m.Tags != nil {
		m.Tags = nil
		changed++
	}
	return changed
}

func (m *AppOfficialFqdnReply) DeepCopyIn(src *AppOfficialFqdnReply) {
	m.Ver = src.Ver
	m.AppOfficialFqdn = src.AppOfficialFqdn
	m.ClientToken = src.ClientToken
	m.Status = src.Status
	if src.Ports != nil {
		m.Ports = make([]*AppPort, len(src.Ports), len(src.Ports))
		for ii, s := range src.Ports {
			var tmp_s AppPort
			tmp_s.DeepCopyIn(s)
			m.Ports[ii] = &tmp_s
		}
	} else {
		m.Ports = nil
	}
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k, v := range src.Tags {
			m.Tags[k] = v
		}
	} else {
		m.Tags = nil
	}
}

// Helper method to check that enums have valid values
func (m *AppOfficialFqdnReply) ValidateEnums() error {
	if _, ok := AppOfficialFqdnReply_AOFStatus_name[int32(m.Status)]; !ok {
		return errors.New("invalid Status")
	}
	for _, e := range m.Ports {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (s *AppOfficialFqdnReply) ClearTagged(tags map[string]struct{}) {
	if s.Ports != nil {
		for ii := 0; ii < len(s.Ports); ii++ {
			s.Ports[ii].ClearTagged(tags)
		}
	}
}

func (m *ClientEdgeEvent) CopyInFields(src *ClientEdgeEvent) int {
	changed := 0
	if m.SessionCookie != src.SessionCookie {
		m.SessionCookie = src.SessionCookie
		changed++
	}
	if m.EdgeEventsCookie != src.EdgeEventsCookie {
		m.EdgeEventsCookie = src.EdgeEventsCookie
		changed++
	}
	if m.EventType != src.EventType {
		m.EventType = src.EventType
		changed++
	}
	if src.GpsLocation != nil {
		if m.GpsLocation == nil {
			m.GpsLocation = &Loc{}
		}
		if m.GpsLocation.Latitude != src.GpsLocation.Latitude {
			m.GpsLocation.Latitude = src.GpsLocation.Latitude
			changed++
		}
		if m.GpsLocation.Longitude != src.GpsLocation.Longitude {
			m.GpsLocation.Longitude = src.GpsLocation.Longitude
			changed++
		}
		if m.GpsLocation.HorizontalAccuracy != src.GpsLocation.HorizontalAccuracy {
			m.GpsLocation.HorizontalAccuracy = src.GpsLocation.HorizontalAccuracy
			changed++
		}
		if m.GpsLocation.VerticalAccuracy != src.GpsLocation.VerticalAccuracy {
			m.GpsLocation.VerticalAccuracy = src.GpsLocation.VerticalAccuracy
			changed++
		}
		if m.GpsLocation.Altitude != src.GpsLocation.Altitude {
			m.GpsLocation.Altitude = src.GpsLocation.Altitude
			changed++
		}
		if m.GpsLocation.Course != src.GpsLocation.Course {
			m.GpsLocation.Course = src.GpsLocation.Course
			changed++
		}
		if m.GpsLocation.Speed != src.GpsLocation.Speed {
			m.GpsLocation.Speed = src.GpsLocation.Speed
			changed++
		}
		if src.GpsLocation.Timestamp != nil {
			if m.GpsLocation.Timestamp == nil {
				m.GpsLocation.Timestamp = &Timestamp{}
			}
			if m.GpsLocation.Timestamp.Seconds != src.GpsLocation.Timestamp.Seconds {
				m.GpsLocation.Timestamp.Seconds = src.GpsLocation.Timestamp.Seconds
				changed++
			}
			if m.GpsLocation.Timestamp.Nanos != src.GpsLocation.Timestamp.Nanos {
				m.GpsLocation.Timestamp.Nanos = src.GpsLocation.Timestamp.Nanos
				changed++
			}
		} else if m.GpsLocation.Timestamp != nil {
			m.GpsLocation.Timestamp = nil
			changed++
		}
	} else if m.GpsLocation != nil {
		m.GpsLocation = nil
		changed++
	}
	if src.Samples != nil {
		m.Samples = src.Samples
		changed++
	} else if m.Samples != nil {
		m.Samples = nil
		changed++
	}
	if src.DeviceInfoStatic != nil {
		if m.DeviceInfoStatic == nil {
			m.DeviceInfoStatic = &DeviceInfoStatic{}
		}
		if m.DeviceInfoStatic.DeviceOs != src.DeviceInfoStatic.DeviceOs {
			m.DeviceInfoStatic.DeviceOs = src.DeviceInfoStatic.DeviceOs
			changed++
		}
		if m.DeviceInfoStatic.DeviceModel != src.DeviceInfoStatic.DeviceModel {
			m.DeviceInfoStatic.DeviceModel = src.DeviceInfoStatic.DeviceModel
			changed++
		}
	} else if m.DeviceInfoStatic != nil {
		m.DeviceInfoStatic = nil
		changed++
	}
	if src.DeviceInfoDynamic != nil {
		if m.DeviceInfoDynamic == nil {
			m.DeviceInfoDynamic = &DeviceInfoDynamic{}
		}
		if m.DeviceInfoDynamic.DataNetworkType != src.DeviceInfoDynamic.DataNetworkType {
			m.DeviceInfoDynamic.DataNetworkType = src.DeviceInfoDynamic.DataNetworkType
			changed++
		}
		if m.DeviceInfoDynamic.SignalStrength != src.DeviceInfoDynamic.SignalStrength {
			m.DeviceInfoDynamic.SignalStrength = src.DeviceInfoDynamic.SignalStrength
			changed++
		}
		if m.DeviceInfoDynamic.CarrierName != src.DeviceInfoDynamic.CarrierName {
			m.DeviceInfoDynamic.CarrierName = src.DeviceInfoDynamic.CarrierName
			changed++
		}
	} else if m.DeviceInfoDynamic != nil {
		m.DeviceInfoDynamic = nil
		changed++
	}
	if m.CustomEvent != src.CustomEvent {
		m.CustomEvent = src.CustomEvent
		changed++
	}
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k0, _ := range src.Tags {
			m.Tags[k0] = src.Tags[k0]
			changed++
		}
	} else if m.Tags != nil {
		m.Tags = nil
		changed++
	}
	return changed
}

func (m *ClientEdgeEvent) DeepCopyIn(src *ClientEdgeEvent) {
	m.SessionCookie = src.SessionCookie
	m.EdgeEventsCookie = src.EdgeEventsCookie
	m.EventType = src.EventType
	if src.GpsLocation != nil {
		var tmp_GpsLocation Loc
		tmp_GpsLocation.DeepCopyIn(src.GpsLocation)
		m.GpsLocation = &tmp_GpsLocation
	} else {
		m.GpsLocation = nil
	}
	if src.Samples != nil {
		m.Samples = make([]*Sample, len(src.Samples), len(src.Samples))
		for ii, s := range src.Samples {
			var tmp_s Sample
			tmp_s.DeepCopyIn(s)
			m.Samples[ii] = &tmp_s
		}
	} else {
		m.Samples = nil
	}
	if src.DeviceInfoStatic != nil {
		var tmp_DeviceInfoStatic DeviceInfoStatic
		tmp_DeviceInfoStatic.DeepCopyIn(src.DeviceInfoStatic)
		m.DeviceInfoStatic = &tmp_DeviceInfoStatic
	} else {
		m.DeviceInfoStatic = nil
	}
	if src.DeviceInfoDynamic != nil {
		var tmp_DeviceInfoDynamic DeviceInfoDynamic
		tmp_DeviceInfoDynamic.DeepCopyIn(src.DeviceInfoDynamic)
		m.DeviceInfoDynamic = &tmp_DeviceInfoDynamic
	} else {
		m.DeviceInfoDynamic = nil
	}
	m.CustomEvent = src.CustomEvent
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k, v := range src.Tags {
			m.Tags[k] = v
		}
	} else {
		m.Tags = nil
	}
}

// Helper method to check that enums have valid values
func (m *ClientEdgeEvent) ValidateEnums() error {
	if _, ok := ClientEdgeEvent_ClientEventType_name[int32(m.EventType)]; !ok {
		return errors.New("invalid EventType")
	}
	if m.GpsLocation != nil {
		if err := m.GpsLocation.ValidateEnums(); err != nil {
			return err
		}
	}
	for _, e := range m.Samples {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	if m.DeviceInfoStatic != nil {
		if err := m.DeviceInfoStatic.ValidateEnums(); err != nil {
			return err
		}
	}
	if m.DeviceInfoDynamic != nil {
		if err := m.DeviceInfoDynamic.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (s *ClientEdgeEvent) ClearTagged(tags map[string]struct{}) {
	if s.GpsLocation != nil {
		s.GpsLocation.ClearTagged(tags)
	}
	if s.Samples != nil {
		for ii := 0; ii < len(s.Samples); ii++ {
			s.Samples[ii].ClearTagged(tags)
		}
	}
	if s.DeviceInfoStatic != nil {
		s.DeviceInfoStatic.ClearTagged(tags)
	}
	if s.DeviceInfoDynamic != nil {
		s.DeviceInfoDynamic.ClearTagged(tags)
	}
}

func (m *ServerEdgeEvent) CopyInFields(src *ServerEdgeEvent) int {
	changed := 0
	if m.EventType != src.EventType {
		m.EventType = src.EventType
		changed++
	}
	if m.CloudletState != src.CloudletState {
		m.CloudletState = src.CloudletState
		changed++
	}
	if m.MaintenanceState != src.MaintenanceState {
		m.MaintenanceState = src.MaintenanceState
		changed++
	}
	if m.HealthCheck != src.HealthCheck {
		m.HealthCheck = src.HealthCheck
		changed++
	}
	if src.Statistics != nil {
		if m.Statistics == nil {
			m.Statistics = &Statistics{}
		}
		if m.Statistics.Avg != src.Statistics.Avg {
			m.Statistics.Avg = src.Statistics.Avg
			changed++
		}
		if m.Statistics.Min != src.Statistics.Min {
			m.Statistics.Min = src.Statistics.Min
			changed++
		}
		if m.Statistics.Max != src.Statistics.Max {
			m.Statistics.Max = src.Statistics.Max
			changed++
		}
		if m.Statistics.StdDev != src.Statistics.StdDev {
			m.Statistics.StdDev = src.Statistics.StdDev
			changed++
		}
		if m.Statistics.Variance != src.Statistics.Variance {
			m.Statistics.Variance = src.Statistics.Variance
			changed++
		}
		if m.Statistics.NumSamples != src.Statistics.NumSamples {
			m.Statistics.NumSamples = src.Statistics.NumSamples
			changed++
		}
		if src.Statistics.Timestamp != nil {
			if m.Statistics.Timestamp == nil {
				m.Statistics.Timestamp = &Timestamp{}
			}
			if m.Statistics.Timestamp.Seconds != src.Statistics.Timestamp.Seconds {
				m.Statistics.Timestamp.Seconds = src.Statistics.Timestamp.Seconds
				changed++
			}
			if m.Statistics.Timestamp.Nanos != src.Statistics.Timestamp.Nanos {
				m.Statistics.Timestamp.Nanos = src.Statistics.Timestamp.Nanos
				changed++
			}
		} else if m.Statistics.Timestamp != nil {
			m.Statistics.Timestamp = nil
			changed++
		}
	} else if m.Statistics != nil {
		m.Statistics = nil
		changed++
	}
	if src.NewCloudlet != nil {
		if m.NewCloudlet == nil {
			m.NewCloudlet = &FindCloudletReply{}
		}
		if m.NewCloudlet.Ver != src.NewCloudlet.Ver {
			m.NewCloudlet.Ver = src.NewCloudlet.Ver
			changed++
		}
		if m.NewCloudlet.Status != src.NewCloudlet.Status {
			m.NewCloudlet.Status = src.NewCloudlet.Status
			changed++
		}
		if m.NewCloudlet.Fqdn != src.NewCloudlet.Fqdn {
			m.NewCloudlet.Fqdn = src.NewCloudlet.Fqdn
			changed++
		}
		if src.NewCloudlet.Ports != nil {
			m.NewCloudlet.Ports = src.NewCloudlet.Ports
			changed++
		} else if m.NewCloudlet.Ports != nil {
			m.NewCloudlet.Ports = nil
			changed++
		}
		if src.NewCloudlet.CloudletLocation != nil {
			if m.NewCloudlet.CloudletLocation == nil {
				m.NewCloudlet.CloudletLocation = &Loc{}
			}
			if m.NewCloudlet.CloudletLocation.Latitude != src.NewCloudlet.CloudletLocation.Latitude {
				m.NewCloudlet.CloudletLocation.Latitude = src.NewCloudlet.CloudletLocation.Latitude
				changed++
			}
			if m.NewCloudlet.CloudletLocation.Longitude != src.NewCloudlet.CloudletLocation.Longitude {
				m.NewCloudlet.CloudletLocation.Longitude = src.NewCloudlet.CloudletLocation.Longitude
				changed++
			}
			if m.NewCloudlet.CloudletLocation.HorizontalAccuracy != src.NewCloudlet.CloudletLocation.HorizontalAccuracy {
				m.NewCloudlet.CloudletLocation.HorizontalAccuracy = src.NewCloudlet.CloudletLocation.HorizontalAccuracy
				changed++
			}
			if m.NewCloudlet.CloudletLocation.VerticalAccuracy != src.NewCloudlet.CloudletLocation.VerticalAccuracy {
				m.NewCloudlet.CloudletLocation.VerticalAccuracy = src.NewCloudlet.CloudletLocation.VerticalAccuracy
				changed++
			}
			if m.NewCloudlet.CloudletLocation.Altitude != src.NewCloudlet.CloudletLocation.Altitude {
				m.NewCloudlet.CloudletLocation.Altitude = src.NewCloudlet.CloudletLocation.Altitude
				changed++
			}
			if m.NewCloudlet.CloudletLocation.Course != src.NewCloudlet.CloudletLocation.Course {
				m.NewCloudlet.CloudletLocation.Course = src.NewCloudlet.CloudletLocation.Course
				changed++
			}
			if m.NewCloudlet.CloudletLocation.Speed != src.NewCloudlet.CloudletLocation.Speed {
				m.NewCloudlet.CloudletLocation.Speed = src.NewCloudlet.CloudletLocation.Speed
				changed++
			}
			if src.NewCloudlet.CloudletLocation.Timestamp != nil {
				if m.NewCloudlet.CloudletLocation.Timestamp == nil {
					m.NewCloudlet.CloudletLocation.Timestamp = &Timestamp{}
				}
				if m.NewCloudlet.CloudletLocation.Timestamp.Seconds != src.NewCloudlet.CloudletLocation.Timestamp.Seconds {
					m.NewCloudlet.CloudletLocation.Timestamp.Seconds = src.NewCloudlet.CloudletLocation.Timestamp.Seconds
					changed++
				}
				if m.NewCloudlet.CloudletLocation.Timestamp.Nanos != src.NewCloudlet.CloudletLocation.Timestamp.Nanos {
					m.NewCloudlet.CloudletLocation.Timestamp.Nanos = src.NewCloudlet.CloudletLocation.Timestamp.Nanos
					changed++
				}
			} else if m.NewCloudlet.CloudletLocation.Timestamp != nil {
				m.NewCloudlet.CloudletLocation.Timestamp = nil
				changed++
			}
		} else if m.NewCloudlet.CloudletLocation != nil {
			m.NewCloudlet.CloudletLocation = nil
			changed++
		}
		if m.NewCloudlet.EdgeEventsCookie != src.NewCloudlet.EdgeEventsCookie {
			m.NewCloudlet.EdgeEventsCookie = src.NewCloudlet.EdgeEventsCookie
			changed++
		}
		if m.NewCloudlet.QosResult != src.NewCloudlet.QosResult {
			m.NewCloudlet.QosResult = src.NewCloudlet.QosResult
			changed++
		}
		if m.NewCloudlet.QosErrorMsg != src.NewCloudlet.QosErrorMsg {
			m.NewCloudlet.QosErrorMsg = src.NewCloudlet.QosErrorMsg
			changed++
		}
		if src.NewCloudlet.Tags != nil {
			m.NewCloudlet.Tags = make(map[string]string)
			for k1, _ := range src.NewCloudlet.Tags {
				m.NewCloudlet.Tags[k1] = src.NewCloudlet.Tags[k1]
				changed++
			}
		} else if m.NewCloudlet.Tags != nil {
			m.NewCloudlet.Tags = nil
			changed++
		}
	} else if m.NewCloudlet != nil {
		m.NewCloudlet = nil
		changed++
	}
	if m.ErrorMsg != src.ErrorMsg {
		m.ErrorMsg = src.ErrorMsg
		changed++
	}
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k0, _ := range src.Tags {
			m.Tags[k0] = src.Tags[k0]
			changed++
		}
	} else if m.Tags != nil {
		m.Tags = nil
		changed++
	}
	return changed
}

func (m *ServerEdgeEvent) DeepCopyIn(src *ServerEdgeEvent) {
	m.EventType = src.EventType
	m.CloudletState = src.CloudletState
	m.MaintenanceState = src.MaintenanceState
	m.HealthCheck = src.HealthCheck
	if src.Statistics != nil {
		var tmp_Statistics Statistics
		tmp_Statistics.DeepCopyIn(src.Statistics)
		m.Statistics = &tmp_Statistics
	} else {
		m.Statistics = nil
	}
	if src.NewCloudlet != nil {
		var tmp_NewCloudlet FindCloudletReply
		tmp_NewCloudlet.DeepCopyIn(src.NewCloudlet)
		m.NewCloudlet = &tmp_NewCloudlet
	} else {
		m.NewCloudlet = nil
	}
	m.ErrorMsg = src.ErrorMsg
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k, v := range src.Tags {
			m.Tags[k] = v
		}
	} else {
		m.Tags = nil
	}
}

// Helper method to check that enums have valid values
func (m *ServerEdgeEvent) ValidateEnums() error {
	if _, ok := ServerEdgeEvent_ServerEventType_name[int32(m.EventType)]; !ok {
		return errors.New("invalid EventType")
	}
	if _, ok := CloudletState_name[int32(m.CloudletState)]; !ok {
		return errors.New("invalid CloudletState")
	}
	if _, ok := MaintenanceState_name[int32(m.MaintenanceState)]; !ok {
		return errors.New("invalid MaintenanceState")
	}
	if _, ok := HealthCheck_name[int32(m.HealthCheck)]; !ok {
		return errors.New("invalid HealthCheck")
	}
	if m.Statistics != nil {
		if err := m.Statistics.ValidateEnums(); err != nil {
			return err
		}
	}
	if m.NewCloudlet != nil {
		if err := m.NewCloudlet.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (s *ServerEdgeEvent) ClearTagged(tags map[string]struct{}) {
	if s.Statistics != nil {
		s.Statistics.ClearTagged(tags)
	}
	if s.NewCloudlet != nil {
		s.NewCloudlet.ClearTagged(tags)
	}
}

var IDTypesStrings = []string{
	"ID_UNDEFINED",
	"IMEI",
	"MSISDN",
	"IPADDR",
}

const (
	IDTypesID_UNDEFINED uint64 = 1 << 0
	IDTypesIMEI         uint64 = 1 << 1
	IDTypesMSISDN       uint64 = 1 << 2
	IDTypesIPADDR       uint64 = 1 << 3
)

var IDTypes_CamelName = map[int32]string{
	// ID_UNDEFINED -> IdUndefined
	0: "IdUndefined",
	// IMEI -> Imei
	1: "Imei",
	// MSISDN -> Msisdn
	2: "Msisdn",
	// IPADDR -> Ipaddr
	3: "Ipaddr",
}
var IDTypes_CamelValue = map[string]int32{
	"IdUndefined": 0,
	"Imei":        1,
	"Msisdn":      2,
	"Ipaddr":      3,
}

func ParseIDTypes(data interface{}) (IDTypes, error) {
	if val, ok := data.(IDTypes); ok {
		return val, nil
	} else if str, ok := data.(string); ok {
		val, ok := IDTypes_CamelValue[util.CamelCase(str)]
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = IDTypes_CamelName[val]
			}
		}
		if !ok {
			return IDTypes(0), fmt.Errorf("Invalid IDTypes value %q", str)
		}
		return IDTypes(val), nil
	} else if ival, ok := data.(int32); ok {
		if _, ok := IDTypes_CamelName[ival]; ok {
			return IDTypes(ival), nil
		} else {
			return IDTypes(0), fmt.Errorf("Invalid IDTypes value %d", ival)
		}
	}
	return IDTypes(0), fmt.Errorf("Invalid IDTypes value %v", data)
}

func (e *IDTypes) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, err := ParseIDTypes(str)
	if err != nil {
		return err
	}
	*e = val
	return nil
}

func (e IDTypes) MarshalYAML() (interface{}, error) {
	str := proto.EnumName(IDTypes_CamelName, int32(e))
	return str, nil
}

// custom JSON encoding/decoding
func (e *IDTypes) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, err := ParseIDTypes(str)
		if err != nil {
			return &json.UnmarshalTypeError{
				Value: "string " + str,
				Type:  reflect.TypeOf(IDTypes(0)),
			}
		}
		*e = IDTypes(val)
		return nil
	}
	var ival int32
	err = json.Unmarshal(b, &ival)
	if err == nil {
		val, err := ParseIDTypes(ival)
		if err == nil {
			*e = val
			return nil
		}
	}
	return &json.UnmarshalTypeError{
		Value: "value " + string(b),
		Type:  reflect.TypeOf(IDTypes(0)),
	}
}

func (e IDTypes) MarshalJSON() ([]byte, error) {
	str := proto.EnumName(IDTypes_CamelName, int32(e))
	return json.Marshal(str)
}

var FindStatusStrings = []string{
	"FIND_UNKNOWN",
	"FIND_FOUND",
	"FIND_NOTFOUND",
}

const (
	FindStatusFIND_UNKNOWN  uint64 = 1 << 0
	FindStatusFIND_FOUND    uint64 = 1 << 1
	FindStatusFIND_NOTFOUND uint64 = 1 << 2
)

var FindCloudletReply_FindStatus_CamelName = map[int32]string{
	// FIND_UNKNOWN -> FindUnknown
	0: "FindUnknown",
	// FIND_FOUND -> FindFound
	1: "FindFound",
	// FIND_NOTFOUND -> FindNotfound
	2: "FindNotfound",
}
var FindCloudletReply_FindStatus_CamelValue = map[string]int32{
	"FindUnknown":  0,
	"FindFound":    1,
	"FindNotfound": 2,
}

func ParseFindCloudletReply_FindStatus(data interface{}) (FindCloudletReply_FindStatus, error) {
	if val, ok := data.(FindCloudletReply_FindStatus); ok {
		return val, nil
	} else if str, ok := data.(string); ok {
		val, ok := FindCloudletReply_FindStatus_CamelValue[util.CamelCase(str)]
		if !ok {
			// may have omitted common prefix
			val, ok = FindCloudletReply_FindStatus_CamelValue["Find"+util.CamelCase(str)]
		}
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = FindCloudletReply_FindStatus_CamelName[val]
			}
		}
		if !ok {
			return FindCloudletReply_FindStatus(0), fmt.Errorf("Invalid FindCloudletReply_FindStatus value %q", str)
		}
		return FindCloudletReply_FindStatus(val), nil
	} else if ival, ok := data.(int32); ok {
		if _, ok := FindCloudletReply_FindStatus_CamelName[ival]; ok {
			return FindCloudletReply_FindStatus(ival), nil
		} else {
			return FindCloudletReply_FindStatus(0), fmt.Errorf("Invalid FindCloudletReply_FindStatus value %d", ival)
		}
	}
	return FindCloudletReply_FindStatus(0), fmt.Errorf("Invalid FindCloudletReply_FindStatus value %v", data)
}

func (e *FindCloudletReply_FindStatus) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, err := ParseFindCloudletReply_FindStatus(str)
	if err != nil {
		return err
	}
	*e = val
	return nil
}

func (e FindCloudletReply_FindStatus) MarshalYAML() (interface{}, error) {
	str := proto.EnumName(FindCloudletReply_FindStatus_CamelName, int32(e))
	str = strings.TrimPrefix(str, "Find")
	return str, nil
}

// custom JSON encoding/decoding
func (e *FindCloudletReply_FindStatus) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, err := ParseFindCloudletReply_FindStatus(str)
		if err != nil {
			return &json.UnmarshalTypeError{
				Value: "string " + str,
				Type:  reflect.TypeOf(FindCloudletReply_FindStatus(0)),
			}
		}
		*e = FindCloudletReply_FindStatus(val)
		return nil
	}
	var ival int32
	err = json.Unmarshal(b, &ival)
	if err == nil {
		val, err := ParseFindCloudletReply_FindStatus(ival)
		if err == nil {
			*e = val
			return nil
		}
	}
	return &json.UnmarshalTypeError{
		Value: "value " + string(b),
		Type:  reflect.TypeOf(FindCloudletReply_FindStatus(0)),
	}
}

func (e FindCloudletReply_FindStatus) MarshalJSON() ([]byte, error) {
	str := proto.EnumName(FindCloudletReply_FindStatus_CamelName, int32(e))
	str = strings.TrimPrefix(str, "Find")
	return json.Marshal(str)
}

var FindStatusCommonPrefix = "Find"

var QosSessionResultStrings = []string{
	"QOS_NOT_ATTEMPTED",
	"QOS_SESSION_CREATED",
	"QOS_SESSION_FAILED",
}

const (
	QosSessionResultQOS_NOT_ATTEMPTED   uint64 = 1 << 0
	QosSessionResultQOS_SESSION_CREATED uint64 = 1 << 1
	QosSessionResultQOS_SESSION_FAILED  uint64 = 1 << 2
)

var FindCloudletReply_QosSessionResult_CamelName = map[int32]string{
	// QOS_NOT_ATTEMPTED -> QosNotAttempted
	0: "QosNotAttempted",
	// QOS_SESSION_CREATED -> QosSessionCreated
	1: "QosSessionCreated",
	// QOS_SESSION_FAILED -> QosSessionFailed
	2: "QosSessionFailed",
}
var FindCloudletReply_QosSessionResult_CamelValue = map[string]int32{
	"QosNotAttempted":   0,
	"QosSessionCreated": 1,
	"QosSessionFailed":  2,
}

func ParseFindCloudletReply_QosSessionResult(data interface{}) (FindCloudletReply_QosSessionResult, error) {
	if val, ok := data.(FindCloudletReply_QosSessionResult); ok {
		return val, nil
	} else if str, ok := data.(string); ok {
		val, ok := FindCloudletReply_QosSessionResult_CamelValue[util.CamelCase(str)]
		if !ok {
			// may have omitted common prefix
			val, ok = FindCloudletReply_QosSessionResult_CamelValue["Qos"+util.CamelCase(str)]
		}
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = FindCloudletReply_QosSessionResult_CamelName[val]
			}
		}
		if !ok {
			return FindCloudletReply_QosSessionResult(0), fmt.Errorf("Invalid FindCloudletReply_QosSessionResult value %q", str)
		}
		return FindCloudletReply_QosSessionResult(val), nil
	} else if ival, ok := data.(int32); ok {
		if _, ok := FindCloudletReply_QosSessionResult_CamelName[ival]; ok {
			return FindCloudletReply_QosSessionResult(ival), nil
		} else {
			return FindCloudletReply_QosSessionResult(0), fmt.Errorf("Invalid FindCloudletReply_QosSessionResult value %d", ival)
		}
	}
	return FindCloudletReply_QosSessionResult(0), fmt.Errorf("Invalid FindCloudletReply_QosSessionResult value %v", data)
}

func (e *FindCloudletReply_QosSessionResult) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, err := ParseFindCloudletReply_QosSessionResult(str)
	if err != nil {
		return err
	}
	*e = val
	return nil
}

func (e FindCloudletReply_QosSessionResult) MarshalYAML() (interface{}, error) {
	str := proto.EnumName(FindCloudletReply_QosSessionResult_CamelName, int32(e))
	str = strings.TrimPrefix(str, "Qos")
	return str, nil
}

// custom JSON encoding/decoding
func (e *FindCloudletReply_QosSessionResult) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, err := ParseFindCloudletReply_QosSessionResult(str)
		if err != nil {
			return &json.UnmarshalTypeError{
				Value: "string " + str,
				Type:  reflect.TypeOf(FindCloudletReply_QosSessionResult(0)),
			}
		}
		*e = FindCloudletReply_QosSessionResult(val)
		return nil
	}
	var ival int32
	err = json.Unmarshal(b, &ival)
	if err == nil {
		val, err := ParseFindCloudletReply_QosSessionResult(ival)
		if err == nil {
			*e = val
			return nil
		}
	}
	return &json.UnmarshalTypeError{
		Value: "value " + string(b),
		Type:  reflect.TypeOf(FindCloudletReply_QosSessionResult(0)),
	}
}

func (e FindCloudletReply_QosSessionResult) MarshalJSON() ([]byte, error) {
	str := proto.EnumName(FindCloudletReply_QosSessionResult_CamelName, int32(e))
	str = strings.TrimPrefix(str, "Qos")
	return json.Marshal(str)
}

var QosSessionResultCommonPrefix = "Qos"

var AIStatusStrings = []string{
	"AI_UNDEFINED",
	"AI_SUCCESS",
	"AI_FAIL",
}

const (
	AIStatusAI_UNDEFINED uint64 = 1 << 0
	AIStatusAI_SUCCESS   uint64 = 1 << 1
	AIStatusAI_FAIL      uint64 = 1 << 2
)

var AppInstListReply_AIStatus_CamelName = map[int32]string{
	// AI_UNDEFINED -> AiUndefined
	0: "AiUndefined",
	// AI_SUCCESS -> AiSuccess
	1: "AiSuccess",
	// AI_FAIL -> AiFail
	2: "AiFail",
}
var AppInstListReply_AIStatus_CamelValue = map[string]int32{
	"AiUndefined": 0,
	"AiSuccess":   1,
	"AiFail":      2,
}

func ParseAppInstListReply_AIStatus(data interface{}) (AppInstListReply_AIStatus, error) {
	if val, ok := data.(AppInstListReply_AIStatus); ok {
		return val, nil
	} else if str, ok := data.(string); ok {
		val, ok := AppInstListReply_AIStatus_CamelValue[util.CamelCase(str)]
		if !ok {
			// may have omitted common prefix
			val, ok = AppInstListReply_AIStatus_CamelValue["Ai"+util.CamelCase(str)]
		}
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = AppInstListReply_AIStatus_CamelName[val]
			}
		}
		if !ok {
			return AppInstListReply_AIStatus(0), fmt.Errorf("Invalid AppInstListReply_AIStatus value %q", str)
		}
		return AppInstListReply_AIStatus(val), nil
	} else if ival, ok := data.(int32); ok {
		if _, ok := AppInstListReply_AIStatus_CamelName[ival]; ok {
			return AppInstListReply_AIStatus(ival), nil
		} else {
			return AppInstListReply_AIStatus(0), fmt.Errorf("Invalid AppInstListReply_AIStatus value %d", ival)
		}
	}
	return AppInstListReply_AIStatus(0), fmt.Errorf("Invalid AppInstListReply_AIStatus value %v", data)
}

func (e *AppInstListReply_AIStatus) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, err := ParseAppInstListReply_AIStatus(str)
	if err != nil {
		return err
	}
	*e = val
	return nil
}

func (e AppInstListReply_AIStatus) MarshalYAML() (interface{}, error) {
	str := proto.EnumName(AppInstListReply_AIStatus_CamelName, int32(e))
	str = strings.TrimPrefix(str, "Ai")
	return str, nil
}

// custom JSON encoding/decoding
func (e *AppInstListReply_AIStatus) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, err := ParseAppInstListReply_AIStatus(str)
		if err != nil {
			return &json.UnmarshalTypeError{
				Value: "string " + str,
				Type:  reflect.TypeOf(AppInstListReply_AIStatus(0)),
			}
		}
		*e = AppInstListReply_AIStatus(val)
		return nil
	}
	var ival int32
	err = json.Unmarshal(b, &ival)
	if err == nil {
		val, err := ParseAppInstListReply_AIStatus(ival)
		if err == nil {
			*e = val
			return nil
		}
	}
	return &json.UnmarshalTypeError{
		Value: "value " + string(b),
		Type:  reflect.TypeOf(AppInstListReply_AIStatus(0)),
	}
}

func (e AppInstListReply_AIStatus) MarshalJSON() ([]byte, error) {
	str := proto.EnumName(AppInstListReply_AIStatus_CamelName, int32(e))
	str = strings.TrimPrefix(str, "Ai")
	return json.Marshal(str)
}

var AIStatusCommonPrefix = "Ai"

var AOFStatusStrings = []string{
	"AOF_UNDEFINED",
	"AOF_SUCCESS",
	"AOF_FAIL",
}

const (
	AOFStatusAOF_UNDEFINED uint64 = 1 << 0
	AOFStatusAOF_SUCCESS   uint64 = 1 << 1
	AOFStatusAOF_FAIL      uint64 = 1 << 2
)

var AppOfficialFqdnReply_AOFStatus_CamelName = map[int32]string{
	// AOF_UNDEFINED -> AofUndefined
	0: "AofUndefined",
	// AOF_SUCCESS -> AofSuccess
	1: "AofSuccess",
	// AOF_FAIL -> AofFail
	2: "AofFail",
}
var AppOfficialFqdnReply_AOFStatus_CamelValue = map[string]int32{
	"AofUndefined": 0,
	"AofSuccess":   1,
	"AofFail":      2,
}

func ParseAppOfficialFqdnReply_AOFStatus(data interface{}) (AppOfficialFqdnReply_AOFStatus, error) {
	if val, ok := data.(AppOfficialFqdnReply_AOFStatus); ok {
		return val, nil
	} else if str, ok := data.(string); ok {
		val, ok := AppOfficialFqdnReply_AOFStatus_CamelValue[util.CamelCase(str)]
		if !ok {
			// may have omitted common prefix
			val, ok = AppOfficialFqdnReply_AOFStatus_CamelValue["Aof"+util.CamelCase(str)]
		}
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = AppOfficialFqdnReply_AOFStatus_CamelName[val]
			}
		}
		if !ok {
			return AppOfficialFqdnReply_AOFStatus(0), fmt.Errorf("Invalid AppOfficialFqdnReply_AOFStatus value %q", str)
		}
		return AppOfficialFqdnReply_AOFStatus(val), nil
	} else if ival, ok := data.(int32); ok {
		if _, ok := AppOfficialFqdnReply_AOFStatus_CamelName[ival]; ok {
			return AppOfficialFqdnReply_AOFStatus(ival), nil
		} else {
			return AppOfficialFqdnReply_AOFStatus(0), fmt.Errorf("Invalid AppOfficialFqdnReply_AOFStatus value %d", ival)
		}
	}
	return AppOfficialFqdnReply_AOFStatus(0), fmt.Errorf("Invalid AppOfficialFqdnReply_AOFStatus value %v", data)
}

func (e *AppOfficialFqdnReply_AOFStatus) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, err := ParseAppOfficialFqdnReply_AOFStatus(str)
	if err != nil {
		return err
	}
	*e = val
	return nil
}

func (e AppOfficialFqdnReply_AOFStatus) MarshalYAML() (interface{}, error) {
	str := proto.EnumName(AppOfficialFqdnReply_AOFStatus_CamelName, int32(e))
	str = strings.TrimPrefix(str, "Aof")
	return str, nil
}

// custom JSON encoding/decoding
func (e *AppOfficialFqdnReply_AOFStatus) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, err := ParseAppOfficialFqdnReply_AOFStatus(str)
		if err != nil {
			return &json.UnmarshalTypeError{
				Value: "string " + str,
				Type:  reflect.TypeOf(AppOfficialFqdnReply_AOFStatus(0)),
			}
		}
		*e = AppOfficialFqdnReply_AOFStatus(val)
		return nil
	}
	var ival int32
	err = json.Unmarshal(b, &ival)
	if err == nil {
		val, err := ParseAppOfficialFqdnReply_AOFStatus(ival)
		if err == nil {
			*e = val
			return nil
		}
	}
	return &json.UnmarshalTypeError{
		Value: "value " + string(b),
		Type:  reflect.TypeOf(AppOfficialFqdnReply_AOFStatus(0)),
	}
}

func (e AppOfficialFqdnReply_AOFStatus) MarshalJSON() ([]byte, error) {
	str := proto.EnumName(AppOfficialFqdnReply_AOFStatus_CamelName, int32(e))
	str = strings.TrimPrefix(str, "Aof")
	return json.Marshal(str)
}

var AOFStatusCommonPrefix = "Aof"

var ClientEventTypeStrings = []string{
	"EVENT_UNKNOWN",
	"EVENT_INIT_CONNECTION",
	"EVENT_TERMINATE_CONNECTION",
	"EVENT_LATENCY_SAMPLES",
	"EVENT_LOCATION_UPDATE",
	"EVENT_CUSTOM_EVENT",
}

const (
	ClientEventTypeEVENT_UNKNOWN              uint64 = 1 << 0
	ClientEventTypeEVENT_INIT_CONNECTION      uint64 = 1 << 1
	ClientEventTypeEVENT_TERMINATE_CONNECTION uint64 = 1 << 2
	ClientEventTypeEVENT_LATENCY_SAMPLES      uint64 = 1 << 3
	ClientEventTypeEVENT_LOCATION_UPDATE      uint64 = 1 << 4
	ClientEventTypeEVENT_CUSTOM_EVENT         uint64 = 1 << 5
)

var ClientEdgeEvent_ClientEventType_CamelName = map[int32]string{
	// EVENT_UNKNOWN -> EventUnknown
	0: "EventUnknown",
	// EVENT_INIT_CONNECTION -> EventInitConnection
	1: "EventInitConnection",
	// EVENT_TERMINATE_CONNECTION -> EventTerminateConnection
	2: "EventTerminateConnection",
	// EVENT_LATENCY_SAMPLES -> EventLatencySamples
	3: "EventLatencySamples",
	// EVENT_LOCATION_UPDATE -> EventLocationUpdate
	4: "EventLocationUpdate",
	// EVENT_CUSTOM_EVENT -> EventCustomEvent
	5: "EventCustomEvent",
}
var ClientEdgeEvent_ClientEventType_CamelValue = map[string]int32{
	"EventUnknown":             0,
	"EventInitConnection":      1,
	"EventTerminateConnection": 2,
	"EventLatencySamples":      3,
	"EventLocationUpdate":      4,
	"EventCustomEvent":         5,
}

func ParseClientEdgeEvent_ClientEventType(data interface{}) (ClientEdgeEvent_ClientEventType, error) {
	if val, ok := data.(ClientEdgeEvent_ClientEventType); ok {
		return val, nil
	} else if str, ok := data.(string); ok {
		val, ok := ClientEdgeEvent_ClientEventType_CamelValue[util.CamelCase(str)]
		if !ok {
			// may have omitted common prefix
			val, ok = ClientEdgeEvent_ClientEventType_CamelValue["Event"+util.CamelCase(str)]
		}
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = ClientEdgeEvent_ClientEventType_CamelName[val]
			}
		}
		if !ok {
			return ClientEdgeEvent_ClientEventType(0), fmt.Errorf("Invalid ClientEdgeEvent_ClientEventType value %q", str)
		}
		return ClientEdgeEvent_ClientEventType(val), nil
	} else if ival, ok := data.(int32); ok {
		if _, ok := ClientEdgeEvent_ClientEventType_CamelName[ival]; ok {
			return ClientEdgeEvent_ClientEventType(ival), nil
		} else {
			return ClientEdgeEvent_ClientEventType(0), fmt.Errorf("Invalid ClientEdgeEvent_ClientEventType value %d", ival)
		}
	}
	return ClientEdgeEvent_ClientEventType(0), fmt.Errorf("Invalid ClientEdgeEvent_ClientEventType value %v", data)
}

func (e *ClientEdgeEvent_ClientEventType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, err := ParseClientEdgeEvent_ClientEventType(str)
	if err != nil {
		return err
	}
	*e = val
	return nil
}

func (e ClientEdgeEvent_ClientEventType) MarshalYAML() (interface{}, error) {
	str := proto.EnumName(ClientEdgeEvent_ClientEventType_CamelName, int32(e))
	str = strings.TrimPrefix(str, "Event")
	return str, nil
}

// custom JSON encoding/decoding
func (e *ClientEdgeEvent_ClientEventType) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, err := ParseClientEdgeEvent_ClientEventType(str)
		if err != nil {
			return &json.UnmarshalTypeError{
				Value: "string " + str,
				Type:  reflect.TypeOf(ClientEdgeEvent_ClientEventType(0)),
			}
		}
		*e = ClientEdgeEvent_ClientEventType(val)
		return nil
	}
	var ival int32
	err = json.Unmarshal(b, &ival)
	if err == nil {
		val, err := ParseClientEdgeEvent_ClientEventType(ival)
		if err == nil {
			*e = val
			return nil
		}
	}
	return &json.UnmarshalTypeError{
		Value: "value " + string(b),
		Type:  reflect.TypeOf(ClientEdgeEvent_ClientEventType(0)),
	}
}

func (e ClientEdgeEvent_ClientEventType) MarshalJSON() ([]byte, error) {
	str := proto.EnumName(ClientEdgeEvent_ClientEventType_CamelName, int32(e))
	str = strings.TrimPrefix(str, "Event")
	return json.Marshal(str)
}

var ClientEventTypeCommonPrefix = "Event"

var ServerEventTypeStrings = []string{
	"EVENT_UNKNOWN",
	"EVENT_INIT_CONNECTION",
	"EVENT_LATENCY_REQUEST",
	"EVENT_LATENCY_PROCESSED",
	"EVENT_CLOUDLET_STATE",
	"EVENT_CLOUDLET_MAINTENANCE",
	"EVENT_APPINST_HEALTH",
	"EVENT_CLOUDLET_UPDATE",
	"EVENT_ERROR",
}

const (
	ServerEventTypeEVENT_UNKNOWN              uint64 = 1 << 0
	ServerEventTypeEVENT_INIT_CONNECTION      uint64 = 1 << 1
	ServerEventTypeEVENT_LATENCY_REQUEST      uint64 = 1 << 2
	ServerEventTypeEVENT_LATENCY_PROCESSED    uint64 = 1 << 3
	ServerEventTypeEVENT_CLOUDLET_STATE       uint64 = 1 << 4
	ServerEventTypeEVENT_CLOUDLET_MAINTENANCE uint64 = 1 << 5
	ServerEventTypeEVENT_APPINST_HEALTH       uint64 = 1 << 6
	ServerEventTypeEVENT_CLOUDLET_UPDATE      uint64 = 1 << 7
	ServerEventTypeEVENT_ERROR                uint64 = 1 << 8
)

var ServerEdgeEvent_ServerEventType_CamelName = map[int32]string{
	// EVENT_UNKNOWN -> EventUnknown
	0: "EventUnknown",
	// EVENT_INIT_CONNECTION -> EventInitConnection
	1: "EventInitConnection",
	// EVENT_LATENCY_REQUEST -> EventLatencyRequest
	2: "EventLatencyRequest",
	// EVENT_LATENCY_PROCESSED -> EventLatencyProcessed
	3: "EventLatencyProcessed",
	// EVENT_CLOUDLET_STATE -> EventCloudletState
	4: "EventCloudletState",
	// EVENT_CLOUDLET_MAINTENANCE -> EventCloudletMaintenance
	5: "EventCloudletMaintenance",
	// EVENT_APPINST_HEALTH -> EventAppinstHealth
	6: "EventAppinstHealth",
	// EVENT_CLOUDLET_UPDATE -> EventCloudletUpdate
	7: "EventCloudletUpdate",
	// EVENT_ERROR -> EventError
	8: "EventError",
}
var ServerEdgeEvent_ServerEventType_CamelValue = map[string]int32{
	"EventUnknown":             0,
	"EventInitConnection":      1,
	"EventLatencyRequest":      2,
	"EventLatencyProcessed":    3,
	"EventCloudletState":       4,
	"EventCloudletMaintenance": 5,
	"EventAppinstHealth":       6,
	"EventCloudletUpdate":      7,
	"EventError":               8,
}

func ParseServerEdgeEvent_ServerEventType(data interface{}) (ServerEdgeEvent_ServerEventType, error) {
	if val, ok := data.(ServerEdgeEvent_ServerEventType); ok {
		return val, nil
	} else if str, ok := data.(string); ok {
		val, ok := ServerEdgeEvent_ServerEventType_CamelValue[util.CamelCase(str)]
		if !ok {
			// may have omitted common prefix
			val, ok = ServerEdgeEvent_ServerEventType_CamelValue["Event"+util.CamelCase(str)]
		}
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = ServerEdgeEvent_ServerEventType_CamelName[val]
			}
		}
		if !ok {
			return ServerEdgeEvent_ServerEventType(0), fmt.Errorf("Invalid ServerEdgeEvent_ServerEventType value %q", str)
		}
		return ServerEdgeEvent_ServerEventType(val), nil
	} else if ival, ok := data.(int32); ok {
		if _, ok := ServerEdgeEvent_ServerEventType_CamelName[ival]; ok {
			return ServerEdgeEvent_ServerEventType(ival), nil
		} else {
			return ServerEdgeEvent_ServerEventType(0), fmt.Errorf("Invalid ServerEdgeEvent_ServerEventType value %d", ival)
		}
	}
	return ServerEdgeEvent_ServerEventType(0), fmt.Errorf("Invalid ServerEdgeEvent_ServerEventType value %v", data)
}

func (e *ServerEdgeEvent_ServerEventType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, err := ParseServerEdgeEvent_ServerEventType(str)
	if err != nil {
		return err
	}
	*e = val
	return nil
}

func (e ServerEdgeEvent_ServerEventType) MarshalYAML() (interface{}, error) {
	str := proto.EnumName(ServerEdgeEvent_ServerEventType_CamelName, int32(e))
	str = strings.TrimPrefix(str, "Event")
	return str, nil
}

// custom JSON encoding/decoding
func (e *ServerEdgeEvent_ServerEventType) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, err := ParseServerEdgeEvent_ServerEventType(str)
		if err != nil {
			return &json.UnmarshalTypeError{
				Value: "string " + str,
				Type:  reflect.TypeOf(ServerEdgeEvent_ServerEventType(0)),
			}
		}
		*e = ServerEdgeEvent_ServerEventType(val)
		return nil
	}
	var ival int32
	err = json.Unmarshal(b, &ival)
	if err == nil {
		val, err := ParseServerEdgeEvent_ServerEventType(ival)
		if err == nil {
			*e = val
			return nil
		}
	}
	return &json.UnmarshalTypeError{
		Value: "value " + string(b),
		Type:  reflect.TypeOf(ServerEdgeEvent_ServerEventType(0)),
	}
}

func (e ServerEdgeEvent_ServerEventType) MarshalJSON() ([]byte, error) {
	str := proto.EnumName(ServerEdgeEvent_ServerEventType_CamelName, int32(e))
	str = strings.TrimPrefix(str, "Event")
	return json.Marshal(str)
}

var ServerEventTypeCommonPrefix = "Event"

func (m *FindCloudletRequest) IsValidArgsForFindCloudlet() error {
	return nil
}

func (m *AppInstListRequest) IsValidArgsForGetAppInstList() error {
	return nil
}

func (m *AppOfficialFqdnRequest) IsValidArgsForGetAppOfficialFqdn() error {
	return nil
}

func (m *ClientEdgeEvent) IsValidArgsForStreamEdgeEvent() error {
	return nil
}

func (m *FindCloudletRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	l = len(m.SessionCookie)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.CarrierName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.GpsLocation != nil {
		l = m.GpsLocation.Size()
		n += 1 + l + sovAppClient(uint64(l))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAppClient(uint64(len(k))) + 1 + len(v) + sovAppClient(uint64(len(v)))
			n += mapEntrySize + 2 + sovAppClient(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FindCloudletReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	if m.Status != 0 {
		n += 1 + sovAppClient(uint64(m.Status))
	}
	l = len(m.Fqdn)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if len(m.Ports) > 0 {
		for _, e := range m.Ports {
			l = e.Size()
			n += 1 + l + sovAppClient(uint64(l))
		}
	}
	if m.CloudletLocation != nil {
		l = m.CloudletLocation.Size()
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.EdgeEventsCookie)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.QosResult != 0 {
		n += 1 + sovAppClient(uint64(m.QosResult))
	}
	l = len(m.QosErrorMsg)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAppClient(uint64(len(k))) + 1 + len(v) + sovAppClient(uint64(len(v)))
			n += mapEntrySize + 2 + sovAppClient(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AppInstListRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	l = len(m.SessionCookie)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.CarrierName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.GpsLocation != nil {
		l = m.GpsLocation.Size()
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.Limit != 0 {
		n += 1 + sovAppClient(uint64(m.Limit))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAppClient(uint64(len(k))) + 1 + len(v) + sovAppClient(uint64(len(v)))
			n += mapEntrySize + 2 + sovAppClient(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Appinstance) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AppName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.AppVers)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.Fqdn)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if len(m.Ports) > 0 {
		for _, e := range m.Ports {
			l = e.Size()
			n += 1 + l + sovAppClient(uint64(l))
		}
	}
	l = len(m.OrgName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.EdgeEventsCookie)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CloudletLocation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CarrierName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.CloudletName)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.GpsLocation != nil {
		l = m.GpsLocation.Size()
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.Distance != 0 {
		n += 9
	}
	if len(m.Appinstances) > 0 {
		for _, e := range m.Appinstances {
			l = e.Size()
			n += 1 + l + sovAppClient(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AppInstListReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	if m.Status != 0 {
		n += 1 + sovAppClient(uint64(m.Status))
	}
	if len(m.Cloudlets) > 0 {
		for _, e := range m.Cloudlets {
			l = e.Size()
			n += 1 + l + sovAppClient(uint64(l))
		}
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAppClient(uint64(len(k))) + 1 + len(v) + sovAppClient(uint64(len(v)))
			n += mapEntrySize + 2 + sovAppClient(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AppOfficialFqdnRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	l = len(m.SessionCookie)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.GpsLocation != nil {
		l = m.GpsLocation.Size()
		n += 1 + l + sovAppClient(uint64(l))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAppClient(uint64(len(k))) + 1 + len(v) + sovAppClient(uint64(len(v)))
			n += mapEntrySize + 2 + sovAppClient(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AppOfficialFqdnReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClient(uint64(m.Ver))
	}
	l = len(m.AppOfficialFqdn)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.ClientToken)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovAppClient(uint64(m.Status))
	}
	if len(m.Ports) > 0 {
		for _, e := range m.Ports {
			l = e.Size()
			n += 1 + l + sovAppClient(uint64(l))
		}
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAppClient(uint64(len(k))) + 1 + len(v) + sovAppClient(uint64(len(v)))
			n += mapEntrySize + 2 + sovAppClient(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClientEdgeEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SessionCookie)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.EdgeEventsCookie)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.EventType != 0 {
		n += 1 + sovAppClient(uint64(m.EventType))
	}
	if m.GpsLocation != nil {
		l = m.GpsLocation.Size()
		n += 1 + l + sovAppClient(uint64(l))
	}
	if len(m.Samples) > 0 {
		for _, e := range m.Samples {
			l = e.Size()
			n += 1 + l + sovAppClient(uint64(l))
		}
	}
	if m.DeviceInfoStatic != nil {
		l = m.DeviceInfoStatic.Size()
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.DeviceInfoDynamic != nil {
		l = m.DeviceInfoDynamic.Size()
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.CustomEvent)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAppClient(uint64(len(k))) + 1 + len(v) + sovAppClient(uint64(len(v)))
			n += mapEntrySize + 2 + sovAppClient(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ServerEdgeEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EventType != 0 {
		n += 1 + sovAppClient(uint64(m.EventType))
	}
	if m.CloudletState != 0 {
		n += 1 + sovAppClient(uint64(m.CloudletState))
	}
	if m.MaintenanceState != 0 {
		n += 1 + sovAppClient(uint64(m.MaintenanceState))
	}
	if m.HealthCheck != 0 {
		n += 1 + sovAppClient(uint64(m.HealthCheck))
	}
	if m.Statistics != nil {
		l = m.Statistics.Size()
		n += 1 + l + sovAppClient(uint64(l))
	}
	if m.NewCloudlet != nil {
		l = m.NewCloudlet.Size()
		n += 1 + l + sovAppClient(uint64(l))
	}
	l = len(m.ErrorMsg)
	if l > 0 {
		n += 1 + l + sovAppClient(uint64(l))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAppClient(uint64(len(k))) + 1 + len(v) + sovAppClient(uint64(len(v)))
			n += mapEntrySize + 2 + sovAppClient(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovAppClient(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozAppClient(x uint64) (n int) {
	return sovAppClient(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *FindCloudletRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FindCloudletRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FindCloudletRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionCookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionCookie = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CarrierName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CarrierName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpsLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GpsLocation == nil {
				m.GpsLocation = &Loc{}
			}
			if err := m.GpsLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAppClient
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClient
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAppClient
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAppClient
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClient
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAppClient
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAppClient
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAppClient(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthAppClient
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FindCloudletReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FindCloudletReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FindCloudletReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= FindCloudletReply_FindStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fqdn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fqdn = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ports = append(m.Ports, &AppPort{})
			if err := m.Ports[len(m.Ports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudletLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CloudletLocation == nil {
				m.CloudletLocation = &Loc{}
			}
			if err := m.CloudletLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EdgeEventsCookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EdgeEventsCookie = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QosResult", wireType)
			}
			m.QosResult = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QosResult |= FindCloudletReply_QosSessionResult(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QosErrorMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QosErrorMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAppClient
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClient
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAppClient
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAppClient
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClient
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAppClient
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAppClient
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAppClient(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthAppClient
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppInstListRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppInstListRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppInstListRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionCookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionCookie = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CarrierName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CarrierName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpsLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GpsLocation == nil {
				m.GpsLocation = &Loc{}
			}
			if err := m.GpsLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAppClient
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClient
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAppClient
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAppClient
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClient
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAppClient
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAppClient
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAppClient(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthAppClient
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Appinstance) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Appinstance: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Appinstance: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppVers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppVers = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fqdn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fqdn = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ports = append(m.Ports, &AppPort{})
			if err := m.Ports[len(m.Ports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrgName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrgName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EdgeEventsCookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EdgeEventsCookie = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloudletLocation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloudletLocation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloudletLocation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CarrierName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CarrierName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudletName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CloudletName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpsLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GpsLocation == nil {
				m.GpsLocation = &Loc{}
			}
			if err := m.GpsLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Distance", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Distance = float64(math.Float64frombits(v))
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Appinstances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Appinstances = append(m.Appinstances, &Appinstance{})
			if err := m.Appinstances[len(m.Appinstances)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppInstListReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppInstListReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppInstListReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= AppInstListReply_AIStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cloudlets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cloudlets = append(m.Cloudlets, &CloudletLocation{})
			if err := m.Cloudlets[len(m.Cloudlets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAppClient
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClient
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAppClient
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAppClient
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClient
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAppClient
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAppClient
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAppClient(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthAppClient
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppOfficialFqdnRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppOfficialFqdnRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppOfficialFqdnRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionCookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionCookie = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpsLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GpsLocation == nil {
				m.GpsLocation = &Loc{}
			}
			if err := m.GpsLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAppClient
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClient
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAppClient
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAppClient
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClient
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAppClient
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAppClient
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAppClient(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthAppClient
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppOfficialFqdnReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppOfficialFqdnReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppOfficialFqdnReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppOfficialFqdn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppOfficialFqdn = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= AppOfficialFqdnReply_AOFStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ports = append(m.Ports, &AppPort{})
			if err := m.Ports[len(m.Ports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAppClient
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClient
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAppClient
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAppClient
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClient
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAppClient
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAppClient
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAppClient(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthAppClient
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientEdgeEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientEdgeEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientEdgeEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionCookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionCookie = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EdgeEventsCookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EdgeEventsCookie = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventType", wireType)
			}
			m.EventType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventType |= ClientEdgeEvent_ClientEventType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpsLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GpsLocation == nil {
				m.GpsLocation = &Loc{}
			}
			if err := m.GpsLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Samples", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Samples = append(m.Samples, &Sample{})
			if err := m.Samples[len(m.Samples)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceInfoStatic", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeviceInfoStatic == nil {
				m.DeviceInfoStatic = &DeviceInfoStatic{}
			}
			if err := m.DeviceInfoStatic.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceInfoDynamic", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeviceInfoDynamic == nil {
				m.DeviceInfoDynamic = &DeviceInfoDynamic{}
			}
			if err := m.DeviceInfoDynamic.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomEvent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomEvent = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAppClient
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClient
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAppClient
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAppClient
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClient
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAppClient
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAppClient
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAppClient(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthAppClient
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServerEdgeEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServerEdgeEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServerEdgeEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventType", wireType)
			}
			m.EventType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventType |= ServerEdgeEvent_ServerEventType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudletState", wireType)
			}
			m.CloudletState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CloudletState |= CloudletState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaintenanceState", wireType)
			}
			m.MaintenanceState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaintenanceState |= MaintenanceState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HealthCheck", wireType)
			}
			m.HealthCheck = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HealthCheck |= HealthCheck(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Statistics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Statistics == nil {
				m.Statistics = &Statistics{}
			}
			if err := m.Statistics.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewCloudlet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NewCloudlet == nil {
				m.NewCloudlet = &FindCloudletReply{}
			}
			if err := m.NewCloudlet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAppClient
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClient
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAppClient
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAppClient
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClient
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAppClient
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAppClient
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAppClient(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthAppClient
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAppClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAppClient(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAppClient
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAppClient
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAppClient
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupAppClient
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthAppClient
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthAppClient        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAppClient          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupAppClient = fmt.Errorf("proto: unexpected end of group")
)
