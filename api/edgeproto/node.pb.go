// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: node.proto

package edgeproto

import (
	context "context"
	"encoding/json"
	fmt "fmt"
	"github.com/edgexr/edge-cloud-platform/pkg/log"
	"github.com/edgexr/edge-cloud-platform/pkg/objstore"
	"github.com/edgexr/edge-cloud-platform/pkg/util"
	_ "github.com/edgexr/edge-cloud-platform/tools/protogen"
	_ "github.com/gogo/googleapis/google/api"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"go.etcd.io/etcd/client/v3/concurrency"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// NodeKey
//
// NodeKey uniquely identifies a node (VM or machine)
type NodeKey struct {
	// Organization the node belongs to.
	Organization string `protobuf:"bytes,1,opt,name=organization,proto3" json:"organization,omitempty"`
	// Name of the node
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *NodeKey) Reset()         { *m = NodeKey{} }
func (m *NodeKey) String() string { return proto.CompactTextString(m) }
func (*NodeKey) ProtoMessage()    {}
func (*NodeKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c843d59d2d938e7, []int{0}
}
func (m *NodeKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeKey.Merge(m, src)
}
func (m *NodeKey) XXX_Size() int {
	return m.Size()
}
func (m *NodeKey) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeKey.DiscardUnknown(m)
}

var xxx_messageInfo_NodeKey proto.InternalMessageInfo

// Node
//
// A Node is a VM or bare metal machine that can be grouped to
// form a cluster.
type Node struct {
	// Fields are used for the Update API to specify which fields to apply
	Fields []string `protobuf:"bytes,1,rep,name=fields,proto3" json:"fields,omitempty"`
	// Unique identifier key
	Key NodeKey `protobuf:"bytes,2,opt,name=key,proto3" json:"key"`
	// Cloudlet key that the node is associated with
	CloudletKey CloudletKey `protobuf:"bytes,3,opt,name=cloudlet_key,json=cloudletKey,proto3" json:"cloudlet_key"`
	// Username for accessing the node
	Username string `protobuf:"bytes,4,opt,name=username,proto3" json:"username,omitempty"`
	// Hostname or IP address of the public interface
	PublicAddr string `protobuf:"bytes,5,opt,name=public_addr,json=publicAddr,proto3" json:"public_addr,omitempty"`
	// Hostname or IP address of the management interface (defaults to public address)
	MgmtAddr string `protobuf:"bytes,6,opt,name=mgmt_addr,json=mgmtAddr,proto3" json:"mgmt_addr,omitempty"`
	// SSH port on the management interface (defaults to 22)
	SshPort uint32 `protobuf:"varint,7,opt,name=ssh_port,json=sshPort,proto3" json:"ssh_port,omitempty"`
	// Assignment status of node
	Assignment string `protobuf:"bytes,8,opt,name=assignment,proto3" json:"assignment,omitempty"`
	// Health status of node (set by system unless skip node check is set)
	Health string `protobuf:"bytes,9,opt,name=health,proto3" json:"health,omitempty"`
	// Dynamically created is set to true if the node was created on-demand.
	DynamicallyCreated bool `protobuf:"varint,10,opt,name=dynamically_created,json=dynamicallyCreated,proto3" json:"dynamically_created,omitempty"`
	// Owner is set to a cluster key if the node is in use
	Owner *ClusterKey `protobuf:"bytes,11,opt,name=owner,proto3" json:"owner,omitempty"`
	// Resources on the node (set by system unless skip node check is set)
	NodeResources *NodeResources `protobuf:"bytes,12,opt,name=node_resources,json=nodeResources,proto3" json:"node_resources,omitempty"`
	// Node role in the context of the owning cluster
	Role string `protobuf:"bytes,13,opt,name=role,proto3" json:"role,omitempty"`
	// Node pool assignment if applicable
	NodePool string `protobuf:"bytes,14,opt,name=node_pool,json=nodePool,proto3" json:"node_pool,omitempty"`
	// Name to use when represented as a flavor
	FlavorName string `protobuf:"bytes,15,opt,name=flavor_name,json=flavorName,proto3" json:"flavor_name,omitempty"`
	// Use on create/update to skip node checks, avoids ssh test
	SkipNodeCheck bool `protobuf:"varint,98,opt,name=skip_node_check,json=skipNodeCheck,proto3" json:"skip_node_check,omitempty"`
	// Object ID
	ObjId string `protobuf:"bytes,99,opt,name=obj_id,json=objId,proto3" json:"obj_id,omitempty"`
}

func (m *Node) Reset()         { *m = Node{} }
func (m *Node) String() string { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()    {}
func (*Node) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c843d59d2d938e7, []int{1}
}
func (m *Node) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node.Merge(m, src)
}
func (m *Node) XXX_Size() int {
	return m.Size()
}
func (m *Node) XXX_DiscardUnknown() {
	xxx_messageInfo_Node.DiscardUnknown(m)
}

var xxx_messageInfo_Node proto.InternalMessageInfo

func init() {
	proto.RegisterType((*NodeKey)(nil), "edgeproto.NodeKey")
	proto.RegisterType((*Node)(nil), "edgeproto.Node")
}

func init() { proto.RegisterFile("node.proto", fileDescriptor_0c843d59d2d938e7) }

var fileDescriptor_0c843d59d2d938e7 = []byte{
	// 862 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x54, 0x41, 0x6f, 0x1b, 0x45,
	0x14, 0xf6, 0x34, 0x8e, 0x63, 0x8f, 0xed, 0xba, 0x19, 0xa0, 0x1a, 0xa2, 0xe0, 0xb8, 0x56, 0x41,
	0x51, 0xb5, 0x64, 0xa1, 0x88, 0x4b, 0xa4, 0x0a, 0x25, 0x29, 0x95, 0xa0, 0x22, 0xa9, 0x16, 0xc1,
	0x11, 0x6b, 0xbd, 0xfb, 0xba, 0xde, 0x7a, 0xbc, 0x6f, 0x35, 0xb3, 0x6e, 0x64, 0x84, 0x04, 0xe2,
	0x17, 0x44, 0xc0, 0x01, 0x71, 0xe2, 0x88, 0x38, 0xa1, 0x1e, 0xfb, 0x0b, 0xa2, 0x9e, 0x2a, 0x71,
	0xe1, 0x84, 0x20, 0xe1, 0x80, 0x7a, 0x42, 0x8a, 0x13, 0x71, 0x44, 0x33, 0xbb, 0xde, 0x6e, 0x4d,
	0x38, 0xc0, 0x81, 0xdb, 0xce, 0xf7, 0xbe, 0xf7, 0xbe, 0xf7, 0xbe, 0x37, 0xb3, 0x94, 0x46, 0xe8,
	0xc3, 0x46, 0x2c, 0x31, 0x41, 0x56, 0x03, 0x3f, 0x00, 0xf3, 0xb9, 0xb2, 0x1a, 0x20, 0x06, 0x02,
	0x6c, 0x37, 0x0e, 0x6d, 0x37, 0x8a, 0x30, 0x71, 0x93, 0x10, 0x23, 0x95, 0x12, 0x57, 0x5e, 0x4a,
	0x10, 0x85, 0xb2, 0xcd, 0x21, 0x80, 0x28, 0xff, 0xc8, 0xc2, 0xcb, 0x9e, 0xc0, 0xb1, 0x2f, 0x20,
	0x19, 0xc2, 0x24, 0x83, 0x1a, 0x12, 0xd4, 0x58, 0x24, 0xd9, 0xa9, 0x25, 0x41, 0xe1, 0x58, 0x7a,
	0x30, 0x2b, 0xf8, 0x7c, 0x80, 0x01, 0x9a, 0x4f, 0x5b, 0x7f, 0x65, 0x68, 0xd3, 0x13, 0x63, 0x95,
	0x80, 0x4c, 0x8f, 0xdd, 0x4f, 0xe9, 0xd2, 0x2e, 0xfa, 0x70, 0x1b, 0x26, 0xcc, 0xa6, 0x0d, 0x94,
	0x81, 0x1b, 0x85, 0x1f, 0x9b, 0xbe, 0x38, 0xe9, 0x90, 0xf5, 0xda, 0x76, 0xfd, 0xe1, 0x19, 0x5f,
	0xd2, 0xf3, 0xa0, 0x0c, 0x9c, 0x67, 0x08, 0xac, 0x43, 0xcb, 0x91, 0x3b, 0x02, 0x7e, 0xc1, 0x10,
	0x1b, 0x0f, 0xcf, 0x78, 0x55, 0x13, 0x35, 0xe6, 0x98, 0xc8, 0xe6, 0x95, 0xdf, 0x4f, 0x38, 0xf9,
	0xf3, 0x84, 0x93, 0x47, 0xa7, 0x7c, 0x79, 0xd7, 0x1d, 0x81, 0xb5, 0x57, 0x28, 0xf0, 0xc3, 0xb7,
	0x6b, 0xa4, 0xfb, 0xa8, 0x42, 0xcb, 0xba, 0x03, 0x76, 0x99, 0x56, 0xee, 0x86, 0x20, 0x7c, 0xc5,
	0x49, 0x67, 0x61, 0xbd, 0xe6, 0x64, 0x27, 0x76, 0x8d, 0x2e, 0x0c, 0x61, 0x62, 0x44, 0xea, 0xd7,
	0xd9, 0x46, 0x6e, 0xe7, 0x46, 0xd6, 0xf7, 0x76, 0xf9, 0xf0, 0xe7, 0xb5, 0x92, 0xa3, 0x49, 0xec,
	0x2d, 0xda, 0x98, 0xd9, 0xd4, 0xd3, 0x49, 0x0b, 0x26, 0xe9, 0x72, 0x21, 0x69, 0x27, 0x0b, 0x3f,
	0x4d, 0xac, 0x7b, 0x4f, 0x21, 0xb6, 0x42, 0xab, 0x63, 0x05, 0xd2, 0x8c, 0x55, 0xd6, 0x63, 0x39,
	0xf9, 0x99, 0xad, 0xd1, 0x7a, 0x3c, 0xee, 0x8b, 0xd0, 0xeb, 0xb9, 0xbe, 0x2f, 0xf9, 0xa2, 0x09,
	0xd3, 0x14, 0xda, 0xf2, 0x7d, 0xc9, 0xae, 0xd0, 0xda, 0x28, 0x18, 0x25, 0x69, 0xb8, 0x62, 0x4c,
	0x29, 0x7f, 0x37, 0xe5, 0xc4, 0xa9, 0x6a, 0xd8, 0x50, 0xd6, 0x68, 0x55, 0xa9, 0x41, 0x2f, 0x46,
	0x99, 0xf0, 0xa5, 0x0e, 0x59, 0x6f, 0x66, 0x8c, 0x25, 0xa5, 0x06, 0x77, 0x50, 0x26, 0xec, 0x2a,
	0xa5, 0xae, 0x52, 0x61, 0x10, 0x8d, 0x20, 0x4a, 0x78, 0xb5, 0x50, 0xa4, 0x80, 0xb3, 0x55, 0x5a,
	0x19, 0x80, 0x2b, 0x92, 0x01, 0xaf, 0x15, 0x18, 0x19, 0xc6, 0xde, 0xa4, 0xcf, 0xf9, 0x93, 0xc8,
	0x1d, 0x85, 0x9e, 0x2b, 0xc4, 0xa4, 0xe7, 0x49, 0x70, 0x13, 0xf0, 0x39, 0xed, 0x90, 0xf5, 0x6a,
	0x46, 0x65, 0x05, 0xc2, 0x4e, 0x1a, 0x67, 0xaf, 0xd3, 0x45, 0xdc, 0x8f, 0x40, 0xf2, 0xba, 0x71,
	0xed, 0x85, 0x67, 0x5c, 0x33, 0x77, 0xc6, 0x98, 0x66, 0xf2, 0x53, 0x26, 0x7b, 0x9b, 0x5e, 0xd4,
	0x1b, 0xef, 0xe5, 0x57, 0x8f, 0x37, 0x4c, 0x2e, 0x9f, 0x5b, 0x93, 0x33, 0x8b, 0x67, 0xe9, 0xcd,
	0xa8, 0x08, 0x32, 0x4e, 0xcb, 0x12, 0x05, 0xf0, 0x66, 0x61, 0x18, 0x83, 0x68, 0x4b, 0x8d, 0x40,
	0x8c, 0x28, 0xf8, 0xc5, 0xa2, 0xa5, 0x1a, 0xbe, 0x83, 0x28, 0xd8, 0xcb, 0xb4, 0x7e, 0x57, 0xb8,
	0xf7, 0x51, 0xf6, 0xcc, 0xd6, 0x5a, 0x45, 0xcb, 0xd2, 0x80, 0xbe, 0x78, 0xec, 0x15, 0xda, 0x52,
	0xc3, 0x30, 0xee, 0x99, 0x72, 0xde, 0x00, 0xbc, 0x21, 0xef, 0x6b, 0x43, 0x9c, 0xa6, 0x86, 0x75,
	0x93, 0x3b, 0x1a, 0x64, 0x57, 0x69, 0x05, 0xfb, 0xf7, 0x7a, 0xa1, 0xcf, 0x3d, 0x53, 0xa9, 0xa9,
	0x2b, 0x7d, 0xf1, 0xe0, 0xc5, 0xc5, 0x08, 0xbd, 0x51, 0xec, 0x2c, 0x62, 0xff, 0xde, 0x3b, 0xfe,
	0xe6, 0x57, 0x44, 0xdf, 0xec, 0x3f, 0x4e, 0x38, 0xf9, 0x6c, 0xca, 0xc9, 0xc1, 0x94, 0x93, 0xaf,
	0x35, 0xed, 0x94, 0x6f, 0x6f, 0xe5, 0x5b, 0xb2, 0x6e, 0xfe, 0xcd, 0x63, 0x6b, 0x4f, 0xdb, 0x66,
	0x39, 0x28, 0xc0, 0xda, 0xcd, 0x06, 0xb0, 0x6e, 0xe5, 0x4d, 0x5a, 0x7b, 0xba, 0xf8, 0x37, 0xa7,
	0xbc, 0xab, 0x47, 0xb9, 0x71, 0x1b, 0x26, 0x1b, 0x06, 0x46, 0x19, 0x98, 0x43, 0xf1, 0xf1, 0x3c,
	0x38, 0xe3, 0x97, 0x86, 0x30, 0xb9, 0x51, 0xc4, 0xae, 0x1f, 0x94, 0xd3, 0xe7, 0xbc, 0x15, 0x87,
	0xec, 0x80, 0x50, 0x9a, 0xca, 0x9a, 0xe7, 0xd5, 0x9a, 0x5b, 0xc9, 0xca, 0x72, 0x01, 0x70, 0xcc,
	0x8f, 0xa4, 0xfb, 0xd1, 0x93, 0x29, 0xb7, 0x67, 0x6b, 0x99, 0xbd, 0x14, 0x65, 0x6d, 0x79, 0xba,
	0xf8, 0x7b, 0x6e, 0xe4, 0x06, 0x60, 0xcd, 0xf7, 0xf1, 0xfd, 0x19, 0xbf, 0x34, 0x8f, 0x7d, 0xfe,
	0xe3, 0x6f, 0x5f, 0x5e, 0x58, 0xee, 0x36, 0xec, 0xf4, 0xea, 0xd9, 0xda, 0xf3, 0x4d, 0x72, 0x8d,
	0x7d, 0x42, 0xe9, 0x4d, 0x10, 0xf0, 0x2f, 0x3a, 0x7a, 0xf7, 0x3f, 0x74, 0x94, 0xab, 0xfb, 0x46,
	0xab, 0xa8, 0xfe, 0x41, 0xec, 0xbb, 0xff, 0x97, 0xfa, 0xd8, 0x68, 0xe5, 0xea, 0xf7, 0x69, 0xf5,
	0xfd, 0x01, 0xee, 0x9f, 0xaf, 0x3d, 0x0f, 0x74, 0x6f, 0x3d, 0x99, 0xf2, 0x57, 0xff, 0x49, 0xf9,
	0xc3, 0x10, 0xf6, 0xcf, 0xd7, 0x6d, 0x75, 0xa9, 0xad, 0x06, 0xb8, 0x3f, 0x53, 0x7d, 0x8d, 0x6c,
	0xaf, 0x1e, 0xfe, 0xda, 0x2e, 0x1d, 0x1e, 0xb5, 0xc9, 0xe3, 0xa3, 0x36, 0xf9, 0xe5, 0xa8, 0x4d,
	0x0e, 0x8e, 0xdb, 0xa5, 0xc7, 0xc7, 0xed, 0xd2, 0x4f, 0xc7, 0xed, 0x52, 0xbf, 0x62, 0x34, 0xdf,
	0xf8, 0x2b, 0x00, 0x00, 0xff, 0xff, 0x60, 0xd0, 0xe3, 0x1a, 0xb2, 0x06, 0x00, 0x00,
}

func (this *NodeKey) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&edgeproto.NodeKey{")
	s = append(s, "Organization: "+fmt.Sprintf("%#v", this.Organization)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringNode(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// NodeApiClient is the client API for NodeApi service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type NodeApiClient interface {
	// Create a Node corresponding to an existing machine/VM
	CreateNode(ctx context.Context, in *Node, opts ...grpc.CallOption) (*Result, error)
	// Delete a Node
	DeleteNode(ctx context.Context, in *Node, opts ...grpc.CallOption) (*Result, error)
	// Update a Node
	UpdateNode(ctx context.Context, in *Node, opts ...grpc.CallOption) (*Result, error)
	// Show Nodes
	ShowNode(ctx context.Context, in *Node, opts ...grpc.CallOption) (NodeApi_ShowNodeClient, error)
}

type nodeApiClient struct {
	cc *grpc.ClientConn
}

func NewNodeApiClient(cc *grpc.ClientConn) NodeApiClient {
	return &nodeApiClient{cc}
}

func (c *nodeApiClient) CreateNode(ctx context.Context, in *Node, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/edgeproto.NodeApi/CreateNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeApiClient) DeleteNode(ctx context.Context, in *Node, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/edgeproto.NodeApi/DeleteNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeApiClient) UpdateNode(ctx context.Context, in *Node, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/edgeproto.NodeApi/UpdateNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeApiClient) ShowNode(ctx context.Context, in *Node, opts ...grpc.CallOption) (NodeApi_ShowNodeClient, error) {
	stream, err := c.cc.NewStream(ctx, &_NodeApi_serviceDesc.Streams[0], "/edgeproto.NodeApi/ShowNode", opts...)
	if err != nil {
		return nil, err
	}
	x := &nodeApiShowNodeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type NodeApi_ShowNodeClient interface {
	Recv() (*Node, error)
	grpc.ClientStream
}

type nodeApiShowNodeClient struct {
	grpc.ClientStream
}

func (x *nodeApiShowNodeClient) Recv() (*Node, error) {
	m := new(Node)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// NodeApiServer is the server API for NodeApi service.
type NodeApiServer interface {
	// Create a Node corresponding to an existing machine/VM
	CreateNode(context.Context, *Node) (*Result, error)
	// Delete a Node
	DeleteNode(context.Context, *Node) (*Result, error)
	// Update a Node
	UpdateNode(context.Context, *Node) (*Result, error)
	// Show Nodes
	ShowNode(*Node, NodeApi_ShowNodeServer) error
}

// UnimplementedNodeApiServer can be embedded to have forward compatible implementations.
type UnimplementedNodeApiServer struct {
}

func (*UnimplementedNodeApiServer) CreateNode(ctx context.Context, req *Node) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateNode not implemented")
}
func (*UnimplementedNodeApiServer) DeleteNode(ctx context.Context, req *Node) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteNode not implemented")
}
func (*UnimplementedNodeApiServer) UpdateNode(ctx context.Context, req *Node) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateNode not implemented")
}
func (*UnimplementedNodeApiServer) ShowNode(req *Node, srv NodeApi_ShowNodeServer) error {
	return status.Errorf(codes.Unimplemented, "method ShowNode not implemented")
}

func RegisterNodeApiServer(s *grpc.Server, srv NodeApiServer) {
	s.RegisterService(&_NodeApi_serviceDesc, srv)
}

func _NodeApi_CreateNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Node)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeApiServer).CreateNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.NodeApi/CreateNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeApiServer).CreateNode(ctx, req.(*Node))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeApi_DeleteNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Node)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeApiServer).DeleteNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.NodeApi/DeleteNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeApiServer).DeleteNode(ctx, req.(*Node))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeApi_UpdateNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Node)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeApiServer).UpdateNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.NodeApi/UpdateNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeApiServer).UpdateNode(ctx, req.(*Node))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeApi_ShowNode_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Node)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NodeApiServer).ShowNode(m, &nodeApiShowNodeServer{stream})
}

type NodeApi_ShowNodeServer interface {
	Send(*Node) error
	grpc.ServerStream
}

type nodeApiShowNodeServer struct {
	grpc.ServerStream
}

func (x *nodeApiShowNodeServer) Send(m *Node) error {
	return x.ServerStream.SendMsg(m)
}

var _NodeApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "edgeproto.NodeApi",
	HandlerType: (*NodeApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateNode",
			Handler:    _NodeApi_CreateNode_Handler,
		},
		{
			MethodName: "DeleteNode",
			Handler:    _NodeApi_DeleteNode_Handler,
		},
		{
			MethodName: "UpdateNode",
			Handler:    _NodeApi_UpdateNode_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ShowNode",
			Handler:       _NodeApi_ShowNode_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "node.proto",
}

func (m *NodeKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintNode(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Organization) > 0 {
		i -= len(m.Organization)
		copy(dAtA[i:], m.Organization)
		i = encodeVarintNode(dAtA, i, uint64(len(m.Organization)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Node) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ObjId) > 0 {
		i -= len(m.ObjId)
		copy(dAtA[i:], m.ObjId)
		i = encodeVarintNode(dAtA, i, uint64(len(m.ObjId)))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0x9a
	}
	if m.SkipNodeCheck {
		i--
		if m.SkipNodeCheck {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0x90
	}
	if len(m.FlavorName) > 0 {
		i -= len(m.FlavorName)
		copy(dAtA[i:], m.FlavorName)
		i = encodeVarintNode(dAtA, i, uint64(len(m.FlavorName)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.NodePool) > 0 {
		i -= len(m.NodePool)
		copy(dAtA[i:], m.NodePool)
		i = encodeVarintNode(dAtA, i, uint64(len(m.NodePool)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.Role) > 0 {
		i -= len(m.Role)
		copy(dAtA[i:], m.Role)
		i = encodeVarintNode(dAtA, i, uint64(len(m.Role)))
		i--
		dAtA[i] = 0x6a
	}
	if m.NodeResources != nil {
		{
			size, err := m.NodeResources.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.Owner != nil {
		{
			size, err := m.Owner.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.DynamicallyCreated {
		i--
		if m.DynamicallyCreated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if len(m.Health) > 0 {
		i -= len(m.Health)
		copy(dAtA[i:], m.Health)
		i = encodeVarintNode(dAtA, i, uint64(len(m.Health)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Assignment) > 0 {
		i -= len(m.Assignment)
		copy(dAtA[i:], m.Assignment)
		i = encodeVarintNode(dAtA, i, uint64(len(m.Assignment)))
		i--
		dAtA[i] = 0x42
	}
	if m.SshPort != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.SshPort))
		i--
		dAtA[i] = 0x38
	}
	if len(m.MgmtAddr) > 0 {
		i -= len(m.MgmtAddr)
		copy(dAtA[i:], m.MgmtAddr)
		i = encodeVarintNode(dAtA, i, uint64(len(m.MgmtAddr)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.PublicAddr) > 0 {
		i -= len(m.PublicAddr)
		copy(dAtA[i:], m.PublicAddr)
		i = encodeVarintNode(dAtA, i, uint64(len(m.PublicAddr)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Username) > 0 {
		i -= len(m.Username)
		copy(dAtA[i:], m.Username)
		i = encodeVarintNode(dAtA, i, uint64(len(m.Username)))
		i--
		dAtA[i] = 0x22
	}
	{
		size, err := m.CloudletKey.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintNode(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintNode(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Fields) > 0 {
		for iNdEx := len(m.Fields) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Fields[iNdEx])
			copy(dAtA[i:], m.Fields[iNdEx])
			i = encodeVarintNode(dAtA, i, uint64(len(m.Fields[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintNode(dAtA []byte, offset int, v uint64) int {
	offset -= sovNode(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *NodeKey) Matches(o *NodeKey, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !opts.Filter || o.Organization != "" {
		if o.Organization != m.Organization {
			return false
		}
	}
	if !opts.Filter || o.Name != "" {
		if o.Name != m.Name {
			return false
		}
	}
	return true
}

func (m *NodeKey) Clone() *NodeKey {
	cp := &NodeKey{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *NodeKey) CopyInFields(src *NodeKey) int {
	changed := 0
	if m.Organization != src.Organization {
		m.Organization = src.Organization
		changed++
	}
	if m.Name != src.Name {
		m.Name = src.Name
		changed++
	}
	return changed
}

func (m *NodeKey) DeepCopyIn(src *NodeKey) {
	m.Organization = src.Organization
	m.Name = src.Name
}

func (m *NodeKey) GetKeyString() string {
	key, err := json.Marshal(m)
	if err != nil {
		log.FatalLog("Failed to marshal NodeKey key string", "obj", m)
	}
	return string(key)
}

func NodeKeyStringParse(str string, key *NodeKey) {
	err := json.Unmarshal([]byte(str), key)
	if err != nil {
		log.FatalLog("Failed to unmarshal NodeKey key string", "str", str)
	}
}

func (m *NodeKey) NotFoundError() error {
	return fmt.Errorf("Node key %s not found", m.GetKeyString())
}

func (m *NodeKey) ExistsError() error {
	return fmt.Errorf("Node key %s already exists", m.GetKeyString())
}

func (m *NodeKey) BeingDeletedError() error {
	return fmt.Errorf("Node %s is being deleted", m.GetKeyString())
}

var NodeKeyTagOrganization = "nodeorg"
var NodeKeyTagName = "nodename"

func (m *NodeKey) GetTags() map[string]string {
	tags := make(map[string]string)
	m.AddTags(tags)
	return tags
}

func (m *NodeKey) AddTagsByFunc(addTag AddTagFunc) {
	addTag("nodeorg", m.Organization)
	addTag("nodename", m.Name)
}

func (m *NodeKey) AddTags(tags map[string]string) {
	tagMap := TagMap(tags)
	m.AddTagsByFunc(tagMap.AddTag)
}

// Helper method to check that enums have valid values
func (m *NodeKey) ValidateEnums() error {
	return nil
}

func (s *NodeKey) ClearTagged(tags map[string]struct{}) {
}

func (m *Node) Matches(o *Node, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !m.Key.Matches(&o.Key, fopts...) {
		return false
	}
	if !m.CloudletKey.Matches(&o.CloudletKey, fopts...) {
		return false
	}
	if !opts.Filter || o.Username != "" {
		if o.Username != m.Username {
			return false
		}
	}
	if !opts.Filter || o.PublicAddr != "" {
		if o.PublicAddr != m.PublicAddr {
			return false
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.MgmtAddr != "" {
			if o.MgmtAddr != m.MgmtAddr {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.SshPort != 0 {
			if o.SshPort != m.SshPort {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.Assignment != "" {
			if o.Assignment != m.Assignment {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.Health != "" {
			if o.Health != m.Health {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.DynamicallyCreated != false {
			if o.DynamicallyCreated != m.DynamicallyCreated {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.Owner != nil {
			if m.Owner == nil && o.Owner != nil || m.Owner != nil && o.Owner == nil {
				return false
			} else if m.Owner != nil && o.Owner != nil {
				if !m.Owner.Matches(o.Owner, fopts...) {
					return false
				}
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.NodeResources != nil {
			if m.NodeResources == nil && o.NodeResources != nil || m.NodeResources != nil && o.NodeResources == nil {
				return false
			} else if m.NodeResources != nil && o.NodeResources != nil {
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.Role != "" {
			if o.Role != m.Role {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.NodePool != "" {
			if o.NodePool != m.NodePool {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.FlavorName != "" {
			if o.FlavorName != m.FlavorName {
				return false
			}
		}
	}
	if !opts.Filter || o.SkipNodeCheck != false {
		if o.SkipNodeCheck != m.SkipNodeCheck {
			return false
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.ObjId != "" {
			if o.ObjId != m.ObjId {
				return false
			}
		}
	}
	return true
}

const NodeFieldKey = "2"
const NodeFieldKeyOrganization = "2.1"
const NodeFieldKeyName = "2.2"
const NodeFieldCloudletKey = "3"
const NodeFieldCloudletKeyOrganization = "3.1"
const NodeFieldCloudletKeyName = "3.2"
const NodeFieldCloudletKeyFederatedOrganization = "3.3"
const NodeFieldUsername = "4"
const NodeFieldPublicAddr = "5"
const NodeFieldMgmtAddr = "6"
const NodeFieldSshPort = "7"
const NodeFieldAssignment = "8"
const NodeFieldHealth = "9"
const NodeFieldDynamicallyCreated = "10"
const NodeFieldOwner = "11"
const NodeFieldOwnerName = "11.1"
const NodeFieldOwnerOrganization = "11.2"
const NodeFieldNodeResources = "12"
const NodeFieldNodeResourcesVcpus = "12.1"
const NodeFieldNodeResourcesRam = "12.2"
const NodeFieldNodeResourcesDisk = "12.3"
const NodeFieldNodeResourcesOptResMap = "12.4"
const NodeFieldNodeResourcesOptResMapKey = "12.4.1"
const NodeFieldNodeResourcesOptResMapValue = "12.4.2"
const NodeFieldNodeResourcesInfraNodeFlavor = "12.5"
const NodeFieldNodeResourcesExternalVolumeSize = "12.6"
const NodeFieldNodeResourcesGpus = "12.7"
const NodeFieldNodeResourcesGpusModelId = "12.7.1"
const NodeFieldNodeResourcesGpusCount = "12.7.2"
const NodeFieldNodeResourcesGpusVendor = "12.7.3"
const NodeFieldNodeResourcesGpusMemory = "12.7.4"
const NodeFieldNodeResourcesGpusInUse = "12.7.5"
const NodeFieldNodeResourcesNodeName = "12.8"
const NodeFieldRole = "13"
const NodeFieldNodePool = "14"
const NodeFieldFlavorName = "15"
const NodeFieldSkipNodeCheck = "98"
const NodeFieldObjId = "99"

var NodeAllFields = []string{
	NodeFieldKeyOrganization,
	NodeFieldKeyName,
	NodeFieldCloudletKeyOrganization,
	NodeFieldCloudletKeyName,
	NodeFieldCloudletKeyFederatedOrganization,
	NodeFieldUsername,
	NodeFieldPublicAddr,
	NodeFieldMgmtAddr,
	NodeFieldSshPort,
	NodeFieldAssignment,
	NodeFieldHealth,
	NodeFieldDynamicallyCreated,
	NodeFieldOwnerName,
	NodeFieldOwnerOrganization,
	NodeFieldNodeResourcesVcpus,
	NodeFieldNodeResourcesRam,
	NodeFieldNodeResourcesDisk,
	NodeFieldNodeResourcesOptResMapKey,
	NodeFieldNodeResourcesOptResMapValue,
	NodeFieldNodeResourcesInfraNodeFlavor,
	NodeFieldNodeResourcesExternalVolumeSize,
	NodeFieldNodeResourcesGpusModelId,
	NodeFieldNodeResourcesGpusCount,
	NodeFieldNodeResourcesGpusVendor,
	NodeFieldNodeResourcesGpusMemory,
	NodeFieldNodeResourcesGpusInUse,
	NodeFieldNodeResourcesNodeName,
	NodeFieldRole,
	NodeFieldNodePool,
	NodeFieldFlavorName,
	NodeFieldSkipNodeCheck,
	NodeFieldObjId,
}

var NodeAllFieldsMap = NewFieldMap(map[string]struct{}{
	NodeFieldKeyOrganization:                  struct{}{},
	NodeFieldKeyName:                          struct{}{},
	NodeFieldCloudletKeyOrganization:          struct{}{},
	NodeFieldCloudletKeyName:                  struct{}{},
	NodeFieldCloudletKeyFederatedOrganization: struct{}{},
	NodeFieldUsername:                         struct{}{},
	NodeFieldPublicAddr:                       struct{}{},
	NodeFieldMgmtAddr:                         struct{}{},
	NodeFieldSshPort:                          struct{}{},
	NodeFieldAssignment:                       struct{}{},
	NodeFieldHealth:                           struct{}{},
	NodeFieldDynamicallyCreated:               struct{}{},
	NodeFieldOwnerName:                        struct{}{},
	NodeFieldOwnerOrganization:                struct{}{},
	NodeFieldNodeResourcesVcpus:               struct{}{},
	NodeFieldNodeResourcesRam:                 struct{}{},
	NodeFieldNodeResourcesDisk:                struct{}{},
	NodeFieldNodeResourcesOptResMapKey:        struct{}{},
	NodeFieldNodeResourcesOptResMapValue:      struct{}{},
	NodeFieldNodeResourcesInfraNodeFlavor:     struct{}{},
	NodeFieldNodeResourcesExternalVolumeSize:  struct{}{},
	NodeFieldNodeResourcesGpusModelId:         struct{}{},
	NodeFieldNodeResourcesGpusCount:           struct{}{},
	NodeFieldNodeResourcesGpusVendor:          struct{}{},
	NodeFieldNodeResourcesGpusMemory:          struct{}{},
	NodeFieldNodeResourcesGpusInUse:           struct{}{},
	NodeFieldNodeResourcesNodeName:            struct{}{},
	NodeFieldRole:                             struct{}{},
	NodeFieldNodePool:                         struct{}{},
	NodeFieldFlavorName:                       struct{}{},
	NodeFieldSkipNodeCheck:                    struct{}{},
	NodeFieldObjId:                            struct{}{},
})

var NodeAllFieldsStringMap = map[string]string{
	NodeFieldKeyOrganization:                  "Key Organization",
	NodeFieldKeyName:                          "Key Name",
	NodeFieldCloudletKeyOrganization:          "Cloudlet Key Organization",
	NodeFieldCloudletKeyName:                  "Cloudlet Key Name",
	NodeFieldCloudletKeyFederatedOrganization: "Cloudlet Key Federated Organization",
	NodeFieldUsername:                         "Username",
	NodeFieldPublicAddr:                       "Public Addr",
	NodeFieldMgmtAddr:                         "Mgmt Addr",
	NodeFieldSshPort:                          "Ssh Port",
	NodeFieldAssignment:                       "Assignment",
	NodeFieldHealth:                           "Health",
	NodeFieldDynamicallyCreated:               "Dynamically Created",
	NodeFieldOwnerName:                        "Owner Name",
	NodeFieldOwnerOrganization:                "Owner Organization",
	NodeFieldNodeResourcesVcpus:               "Node Resources Vcpus",
	NodeFieldNodeResourcesRam:                 "Node Resources Ram",
	NodeFieldNodeResourcesDisk:                "Node Resources Disk",
	NodeFieldNodeResourcesOptResMapKey:        "Node Resources Opt Res Map Key",
	NodeFieldNodeResourcesOptResMapValue:      "Node Resources Opt Res Map Value",
	NodeFieldNodeResourcesInfraNodeFlavor:     "Node Resources Infra Node Flavor",
	NodeFieldNodeResourcesExternalVolumeSize:  "Node Resources External Volume Size",
	NodeFieldNodeResourcesGpusModelId:         "Node Resources Gpus Model Id",
	NodeFieldNodeResourcesGpusCount:           "Node Resources Gpus Count",
	NodeFieldNodeResourcesGpusVendor:          "Node Resources Gpus Vendor",
	NodeFieldNodeResourcesGpusMemory:          "Node Resources Gpus Memory",
	NodeFieldNodeResourcesGpusInUse:           "Node Resources Gpus In Use",
	NodeFieldNodeResourcesNodeName:            "Node Resources Node Name",
	NodeFieldRole:                             "Role",
	NodeFieldNodePool:                         "Node Pool",
	NodeFieldFlavorName:                       "Flavor Name",
	NodeFieldSkipNodeCheck:                    "Skip Node Check",
	NodeFieldObjId:                            "Obj Id",
}

func (m *Node) IsKeyField(s string) bool {
	return strings.HasPrefix(s, NodeFieldKey+".") || s == NodeFieldKey
}

func (m *Node) DiffFields(o *Node, fields *FieldMap) {
	if m.Key.Organization != o.Key.Organization {
		fields.Set(NodeFieldKeyOrganization)
		fields.Set(NodeFieldKey)
	}
	if m.Key.Name != o.Key.Name {
		fields.Set(NodeFieldKeyName)
		fields.Set(NodeFieldKey)
	}
	if m.CloudletKey.Organization != o.CloudletKey.Organization {
		fields.Set(NodeFieldCloudletKeyOrganization)
		fields.Set(NodeFieldCloudletKey)
	}
	if m.CloudletKey.Name != o.CloudletKey.Name {
		fields.Set(NodeFieldCloudletKeyName)
		fields.Set(NodeFieldCloudletKey)
	}
	if m.CloudletKey.FederatedOrganization != o.CloudletKey.FederatedOrganization {
		fields.Set(NodeFieldCloudletKeyFederatedOrganization)
		fields.Set(NodeFieldCloudletKey)
	}
	if m.Username != o.Username {
		fields.Set(NodeFieldUsername)
	}
	if m.PublicAddr != o.PublicAddr {
		fields.Set(NodeFieldPublicAddr)
	}
	if m.MgmtAddr != o.MgmtAddr {
		fields.Set(NodeFieldMgmtAddr)
	}
	if m.SshPort != o.SshPort {
		fields.Set(NodeFieldSshPort)
	}
	if m.Assignment != o.Assignment {
		fields.Set(NodeFieldAssignment)
	}
	if m.Health != o.Health {
		fields.Set(NodeFieldHealth)
	}
	if m.DynamicallyCreated != o.DynamicallyCreated {
		fields.Set(NodeFieldDynamicallyCreated)
	}
	if m.Owner != nil && o.Owner != nil {
		if m.Owner.Name != o.Owner.Name {
			fields.Set(NodeFieldOwnerName)
			fields.Set(NodeFieldOwner)
		}
		if m.Owner.Organization != o.Owner.Organization {
			fields.Set(NodeFieldOwnerOrganization)
			fields.Set(NodeFieldOwner)
		}
	} else if (m.Owner != nil && o.Owner == nil) || (m.Owner == nil && o.Owner != nil) {
		fields.Set(NodeFieldOwner)
	}
	if m.NodeResources != nil && o.NodeResources != nil {
		if m.NodeResources.Vcpus != o.NodeResources.Vcpus {
			fields.Set(NodeFieldNodeResourcesVcpus)
			fields.Set(NodeFieldNodeResources)
		}
		if m.NodeResources.Ram != o.NodeResources.Ram {
			fields.Set(NodeFieldNodeResourcesRam)
			fields.Set(NodeFieldNodeResources)
		}
		if m.NodeResources.Disk != o.NodeResources.Disk {
			fields.Set(NodeFieldNodeResourcesDisk)
			fields.Set(NodeFieldNodeResources)
		}
		if m.NodeResources.OptResMap != nil && o.NodeResources.OptResMap != nil {
			if len(m.NodeResources.OptResMap) != len(o.NodeResources.OptResMap) {
				fields.Set(NodeFieldNodeResourcesOptResMap)
				fields.Set(NodeFieldNodeResources)
			} else {
				for k1, _ := range m.NodeResources.OptResMap {
					_, vok1 := o.NodeResources.OptResMap[k1]
					if !vok1 {
						fields.Set(NodeFieldNodeResourcesOptResMap)
						fields.Set(NodeFieldNodeResources)
					} else {
						if m.NodeResources.OptResMap[k1] != o.NodeResources.OptResMap[k1] {
							fields.Set(NodeFieldNodeResourcesOptResMap)
							fields.Set(NodeFieldNodeResources)
							break
						}
					}
				}
			}
		} else if (m.NodeResources.OptResMap != nil && o.NodeResources.OptResMap == nil) || (m.NodeResources.OptResMap == nil && o.NodeResources.OptResMap != nil) {
			fields.Set(NodeFieldNodeResourcesOptResMap)
			fields.Set(NodeFieldNodeResources)
		}
		if m.NodeResources.InfraNodeFlavor != o.NodeResources.InfraNodeFlavor {
			fields.Set(NodeFieldNodeResourcesInfraNodeFlavor)
			fields.Set(NodeFieldNodeResources)
		}
		if m.NodeResources.ExternalVolumeSize != o.NodeResources.ExternalVolumeSize {
			fields.Set(NodeFieldNodeResourcesExternalVolumeSize)
			fields.Set(NodeFieldNodeResources)
		}
		if m.NodeResources.Gpus != nil && o.NodeResources.Gpus != nil {
			if len(m.NodeResources.Gpus) != len(o.NodeResources.Gpus) {
				fields.Set(NodeFieldNodeResourcesGpus)
				fields.Set(NodeFieldNodeResources)
			} else {
				for i1 := 0; i1 < len(m.NodeResources.Gpus); i1++ {
					if m.NodeResources.Gpus[i1].ModelId != o.NodeResources.Gpus[i1].ModelId {
						fields.Set(NodeFieldNodeResourcesGpusModelId)
						fields.Set(NodeFieldNodeResourcesGpus)
						fields.Set(NodeFieldNodeResources)
					}
					if m.NodeResources.Gpus[i1].Count != o.NodeResources.Gpus[i1].Count {
						fields.Set(NodeFieldNodeResourcesGpusCount)
						fields.Set(NodeFieldNodeResourcesGpus)
						fields.Set(NodeFieldNodeResources)
					}
					if m.NodeResources.Gpus[i1].Vendor != o.NodeResources.Gpus[i1].Vendor {
						fields.Set(NodeFieldNodeResourcesGpusVendor)
						fields.Set(NodeFieldNodeResourcesGpus)
						fields.Set(NodeFieldNodeResources)
					}
					if m.NodeResources.Gpus[i1].Memory != o.NodeResources.Gpus[i1].Memory {
						fields.Set(NodeFieldNodeResourcesGpusMemory)
						fields.Set(NodeFieldNodeResourcesGpus)
						fields.Set(NodeFieldNodeResources)
					}
					if m.NodeResources.Gpus[i1].InUse != o.NodeResources.Gpus[i1].InUse {
						fields.Set(NodeFieldNodeResourcesGpusInUse)
						fields.Set(NodeFieldNodeResourcesGpus)
						fields.Set(NodeFieldNodeResources)
					}
				}
			}
		} else if (m.NodeResources.Gpus != nil && o.NodeResources.Gpus == nil) || (m.NodeResources.Gpus == nil && o.NodeResources.Gpus != nil) {
			fields.Set(NodeFieldNodeResourcesGpus)
			fields.Set(NodeFieldNodeResources)
		}
		if m.NodeResources.NodeName != o.NodeResources.NodeName {
			fields.Set(NodeFieldNodeResourcesNodeName)
			fields.Set(NodeFieldNodeResources)
		}
	} else if (m.NodeResources != nil && o.NodeResources == nil) || (m.NodeResources == nil && o.NodeResources != nil) {
		fields.Set(NodeFieldNodeResources)
	}
	if m.Role != o.Role {
		fields.Set(NodeFieldRole)
	}
	if m.NodePool != o.NodePool {
		fields.Set(NodeFieldNodePool)
	}
	if m.FlavorName != o.FlavorName {
		fields.Set(NodeFieldFlavorName)
	}
	if m.SkipNodeCheck != o.SkipNodeCheck {
		fields.Set(NodeFieldSkipNodeCheck)
	}
	if m.ObjId != o.ObjId {
		fields.Set(NodeFieldObjId)
	}
}

func (m *Node) GetDiffFields(o *Node) *FieldMap {
	diffFields := NewFieldMap(nil)
	m.DiffFields(o, diffFields)
	return diffFields
}

var UpdateNodeFieldsMap = NewFieldMap(map[string]struct{}{
	NodeFieldCloudletKey:                      struct{}{},
	NodeFieldCloudletKeyOrganization:          struct{}{},
	NodeFieldCloudletKeyName:                  struct{}{},
	NodeFieldCloudletKeyFederatedOrganization: struct{}{},
	NodeFieldUsername:                         struct{}{},
	NodeFieldPublicAddr:                       struct{}{},
	NodeFieldMgmtAddr:                         struct{}{},
	NodeFieldSshPort:                          struct{}{},
	NodeFieldHealth:                           struct{}{},
	NodeFieldNodeResources:                    struct{}{},
	NodeFieldNodeResourcesVcpus:               struct{}{},
	NodeFieldNodeResourcesRam:                 struct{}{},
	NodeFieldNodeResourcesDisk:                struct{}{},
	NodeFieldNodeResourcesOptResMap:           struct{}{},
	NodeFieldNodeResourcesOptResMapKey:        struct{}{},
	NodeFieldNodeResourcesOptResMapValue:      struct{}{},
	NodeFieldNodeResourcesInfraNodeFlavor:     struct{}{},
	NodeFieldNodeResourcesExternalVolumeSize:  struct{}{},
	NodeFieldNodeResourcesGpus:                struct{}{},
	NodeFieldNodeResourcesGpusModelId:         struct{}{},
	NodeFieldNodeResourcesGpusCount:           struct{}{},
	NodeFieldNodeResourcesGpusVendor:          struct{}{},
	NodeFieldNodeResourcesGpusMemory:          struct{}{},
	NodeFieldNodeResourcesGpusInUse:           struct{}{},
	NodeFieldNodeResourcesNodeName:            struct{}{},
	NodeFieldSkipNodeCheck:                    struct{}{},
})

func (m *Node) ValidateUpdateFields() error {
	return m.ValidateUpdateFieldsCustom(UpdateNodeFieldsMap)
}

func (m *Node) ValidateUpdateFieldsCustom(allowedFields *FieldMap) error {
	if m.Fields == nil {
		return fmt.Errorf("nothing specified to update")
	}
	fmap := MakeFieldMap(m.Fields)
	badFieldStrs := []string{}
	for _, field := range fmap.Fields() {
		if m.IsKeyField(field) {
			continue
		}
		if !allowedFields.Has(field) {
			if _, ok := NodeAllFieldsStringMap[field]; !ok {
				continue
			}
			badFieldStrs = append(badFieldStrs, NodeAllFieldsStringMap[field])
		}
	}
	if len(badFieldStrs) > 0 {
		return fmt.Errorf("specified field(s) %s cannot be modified", strings.Join(badFieldStrs, ","))
	}
	return nil
}

func (m *Node) Clone() *Node {
	cp := &Node{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *Node) AddNodeResourcesGpus(vals ...*GPUResource) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.NodeResources.Gpus {
		cur[v.GetKey().GetKeyString()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.GetKey().GetKeyString()]; found {
			continue // duplicate
		}
		m.NodeResources.Gpus = append(m.NodeResources.Gpus, v)
		changes++
	}
	return changes
}

func (m *Node) RemoveNodeResourcesGpus(vals ...*GPUResource) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.GetKey().GetKeyString()] = struct{}{}
	}
	for i := len(m.NodeResources.Gpus); i >= 0; i-- {
		if _, found := remove[m.NodeResources.Gpus[i].GetKey().GetKeyString()]; found {
			m.NodeResources.Gpus = append(m.NodeResources.Gpus[:i], m.NodeResources.Gpus[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *Node) CopyInFields(src *Node) int {
	updateListAction := "replace"
	changed := 0
	fmap := MakeFieldMap(src.Fields)
	if fmap.HasOrHasChild("2") {
		if fmap.Has("2.1") {
			if m.Key.Organization != src.Key.Organization {
				m.Key.Organization = src.Key.Organization
				changed++
			}
		}
		if fmap.Has("2.2") {
			if m.Key.Name != src.Key.Name {
				m.Key.Name = src.Key.Name
				changed++
			}
		}
	}
	if fmap.HasOrHasChild("3") {
		if fmap.Has("3.1") {
			if m.CloudletKey.Organization != src.CloudletKey.Organization {
				m.CloudletKey.Organization = src.CloudletKey.Organization
				changed++
			}
		}
		if fmap.Has("3.2") {
			if m.CloudletKey.Name != src.CloudletKey.Name {
				m.CloudletKey.Name = src.CloudletKey.Name
				changed++
			}
		}
		if fmap.Has("3.3") {
			if m.CloudletKey.FederatedOrganization != src.CloudletKey.FederatedOrganization {
				m.CloudletKey.FederatedOrganization = src.CloudletKey.FederatedOrganization
				changed++
			}
		}
	}
	if fmap.Has("4") {
		if m.Username != src.Username {
			m.Username = src.Username
			changed++
		}
	}
	if fmap.Has("5") {
		if m.PublicAddr != src.PublicAddr {
			m.PublicAddr = src.PublicAddr
			changed++
		}
	}
	if fmap.Has("6") {
		if m.MgmtAddr != src.MgmtAddr {
			m.MgmtAddr = src.MgmtAddr
			changed++
		}
	}
	if fmap.Has("7") {
		if m.SshPort != src.SshPort {
			m.SshPort = src.SshPort
			changed++
		}
	}
	if fmap.Has("8") {
		if m.Assignment != src.Assignment {
			m.Assignment = src.Assignment
			changed++
		}
	}
	if fmap.Has("9") {
		if m.Health != src.Health {
			m.Health = src.Health
			changed++
		}
	}
	if fmap.Has("10") {
		if m.DynamicallyCreated != src.DynamicallyCreated {
			m.DynamicallyCreated = src.DynamicallyCreated
			changed++
		}
	}
	if fmap.HasOrHasChild("11") {
		if src.Owner != nil {
			if m.Owner == nil {
				m.Owner = &ClusterKey{}
			}
			if fmap.Has("11.1") {
				if m.Owner.Name != src.Owner.Name {
					m.Owner.Name = src.Owner.Name
					changed++
				}
			}
			if fmap.Has("11.2") {
				if m.Owner.Organization != src.Owner.Organization {
					m.Owner.Organization = src.Owner.Organization
					changed++
				}
			}
		} else if m.Owner != nil {
			m.Owner = nil
			changed++
		}
	}
	if fmap.HasOrHasChild("12") {
		if src.NodeResources != nil {
			if m.NodeResources == nil {
				m.NodeResources = &NodeResources{}
			}
			if fmap.Has("12.1") {
				if m.NodeResources.Vcpus != src.NodeResources.Vcpus {
					m.NodeResources.Vcpus = src.NodeResources.Vcpus
					changed++
				}
			}
			if fmap.Has("12.2") {
				if m.NodeResources.Ram != src.NodeResources.Ram {
					m.NodeResources.Ram = src.NodeResources.Ram
					changed++
				}
			}
			if fmap.Has("12.3") {
				if m.NodeResources.Disk != src.NodeResources.Disk {
					m.NodeResources.Disk = src.NodeResources.Disk
					changed++
				}
			}
			if fmap.HasOrHasChild("12.4") {
				if src.NodeResources.OptResMap != nil {
					if updateListAction == "add" {
						for k1, v := range src.NodeResources.OptResMap {
							m.NodeResources.OptResMap[k1] = v
							changed++
						}
					} else if updateListAction == "remove" {
						for k1, _ := range src.NodeResources.OptResMap {
							if _, ok := m.NodeResources.OptResMap[k1]; ok {
								delete(m.NodeResources.OptResMap, k1)
								changed++
							}
						}
					} else {
						m.NodeResources.OptResMap = make(map[string]string)
						for k1, v := range src.NodeResources.OptResMap {
							m.NodeResources.OptResMap[k1] = v
						}
						changed++
					}
				} else if m.NodeResources.OptResMap != nil {
					m.NodeResources.OptResMap = nil
					changed++
				}
			}
			if fmap.Has("12.5") {
				if m.NodeResources.InfraNodeFlavor != src.NodeResources.InfraNodeFlavor {
					m.NodeResources.InfraNodeFlavor = src.NodeResources.InfraNodeFlavor
					changed++
				}
			}
			if fmap.Has("12.6") {
				if m.NodeResources.ExternalVolumeSize != src.NodeResources.ExternalVolumeSize {
					m.NodeResources.ExternalVolumeSize = src.NodeResources.ExternalVolumeSize
					changed++
				}
			}
			if fmap.HasOrHasChild("12.7") {
				if src.NodeResources.Gpus != nil {
					if updateListAction == "add" {
						changed += m.AddNodeResourcesGpus(src.NodeResources.Gpus...)
					} else if updateListAction == "remove" {
						changed += m.RemoveNodeResourcesGpus(src.NodeResources.Gpus...)
					} else {
						m.NodeResources.Gpus = make([]*GPUResource, 0)
						for k1, _ := range src.NodeResources.Gpus {
							m.NodeResources.Gpus = append(m.NodeResources.Gpus, src.NodeResources.Gpus[k1].Clone())
						}
						changed++
					}
				} else if m.NodeResources.Gpus != nil {
					m.NodeResources.Gpus = nil
					changed++
				}
			}
			if fmap.Has("12.8") {
				if m.NodeResources.NodeName != src.NodeResources.NodeName {
					m.NodeResources.NodeName = src.NodeResources.NodeName
					changed++
				}
			}
		} else if m.NodeResources != nil {
			m.NodeResources = nil
			changed++
		}
	}
	if fmap.Has("13") {
		if m.Role != src.Role {
			m.Role = src.Role
			changed++
		}
	}
	if fmap.Has("14") {
		if m.NodePool != src.NodePool {
			m.NodePool = src.NodePool
			changed++
		}
	}
	if fmap.Has("15") {
		if m.FlavorName != src.FlavorName {
			m.FlavorName = src.FlavorName
			changed++
		}
	}
	if fmap.Has("98") {
		if m.SkipNodeCheck != src.SkipNodeCheck {
			m.SkipNodeCheck = src.SkipNodeCheck
			changed++
		}
	}
	if fmap.Has("99") {
		if m.ObjId != src.ObjId {
			m.ObjId = src.ObjId
			changed++
		}
	}
	return changed
}

func (m *Node) DeepCopyIn(src *Node) {
	m.Key.DeepCopyIn(&src.Key)
	m.CloudletKey.DeepCopyIn(&src.CloudletKey)
	m.Username = src.Username
	m.PublicAddr = src.PublicAddr
	m.MgmtAddr = src.MgmtAddr
	m.SshPort = src.SshPort
	m.Assignment = src.Assignment
	m.Health = src.Health
	m.DynamicallyCreated = src.DynamicallyCreated
	if src.Owner != nil {
		var tmp_Owner ClusterKey
		tmp_Owner.DeepCopyIn(src.Owner)
		m.Owner = &tmp_Owner
	} else {
		m.Owner = nil
	}
	if src.NodeResources != nil {
		var tmp_NodeResources NodeResources
		tmp_NodeResources.DeepCopyIn(src.NodeResources)
		m.NodeResources = &tmp_NodeResources
	} else {
		m.NodeResources = nil
	}
	m.Role = src.Role
	m.NodePool = src.NodePool
	m.FlavorName = src.FlavorName
	m.SkipNodeCheck = src.SkipNodeCheck
	m.ObjId = src.ObjId
}

func (s *Node) HasFields() bool {
	return true
}

type NodeStore interface {
	Create(ctx context.Context, m *Node, wait func(int64)) (*Result, error)
	Update(ctx context.Context, m *Node, wait func(int64)) (*Result, error)
	Delete(ctx context.Context, m *Node, wait func(int64)) (*Result, error)
	Put(ctx context.Context, m *Node, wait func(int64), ops ...objstore.KVOp) (*Result, error)
	LoadOne(key string) (*Node, int64, error)
	Get(ctx context.Context, key *NodeKey, buf *Node) bool
	STMGet(stm concurrency.STM, key *NodeKey, buf *Node) bool
	STMPut(stm concurrency.STM, obj *Node, ops ...objstore.KVOp)
	STMDel(stm concurrency.STM, key *NodeKey)
	STMHas(stm concurrency.STM, key *NodeKey) bool
}

type NodeStoreImpl struct {
	kvstore objstore.KVStore
}

func NewNodeStore(kvstore objstore.KVStore) *NodeStoreImpl {
	return &NodeStoreImpl{kvstore: kvstore}
}

func (s *NodeStoreImpl) Create(ctx context.Context, m *Node, wait func(int64)) (*Result, error) {
	err := m.Validate(NodeAllFieldsMap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("Node", m.GetKey())
	val, err := json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Create(ctx, key, string(val))
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *NodeStoreImpl) Update(ctx context.Context, m *Node, wait func(int64)) (*Result, error) {
	fmap := MakeFieldMap(m.Fields)
	err := m.Validate(fmap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("Node", m.GetKey())
	var vers int64 = 0
	curBytes, vers, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, err
	}
	var cur Node
	err = json.Unmarshal(curBytes, &cur)
	if err != nil {
		return nil, err
	}
	cur.CopyInFields(m)
	// never save fields
	cur.Fields = nil
	val, err := json.Marshal(cur)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Update(ctx, key, string(val), vers)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *NodeStoreImpl) Put(ctx context.Context, m *Node, wait func(int64), ops ...objstore.KVOp) (*Result, error) {
	err := m.Validate(NodeAllFieldsMap)
	m.Fields = nil
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("Node", m.GetKey())
	var val []byte
	val, err = json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Put(ctx, key, string(val), ops...)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *NodeStoreImpl) Delete(ctx context.Context, m *Node, wait func(int64)) (*Result, error) {
	err := m.GetKey().ValidateKey()
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("Node", m.GetKey())
	rev, err := s.kvstore.Delete(ctx, key)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *NodeStoreImpl) LoadOne(key string) (*Node, int64, error) {
	val, rev, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, 0, err
	}
	var obj Node
	err = json.Unmarshal(val, &obj)
	if err != nil {
		log.DebugLog(log.DebugLevelApi, "Failed to parse Node data", "val", string(val), "err", err)
		return nil, 0, err
	}
	return &obj, rev, nil
}

func (s *NodeStoreImpl) Get(ctx context.Context, key *NodeKey, buf *Node) bool {
	keystr := objstore.DbKeyString("Node", key)
	val, _, _, err := s.kvstore.Get(keystr)
	if err != nil {
		return false
	}
	return s.parseGetData(val, buf)
}

func (s *NodeStoreImpl) STMGet(stm concurrency.STM, key *NodeKey, buf *Node) bool {
	keystr := objstore.DbKeyString("Node", key)
	valstr := stm.Get(keystr)
	return s.parseGetData([]byte(valstr), buf)
}

func (s *NodeStoreImpl) STMHas(stm concurrency.STM, key *NodeKey) bool {
	keystr := objstore.DbKeyString("Node", key)
	return stm.Get(keystr) != ""
}

func (s *NodeStoreImpl) parseGetData(val []byte, buf *Node) bool {
	if len(val) == 0 {
		return false
	}
	if buf != nil {
		// clear buf, because empty values in val won't
		// overwrite non-empty values in buf.
		*buf = Node{}
		err := json.Unmarshal(val, buf)
		if err != nil {
			return false
		}
	}
	return true
}

func (s *NodeStoreImpl) STMPut(stm concurrency.STM, obj *Node, ops ...objstore.KVOp) {
	keystr := objstore.DbKeyString("Node", obj.GetKey())

	val, err := json.Marshal(obj)
	if err != nil {
		log.InfoLog("Node json marshal failed", "obj", obj, "err", err)
	}
	v3opts := GetSTMOpts(ops...)
	stm.Put(keystr, string(val), v3opts...)
}

func (s *NodeStoreImpl) STMDel(stm concurrency.STM, key *NodeKey) {
	keystr := objstore.DbKeyString("Node", key)
	stm.Del(keystr)
}

func StoreListNode(ctx context.Context, kvstore objstore.KVStore) ([]Node, error) {
	keyPrefix := objstore.DbKeyPrefixString("Node") + "/"
	objs := []Node{}
	err := kvstore.List(keyPrefix, func(key, val []byte, rev, modRev int64) error {
		obj := Node{}
		err := json.Unmarshal(val, &obj)
		if err != nil {
			return fmt.Errorf("failed to unmarshal Node json %s, %s", string(val), err)
		}
		objs = append(objs, obj)
		return nil
	})
	return objs, err
}

type NodeKeyWatcher struct {
	cb func(ctx context.Context)
}

type NodeCacheData struct {
	Obj    *Node
	ModRev int64
}

func (s *NodeCacheData) Clone() *NodeCacheData {
	cp := NodeCacheData{}
	if s.Obj != nil {
		cp.Obj = &Node{}
		cp.Obj.DeepCopyIn(s.Obj)
	}
	cp.ModRev = s.ModRev
	return &cp
}

// NodeCache caches Node objects in memory in a hash table
// and keeps them in sync with the database.
type NodeCache struct {
	Objs          map[NodeKey]*NodeCacheData
	Mux           util.Mutex
	List          map[NodeKey]struct{}
	FlushAll      bool
	NotifyCbs     []func(ctx context.Context, obj *Node, modRev int64)
	UpdatedCbs    []func(ctx context.Context, old *Node, new *Node)
	DeletedCbs    []func(ctx context.Context, old *Node)
	KeyWatchers   map[NodeKey][]*NodeKeyWatcher
	UpdatedKeyCbs []func(ctx context.Context, key *NodeKey)
	DeletedKeyCbs []func(ctx context.Context, key *NodeKey)
	Store         NodeStore
}

func NewNodeCache() *NodeCache {
	cache := NodeCache{}
	InitNodeCache(&cache)
	return &cache
}

func InitNodeCache(cache *NodeCache) {
	cache.Objs = make(map[NodeKey]*NodeCacheData)
	cache.KeyWatchers = make(map[NodeKey][]*NodeKeyWatcher)
	cache.NotifyCbs = nil
	cache.UpdatedCbs = nil
	cache.DeletedCbs = nil
	cache.UpdatedKeyCbs = nil
	cache.DeletedKeyCbs = nil
}

func (c *NodeCache) GetTypeString() string {
	return "Node"
}

func (c *NodeCache) Get(key *NodeKey, valbuf *Node) bool {
	var modRev int64
	return c.GetWithRev(key, valbuf, &modRev)
}

// STMGet gets from the store if STM is set, otherwise gets from cache
func (c *NodeCache) STMGet(ostm *OptionalSTM, key *NodeKey, valbuf *Node) bool {
	if ostm.stm != nil {
		if c.Store == nil {
			// panic, otherwise if we fallback to cache, we may silently
			// introduce race conditions and intermittent failures due to
			// reading from cache during a transaction.
			panic("NodeCache store not set, cannot read via STM")
		}
		return c.Store.STMGet(ostm.stm, key, valbuf)
	}
	var modRev int64
	return c.GetWithRev(key, valbuf, &modRev)
}

func (c *NodeCache) GetWithRev(key *NodeKey, valbuf *Node, modRev *int64) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	inst, found := c.Objs[*key]
	if found {
		valbuf.DeepCopyIn(inst.Obj)
		*modRev = inst.ModRev
	}
	return found
}

func (c *NodeCache) HasKey(key *NodeKey) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	_, found := c.Objs[*key]
	return found
}

func (c *NodeCache) GetAllKeys(ctx context.Context, cb func(key *NodeKey, modRev int64)) {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for key, data := range c.Objs {
		cb(&key, data.ModRev)
	}
}

func (c *NodeCache) GetAllLocked(ctx context.Context, cb func(obj *Node, modRev int64)) {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for _, data := range c.Objs {
		cb(data.Obj, data.ModRev)
	}
}

func (c *NodeCache) Update(ctx context.Context, in *Node, modRev int64) {
	c.UpdateModFunc(ctx, in.GetKey(), modRev, func(old *Node) (*Node, bool) {
		return in, true
	})
}

func (c *NodeCache) UpdateModFunc(ctx context.Context, key *NodeKey, modRev int64, modFunc func(old *Node) (new *Node, changed bool)) {
	c.Mux.Lock()
	var old *Node
	if oldData, found := c.Objs[*key]; found {
		old = oldData.Obj
	}
	new, changed := modFunc(old)
	if !changed {
		c.Mux.Unlock()
		return
	}
	if len(c.UpdatedCbs) > 0 || len(c.NotifyCbs) > 0 {
		newCopy := &Node{}
		newCopy.DeepCopyIn(new)
		for _, cb := range c.UpdatedCbs {
			defer cb(ctx, old, newCopy)
		}
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				defer cb(ctx, newCopy, modRev)
			}
		}
	}
	for _, cb := range c.UpdatedKeyCbs {
		defer cb(ctx, key)
	}
	store := &Node{}
	store.DeepCopyIn(new)
	c.Objs[new.GetKeyVal()] = &NodeCacheData{
		Obj:    store,
		ModRev: modRev,
	}
	log.SpanLog(ctx, log.DebugLevelApi, "cache update", "new", store)
	c.Mux.Unlock()
	c.TriggerKeyWatchers(ctx, new.GetKey())
}

func (c *NodeCache) Delete(ctx context.Context, in *Node, modRev int64) {
	c.DeleteCondFunc(ctx, in, modRev, func(old *Node) bool {
		return true
	})
}

func (c *NodeCache) DeleteCondFunc(ctx context.Context, in *Node, modRev int64, condFunc func(old *Node) bool) {
	c.Mux.Lock()
	var old *Node
	oldData, found := c.Objs[in.GetKeyVal()]
	if found {
		old = oldData.Obj
		if !condFunc(old) {
			c.Mux.Unlock()
			return
		}
	}
	delete(c.Objs, in.GetKeyVal())
	log.SpanLog(ctx, log.DebugLevelApi, "cache delete", "key", in.GetKeyVal())
	c.Mux.Unlock()
	obj := old
	if obj == nil {
		obj = in
	}
	for _, cb := range c.NotifyCbs {
		if cb != nil {
			cb(ctx, obj, modRev)
		}
	}
	if old != nil {
		for _, cb := range c.DeletedCbs {
			cb(ctx, old)
		}
	}
	for _, cb := range c.DeletedKeyCbs {
		cb(ctx, in.GetKey())
	}
	c.TriggerKeyWatchers(ctx, in.GetKey())
}

func (c *NodeCache) Prune(ctx context.Context, validKeys map[NodeKey]struct{}) {
	log.SpanLog(ctx, log.DebugLevelApi, "Prune Node", "numValidKeys", len(validKeys))
	notify := make(map[NodeKey]*NodeCacheData)
	c.Mux.Lock()
	for key, _ := range c.Objs {
		if _, ok := validKeys[key]; !ok {
			if len(c.NotifyCbs) > 0 || len(c.DeletedKeyCbs) > 0 || len(c.DeletedCbs) > 0 {
				notify[key] = c.Objs[key]
			}
			delete(c.Objs, key)
		}
	}
	c.Mux.Unlock()
	for key, old := range notify {
		obj := old.Obj
		if obj == nil {
			obj = &Node{}
			obj.SetKey(&key)
		}
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, obj, old.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if old.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, old.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (c *NodeCache) GetCount() int {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	return len(c.Objs)
}

func (c *NodeCache) Flush(ctx context.Context, notifyId int64) {
}

func (c *NodeCache) Show(filter *Node, cb func(ret *Node) error) error {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for _, data := range c.Objs {
		if !data.Obj.Matches(filter, MatchFilter()) {
			continue
		}
		err := cb(data.Obj)
		if err != nil {
			return err
		}
	}
	return nil
}

func NodeGenericNotifyCb(fn func(key *NodeKey, old *Node)) func(objstore.ObjKey, objstore.Obj) {
	return func(objkey objstore.ObjKey, obj objstore.Obj) {
		fn(objkey.(*NodeKey), obj.(*Node))
	}
}

func (c *NodeCache) SetNotifyCb(fn func(ctx context.Context, obj *Node, modRev int64)) {
	c.NotifyCbs = []func(ctx context.Context, obj *Node, modRev int64){fn}
}

func (c *NodeCache) SetUpdatedCb(fn func(ctx context.Context, old *Node, new *Node)) {
	c.UpdatedCbs = []func(ctx context.Context, old *Node, new *Node){fn}
}

func (c *NodeCache) SetDeletedCb(fn func(ctx context.Context, old *Node)) {
	c.DeletedCbs = []func(ctx context.Context, old *Node){fn}
}

func (c *NodeCache) SetUpdatedKeyCb(fn func(ctx context.Context, key *NodeKey)) {
	c.UpdatedKeyCbs = []func(ctx context.Context, key *NodeKey){fn}
}

func (c *NodeCache) SetDeletedKeyCb(fn func(ctx context.Context, key *NodeKey)) {
	c.DeletedKeyCbs = []func(ctx context.Context, key *NodeKey){fn}
}

func (c *NodeCache) AddUpdatedCb(fn func(ctx context.Context, old *Node, new *Node)) {
	c.UpdatedCbs = append(c.UpdatedCbs, fn)
}

func (c *NodeCache) AddDeletedCb(fn func(ctx context.Context, old *Node)) {
	c.DeletedCbs = append(c.DeletedCbs, fn)
}

func (c *NodeCache) AddNotifyCb(fn func(ctx context.Context, obj *Node, modRev int64)) {
	c.NotifyCbs = append(c.NotifyCbs, fn)
}

func (c *NodeCache) AddUpdatedKeyCb(fn func(ctx context.Context, key *NodeKey)) {
	c.UpdatedKeyCbs = append(c.UpdatedKeyCbs, fn)
}

func (c *NodeCache) AddDeletedKeyCb(fn func(ctx context.Context, key *NodeKey)) {
	c.DeletedKeyCbs = append(c.DeletedKeyCbs, fn)
}

func (c *NodeCache) SetFlushAll() {
	c.FlushAll = true
}

func (c *NodeCache) WatchKey(key *NodeKey, cb func(ctx context.Context)) context.CancelFunc {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	list, ok := c.KeyWatchers[*key]
	if !ok {
		list = make([]*NodeKeyWatcher, 0)
	}
	watcher := NodeKeyWatcher{cb: cb}
	c.KeyWatchers[*key] = append(list, &watcher)
	log.DebugLog(log.DebugLevelApi, "Watching Node", "key", key)
	return func() {
		c.Mux.Lock()
		defer c.Mux.Unlock()
		list, ok := c.KeyWatchers[*key]
		if !ok {
			return
		}
		for ii, _ := range list {
			if list[ii] != &watcher {
				continue
			}
			if len(list) == 1 {
				delete(c.KeyWatchers, *key)
				return
			}
			list[ii] = list[len(list)-1]
			list[len(list)-1] = nil
			c.KeyWatchers[*key] = list[:len(list)-1]
			return
		}
	}
}

func (c *NodeCache) TriggerKeyWatchers(ctx context.Context, key *NodeKey) {
	watchers := make([]*NodeKeyWatcher, 0)
	c.Mux.Lock()
	if list, ok := c.KeyWatchers[*key]; ok {
		watchers = append(watchers, list...)
	}
	c.Mux.Unlock()
	for ii, _ := range watchers {
		watchers[ii].cb(ctx)
	}
}

// Note that we explicitly ignore the global revision number, because of the way
// the notify framework sends updates (by hashing keys and doing lookups, instead
// of sequentially through a history buffer), updates may be done out-of-order
// or multiple updates compressed into one update, so the state of the cache at
// any point in time may not by in sync with a particular database revision number.

func (c *NodeCache) SyncUpdate(ctx context.Context, key, val []byte, rev, modRev int64) {
	obj := Node{}
	err := json.Unmarshal(val, &obj)
	if err != nil {
		log.WarnLog("Failed to parse Node data", "val", string(val), "err", err)
		return
	}
	c.Update(ctx, &obj, modRev)
	c.Mux.Lock()
	if c.List != nil {
		c.List[obj.GetKeyVal()] = struct{}{}
	}
	c.Mux.Unlock()
}

func (c *NodeCache) SyncDelete(ctx context.Context, key []byte, rev, modRev int64) {
	obj := Node{}
	keystr := objstore.DbKeyPrefixRemove(string(key))
	NodeKeyStringParse(keystr, obj.GetKey())
	c.Delete(ctx, &obj, modRev)
}

func (c *NodeCache) SyncListStart(ctx context.Context) {
	c.List = make(map[NodeKey]struct{})
}

func (c *NodeCache) SyncListEnd(ctx context.Context) {
	deleted := make(map[NodeKey]*NodeCacheData)
	c.Mux.Lock()
	for key, val := range c.Objs {
		if _, found := c.List[key]; !found {
			deleted[key] = val
			delete(c.Objs, key)
		}
	}
	c.List = nil
	c.Mux.Unlock()
	for key, val := range deleted {
		obj := val.Obj
		if obj == nil {
			obj = &Node{}
			obj.SetKey(&key)
		}
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, obj, val.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if val.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, val.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (s *NodeCache) InitCacheWithSync(sync DataSync) {
	InitNodeCache(s)
	s.InitSync(sync)
}

func (s *NodeCache) InitSync(sync DataSync) {
	if sync != nil {
		s.Store = NewNodeStore(sync.GetKVStore())
		sync.RegisterCache(s)
	}
}

func InitNodeCacheWithStore(cache *NodeCache, store NodeStore) {
	InitNodeCache(cache)
	cache.Store = store
}

func (c *NodeCache) UsesOrg(org string) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for key, _ := range c.Objs {
		if key.Organization == org {
			return true
		}
	}
	return false
}

func (m *Node) GetObjKey() objstore.ObjKey {
	return m.GetKey()
}

func (m *Node) GetKey() *NodeKey {
	return &m.Key
}

func (m *Node) GetKeyVal() NodeKey {
	return m.Key
}

func (m *Node) SetKey(key *NodeKey) {
	m.Key = *key
}

func CmpSortNode(a Node, b Node) bool {
	return a.Key.GetKeyString() < b.Key.GetKeyString()
}

// Helper method to check that enums have valid values
// NOTE: ValidateEnums checks all Fields even if some are not set
func (m *Node) ValidateEnums() error {
	if err := m.Key.ValidateEnums(); err != nil {
		return err
	}
	if err := m.CloudletKey.ValidateEnums(); err != nil {
		return err
	}
	if m.Owner != nil {
		if err := m.Owner.ValidateEnums(); err != nil {
			return err
		}
	}
	if m.NodeResources != nil {
		if err := m.NodeResources.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (s *Node) ClearTagged(tags map[string]struct{}) {
	s.Key.ClearTagged(tags)
	s.CloudletKey.ClearTagged(tags)
	if s.Owner != nil {
		s.Owner.ClearTagged(tags)
	}
	if s.NodeResources != nil {
		s.NodeResources.ClearTagged(tags)
	}
	if _, found := tags["nocmp"]; found {
		s.ObjId = ""
	}
}

func IgnoreNodeFields(taglist string) cmp.Option {
	names := []string{}
	tags := make(map[string]struct{})
	for _, tag := range strings.Split(taglist, ",") {
		tags[tag] = struct{}{}
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "ObjId")
	}
	return cmpopts.IgnoreFields(Node{}, names...)
}

func (m *Node) IsValidArgsForCreateNode() error {
	if m.Assignment != "" {
		return fmt.Errorf("Invalid field specified: Assignment, this field is only for internal use")
	}
	if m.DynamicallyCreated != false {
		return fmt.Errorf("Invalid field specified: DynamicallyCreated, this field is only for internal use")
	}
	if m.Owner != nil {
		return fmt.Errorf("Invalid field specified: Owner, this field is only for internal use")
	}
	if m.Role != "" {
		return fmt.Errorf("Invalid field specified: Role, this field is only for internal use")
	}
	if m.NodePool != "" {
		return fmt.Errorf("Invalid field specified: NodePool, this field is only for internal use")
	}
	if m.FlavorName != "" {
		return fmt.Errorf("Invalid field specified: FlavorName, this field is only for internal use")
	}
	if m.ObjId != "" {
		return fmt.Errorf("Invalid field specified: ObjId, this field is only for internal use")
	}
	return nil
}

func (m *Node) IsValidArgsForDeleteNode() error {
	if m.Assignment != "" {
		return fmt.Errorf("Invalid field specified: Assignment, this field is only for internal use")
	}
	if m.DynamicallyCreated != false {
		return fmt.Errorf("Invalid field specified: DynamicallyCreated, this field is only for internal use")
	}
	if m.Owner != nil {
		return fmt.Errorf("Invalid field specified: Owner, this field is only for internal use")
	}
	if m.Role != "" {
		return fmt.Errorf("Invalid field specified: Role, this field is only for internal use")
	}
	if m.NodePool != "" {
		return fmt.Errorf("Invalid field specified: NodePool, this field is only for internal use")
	}
	if m.FlavorName != "" {
		return fmt.Errorf("Invalid field specified: FlavorName, this field is only for internal use")
	}
	if m.ObjId != "" {
		return fmt.Errorf("Invalid field specified: ObjId, this field is only for internal use")
	}
	return nil
}

func (m *Node) IsValidArgsForUpdateNode() error {
	if m.Assignment != "" {
		return fmt.Errorf("Invalid field specified: Assignment, this field is only for internal use")
	}
	if m.DynamicallyCreated != false {
		return fmt.Errorf("Invalid field specified: DynamicallyCreated, this field is only for internal use")
	}
	if m.Owner != nil {
		return fmt.Errorf("Invalid field specified: Owner, this field is only for internal use")
	}
	if m.Role != "" {
		return fmt.Errorf("Invalid field specified: Role, this field is only for internal use")
	}
	if m.NodePool != "" {
		return fmt.Errorf("Invalid field specified: NodePool, this field is only for internal use")
	}
	if m.FlavorName != "" {
		return fmt.Errorf("Invalid field specified: FlavorName, this field is only for internal use")
	}
	if m.ObjId != "" {
		return fmt.Errorf("Invalid field specified: ObjId, this field is only for internal use")
	}
	return nil
}

func (m *NodeKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Organization)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	return n
}

func (m *Node) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovNode(uint64(l))
		}
	}
	l = m.Key.Size()
	n += 1 + l + sovNode(uint64(l))
	l = m.CloudletKey.Size()
	n += 1 + l + sovNode(uint64(l))
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	l = len(m.PublicAddr)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	l = len(m.MgmtAddr)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	if m.SshPort != 0 {
		n += 1 + sovNode(uint64(m.SshPort))
	}
	l = len(m.Assignment)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	l = len(m.Health)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	if m.DynamicallyCreated {
		n += 2
	}
	if m.Owner != nil {
		l = m.Owner.Size()
		n += 1 + l + sovNode(uint64(l))
	}
	if m.NodeResources != nil {
		l = m.NodeResources.Size()
		n += 1 + l + sovNode(uint64(l))
	}
	l = len(m.Role)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	l = len(m.NodePool)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	l = len(m.FlavorName)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	if m.SkipNodeCheck {
		n += 3
	}
	l = len(m.ObjId)
	if l > 0 {
		n += 2 + l + sovNode(uint64(l))
	}
	return n
}

func sovNode(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozNode(x uint64) (n int) {
	return sovNode(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *NodeKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Organization", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Organization = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudletKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CloudletKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MgmtAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MgmtAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SshPort", wireType)
			}
			m.SshPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SshPort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Assignment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Assignment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Health", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Health = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DynamicallyCreated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DynamicallyCreated = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Owner == nil {
				m.Owner = &ClusterKey{}
			}
			if err := m.Owner.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeResources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeResources == nil {
				m.NodeResources = &NodeResources{}
			}
			if err := m.NodeResources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Role = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodePool", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodePool = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlavorName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FlavorName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 98:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipNodeCheck", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SkipNodeCheck = bool(v != 0)
		case 99:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipNode(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowNode
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNode
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNode
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthNode
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupNode
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthNode
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthNode        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowNode          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupNode = fmt.Errorf("proto: unexpected end of group")
)
