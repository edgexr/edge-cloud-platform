// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: flavor.proto

package edgeproto

import (
	context "context"
	"encoding/json"
	fmt "fmt"
	"github.com/edgexr/edge-cloud-platform/pkg/log"
	"github.com/edgexr/edge-cloud-platform/pkg/objstore"
	"github.com/edgexr/edge-cloud-platform/pkg/util"
	_ "github.com/edgexr/edge-cloud-platform/tools/protogen"
	_ "github.com/gogo/googleapis/google/api"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	"go.etcd.io/etcd/client/v3/concurrency"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Flavor
//
// FlavorKey uniquely identifies a Flavor.
type FlavorKey struct {
	// Flavor name
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *FlavorKey) Reset()         { *m = FlavorKey{} }
func (m *FlavorKey) String() string { return proto.CompactTextString(m) }
func (*FlavorKey) ProtoMessage()    {}
func (*FlavorKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_827a674ddbd1f38f, []int{0}
}
func (m *FlavorKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FlavorKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FlavorKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FlavorKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlavorKey.Merge(m, src)
}
func (m *FlavorKey) XXX_Size() int {
	return m.Size()
}
func (m *FlavorKey) XXX_DiscardUnknown() {
	xxx_messageInfo_FlavorKey.DiscardUnknown(m)
}

var xxx_messageInfo_FlavorKey proto.InternalMessageInfo

// Flavors define the compute, memory, and storage capacity of computing instances.
// To put it simply, a flavor is an available hardware configuration for a server.
// It defines the size of a virtual server that can be launched.
type Flavor struct {
	// Fields are used for the Update API to specify which fields to apply
	Fields []string `protobuf:"bytes,1,rep,name=fields,proto3" json:"fields,omitempty"`
	// Unique key for the new flavor.
	Key FlavorKey `protobuf:"bytes,2,opt,name=key,proto3" json:"key"`
	// RAM in megabytes
	Ram uint64 `protobuf:"varint,3,opt,name=ram,proto3" json:"ram,omitempty"`
	// Number of virtual CPUs
	Vcpus uint64 `protobuf:"varint,4,opt,name=vcpus,proto3" json:"vcpus,omitempty"`
	// Amount of disk space in gigabytes
	Disk uint64 `protobuf:"varint,5,opt,name=disk,proto3" json:"disk,omitempty"`
	// GPUs
	Gpus []*GPUResource `protobuf:"bytes,8,rep,name=gpus,proto3" json:"gpus,omitempty"`
	// Optional Resources request, key = gpu
	// form: $resource=$kind:[$alias]$count ex: optresmap=gpu=vgpu:nvidia-63:1
	OptResMap map[string]string `protobuf:"bytes,6,rep,name=opt_res_map,json=optResMap,proto3" json:"opt_res_map,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Preparing to be deleted
	DeletePrepare bool `protobuf:"varint,7,opt,name=delete_prepare,json=deletePrepare,proto3" json:"delete_prepare,omitempty"`
}

func (m *Flavor) Reset()         { *m = Flavor{} }
func (m *Flavor) String() string { return proto.CompactTextString(m) }
func (*Flavor) ProtoMessage()    {}
func (*Flavor) Descriptor() ([]byte, []int) {
	return fileDescriptor_827a674ddbd1f38f, []int{1}
}
func (m *Flavor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Flavor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Flavor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Flavor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Flavor.Merge(m, src)
}
func (m *Flavor) XXX_Size() int {
	return m.Size()
}
func (m *Flavor) XXX_DiscardUnknown() {
	xxx_messageInfo_Flavor.DiscardUnknown(m)
}

var xxx_messageInfo_Flavor proto.InternalMessageInfo

func init() {
	proto.RegisterType((*FlavorKey)(nil), "edgeproto.FlavorKey")
	proto.RegisterType((*Flavor)(nil), "edgeproto.Flavor")
	proto.RegisterMapType((map[string]string)(nil), "edgeproto.Flavor.OptResMapEntry")
}

func init() { proto.RegisterFile("flavor.proto", fileDescriptor_827a674ddbd1f38f) }

var fileDescriptor_827a674ddbd1f38f = []byte{
	// 676 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x92, 0x41, 0x4f, 0x13, 0x41,
	0x14, 0xc7, 0x3b, 0x74, 0xa9, 0x74, 0x28, 0x45, 0x56, 0x42, 0x26, 0x0d, 0x2c, 0x4d, 0x0f, 0xa6,
	0xc1, 0xa6, 0x6b, 0xf0, 0xa2, 0x8d, 0x18, 0x5b, 0x51, 0x0f, 0x88, 0x92, 0x35, 0x70, 0x25, 0x63,
	0xf7, 0xb1, 0x6c, 0xda, 0xee, 0x6c, 0x66, 0xb6, 0x6d, 0x7a, 0x33, 0x7c, 0x02, 0xa2, 0x17, 0xe3,
	0xc9, 0xc4, 0x8b, 0x47, 0xe3, 0xd1, 0x4f, 0xc0, 0x91, 0xc4, 0x83, 0x9e, 0x8c, 0x16, 0x0f, 0x86,
	0x93, 0x09, 0x85, 0x78, 0x34, 0x3b, 0xb3, 0xd4, 0x12, 0x4c, 0x84, 0x44, 0x6f, 0xef, 0xbd, 0x79,
	0x33, 0xbf, 0xf7, 0xff, 0xbf, 0xc1, 0xa9, 0x8d, 0x3a, 0x6d, 0x31, 0x5e, 0xf4, 0x39, 0x0b, 0x98,
	0x9e, 0x04, 0xdb, 0x01, 0x19, 0x66, 0xa6, 0x1d, 0xc6, 0x9c, 0x3a, 0x98, 0xd4, 0x77, 0x4d, 0xea,
	0x79, 0x2c, 0xa0, 0x81, 0xcb, 0x3c, 0xa1, 0x1a, 0x33, 0x33, 0x01, 0x63, 0x75, 0x61, 0xca, 0xc4,
	0x01, 0xaf, 0x1f, 0x44, 0xc7, 0x29, 0x0e, 0xa2, 0x59, 0x0f, 0xa2, 0x6c, 0xd2, 0x61, 0x0e, 0x93,
	0xa1, 0x19, 0x46, 0x51, 0x75, 0x9c, 0x83, 0x60, 0x4d, 0x5e, 0x85, 0xe8, 0xcd, 0xdc, 0x0d, 0x9c,
	0xbc, 0x27, 0x87, 0x59, 0x82, 0x8e, 0x6e, 0x60, 0xcd, 0xa3, 0x0d, 0x20, 0x28, 0x8b, 0xf2, 0xc9,
	0x0a, 0x7e, 0x7f, 0x44, 0x12, 0x6a, 0x52, 0x4b, 0xd6, 0x4b, 0xa9, 0xef, 0x07, 0x04, 0xfd, 0x3c,
	0x20, 0xe8, 0xed, 0xab, 0x59, 0x94, 0x7b, 0x1d, 0xc7, 0x09, 0x75, 0x57, 0x9f, 0xc2, 0x89, 0x0d,
	0x17, 0xea, 0xb6, 0x20, 0x28, 0x1b, 0xcf, 0x27, 0xad, 0x28, 0xd3, 0x0b, 0x38, 0x5e, 0x83, 0x0e,
	0x19, 0xca, 0xa2, 0xfc, 0xe8, 0xfc, 0x64, 0xb1, 0x2f, 0xb4, 0xd8, 0x67, 0x56, 0xb4, 0x9d, 0xcf,
	0xb3, 0x31, 0x2b, 0x6c, 0xd3, 0x2f, 0xe2, 0x38, 0xa7, 0x0d, 0x12, 0xcf, 0xa2, 0xbc, 0x66, 0x85,
	0xa1, 0x3e, 0x89, 0x87, 0x5b, 0x55, 0xbf, 0x29, 0x88, 0x26, 0x6b, 0x2a, 0xd1, 0x75, 0xac, 0xd9,
	0xae, 0xa8, 0x91, 0x61, 0x59, 0x94, 0xb1, 0x3e, 0x87, 0x35, 0x27, 0x6c, 0x1c, 0xc9, 0xc6, 0xf3,
	0xa3, 0xf3, 0x53, 0x03, 0xa8, 0xfb, 0x2b, 0xab, 0x56, 0x24, 0xda, 0x92, 0x3d, 0xfa, 0x6d, 0x3c,
	0xca, 0xfc, 0x60, 0x9d, 0x83, 0x58, 0x6f, 0x50, 0x9f, 0x24, 0xe4, 0x95, 0xec, 0xa9, 0xe9, 0x8a,
	0x8f, 0xfc, 0xc0, 0x02, 0xb1, 0x4c, 0xfd, 0xbb, 0x5e, 0xc0, 0x3b, 0x56, 0x92, 0x1d, 0xe7, 0xfa,
	0x15, 0x9c, 0xb6, 0xa1, 0x0e, 0x01, 0xac, 0xfb, 0x1c, 0x7c, 0xca, 0x81, 0x5c, 0xc8, 0xa2, 0xfc,
	0x48, 0x45, 0x7b, 0xd3, 0x23, 0xc8, 0x1a, 0x53, 0x67, 0x2b, 0xea, 0x28, 0x73, 0x13, 0xa7, 0x4f,
	0xbe, 0x14, 0x0a, 0x0d, 0x6d, 0x91, 0x36, 0x2b, 0xe9, 0xa1, 0x50, 0x5a, 0x6f, 0x82, 0xb4, 0x2a,
	0x69, 0xa9, 0xa4, 0x34, 0x74, 0x1d, 0x95, 0x6e, 0x85, 0x9e, 0xff, 0x38, 0x20, 0xe8, 0x69, 0x8f,
	0xa0, 0xed, 0x1e, 0x41, 0x2f, 0x7a, 0x04, 0x3d, 0x3b, 0x24, 0x63, 0x8b, 0x83, 0x90, 0x97, 0x87,
	0x64, 0x2c, 0x5c, 0xd1, 0xc2, 0x12, 0x74, 0x8a, 0x0f, 0x69, 0x03, 0xde, 0x1d, 0x11, 0xcd, 0x63,
	0x1e, 0xcc, 0x7f, 0x1c, 0x3e, 0xde, 0x70, 0xd9, 0x77, 0xf5, 0x2d, 0x84, 0x53, 0x77, 0x38, 0xd0,
	0x00, 0xa2, 0xcd, 0x4d, 0x9c, 0x92, 0x9d, 0x19, 0x2c, 0x59, 0xf2, 0x4b, 0xe5, 0x1e, 0xec, 0xf7,
	0xc8, 0xcc, 0xb1, 0x8b, 0xaa, 0x4d, 0x14, 0xca, 0xd5, 0xf0, 0x73, 0x2e, 0x53, 0x8f, 0x3a, 0x50,
	0xe8, 0x1e, 0x92, 0xb4, 0x45, 0x1b, 0x85, 0xb5, 0x70, 0x43, 0x85, 0x45, 0x57, 0xd4, 0xb6, 0x3e,
	0x7c, 0x7b, 0x3e, 0x74, 0x29, 0x97, 0x36, 0xab, 0x92, 0x67, 0xaa, 0x9f, 0x54, 0x42, 0x73, 0xba,
	0x8f, 0x53, 0x6a, 0xf8, 0x73, 0xcd, 0x50, 0xfa, 0xeb, 0x0c, 0x7d, 0xa2, 0xf2, 0xff, 0x24, 0x71,
	0xd5, 0xb7, 0xe9, 0xff, 0x23, 0x36, 0xe5, 0xeb, 0x03, 0xc4, 0x36, 0xc6, 0x8f, 0x37, 0x59, 0xfb,
	0x6c, 0x3c, 0x55, 0xca, 0x95, 0xf7, 0x7b, 0xe4, 0xf2, 0x9f, 0x79, 0x6b, 0x2e, 0xb4, 0x0b, 0xa2,
	0xe6, 0xfa, 0xe0, 0x6d, 0x30, 0x5e, 0x05, 0x09, 0x9e, 0xc8, 0xa5, 0x4c, 0xb1, 0xc9, 0xda, 0xbf,
	0xb1, 0x57, 0x51, 0x28, 0xb5, 0x6c, 0xdb, 0xea, 0xb6, 0x05, 0xe2, 0xdf, 0x4b, 0xa5, 0xb6, 0xcd,
	0x41, 0x0c, 0x48, 0x6d, 0xe1, 0x71, 0x0b, 0x1a, 0xac, 0x05, 0xe7, 0x85, 0x2e, 0x9c, 0x0d, 0x3a,
	0x95, 0x9b, 0x30, 0xb9, 0x04, 0x9c, 0xe0, 0x56, 0xa6, 0x77, 0xbe, 0x1a, 0xb1, 0x9d, 0xae, 0x81,
	0x76, 0xbb, 0x06, 0xfa, 0xd2, 0x35, 0xd0, 0xf6, 0x9e, 0x11, 0xdb, 0xdd, 0x33, 0x62, 0x9f, 0xf6,
	0x8c, 0xd8, 0x93, 0x84, 0x44, 0x5d, 0xfb, 0x15, 0x00, 0x00, 0xff, 0xff, 0x42, 0xfc, 0x6d, 0x4c,
	0x6c, 0x05, 0x00, 0x00,
}

func (this *FlavorKey) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&edgeproto.FlavorKey{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringFlavor(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// FlavorApiClient is the client API for FlavorApi service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type FlavorApiClient interface {
	// Create a Flavor
	CreateFlavor(ctx context.Context, in *Flavor, opts ...grpc.CallOption) (*Result, error)
	// Delete a Flavor
	DeleteFlavor(ctx context.Context, in *Flavor, opts ...grpc.CallOption) (*Result, error)
	// Update a Flavor
	UpdateFlavor(ctx context.Context, in *Flavor, opts ...grpc.CallOption) (*Result, error)
	// Show Flavors
	ShowFlavor(ctx context.Context, in *Flavor, opts ...grpc.CallOption) (FlavorApi_ShowFlavorClient, error)
	// Add Optional Resource
	AddFlavorRes(ctx context.Context, in *Flavor, opts ...grpc.CallOption) (*Result, error)
	// Remove Optional Resource
	RemoveFlavorRes(ctx context.Context, in *Flavor, opts ...grpc.CallOption) (*Result, error)
}

type flavorApiClient struct {
	cc *grpc.ClientConn
}

func NewFlavorApiClient(cc *grpc.ClientConn) FlavorApiClient {
	return &flavorApiClient{cc}
}

func (c *flavorApiClient) CreateFlavor(ctx context.Context, in *Flavor, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/edgeproto.FlavorApi/CreateFlavor", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flavorApiClient) DeleteFlavor(ctx context.Context, in *Flavor, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/edgeproto.FlavorApi/DeleteFlavor", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flavorApiClient) UpdateFlavor(ctx context.Context, in *Flavor, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/edgeproto.FlavorApi/UpdateFlavor", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flavorApiClient) ShowFlavor(ctx context.Context, in *Flavor, opts ...grpc.CallOption) (FlavorApi_ShowFlavorClient, error) {
	stream, err := c.cc.NewStream(ctx, &_FlavorApi_serviceDesc.Streams[0], "/edgeproto.FlavorApi/ShowFlavor", opts...)
	if err != nil {
		return nil, err
	}
	x := &flavorApiShowFlavorClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type FlavorApi_ShowFlavorClient interface {
	Recv() (*Flavor, error)
	grpc.ClientStream
}

type flavorApiShowFlavorClient struct {
	grpc.ClientStream
}

func (x *flavorApiShowFlavorClient) Recv() (*Flavor, error) {
	m := new(Flavor)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *flavorApiClient) AddFlavorRes(ctx context.Context, in *Flavor, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/edgeproto.FlavorApi/AddFlavorRes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flavorApiClient) RemoveFlavorRes(ctx context.Context, in *Flavor, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/edgeproto.FlavorApi/RemoveFlavorRes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FlavorApiServer is the server API for FlavorApi service.
type FlavorApiServer interface {
	// Create a Flavor
	CreateFlavor(context.Context, *Flavor) (*Result, error)
	// Delete a Flavor
	DeleteFlavor(context.Context, *Flavor) (*Result, error)
	// Update a Flavor
	UpdateFlavor(context.Context, *Flavor) (*Result, error)
	// Show Flavors
	ShowFlavor(*Flavor, FlavorApi_ShowFlavorServer) error
	// Add Optional Resource
	AddFlavorRes(context.Context, *Flavor) (*Result, error)
	// Remove Optional Resource
	RemoveFlavorRes(context.Context, *Flavor) (*Result, error)
}

// UnimplementedFlavorApiServer can be embedded to have forward compatible implementations.
type UnimplementedFlavorApiServer struct {
}

func (*UnimplementedFlavorApiServer) CreateFlavor(ctx context.Context, req *Flavor) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateFlavor not implemented")
}
func (*UnimplementedFlavorApiServer) DeleteFlavor(ctx context.Context, req *Flavor) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteFlavor not implemented")
}
func (*UnimplementedFlavorApiServer) UpdateFlavor(ctx context.Context, req *Flavor) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateFlavor not implemented")
}
func (*UnimplementedFlavorApiServer) ShowFlavor(req *Flavor, srv FlavorApi_ShowFlavorServer) error {
	return status.Errorf(codes.Unimplemented, "method ShowFlavor not implemented")
}
func (*UnimplementedFlavorApiServer) AddFlavorRes(ctx context.Context, req *Flavor) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddFlavorRes not implemented")
}
func (*UnimplementedFlavorApiServer) RemoveFlavorRes(ctx context.Context, req *Flavor) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveFlavorRes not implemented")
}

func RegisterFlavorApiServer(s *grpc.Server, srv FlavorApiServer) {
	s.RegisterService(&_FlavorApi_serviceDesc, srv)
}

func _FlavorApi_CreateFlavor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Flavor)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlavorApiServer).CreateFlavor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.FlavorApi/CreateFlavor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlavorApiServer).CreateFlavor(ctx, req.(*Flavor))
	}
	return interceptor(ctx, in, info, handler)
}

func _FlavorApi_DeleteFlavor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Flavor)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlavorApiServer).DeleteFlavor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.FlavorApi/DeleteFlavor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlavorApiServer).DeleteFlavor(ctx, req.(*Flavor))
	}
	return interceptor(ctx, in, info, handler)
}

func _FlavorApi_UpdateFlavor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Flavor)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlavorApiServer).UpdateFlavor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.FlavorApi/UpdateFlavor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlavorApiServer).UpdateFlavor(ctx, req.(*Flavor))
	}
	return interceptor(ctx, in, info, handler)
}

func _FlavorApi_ShowFlavor_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Flavor)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(FlavorApiServer).ShowFlavor(m, &flavorApiShowFlavorServer{stream})
}

type FlavorApi_ShowFlavorServer interface {
	Send(*Flavor) error
	grpc.ServerStream
}

type flavorApiShowFlavorServer struct {
	grpc.ServerStream
}

func (x *flavorApiShowFlavorServer) Send(m *Flavor) error {
	return x.ServerStream.SendMsg(m)
}

func _FlavorApi_AddFlavorRes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Flavor)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlavorApiServer).AddFlavorRes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.FlavorApi/AddFlavorRes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlavorApiServer).AddFlavorRes(ctx, req.(*Flavor))
	}
	return interceptor(ctx, in, info, handler)
}

func _FlavorApi_RemoveFlavorRes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Flavor)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlavorApiServer).RemoveFlavorRes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.FlavorApi/RemoveFlavorRes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlavorApiServer).RemoveFlavorRes(ctx, req.(*Flavor))
	}
	return interceptor(ctx, in, info, handler)
}

var _FlavorApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "edgeproto.FlavorApi",
	HandlerType: (*FlavorApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateFlavor",
			Handler:    _FlavorApi_CreateFlavor_Handler,
		},
		{
			MethodName: "DeleteFlavor",
			Handler:    _FlavorApi_DeleteFlavor_Handler,
		},
		{
			MethodName: "UpdateFlavor",
			Handler:    _FlavorApi_UpdateFlavor_Handler,
		},
		{
			MethodName: "AddFlavorRes",
			Handler:    _FlavorApi_AddFlavorRes_Handler,
		},
		{
			MethodName: "RemoveFlavorRes",
			Handler:    _FlavorApi_RemoveFlavorRes_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ShowFlavor",
			Handler:       _FlavorApi_ShowFlavor_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "flavor.proto",
}

func (m *FlavorKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlavorKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FlavorKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintFlavor(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Flavor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Flavor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Flavor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Gpus) > 0 {
		for iNdEx := len(m.Gpus) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Gpus[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFlavor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if m.DeletePrepare {
		i--
		if m.DeletePrepare {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.OptResMap) > 0 {
		for k := range m.OptResMap {
			v := m.OptResMap[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintFlavor(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintFlavor(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintFlavor(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if m.Disk != 0 {
		i = encodeVarintFlavor(dAtA, i, uint64(m.Disk))
		i--
		dAtA[i] = 0x28
	}
	if m.Vcpus != 0 {
		i = encodeVarintFlavor(dAtA, i, uint64(m.Vcpus))
		i--
		dAtA[i] = 0x20
	}
	if m.Ram != 0 {
		i = encodeVarintFlavor(dAtA, i, uint64(m.Ram))
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFlavor(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Fields) > 0 {
		for iNdEx := len(m.Fields) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Fields[iNdEx])
			copy(dAtA[i:], m.Fields[iNdEx])
			i = encodeVarintFlavor(dAtA, i, uint64(len(m.Fields[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintFlavor(dAtA []byte, offset int, v uint64) int {
	offset -= sovFlavor(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *FlavorKey) Matches(o *FlavorKey, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !opts.Filter || o.Name != "" {
		if o.Name != m.Name {
			return false
		}
	}
	return true
}

func (m *FlavorKey) Clone() *FlavorKey {
	cp := &FlavorKey{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *FlavorKey) CopyInFields(src *FlavorKey) int {
	changed := 0
	if m.Name != src.Name {
		m.Name = src.Name
		changed++
	}
	return changed
}

func (m *FlavorKey) DeepCopyIn(src *FlavorKey) {
	m.Name = src.Name
}

func (m *FlavorKey) GetKeyString() string {
	key, err := json.Marshal(m)
	if err != nil {
		log.FatalLog("Failed to marshal FlavorKey key string", "obj", m)
	}
	return string(key)
}

func FlavorKeyStringParse(str string, key *FlavorKey) {
	err := json.Unmarshal([]byte(str), key)
	if err != nil {
		log.FatalLog("Failed to unmarshal FlavorKey key string", "str", str)
	}
}

func (m *FlavorKey) NotFoundError() error {
	return fmt.Errorf("Flavor key %s not found", m.GetKeyString())
}

func (m *FlavorKey) ExistsError() error {
	return fmt.Errorf("Flavor key %s already exists", m.GetKeyString())
}

func (m *FlavorKey) BeingDeletedError() error {
	return fmt.Errorf("Flavor %s is being deleted", m.GetKeyString())
}

var FlavorKeyTagName = "flavor"

func (m *FlavorKey) GetTags() map[string]string {
	tags := make(map[string]string)
	m.AddTags(tags)
	return tags
}

func (m *FlavorKey) AddTagsByFunc(addTag AddTagFunc) {
	addTag("flavor", m.Name)
}

func (m *FlavorKey) AddTags(tags map[string]string) {
	tagMap := TagMap(tags)
	m.AddTagsByFunc(tagMap.AddTag)
}

// Helper method to check that enums have valid values
func (m *FlavorKey) ValidateEnums() error {
	return nil
}

func (s *FlavorKey) ClearTagged(tags map[string]struct{}) {
}

func (m *Flavor) Matches(o *Flavor, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !m.Key.Matches(&o.Key, fopts...) {
		return false
	}
	if !opts.Filter || o.Ram != 0 {
		if o.Ram != m.Ram {
			return false
		}
	}
	if !opts.Filter || o.Vcpus != 0 {
		if o.Vcpus != m.Vcpus {
			return false
		}
	}
	if !opts.Filter || o.Disk != 0 {
		if o.Disk != m.Disk {
			return false
		}
	}
	if !opts.Filter || o.OptResMap != nil {
		if len(m.OptResMap) == 0 && len(o.OptResMap) > 0 || len(m.OptResMap) > 0 && len(o.OptResMap) == 0 {
			return false
		} else if m.OptResMap != nil && o.OptResMap != nil {
			if !opts.Filter && len(m.OptResMap) != len(o.OptResMap) {
				return false
			}
			for k, _ := range o.OptResMap {
				_, ok := m.OptResMap[k]
				if !ok {
					return false
				}
				if o.OptResMap[k] != m.OptResMap[k] {
					return false
				}
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.DeletePrepare != false {
			if o.DeletePrepare != m.DeletePrepare {
				return false
			}
		}
	}
	if !opts.Filter || o.Gpus != nil {
		if len(m.Gpus) == 0 && len(o.Gpus) > 0 || len(m.Gpus) > 0 && len(o.Gpus) == 0 {
			return false
		} else if m.Gpus != nil && o.Gpus != nil {
			if !opts.Filter && len(m.Gpus) != len(o.Gpus) {
				return false
			}
			found := 0
			for oIndex, _ := range o.Gpus {
				for mIndex, _ := range m.Gpus {
					if m.Gpus[mIndex].Matches(o.Gpus[oIndex], fopts...) {
						found++
						break
					}
				}
			}
			if found != len(o.Gpus) {
				return false
			}
		}
	}
	return true
}

const FlavorFieldKey = "2"
const FlavorFieldKeyName = "2.1"
const FlavorFieldRam = "3"
const FlavorFieldVcpus = "4"
const FlavorFieldDisk = "5"
const FlavorFieldOptResMap = "6"
const FlavorFieldOptResMapKey = "6.1"
const FlavorFieldOptResMapValue = "6.2"
const FlavorFieldDeletePrepare = "7"
const FlavorFieldGpus = "8"
const FlavorFieldGpusModelId = "8.1"
const FlavorFieldGpusCount = "8.2"
const FlavorFieldGpusVendor = "8.3"
const FlavorFieldGpusMemory = "8.4"
const FlavorFieldGpusInUse = "8.5"

var FlavorAllFields = []string{
	FlavorFieldKeyName,
	FlavorFieldKey,
	FlavorFieldRam,
	FlavorFieldVcpus,
	FlavorFieldDisk,
	FlavorFieldOptResMapKey,
	FlavorFieldOptResMapValue,
	FlavorFieldOptResMap,
	FlavorFieldDeletePrepare,
	FlavorFieldGpusModelId,
	FlavorFieldGpusCount,
	FlavorFieldGpusVendor,
	FlavorFieldGpusMemory,
	FlavorFieldGpusInUse,
	FlavorFieldGpus,
}

var FlavorAllFieldsMap = NewFieldMap(map[string]struct{}{
	FlavorFieldKeyName:        struct{}{},
	FlavorFieldKey:            struct{}{},
	FlavorFieldRam:            struct{}{},
	FlavorFieldVcpus:          struct{}{},
	FlavorFieldDisk:           struct{}{},
	FlavorFieldOptResMapKey:   struct{}{},
	FlavorFieldOptResMapValue: struct{}{},
	FlavorFieldOptResMap:      struct{}{},
	FlavorFieldDeletePrepare:  struct{}{},
	FlavorFieldGpusModelId:    struct{}{},
	FlavorFieldGpusCount:      struct{}{},
	FlavorFieldGpusVendor:     struct{}{},
	FlavorFieldGpusMemory:     struct{}{},
	FlavorFieldGpusInUse:      struct{}{},
	FlavorFieldGpus:           struct{}{},
})

var FlavorAllFieldsStringMap = map[string]string{
	FlavorFieldKeyName:        "Key Name",
	FlavorFieldKey:            "Key",
	FlavorFieldRam:            "Ram",
	FlavorFieldVcpus:          "Vcpus",
	FlavorFieldDisk:           "Disk",
	FlavorFieldOptResMapKey:   "Opt Res Map Key",
	FlavorFieldOptResMapValue: "Opt Res Map Value",
	FlavorFieldOptResMap:      "Opt Res Map",
	FlavorFieldDeletePrepare:  "Delete Prepare",
	FlavorFieldGpusModelId:    "Gpus Model Id",
	FlavorFieldGpusCount:      "Gpus Count",
	FlavorFieldGpusVendor:     "Gpus Vendor",
	FlavorFieldGpusMemory:     "Gpus Memory",
	FlavorFieldGpusInUse:      "Gpus In Use",
	FlavorFieldGpus:           "Gpus",
}

func (m *Flavor) IsKeyField(s string) bool {
	return strings.HasPrefix(s, FlavorFieldKey+".") || s == FlavorFieldKey
}

var FlavorBackendFieldsMap = map[string]struct{}{
	FlavorFieldDeletePrepare: struct{}{},
}

var FlavorNoConfigFieldsMap = map[string]struct{}{
	FlavorFieldDeletePrepare: struct{}{},
}

func (m *Flavor) DiffFields(o *Flavor, fields *FieldMap) {
	if m.Key.Name != o.Key.Name {
		fields.Set(FlavorFieldKeyName)
		fields.Set(FlavorFieldKey)
	}
	if m.Ram != o.Ram {
		fields.Set(FlavorFieldRam)
	}
	if m.Vcpus != o.Vcpus {
		fields.Set(FlavorFieldVcpus)
	}
	if m.Disk != o.Disk {
		fields.Set(FlavorFieldDisk)
	}
	if m.OptResMap != nil && o.OptResMap != nil {
		if len(m.OptResMap) != len(o.OptResMap) {
			fields.Set(FlavorFieldOptResMap)
		} else {
			for k0, _ := range m.OptResMap {
				_, vok0 := o.OptResMap[k0]
				if !vok0 {
					fields.Set(FlavorFieldOptResMap)
				} else {
					if m.OptResMap[k0] != o.OptResMap[k0] {
						fields.Set(FlavorFieldOptResMap)
						break
					}
				}
			}
		}
	} else if (m.OptResMap != nil && o.OptResMap == nil) || (m.OptResMap == nil && o.OptResMap != nil) {
		fields.Set(FlavorFieldOptResMap)
	}
	if m.DeletePrepare != o.DeletePrepare {
		fields.Set(FlavorFieldDeletePrepare)
	}
	if m.Gpus != nil && o.Gpus != nil {
		if len(m.Gpus) != len(o.Gpus) {
			fields.Set(FlavorFieldGpus)
		} else {
			for i0 := 0; i0 < len(m.Gpus); i0++ {
				if m.Gpus[i0].ModelId != o.Gpus[i0].ModelId {
					fields.Set(FlavorFieldGpusModelId)
					fields.Set(FlavorFieldGpus)
				}
				if m.Gpus[i0].Count != o.Gpus[i0].Count {
					fields.Set(FlavorFieldGpusCount)
					fields.Set(FlavorFieldGpus)
				}
				if m.Gpus[i0].Vendor != o.Gpus[i0].Vendor {
					fields.Set(FlavorFieldGpusVendor)
					fields.Set(FlavorFieldGpus)
				}
				if m.Gpus[i0].Memory != o.Gpus[i0].Memory {
					fields.Set(FlavorFieldGpusMemory)
					fields.Set(FlavorFieldGpus)
				}
				if m.Gpus[i0].InUse != o.Gpus[i0].InUse {
					fields.Set(FlavorFieldGpusInUse)
					fields.Set(FlavorFieldGpus)
				}
			}
		}
	} else if (m.Gpus != nil && o.Gpus == nil) || (m.Gpus == nil && o.Gpus != nil) {
		fields.Set(FlavorFieldGpus)
	}
}

func (m *Flavor) GetDiffFields(o *Flavor) *FieldMap {
	diffFields := NewFieldMap(nil)
	m.DiffFields(o, diffFields)
	return diffFields
}

var UpdateFlavorFieldsMap = NewFieldMap(map[string]struct{}{
	FlavorFieldRam:            struct{}{},
	FlavorFieldVcpus:          struct{}{},
	FlavorFieldDisk:           struct{}{},
	FlavorFieldOptResMap:      struct{}{},
	FlavorFieldOptResMapKey:   struct{}{},
	FlavorFieldOptResMapValue: struct{}{},
	FlavorFieldGpus:           struct{}{},
	FlavorFieldGpusModelId:    struct{}{},
	FlavorFieldGpusCount:      struct{}{},
	FlavorFieldGpusVendor:     struct{}{},
	FlavorFieldGpusMemory:     struct{}{},
	FlavorFieldGpusInUse:      struct{}{},
})

func (m *Flavor) ValidateUpdateFields() error {
	return m.ValidateUpdateFieldsCustom(UpdateFlavorFieldsMap)
}

func (m *Flavor) ValidateUpdateFieldsCustom(allowedFields *FieldMap) error {
	if m.Fields == nil {
		return fmt.Errorf("nothing specified to update")
	}
	fmap := MakeFieldMap(m.Fields)
	badFieldStrs := []string{}
	for _, field := range fmap.Fields() {
		if m.IsKeyField(field) {
			continue
		}
		if !allowedFields.Has(field) {
			if _, ok := FlavorAllFieldsStringMap[field]; !ok {
				continue
			}
			badFieldStrs = append(badFieldStrs, FlavorAllFieldsStringMap[field])
		}
	}
	if len(badFieldStrs) > 0 {
		return fmt.Errorf("specified field(s) %s cannot be modified", strings.Join(badFieldStrs, ","))
	}
	return nil
}

func (m *Flavor) Clone() *Flavor {
	cp := &Flavor{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *Flavor) AddGpus(vals ...*GPUResource) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.Gpus {
		cur[v.GetKey().GetKeyString()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.GetKey().GetKeyString()]; found {
			continue // duplicate
		}
		m.Gpus = append(m.Gpus, v)
		changes++
	}
	return changes
}

func (m *Flavor) RemoveGpus(vals ...*GPUResource) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.GetKey().GetKeyString()] = struct{}{}
	}
	for i := len(m.Gpus); i >= 0; i-- {
		if _, found := remove[m.Gpus[i].GetKey().GetKeyString()]; found {
			m.Gpus = append(m.Gpus[:i], m.Gpus[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *Flavor) CopyInFields(src *Flavor) int {
	updateListAction := "replace"
	changed := 0
	fmap := MakeFieldMap(src.Fields)
	if fmap.HasOrHasChild("2") {
		if fmap.Has("2.1") {
			if m.Key.Name != src.Key.Name {
				m.Key.Name = src.Key.Name
				changed++
			}
		}
	}
	if fmap.Has("3") {
		if m.Ram != src.Ram {
			m.Ram = src.Ram
			changed++
		}
	}
	if fmap.Has("4") {
		if m.Vcpus != src.Vcpus {
			m.Vcpus = src.Vcpus
			changed++
		}
	}
	if fmap.Has("5") {
		if m.Disk != src.Disk {
			m.Disk = src.Disk
			changed++
		}
	}
	if fmap.HasOrHasChild("6") {
		if src.OptResMap != nil {
			if updateListAction == "add" {
				for k0, v := range src.OptResMap {
					m.OptResMap[k0] = v
					changed++
				}
			} else if updateListAction == "remove" {
				for k0, _ := range src.OptResMap {
					if _, ok := m.OptResMap[k0]; ok {
						delete(m.OptResMap, k0)
						changed++
					}
				}
			} else {
				m.OptResMap = make(map[string]string)
				for k0, v := range src.OptResMap {
					m.OptResMap[k0] = v
				}
				changed++
			}
		} else if m.OptResMap != nil {
			m.OptResMap = nil
			changed++
		}
	}
	if fmap.Has("7") {
		if m.DeletePrepare != src.DeletePrepare {
			m.DeletePrepare = src.DeletePrepare
			changed++
		}
	}
	if fmap.HasOrHasChild("8") {
		if src.Gpus != nil {
			if updateListAction == "add" {
				changed += m.AddGpus(src.Gpus...)
			} else if updateListAction == "remove" {
				changed += m.RemoveGpus(src.Gpus...)
			} else {
				m.Gpus = make([]*GPUResource, 0)
				for k0, _ := range src.Gpus {
					m.Gpus = append(m.Gpus, src.Gpus[k0].Clone())
				}
				changed++
			}
		} else if m.Gpus != nil {
			m.Gpus = nil
			changed++
		}
	}
	return changed
}

func (m *Flavor) DeepCopyIn(src *Flavor) {
	m.Key.DeepCopyIn(&src.Key)
	m.Ram = src.Ram
	m.Vcpus = src.Vcpus
	m.Disk = src.Disk
	if src.OptResMap != nil {
		m.OptResMap = make(map[string]string)
		for k, v := range src.OptResMap {
			m.OptResMap[k] = v
		}
	} else {
		m.OptResMap = nil
	}
	m.DeletePrepare = src.DeletePrepare
	if src.Gpus != nil {
		m.Gpus = make([]*GPUResource, len(src.Gpus), len(src.Gpus))
		for ii, s := range src.Gpus {
			var tmp_s GPUResource
			tmp_s.DeepCopyIn(s)
			m.Gpus[ii] = &tmp_s
		}
	} else {
		m.Gpus = nil
	}
}

func (s *Flavor) HasFields() bool {
	return true
}

type FlavorStore interface {
	Create(ctx context.Context, m *Flavor, wait func(int64)) (*Result, error)
	Update(ctx context.Context, m *Flavor, wait func(int64)) (*Result, error)
	Delete(ctx context.Context, m *Flavor, wait func(int64)) (*Result, error)
	Put(ctx context.Context, m *Flavor, wait func(int64), ops ...objstore.KVOp) (*Result, error)
	LoadOne(key string) (*Flavor, int64, error)
	Get(ctx context.Context, key *FlavorKey, buf *Flavor) bool
	STMGet(stm concurrency.STM, key *FlavorKey, buf *Flavor) bool
	STMPut(stm concurrency.STM, obj *Flavor, ops ...objstore.KVOp)
	STMDel(stm concurrency.STM, key *FlavorKey)
	STMHas(stm concurrency.STM, key *FlavorKey) bool
}

type FlavorStoreImpl struct {
	kvstore objstore.KVStore
}

func NewFlavorStore(kvstore objstore.KVStore) *FlavorStoreImpl {
	return &FlavorStoreImpl{kvstore: kvstore}
}

func (s *FlavorStoreImpl) Create(ctx context.Context, m *Flavor, wait func(int64)) (*Result, error) {
	err := m.Validate(FlavorAllFieldsMap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("Flavor", m.GetKey())
	val, err := json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Create(ctx, key, string(val))
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *FlavorStoreImpl) Update(ctx context.Context, m *Flavor, wait func(int64)) (*Result, error) {
	fmap := MakeFieldMap(m.Fields)
	err := m.Validate(fmap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("Flavor", m.GetKey())
	var vers int64 = 0
	curBytes, vers, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, err
	}
	var cur Flavor
	err = json.Unmarshal(curBytes, &cur)
	if err != nil {
		return nil, err
	}
	cur.CopyInFields(m)
	// never save fields
	cur.Fields = nil
	val, err := json.Marshal(cur)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Update(ctx, key, string(val), vers)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *FlavorStoreImpl) Put(ctx context.Context, m *Flavor, wait func(int64), ops ...objstore.KVOp) (*Result, error) {
	err := m.Validate(FlavorAllFieldsMap)
	m.Fields = nil
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("Flavor", m.GetKey())
	var val []byte
	val, err = json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Put(ctx, key, string(val), ops...)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *FlavorStoreImpl) Delete(ctx context.Context, m *Flavor, wait func(int64)) (*Result, error) {
	err := m.GetKey().ValidateKey()
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("Flavor", m.GetKey())
	rev, err := s.kvstore.Delete(ctx, key)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *FlavorStoreImpl) LoadOne(key string) (*Flavor, int64, error) {
	val, rev, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, 0, err
	}
	var obj Flavor
	err = json.Unmarshal(val, &obj)
	if err != nil {
		log.DebugLog(log.DebugLevelApi, "Failed to parse Flavor data", "val", string(val), "err", err)
		return nil, 0, err
	}
	return &obj, rev, nil
}

func (s *FlavorStoreImpl) Get(ctx context.Context, key *FlavorKey, buf *Flavor) bool {
	keystr := objstore.DbKeyString("Flavor", key)
	val, _, _, err := s.kvstore.Get(keystr)
	if err != nil {
		return false
	}
	return s.parseGetData(val, buf)
}

func (s *FlavorStoreImpl) STMGet(stm concurrency.STM, key *FlavorKey, buf *Flavor) bool {
	keystr := objstore.DbKeyString("Flavor", key)
	valstr := stm.Get(keystr)
	return s.parseGetData([]byte(valstr), buf)
}

func (s *FlavorStoreImpl) STMHas(stm concurrency.STM, key *FlavorKey) bool {
	keystr := objstore.DbKeyString("Flavor", key)
	return stm.Get(keystr) != ""
}

func (s *FlavorStoreImpl) parseGetData(val []byte, buf *Flavor) bool {
	if len(val) == 0 {
		return false
	}
	if buf != nil {
		// clear buf, because empty values in val won't
		// overwrite non-empty values in buf.
		*buf = Flavor{}
		err := json.Unmarshal(val, buf)
		if err != nil {
			return false
		}
	}
	return true
}

func (s *FlavorStoreImpl) STMPut(stm concurrency.STM, obj *Flavor, ops ...objstore.KVOp) {
	keystr := objstore.DbKeyString("Flavor", obj.GetKey())

	val, err := json.Marshal(obj)
	if err != nil {
		log.InfoLog("Flavor json marshal failed", "obj", obj, "err", err)
	}
	v3opts := GetSTMOpts(ops...)
	stm.Put(keystr, string(val), v3opts...)
}

func (s *FlavorStoreImpl) STMDel(stm concurrency.STM, key *FlavorKey) {
	keystr := objstore.DbKeyString("Flavor", key)
	stm.Del(keystr)
}

func StoreListFlavor(ctx context.Context, kvstore objstore.KVStore) ([]Flavor, error) {
	keyPrefix := objstore.DbKeyPrefixString("Flavor") + "/"
	objs := []Flavor{}
	err := kvstore.List(keyPrefix, func(key, val []byte, rev, modRev int64) error {
		obj := Flavor{}
		err := json.Unmarshal(val, &obj)
		if err != nil {
			return fmt.Errorf("failed to unmarshal Flavor json %s, %s", string(val), err)
		}
		objs = append(objs, obj)
		return nil
	})
	return objs, err
}

type FlavorKeyWatcher struct {
	cb func(ctx context.Context)
}

type FlavorCacheData struct {
	Obj    *Flavor
	ModRev int64
}

func (s *FlavorCacheData) Clone() *FlavorCacheData {
	cp := FlavorCacheData{}
	if s.Obj != nil {
		cp.Obj = &Flavor{}
		cp.Obj.DeepCopyIn(s.Obj)
	}
	cp.ModRev = s.ModRev
	return &cp
}

// FlavorCache caches Flavor objects in memory in a hash table
// and keeps them in sync with the database.
type FlavorCache struct {
	Objs          map[FlavorKey]*FlavorCacheData
	Mux           util.Mutex
	List          map[FlavorKey]struct{}
	FlushAll      bool
	NotifyCbs     []func(ctx context.Context, obj *Flavor, modRev int64)
	UpdatedCbs    []func(ctx context.Context, old *Flavor, new *Flavor)
	DeletedCbs    []func(ctx context.Context, old *Flavor)
	KeyWatchers   map[FlavorKey][]*FlavorKeyWatcher
	UpdatedKeyCbs []func(ctx context.Context, key *FlavorKey)
	DeletedKeyCbs []func(ctx context.Context, key *FlavorKey)
	Store         FlavorStore
}

func NewFlavorCache() *FlavorCache {
	cache := FlavorCache{}
	InitFlavorCache(&cache)
	return &cache
}

func InitFlavorCache(cache *FlavorCache) {
	cache.Objs = make(map[FlavorKey]*FlavorCacheData)
	cache.KeyWatchers = make(map[FlavorKey][]*FlavorKeyWatcher)
	cache.NotifyCbs = nil
	cache.UpdatedCbs = nil
	cache.DeletedCbs = nil
	cache.UpdatedKeyCbs = nil
	cache.DeletedKeyCbs = nil
}

func (c *FlavorCache) GetTypeString() string {
	return "Flavor"
}

func (c *FlavorCache) Get(key *FlavorKey, valbuf *Flavor) bool {
	var modRev int64
	return c.GetWithRev(key, valbuf, &modRev)
}

// STMGet gets from the store if STM is set, otherwise gets from cache
func (c *FlavorCache) STMGet(ostm *OptionalSTM, key *FlavorKey, valbuf *Flavor) bool {
	if ostm.stm != nil {
		if c.Store == nil {
			// panic, otherwise if we fallback to cache, we may silently
			// introduce race conditions and intermittent failures due to
			// reading from cache during a transaction.
			panic("FlavorCache store not set, cannot read via STM")
		}
		return c.Store.STMGet(ostm.stm, key, valbuf)
	}
	var modRev int64
	return c.GetWithRev(key, valbuf, &modRev)
}

func (c *FlavorCache) GetWithRev(key *FlavorKey, valbuf *Flavor, modRev *int64) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	inst, found := c.Objs[*key]
	if found {
		valbuf.DeepCopyIn(inst.Obj)
		*modRev = inst.ModRev
	}
	return found
}

func (c *FlavorCache) HasKey(key *FlavorKey) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	_, found := c.Objs[*key]
	return found
}

func (c *FlavorCache) GetAllKeys(ctx context.Context, cb func(key *FlavorKey, modRev int64)) {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for key, data := range c.Objs {
		cb(&key, data.ModRev)
	}
}

func (c *FlavorCache) GetAllLocked(ctx context.Context, cb func(obj *Flavor, modRev int64)) {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for _, data := range c.Objs {
		cb(data.Obj, data.ModRev)
	}
}

func (c *FlavorCache) Update(ctx context.Context, in *Flavor, modRev int64) {
	c.UpdateModFunc(ctx, in.GetKey(), modRev, func(old *Flavor) (*Flavor, bool) {
		return in, true
	})
}

func (c *FlavorCache) UpdateModFunc(ctx context.Context, key *FlavorKey, modRev int64, modFunc func(old *Flavor) (new *Flavor, changed bool)) {
	c.Mux.Lock()
	var old *Flavor
	if oldData, found := c.Objs[*key]; found {
		old = oldData.Obj
	}
	new, changed := modFunc(old)
	if !changed {
		c.Mux.Unlock()
		return
	}
	if len(c.UpdatedCbs) > 0 || len(c.NotifyCbs) > 0 {
		newCopy := &Flavor{}
		newCopy.DeepCopyIn(new)
		for _, cb := range c.UpdatedCbs {
			defer cb(ctx, old, newCopy)
		}
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				defer cb(ctx, newCopy, modRev)
			}
		}
	}
	for _, cb := range c.UpdatedKeyCbs {
		defer cb(ctx, key)
	}
	store := &Flavor{}
	store.DeepCopyIn(new)
	c.Objs[new.GetKeyVal()] = &FlavorCacheData{
		Obj:    store,
		ModRev: modRev,
	}
	log.SpanLog(ctx, log.DebugLevelApi, "cache update", "new", store)
	c.Mux.Unlock()
	c.TriggerKeyWatchers(ctx, new.GetKey())
}

func (c *FlavorCache) Delete(ctx context.Context, in *Flavor, modRev int64) {
	c.DeleteCondFunc(ctx, in, modRev, func(old *Flavor) bool {
		return true
	})
}

func (c *FlavorCache) DeleteCondFunc(ctx context.Context, in *Flavor, modRev int64, condFunc func(old *Flavor) bool) {
	c.Mux.Lock()
	var old *Flavor
	oldData, found := c.Objs[in.GetKeyVal()]
	if found {
		old = oldData.Obj
		if !condFunc(old) {
			c.Mux.Unlock()
			return
		}
	}
	delete(c.Objs, in.GetKeyVal())
	log.SpanLog(ctx, log.DebugLevelApi, "cache delete", "key", in.GetKeyVal())
	c.Mux.Unlock()
	obj := old
	if obj == nil {
		obj = in
	}
	for _, cb := range c.NotifyCbs {
		if cb != nil {
			cb(ctx, obj, modRev)
		}
	}
	if old != nil {
		for _, cb := range c.DeletedCbs {
			cb(ctx, old)
		}
	}
	for _, cb := range c.DeletedKeyCbs {
		cb(ctx, in.GetKey())
	}
	c.TriggerKeyWatchers(ctx, in.GetKey())
}

func (c *FlavorCache) Prune(ctx context.Context, validKeys map[FlavorKey]struct{}) {
	log.SpanLog(ctx, log.DebugLevelApi, "Prune Flavor", "numValidKeys", len(validKeys))
	notify := make(map[FlavorKey]*FlavorCacheData)
	c.Mux.Lock()
	for key, _ := range c.Objs {
		if _, ok := validKeys[key]; !ok {
			if len(c.NotifyCbs) > 0 || len(c.DeletedKeyCbs) > 0 || len(c.DeletedCbs) > 0 {
				notify[key] = c.Objs[key]
			}
			delete(c.Objs, key)
		}
	}
	c.Mux.Unlock()
	for key, old := range notify {
		obj := old.Obj
		if obj == nil {
			obj = &Flavor{}
			obj.SetKey(&key)
		}
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, obj, old.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if old.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, old.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (c *FlavorCache) GetCount() int {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	return len(c.Objs)
}

func (c *FlavorCache) Flush(ctx context.Context, notifyId int64) {
}

func (c *FlavorCache) Show(filter *Flavor, cb func(ret *Flavor) error) error {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for _, data := range c.Objs {
		if !data.Obj.Matches(filter, MatchFilter()) {
			continue
		}
		err := cb(data.Obj)
		if err != nil {
			return err
		}
	}
	return nil
}

func FlavorGenericNotifyCb(fn func(key *FlavorKey, old *Flavor)) func(objstore.ObjKey, objstore.Obj) {
	return func(objkey objstore.ObjKey, obj objstore.Obj) {
		fn(objkey.(*FlavorKey), obj.(*Flavor))
	}
}

func (c *FlavorCache) SetNotifyCb(fn func(ctx context.Context, obj *Flavor, modRev int64)) {
	c.NotifyCbs = []func(ctx context.Context, obj *Flavor, modRev int64){fn}
}

func (c *FlavorCache) SetUpdatedCb(fn func(ctx context.Context, old *Flavor, new *Flavor)) {
	c.UpdatedCbs = []func(ctx context.Context, old *Flavor, new *Flavor){fn}
}

func (c *FlavorCache) SetDeletedCb(fn func(ctx context.Context, old *Flavor)) {
	c.DeletedCbs = []func(ctx context.Context, old *Flavor){fn}
}

func (c *FlavorCache) SetUpdatedKeyCb(fn func(ctx context.Context, key *FlavorKey)) {
	c.UpdatedKeyCbs = []func(ctx context.Context, key *FlavorKey){fn}
}

func (c *FlavorCache) SetDeletedKeyCb(fn func(ctx context.Context, key *FlavorKey)) {
	c.DeletedKeyCbs = []func(ctx context.Context, key *FlavorKey){fn}
}

func (c *FlavorCache) AddUpdatedCb(fn func(ctx context.Context, old *Flavor, new *Flavor)) {
	c.UpdatedCbs = append(c.UpdatedCbs, fn)
}

func (c *FlavorCache) AddDeletedCb(fn func(ctx context.Context, old *Flavor)) {
	c.DeletedCbs = append(c.DeletedCbs, fn)
}

func (c *FlavorCache) AddNotifyCb(fn func(ctx context.Context, obj *Flavor, modRev int64)) {
	c.NotifyCbs = append(c.NotifyCbs, fn)
}

func (c *FlavorCache) AddUpdatedKeyCb(fn func(ctx context.Context, key *FlavorKey)) {
	c.UpdatedKeyCbs = append(c.UpdatedKeyCbs, fn)
}

func (c *FlavorCache) AddDeletedKeyCb(fn func(ctx context.Context, key *FlavorKey)) {
	c.DeletedKeyCbs = append(c.DeletedKeyCbs, fn)
}

func (c *FlavorCache) SetFlushAll() {
	c.FlushAll = true
}

func (c *FlavorCache) WatchKey(key *FlavorKey, cb func(ctx context.Context)) context.CancelFunc {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	list, ok := c.KeyWatchers[*key]
	if !ok {
		list = make([]*FlavorKeyWatcher, 0)
	}
	watcher := FlavorKeyWatcher{cb: cb}
	c.KeyWatchers[*key] = append(list, &watcher)
	log.DebugLog(log.DebugLevelApi, "Watching Flavor", "key", key)
	return func() {
		c.Mux.Lock()
		defer c.Mux.Unlock()
		list, ok := c.KeyWatchers[*key]
		if !ok {
			return
		}
		for ii, _ := range list {
			if list[ii] != &watcher {
				continue
			}
			if len(list) == 1 {
				delete(c.KeyWatchers, *key)
				return
			}
			list[ii] = list[len(list)-1]
			list[len(list)-1] = nil
			c.KeyWatchers[*key] = list[:len(list)-1]
			return
		}
	}
}

func (c *FlavorCache) TriggerKeyWatchers(ctx context.Context, key *FlavorKey) {
	watchers := make([]*FlavorKeyWatcher, 0)
	c.Mux.Lock()
	if list, ok := c.KeyWatchers[*key]; ok {
		watchers = append(watchers, list...)
	}
	c.Mux.Unlock()
	for ii, _ := range watchers {
		watchers[ii].cb(ctx)
	}
}

// Note that we explicitly ignore the global revision number, because of the way
// the notify framework sends updates (by hashing keys and doing lookups, instead
// of sequentially through a history buffer), updates may be done out-of-order
// or multiple updates compressed into one update, so the state of the cache at
// any point in time may not by in sync with a particular database revision number.

func (c *FlavorCache) SyncUpdate(ctx context.Context, key, val []byte, rev, modRev int64) {
	obj := Flavor{}
	err := json.Unmarshal(val, &obj)
	if err != nil {
		log.WarnLog("Failed to parse Flavor data", "val", string(val), "err", err)
		return
	}
	c.Update(ctx, &obj, modRev)
	c.Mux.Lock()
	if c.List != nil {
		c.List[obj.GetKeyVal()] = struct{}{}
	}
	c.Mux.Unlock()
}

func (c *FlavorCache) SyncDelete(ctx context.Context, key []byte, rev, modRev int64) {
	obj := Flavor{}
	keystr := objstore.DbKeyPrefixRemove(string(key))
	FlavorKeyStringParse(keystr, obj.GetKey())
	c.Delete(ctx, &obj, modRev)
}

func (c *FlavorCache) SyncListStart(ctx context.Context) {
	c.List = make(map[FlavorKey]struct{})
}

func (c *FlavorCache) SyncListEnd(ctx context.Context) {
	deleted := make(map[FlavorKey]*FlavorCacheData)
	c.Mux.Lock()
	for key, val := range c.Objs {
		if _, found := c.List[key]; !found {
			deleted[key] = val
			delete(c.Objs, key)
		}
	}
	c.List = nil
	c.Mux.Unlock()
	for key, val := range deleted {
		obj := val.Obj
		if obj == nil {
			obj = &Flavor{}
			obj.SetKey(&key)
		}
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, obj, val.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if val.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, val.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (s *FlavorCache) InitCacheWithSync(sync DataSync) {
	InitFlavorCache(s)
	s.InitSync(sync)
}

func (s *FlavorCache) InitSync(sync DataSync) {
	if sync != nil {
		s.Store = NewFlavorStore(sync.GetKVStore())
		sync.RegisterCache(s)
	}
}

func InitFlavorCacheWithStore(cache *FlavorCache, store FlavorStore) {
	InitFlavorCache(cache)
	cache.Store = store
}

func (c *FlavorCache) UsesOrg(org string) bool {
	return false
}

func (m *Flavor) GetObjKey() objstore.ObjKey {
	return m.GetKey()
}

func (m *Flavor) GetKey() *FlavorKey {
	return &m.Key
}

func (m *Flavor) GetKeyVal() FlavorKey {
	return m.Key
}

func (m *Flavor) SetKey(key *FlavorKey) {
	m.Key = *key
}

func CmpSortFlavor(a Flavor, b Flavor) bool {
	return a.Key.GetKeyString() < b.Key.GetKeyString()
}

// Helper method to check that enums have valid values
// NOTE: ValidateEnums checks all Fields even if some are not set
func (m *Flavor) ValidateEnums() error {
	if err := m.Key.ValidateEnums(); err != nil {
		return err
	}
	for _, e := range m.Gpus {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (s *Flavor) ClearTagged(tags map[string]struct{}) {
	s.Key.ClearTagged(tags)
	if s.Gpus != nil {
		for ii := 0; ii < len(s.Gpus); ii++ {
			s.Gpus[ii].ClearTagged(tags)
		}
	}
}

func (m *Flavor) IsValidArgsForCreateFlavor() error {
	if m.DeletePrepare != false {
		return fmt.Errorf("Invalid field specified: DeletePrepare, this field is only for internal use")
	}
	return nil
}

func (m *Flavor) IsValidArgsForDeleteFlavor() error {
	if m.DeletePrepare != false {
		return fmt.Errorf("Invalid field specified: DeletePrepare, this field is only for internal use")
	}
	return nil
}

func (m *Flavor) IsValidArgsForUpdateFlavor() error {
	if m.DeletePrepare != false {
		return fmt.Errorf("Invalid field specified: DeletePrepare, this field is only for internal use")
	}
	return nil
}

func (m *Flavor) IsValidArgsForAddFlavorRes() error {
	if m.DeletePrepare != false {
		return fmt.Errorf("Invalid field specified: DeletePrepare, this field is only for internal use")
	}
	return nil
}

func (m *Flavor) IsValidArgsForRemoveFlavorRes() error {
	if m.DeletePrepare != false {
		return fmt.Errorf("Invalid field specified: DeletePrepare, this field is only for internal use")
	}
	return nil
}

func (m *FlavorKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFlavor(uint64(l))
	}
	return n
}

func (m *Flavor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovFlavor(uint64(l))
		}
	}
	l = m.Key.Size()
	n += 1 + l + sovFlavor(uint64(l))
	if m.Ram != 0 {
		n += 1 + sovFlavor(uint64(m.Ram))
	}
	if m.Vcpus != 0 {
		n += 1 + sovFlavor(uint64(m.Vcpus))
	}
	if m.Disk != 0 {
		n += 1 + sovFlavor(uint64(m.Disk))
	}
	if len(m.OptResMap) > 0 {
		for k, v := range m.OptResMap {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovFlavor(uint64(len(k))) + 1 + len(v) + sovFlavor(uint64(len(v)))
			n += mapEntrySize + 1 + sovFlavor(uint64(mapEntrySize))
		}
	}
	if m.DeletePrepare {
		n += 2
	}
	if len(m.Gpus) > 0 {
		for _, e := range m.Gpus {
			l = e.Size()
			n += 1 + l + sovFlavor(uint64(l))
		}
	}
	return n
}

func sovFlavor(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozFlavor(x uint64) (n int) {
	return sovFlavor(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *FlavorKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlavor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlavorKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlavorKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlavor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlavor
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlavor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlavor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlavor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Flavor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlavor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Flavor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Flavor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlavor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlavor
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlavor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlavor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlavor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlavor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ram", wireType)
			}
			m.Ram = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlavor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ram |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vcpus", wireType)
			}
			m.Vcpus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlavor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Vcpus |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disk", wireType)
			}
			m.Disk = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlavor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Disk |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptResMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlavor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlavor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlavor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OptResMap == nil {
				m.OptResMap = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlavor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFlavor
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthFlavor
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthFlavor
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFlavor
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthFlavor
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthFlavor
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFlavor(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFlavor
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.OptResMap[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletePrepare", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlavor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DeletePrepare = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gpus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlavor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlavor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlavor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gpus = append(m.Gpus, &GPUResource{})
			if err := m.Gpus[len(m.Gpus)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlavor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlavor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFlavor(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFlavor
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFlavor
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFlavor
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthFlavor
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupFlavor
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthFlavor
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthFlavor        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFlavor          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupFlavor = fmt.Errorf("proto: unexpected end of group")
)
