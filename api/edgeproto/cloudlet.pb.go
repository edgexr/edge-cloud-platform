// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: cloudlet.proto

package edgeproto

import (
	context "context"
	"encoding/json"
	"errors"
	fmt "fmt"
	distributed_match_engine "github.com/edgexr/edge-cloud-platform/api/distributed_match_engine"
	"github.com/edgexr/edge-cloud-platform/pkg/log"
	"github.com/edgexr/edge-cloud-platform/pkg/objstore"
	"github.com/edgexr/edge-cloud-platform/pkg/util"
	_ "github.com/edgexr/edge-cloud-platform/tools/protogen"
	_ "github.com/gogo/googleapis/google/api"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"go.etcd.io/etcd/client/v3/concurrency"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	"strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Infra API Access
//
// # InfraApiAccess is the type of access available to Infra API endpoint
//
// 0: `DIRECT_ACCESS`
// 1: `RESTRICTED_ACCESS`
type InfraApiAccess int32

const (
	// Infra API endpoint is accessible from public network
	InfraApiAccess_DIRECT_ACCESS InfraApiAccess = 0
	// Infra API endpoint is not accessible from public network
	InfraApiAccess_RESTRICTED_ACCESS InfraApiAccess = 1
)

var InfraApiAccess_name = map[int32]string{
	0: "DIRECT_ACCESS",
	1: "RESTRICTED_ACCESS",
}

var InfraApiAccess_value = map[string]int32{
	"DIRECT_ACCESS":     0,
	"RESTRICTED_ACCESS": 1,
}

func (x InfraApiAccess) String() string {
	return proto.EnumName(InfraApiAccess_name, int32(x))
}

func (InfraApiAccess) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3aea31a648a25d86, []int{0}
}

// Operating System Type
//
// OSType is the type of the Operator System
//
//	0: `Linux`
//	1: `Windows`
//
// 20: `Others`
type OSType int32

const (
	// Linux Operating System
	OSType_LINUX OSType = 0
	// Windows Operating System
	OSType_WINDOWS OSType = 1
	// Other Operating Systems
	OSType_OTHERS OSType = 20
)

var OSType_name = map[int32]string{
	0:  "LINUX",
	1:  "WINDOWS",
	20: "OTHERS",
}

var OSType_value = map[string]int32{
	"LINUX":   0,
	"WINDOWS": 1,
	"OTHERS":  20,
}

func (x OSType) String() string {
	return proto.EnumName(OSType_name, int32(x))
}

func (OSType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3aea31a648a25d86, []int{1}
}

// Report Schedule
//
// # ReportSchedule is the interval for which report is to be generated
//
// 0: `EveryWeek`
// 1: `Every15Days`
// 3: `EveryMonth`
type ReportSchedule int32

const (
	// Every Week
	ReportSchedule_EveryWeek ReportSchedule = 0
	// Every 15 Days
	ReportSchedule_Every15Days ReportSchedule = 1
	// (Deprecated) Every 30 Days
	// Every Month
	ReportSchedule_EveryMonth ReportSchedule = 3
)

var ReportSchedule_name = map[int32]string{
	0: "EveryWeek",
	1: "Every15Days",
	3: "EveryMonth",
}

var ReportSchedule_value = map[string]int32{
	"EveryWeek":   0,
	"Every15Days": 1,
	"EveryMonth":  3,
}

func (x ReportSchedule) String() string {
	return proto.EnumName(ReportSchedule_name, int32(x))
}

func (ReportSchedule) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3aea31a648a25d86, []int{2}
}

// Operation time limits
//
// Time limits for cloudlet create, update and delete operations
type OperationTimeLimits struct {
	// Override default max time to create a cluster instance (duration)
	CreateClusterInstTimeout Duration `protobuf:"varint,1,opt,name=create_cluster_inst_timeout,json=createClusterInstTimeout,proto3,casttype=Duration" json:"create_cluster_inst_timeout,omitempty"`
	// Override default max time to update a cluster instance (duration)
	UpdateClusterInstTimeout Duration `protobuf:"varint,2,opt,name=update_cluster_inst_timeout,json=updateClusterInstTimeout,proto3,casttype=Duration" json:"update_cluster_inst_timeout,omitempty"`
	// Override default max time to delete a cluster instance (duration)
	DeleteClusterInstTimeout Duration `protobuf:"varint,3,opt,name=delete_cluster_inst_timeout,json=deleteClusterInstTimeout,proto3,casttype=Duration" json:"delete_cluster_inst_timeout,omitempty"`
	// Override default max time to create an app instance (duration)
	CreateAppInstTimeout Duration `protobuf:"varint,4,opt,name=create_app_inst_timeout,json=createAppInstTimeout,proto3,casttype=Duration" json:"create_app_inst_timeout,omitempty"`
	// Override default max time to update an app instance (duration)
	UpdateAppInstTimeout Duration `protobuf:"varint,5,opt,name=update_app_inst_timeout,json=updateAppInstTimeout,proto3,casttype=Duration" json:"update_app_inst_timeout,omitempty"`
	// Override default max time to delete an app instance (duration)
	DeleteAppInstTimeout Duration `protobuf:"varint,6,opt,name=delete_app_inst_timeout,json=deleteAppInstTimeout,proto3,casttype=Duration" json:"delete_app_inst_timeout,omitempty"`
}

func (m *OperationTimeLimits) Reset()         { *m = OperationTimeLimits{} }
func (m *OperationTimeLimits) String() string { return proto.CompactTextString(m) }
func (*OperationTimeLimits) ProtoMessage()    {}
func (*OperationTimeLimits) Descriptor() ([]byte, []int) {
	return fileDescriptor_3aea31a648a25d86, []int{0}
}
func (m *OperationTimeLimits) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OperationTimeLimits) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OperationTimeLimits.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OperationTimeLimits) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OperationTimeLimits.Merge(m, src)
}
func (m *OperationTimeLimits) XXX_Size() int {
	return m.Size()
}
func (m *OperationTimeLimits) XXX_DiscardUnknown() {
	xxx_messageInfo_OperationTimeLimits.DiscardUnknown(m)
}

var xxx_messageInfo_OperationTimeLimits proto.InternalMessageInfo

// CloudletInternal is for data exchanged only between CRM and Shepherd and never the controller
type CloudletInternal struct {
	// Fields are used for the Update API to specify which fields to apply.
	Fields []string `protobuf:"bytes,1,rep,name=fields,proto3" json:"fields,omitempty"`
	// Resource cloudlet key
	Key CloudletKey `protobuf:"bytes,2,opt,name=key,proto3" json:"key"`
	// Map of key value pairs for data exchanged between components
	Props map[string]string `protobuf:"bytes,3,rep,name=props,proto3" json:"props,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *CloudletInternal) Reset()         { *m = CloudletInternal{} }
func (m *CloudletInternal) String() string { return proto.CompactTextString(m) }
func (*CloudletInternal) ProtoMessage()    {}
func (*CloudletInternal) Descriptor() ([]byte, []int) {
	return fileDescriptor_3aea31a648a25d86, []int{1}
}
func (m *CloudletInternal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CloudletInternal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CloudletInternal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CloudletInternal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloudletInternal.Merge(m, src)
}
func (m *CloudletInternal) XXX_Size() int {
	return m.Size()
}
func (m *CloudletInternal) XXX_DiscardUnknown() {
	xxx_messageInfo_CloudletInternal.DiscardUnknown(m)
}

var xxx_messageInfo_CloudletInternal proto.InternalMessageInfo

// Platform specific configuration required for Cloudlet management
type PlatformConfig struct {
	// Path to Docker registry holding edge-cloud image
	ContainerRegistryPath string `protobuf:"bytes,1,opt,name=container_registry_path,json=containerRegistryPath,proto3" json:"container_registry_path,omitempty"`
	// Path to platform base image
	CloudletVmImagePath string `protobuf:"bytes,2,opt,name=cloudlet_vm_image_path,json=cloudletVmImagePath,proto3" json:"cloudlet_vm_image_path,omitempty"`
	// Address of controller notify port (can be multiple of these)
	NotifyCtrlAddrs string `protobuf:"bytes,3,opt,name=notify_ctrl_addrs,json=notifyCtrlAddrs,proto3" json:"notify_ctrl_addrs,omitempty"`
	// TLS cert file
	TlsCertFile string `protobuf:"bytes,5,opt,name=tls_cert_file,json=tlsCertFile,proto3" json:"tls_cert_file,omitempty"`
	// TLS key file
	TlsKeyFile string `protobuf:"bytes,20,opt,name=tls_key_file,json=tlsKeyFile,proto3" json:"tls_key_file,omitempty"`
	// TLS ca file
	TlsCaFile string `protobuf:"bytes,21,opt,name=tls_ca_file,json=tlsCaFile,proto3" json:"tls_ca_file,omitempty"`
	// Environment variables
	EnvVar map[string]string `protobuf:"bytes,6,rep,name=env_var,json=envVar,proto3" json:"env_var,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Tag of edge-cloud image
	PlatformTag string `protobuf:"bytes,8,opt,name=platform_tag,json=platformTag,proto3" json:"platform_tag,omitempty"`
	// Internal Test flag
	TestMode bool `protobuf:"varint,9,opt,name=test_mode,json=testMode,proto3" json:"test_mode,omitempty"`
	// Span string
	Span string `protobuf:"bytes,10,opt,name=span,proto3" json:"span,omitempty"`
	// Internal cleanup flag
	CleanupMode bool `protobuf:"varint,11,opt,name=cleanup_mode,json=cleanupMode,proto3" json:"cleanup_mode,omitempty"`
	// Region
	Region string `protobuf:"bytes,12,opt,name=region,proto3" json:"region,omitempty"`
	// Get certs from vault or generate your own for the root load balancer
	CommercialCerts bool `protobuf:"varint,13,opt,name=commercial_certs,json=commercialCerts,proto3" json:"commercial_certs,omitempty"`
	// Use Vault certs and CAs for internal TLS communication
	UseVaultPki bool `protobuf:"varint,14,opt,name=use_vault_pki,json=useVaultPki,proto3" json:"use_vault_pki,omitempty"`
	// App domain name root
	AppDnsRoot string `protobuf:"bytes,16,opt,name=app_dns_root,json=appDnsRoot,proto3" json:"app_dns_root,omitempty"`
	// Deployment Tag
	DeploymentTag string `protobuf:"bytes,19,opt,name=deployment_tag,json=deploymentTag,proto3" json:"deployment_tag,omitempty"`
	// crm access private key
	CrmAccessPrivateKey string `protobuf:"bytes,22,opt,name=crm_access_private_key,json=crmAccessPrivateKey,proto3" json:"crm_access_private_key,omitempty"`
	// controller access API address
	AccessApiAddr string `protobuf:"bytes,23,opt,name=access_api_addr,json=accessApiAddr,proto3" json:"access_api_addr,omitempty"`
	// cache dir
	CacheDir string `protobuf:"bytes,24,opt,name=cache_dir,json=cacheDir,proto3" json:"cache_dir,omitempty"`
	// secondary crm access private key
	SecondaryCrmAccessPrivateKey string `protobuf:"bytes,25,opt,name=secondary_crm_access_private_key,json=secondaryCrmAccessPrivateKey,proto3" json:"secondary_crm_access_private_key,omitempty"`
	// Thanos Receive remote write address
	ThanosRecvAddr string `protobuf:"bytes,26,opt,name=thanos_recv_addr,json=thanosRecvAddr,proto3" json:"thanos_recv_addr,omitempty"`
	// Ansible public address for CRM to connect to CCRM
	AnsiblePublicAddr string `protobuf:"bytes,27,opt,name=ansible_public_addr,json=ansiblePublicAddr,proto3" json:"ansible_public_addr,omitempty"`
	// docker image path for envoy with curl
	EnvoyWithCurlImage string `protobuf:"bytes,29,opt,name=envoy_with_curl_image,json=envoyWithCurlImage,proto3" json:"envoy_with_curl_image,omitempty"`
	// docker image path for nginx with curl
	NginxWithCurlImage string `protobuf:"bytes,30,opt,name=nginx_with_curl_image,json=nginxWithCurlImage,proto3" json:"nginx_with_curl_image,omitempty"`
}

func (m *PlatformConfig) Reset()         { *m = PlatformConfig{} }
func (m *PlatformConfig) String() string { return proto.CompactTextString(m) }
func (*PlatformConfig) ProtoMessage()    {}
func (*PlatformConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_3aea31a648a25d86, []int{2}
}
func (m *PlatformConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlatformConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlatformConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlatformConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlatformConfig.Merge(m, src)
}
func (m *PlatformConfig) XXX_Size() int {
	return m.Size()
}
func (m *PlatformConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_PlatformConfig.DiscardUnknown(m)
}

var xxx_messageInfo_PlatformConfig proto.InternalMessageInfo

// Federation config associated with the cloudlet
type FederationConfig struct {
	// Federation context id
	FederationContextId string `protobuf:"bytes,1,opt,name=federation_context_id,json=federationContextId,proto3" json:"federation_context_id,omitempty"`
	// Partner federation address
	PartnerFederationAddr string `protobuf:"bytes,2,opt,name=partner_federation_addr,json=partnerFederationAddr,proto3" json:"partner_federation_addr,omitempty"`
	// Federation database id
	FederationDbId uint64 `protobuf:"varint,3,opt,name=federation_db_id,json=federationDbId,proto3" json:"federation_db_id,omitempty"`
	// Federation Name
	FederationName string `protobuf:"bytes,4,opt,name=federation_name,json=federationName,proto3" json:"federation_name,omitempty"`
}

func (m *FederationConfig) Reset()         { *m = FederationConfig{} }
func (m *FederationConfig) String() string { return proto.CompactTextString(m) }
func (*FederationConfig) ProtoMessage()    {}
func (*FederationConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_3aea31a648a25d86, []int{3}
}
func (m *FederationConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FederationConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FederationConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FederationConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FederationConfig.Merge(m, src)
}
func (m *FederationConfig) XXX_Size() int {
	return m.Size()
}
func (m *FederationConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_FederationConfig.DiscardUnknown(m)
}

var xxx_messageInfo_FederationConfig proto.InternalMessageInfo

// PlatformFeatures are characteristics and supported
// features of a platform type.
type PlatformFeatures struct {
	// Platform type
	PlatformType string `protobuf:"bytes,1,opt,name=platform_type,json=platformType,proto3" json:"platform_type,omitempty"`
	// Node type that supports this platform
	NodeType string `protobuf:"bytes,25,opt,name=node_type,json=nodeType,proto3" json:"node_type,omitempty"`
	// Platform supports multi tenant kubernetes clusters
	SupportsMultiTenantCluster bool `protobuf:"varint,2,opt,name=supports_multi_tenant_cluster,json=supportsMultiTenantCluster,proto3" json:"supports_multi_tenant_cluster,omitempty"`
	// Platform supports shared volumes
	SupportsSharedVolume bool `protobuf:"varint,3,opt,name=supports_shared_volume,json=supportsSharedVolume,proto3" json:"supports_shared_volume,omitempty"`
	// Platform supports trust policies
	SupportsTrustPolicy bool `protobuf:"varint,4,opt,name=supports_trust_policy,json=supportsTrustPolicy,proto3" json:"supports_trust_policy,omitempty"`
	// Platform only supports kubernetes deployments
	SupportsKubernetesOnly bool `protobuf:"varint,5,opt,name=supports_kubernetes_only,json=supportsKubernetesOnly,proto3" json:"supports_kubernetes_only,omitempty"`
	// Kubernetes clusters requires worker nodes and cannot be master only
	KubernetesRequiresWorkerNodes bool `protobuf:"varint,6,opt,name=kubernetes_requires_worker_nodes,json=kubernetesRequiresWorkerNodes,proto3" json:"kubernetes_requires_worker_nodes,omitempty"`
	// Cloudlet servicess run local to the controller
	CloudletServicesLocal bool `protobuf:"varint,7,opt,name=cloudlet_services_local,json=cloudletServicesLocal,proto3" json:"cloudlet_services_local,omitempty"`
	// Every kubernetes services gets a public IP (public cloud)
	IpAllocatedPerService bool `protobuf:"varint,8,opt,name=ip_allocated_per_service,json=ipAllocatedPerService,proto3" json:"ip_allocated_per_service,omitempty"`
	// Platform supports OVF images for VM deployments
	SupportsImageTypeOvf bool `protobuf:"varint,9,opt,name=supports_image_type_ovf,json=supportsImageTypeOvf,proto3" json:"supports_image_type_ovf,omitempty"`
	// Platform supports OVA images for VM deployments
	SupportsImageTypeOva bool `protobuf:"varint,19,opt,name=supports_image_type_ova,json=supportsImageTypeOva,proto3" json:"supports_image_type_ova,omitempty"`
	// Platform is a a pool of pre-existing virtual machines
	IsVmPool bool `protobuf:"varint,10,opt,name=is_vm_pool,json=isVmPool,proto3" json:"is_vm_pool,omitempty"`
	// Platform is a fake platform for unit/e2e testing
	IsFake bool `protobuf:"varint,11,opt,name=is_fake,json=isFake,proto3" json:"is_fake,omitempty"`
	// Platform is a mock platform for developer/regression testing
	IsMock bool `protobuf:"varint,26,opt,name=is_mock,json=isMock,proto3" json:"is_mock,omitempty"`
	// Platform supports adding networks
	SupportsAdditionalNetworks bool `protobuf:"varint,12,opt,name=supports_additional_networks,json=supportsAdditionalNetworks,proto3" json:"supports_additional_networks,omitempty"`
	// The entire platform is a single kubernetes cluster
	IsSingleKubernetesCluster bool `protobuf:"varint,13,opt,name=is_single_kubernetes_cluster,json=isSingleKubernetesCluster,proto3" json:"is_single_kubernetes_cluster,omitempty"`
	// Platform supports per AppInst dedicated IPs
	SupportsAppInstDedicatedIp bool `protobuf:"varint,14,opt,name=supports_app_inst_dedicated_ip,json=supportsAppInstDedicatedIp,proto3" json:"supports_app_inst_dedicated_ip,omitempty"`
	// Supports high availability with two CRMs on kubernetes
	SupportsPlatformHighAvailabilityOnK8S bool `protobuf:"varint,15,opt,name=supports_platform_high_availability_on_k8s,json=supportsPlatformHighAvailabilityOnK8s,proto3" json:"supports_platform_high_availability_on_k8s,omitempty"`
	// Supports high availability with two CRMs on docker
	SupportsPlatformHighAvailabilityOnDocker bool `protobuf:"varint,16,opt,name=supports_platform_high_availability_on_docker,json=supportsPlatformHighAvailabilityOnDocker,proto3" json:"supports_platform_high_availability_on_docker,omitempty"`
	// No support for kubernetes cluster auto-scale
	NoKubernetesClusterAutoScale bool `protobuf:"varint,17,opt,name=no_kubernetes_cluster_auto_scale,json=noKubernetesClusterAutoScale,proto3" json:"no_kubernetes_cluster_auto_scale,omitempty"`
	// Kubernetes cluster is created externally and already exists
	IsPrebuiltKubernetesCluster bool `protobuf:"varint,18,opt,name=is_prebuilt_kubernetes_cluster,json=isPrebuiltKubernetesCluster,proto3" json:"is_prebuilt_kubernetes_cluster,omitempty"`
	// No cluster support. Some platforms, like Federation, do not support clusters.
	NoClusterSupport bool `protobuf:"varint,20,opt,name=no_cluster_support,json=noClusterSupport,proto3" json:"no_cluster_support,omitempty"`
	// Edgebox platforms are for user-hosted cloudlets, and must use public images and do not get DNS mapping, as they do not get access to sensitive data.
	IsEdgebox bool `protobuf:"varint,21,opt,name=is_edgebox,json=isEdgebox,proto3" json:"is_edgebox,omitempty"`
	// Supports IPv6
	SupportsIpv6 bool `protobuf:"varint,27,opt,name=supports_ipv6,json=supportsIpv6,proto3" json:"supports_ipv6,omitempty"`
	// Platform access vars information
	AccessVars map[string]*PropertyInfo `protobuf:"bytes,22,rep,name=access_vars,json=accessVars,proto3" json:"access_vars,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Platform properties
	Properties map[string]*PropertyInfo `protobuf:"bytes,23,rep,name=properties,proto3" json:"properties,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Platform resource quota properties
	ResourceQuotaProperties []InfraResource `protobuf:"bytes,24,rep,name=resource_quota_properties,json=resourceQuotaProperties,proto3" json:"resource_quota_properties"`
	// Preparing to be deleted
	DeletePrepare bool `protobuf:"varint,99,opt,name=delete_prepare,json=deletePrepare,proto3" json:"delete_prepare,omitempty"`
}

func (m *PlatformFeatures) Reset()         { *m = PlatformFeatures{} }
func (m *PlatformFeatures) String() string { return proto.CompactTextString(m) }
func (*PlatformFeatures) ProtoMessage()    {}
func (*PlatformFeatures) Descriptor() ([]byte, []int) {
	return fileDescriptor_3aea31a648a25d86, []int{4}
}
func (m *PlatformFeatures) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlatformFeatures) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlatformFeatures.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlatformFeatures) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlatformFeatures.Merge(m, src)
}
func (m *PlatformFeatures) XXX_Size() int {
	return m.Size()
}
func (m *PlatformFeatures) XXX_DiscardUnknown() {
	xxx_messageInfo_PlatformFeatures.DiscardUnknown(m)
}

var xxx_messageInfo_PlatformFeatures proto.InternalMessageInfo

// Optional resource input consists of a resource specifier and clouldkey name
type CloudletResMap struct {
	// Resource cloudlet key
	Key CloudletKey `protobuf:"bytes,1,opt,name=key,proto3" json:"key"`
	// Resource mapping info
	Mapping map[string]string `protobuf:"bytes,2,rep,name=mapping,proto3" json:"mapping,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *CloudletResMap) Reset()         { *m = CloudletResMap{} }
func (m *CloudletResMap) String() string { return proto.CompactTextString(m) }
func (*CloudletResMap) ProtoMessage()    {}
func (*CloudletResMap) Descriptor() ([]byte, []int) {
	return fileDescriptor_3aea31a648a25d86, []int{5}
}
func (m *CloudletResMap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CloudletResMap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CloudletResMap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CloudletResMap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloudletResMap.Merge(m, src)
}
func (m *CloudletResMap) XXX_Size() int {
	return m.Size()
}
func (m *CloudletResMap) XXX_DiscardUnknown() {
	xxx_messageInfo_CloudletResMap.DiscardUnknown(m)
}

var xxx_messageInfo_CloudletResMap proto.InternalMessageInfo

// Infra specific configuration used for Cloudlet deployments
type InfraConfig struct {
	// Infra specific external network name
	ExternalNetworkName string `protobuf:"bytes,1,opt,name=external_network_name,json=externalNetworkName,proto3" json:"external_network_name,omitempty"`
	// Infra specific flavor name
	FlavorName string `protobuf:"bytes,2,opt,name=flavor_name,json=flavorName,proto3" json:"flavor_name,omitempty"`
}

func (m *InfraConfig) Reset()         { *m = InfraConfig{} }
func (m *InfraConfig) String() string { return proto.CompactTextString(m) }
func (*InfraConfig) ProtoMessage()    {}
func (*InfraConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_3aea31a648a25d86, []int{6}
}
func (m *InfraConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InfraConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InfraConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InfraConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InfraConfig.Merge(m, src)
}
func (m *InfraConfig) XXX_Size() int {
	return m.Size()
}
func (m *InfraConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_InfraConfig.DiscardUnknown(m)
}

var xxx_messageInfo_InfraConfig proto.InternalMessageInfo

// Resource Quota
type ResourceQuota struct {
	// Resource name on which to set quota
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Quota value of the resource
	Value uint64 `protobuf:"varint,2,opt,name=value,proto3" json:"value,omitempty"`
	// Generate alert when more than threshold percentage of resource is used
	AlertThreshold int32 `protobuf:"varint,3,opt,name=alert_threshold,json=alertThreshold,proto3" json:"alert_threshold,omitempty"`
}

func (m *ResourceQuota) Reset()         { *m = ResourceQuota{} }
func (m *ResourceQuota) String() string { return proto.CompactTextString(m) }
func (*ResourceQuota) ProtoMessage()    {}
func (*ResourceQuota) Descriptor() ([]byte, []int) {
	return fileDescriptor_3aea31a648a25d86, []int{7}
}
func (m *ResourceQuota) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResourceQuota) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResourceQuota.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResourceQuota) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourceQuota.Merge(m, src)
}
func (m *ResourceQuota) XXX_Size() int {
	return m.Size()
}
func (m *ResourceQuota) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourceQuota.DiscardUnknown(m)
}

var xxx_messageInfo_ResourceQuota proto.InternalMessageInfo

// GPU Driver Key
//
// GPUDriverKey uniquely identifies a GPU driver
type GPUDriverKey struct {
	// Name of the driver
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Organization to which the driver belongs to
	Organization string `protobuf:"bytes,2,opt,name=organization,proto3" json:"organization,omitempty"`
}

func (m *GPUDriverKey) Reset()         { *m = GPUDriverKey{} }
func (m *GPUDriverKey) String() string { return proto.CompactTextString(m) }
func (*GPUDriverKey) ProtoMessage()    {}
func (*GPUDriverKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_3aea31a648a25d86, []int{8}
}
func (m *GPUDriverKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GPUDriverKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GPUDriverKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GPUDriverKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GPUDriverKey.Merge(m, src)
}
func (m *GPUDriverKey) XXX_Size() int {
	return m.Size()
}
func (m *GPUDriverKey) XXX_DiscardUnknown() {
	xxx_messageInfo_GPUDriverKey.DiscardUnknown(m)
}

var xxx_messageInfo_GPUDriverKey proto.InternalMessageInfo

type GPUDriverBuild struct {
	// Unique identifier key
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Path where the driver package is located, must be either a public path or the URL to the driver uploaded to the internal artifact registry.
	DriverPath string `protobuf:"bytes,2,opt,name=driver_path,json=driverPath,proto3" json:"driver_path,omitempty"`
	// (deprecated) Optional credentials (username:password) to access driver path
	DriverPathCreds string `protobuf:"bytes,3,opt,name=driver_path_creds,json=driverPathCreds,proto3" json:"driver_path_creds,omitempty"`
	// Operator System supported by GPU driver build
	OperatingSystem OSType `protobuf:"varint,4,opt,name=operating_system,json=operatingSystem,proto3,enum=edgeproto.OSType" json:"operating_system,omitempty"`
	// Kernel Version supported by GPU driver build
	KernelVersion string `protobuf:"bytes,5,opt,name=kernel_version,json=kernelVersion,proto3" json:"kernel_version,omitempty"`
	// Info on hypervisor supported by vGPU driver
	HypervisorInfo string `protobuf:"bytes,6,opt,name=hypervisor_info,json=hypervisorInfo,proto3" json:"hypervisor_info,omitempty"`
	// Driver package md5sum to ensure package is not corrupted
	Md5Sum string `protobuf:"bytes,7,opt,name=md5sum,proto3" json:"md5sum,omitempty"`
	// GPU driver build storage path
	StoragePath string `protobuf:"bytes,8,opt,name=storage_path,json=storagePath,proto3" json:"storage_path,omitempty"`
}

func (m *GPUDriverBuild) Reset()         { *m = GPUDriverBuild{} }
func (m *GPUDriverBuild) String() string { return proto.CompactTextString(m) }
func (*GPUDriverBuild) ProtoMessage()    {}
func (*GPUDriverBuild) Descriptor() ([]byte, []int) {
	return fileDescriptor_3aea31a648a25d86, []int{9}
}
func (m *GPUDriverBuild) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GPUDriverBuild) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GPUDriverBuild.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GPUDriverBuild) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GPUDriverBuild.Merge(m, src)
}
func (m *GPUDriverBuild) XXX_Size() int {
	return m.Size()
}
func (m *GPUDriverBuild) XXX_DiscardUnknown() {
	xxx_messageInfo_GPUDriverBuild.DiscardUnknown(m)
}

var xxx_messageInfo_GPUDriverBuild proto.InternalMessageInfo

type GPUDriverBuildMember struct {
	// Unique identifier key
	Key GPUDriverKey `protobuf:"bytes,1,opt,name=key,proto3" json:"key"`
	// GPU driver build
	Build GPUDriverBuild `protobuf:"bytes,2,opt,name=build,proto3" json:"build"`
	// Ignore state will ignore any action in-progress on the GPU driver
	IgnoreState bool `protobuf:"varint,3,opt,name=ignore_state,json=ignoreState,proto3" json:"ignore_state,omitempty"`
}

func (m *GPUDriverBuildMember) Reset()         { *m = GPUDriverBuildMember{} }
func (m *GPUDriverBuildMember) String() string { return proto.CompactTextString(m) }
func (*GPUDriverBuildMember) ProtoMessage()    {}
func (*GPUDriverBuildMember) Descriptor() ([]byte, []int) {
	return fileDescriptor_3aea31a648a25d86, []int{10}
}
func (m *GPUDriverBuildMember) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GPUDriverBuildMember) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GPUDriverBuildMember.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GPUDriverBuildMember) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GPUDriverBuildMember.Merge(m, src)
}
func (m *GPUDriverBuildMember) XXX_Size() int {
	return m.Size()
}
func (m *GPUDriverBuildMember) XXX_DiscardUnknown() {
	xxx_messageInfo_GPUDriverBuildMember.DiscardUnknown(m)
}

var xxx_messageInfo_GPUDriverBuildMember proto.InternalMessageInfo

type GPUDriverBuildURL struct {
	// Build URL path
	BuildUrlPath string `protobuf:"bytes,1,opt,name=build_url_path,json=buildUrlPath,proto3" json:"build_url_path,omitempty"`
	// Build URL path validity
	Validity Duration `protobuf:"varint,2,opt,name=validity,proto3,casttype=Duration" json:"validity,omitempty"`
}

func (m *GPUDriverBuildURL) Reset()         { *m = GPUDriverBuildURL{} }
func (m *GPUDriverBuildURL) String() string { return proto.CompactTextString(m) }
func (*GPUDriverBuildURL) ProtoMessage()    {}
func (*GPUDriverBuildURL) Descriptor() ([]byte, []int) {
	return fileDescriptor_3aea31a648a25d86, []int{11}
}
func (m *GPUDriverBuildURL) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GPUDriverBuildURL) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GPUDriverBuildURL.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GPUDriverBuildURL) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GPUDriverBuildURL.Merge(m, src)
}
func (m *GPUDriverBuildURL) XXX_Size() int {
	return m.Size()
}
func (m *GPUDriverBuildURL) XXX_DiscardUnknown() {
	xxx_messageInfo_GPUDriverBuildURL.DiscardUnknown(m)
}

var xxx_messageInfo_GPUDriverBuildURL proto.InternalMessageInfo

type GPUDriver struct {
	// Fields are used for the Update API to specify which fields to apply
	Fields []string `protobuf:"bytes,1,rep,name=fields,proto3" json:"fields,omitempty"`
	// Unique identifier key
	Key GPUDriverKey `protobuf:"bytes,2,opt,name=key,proto3" json:"key"`
	// List of GPU driver build
	Builds []GPUDriverBuild `protobuf:"bytes,3,rep,name=builds,proto3" json:"builds"`
	// URL to license config file to setup license
	LicenseConfig string `protobuf:"bytes,4,opt,name=license_config,json=licenseConfig,proto3" json:"license_config,omitempty"`
	// License config md5sum, to ensure integrity of license config
	LicenseConfigMd5Sum string `protobuf:"bytes,5,opt,name=license_config_md5sum,json=licenseConfigMd5sum,proto3" json:"license_config_md5sum,omitempty"`
	// Additional properties associated with GPU driver build
	// For example: license server information, driver release date, etc
	Properties map[string]string `protobuf:"bytes,6,rep,name=properties,proto3" json:"properties,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// State to figure out if any action on the GPU driver is in-progress
	State string `protobuf:"bytes,7,opt,name=state,proto3" json:"state,omitempty"`
	// Ignore state will ignore any action in-progress on the GPU driver
	IgnoreState bool `protobuf:"varint,8,opt,name=ignore_state,json=ignoreState,proto3" json:"ignore_state,omitempty"`
	// Preparing to be deleted
	DeletePrepare bool `protobuf:"varint,9,opt,name=delete_prepare,json=deletePrepare,proto3" json:"delete_prepare,omitempty"`
	// (deprecated) GPU driver storage bucket name
	StorageBucketName string `protobuf:"bytes,10,opt,name=storage_bucket_name,json=storageBucketName,proto3" json:"storage_bucket_name,omitempty"`
	// GPU driver license config storage path
	LicenseConfigStoragePath string `protobuf:"bytes,11,opt,name=license_config_storage_path,json=licenseConfigStoragePath,proto3" json:"license_config_storage_path,omitempty"`
}

func (m *GPUDriver) Reset()         { *m = GPUDriver{} }
func (m *GPUDriver) String() string { return proto.CompactTextString(m) }
func (*GPUDriver) ProtoMessage()    {}
func (*GPUDriver) Descriptor() ([]byte, []int) {
	return fileDescriptor_3aea31a648a25d86, []int{12}
}
func (m *GPUDriver) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GPUDriver) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GPUDriver.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GPUDriver) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GPUDriver.Merge(m, src)
}
func (m *GPUDriver) XXX_Size() int {
	return m.Size()
}
func (m *GPUDriver) XXX_DiscardUnknown() {
	xxx_messageInfo_GPUDriver.DiscardUnknown(m)
}

var xxx_messageInfo_GPUDriver proto.InternalMessageInfo

type GPUConfig struct {
	// GPU driver key
	Driver GPUDriverKey `protobuf:"bytes,1,opt,name=driver,proto3" json:"driver"`
	// Properties to identify specifics of GPU
	Properties map[string]string `protobuf:"bytes,2,rep,name=properties,proto3" json:"properties,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Cloudlet specific license config to setup license
	LicenseConfig string `protobuf:"bytes,3,opt,name=license_config,json=licenseConfig,proto3" json:"license_config,omitempty"`
	// Cloudlet specific license config md5sum, to ensure integrity of license config
	LicenseConfigMd5Sum string `protobuf:"bytes,4,opt,name=license_config_md5sum,json=licenseConfigMd5sum,proto3" json:"license_config_md5sum,omitempty"`
}

func (m *GPUConfig) Reset()         { *m = GPUConfig{} }
func (m *GPUConfig) String() string { return proto.CompactTextString(m) }
func (*GPUConfig) ProtoMessage()    {}
func (*GPUConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_3aea31a648a25d86, []int{13}
}
func (m *GPUConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GPUConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GPUConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GPUConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GPUConfig.Merge(m, src)
}
func (m *GPUConfig) XXX_Size() int {
	return m.Size()
}
func (m *GPUConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_GPUConfig.DiscardUnknown(m)
}

var xxx_messageInfo_GPUConfig proto.InternalMessageInfo

// Cloudlet
//
// A Cloudlet is a set of compute resources at a particular location, provided by an Operator.
type Cloudlet struct {
	// Fields are used for the Update API to specify which fields to apply
	Fields []string `protobuf:"bytes,1,rep,name=fields,proto3" json:"fields,omitempty"`
	// Unique identifier key
	// required: true
	Key CloudletKey `protobuf:"bytes,2,opt,name=key,proto3" json:"key"`
	// Location of the Cloudlet site
	Location distributed_match_engine.Loc `protobuf:"bytes,5,opt,name=location,proto3" json:"location"`
	// Type of IP support provided by Cloudlet (see IpSupport)
	IpSupport IpSupport `protobuf:"varint,6,opt,name=ip_support,json=ipSupport,proto3,enum=edgeproto.IpSupport" json:"ip_support,omitempty"`
	// List of static IPs for static IP support
	StaticIps string `protobuf:"bytes,7,opt,name=static_ips,json=staticIps,proto3" json:"static_ips,omitempty"`
	// Number of dynamic IPs available for dynamic IP support
	NumDynamicIps int32 `protobuf:"varint,8,opt,name=num_dynamic_ips,json=numDynamicIps,proto3" json:"num_dynamic_ips,omitempty"`
	// time limits which override global settings if non-zero
	TimeLimits OperationTimeLimits `protobuf:"bytes,9,opt,name=time_limits,json=timeLimits,proto3" json:"time_limits"`
	// Any errors trying to create, update, or delete the Cloudlet.
	Errors []string `protobuf:"bytes,10,rep,name=errors,proto3" json:"errors,omitempty"`
	// Onboarding state of the cloudlet
	OnboardingState TrackedState `protobuf:"varint,60,opt,name=onboarding_state,json=onboardingState,proto3,enum=edgeproto.TrackedState" json:"onboarding_state,omitempty"`
	// Current state of the crm
	State TrackedState `protobuf:"varint,12,opt,name=state,proto3,enum=edgeproto.TrackedState" json:"state,omitempty"`
	// Override actions to CRM
	CrmOverride CRMOverride `protobuf:"varint,13,opt,name=crm_override,json=crmOverride,proto3,enum=edgeproto.CRMOverride" json:"crm_override,omitempty"`
	// Deploy cloudlet services locally
	DeploymentLocal bool `protobuf:"varint,14,opt,name=deployment_local,json=deploymentLocal,proto3" json:"deployment_local,omitempty"`
	// Platform type
	PlatformType string `protobuf:"bytes,15,opt,name=platform_type,json=platformType,proto3" json:"platform_type,omitempty"`
	// Address for the CRM notify listener to run on
	NotifySrvAddr string `protobuf:"bytes,16,opt,name=notify_srv_addr,json=notifySrvAddr,proto3" json:"notify_srv_addr,omitempty"`
	// Min system resource requirements for platform
	Flavor FlavorKey `protobuf:"bytes,17,opt,name=flavor,proto3" json:"flavor"`
	// Physical infrastructure cloudlet name
	PhysicalName string `protobuf:"bytes,18,opt,name=physical_name,json=physicalName,proto3" json:"physical_name,omitempty"`
	// Single Key-Value pair of env var to be passed to CRM
	EnvVar map[string]string `protobuf:"bytes,19,rep,name=env_var,json=envVar,proto3" json:"env_var,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Cloudlet container version
	ContainerVersion string `protobuf:"bytes,20,opt,name=container_version,json=containerVersion,proto3" json:"container_version,omitempty"`
	// (deprecated, unused) Platform Config Info
	Config PlatformConfig `protobuf:"bytes,21,opt,name=config,proto3" json:"config"`
	// Optional resource to restagtbl key map key values = [gpu, nas, nic]
	ResTagMap map[string]*ResTagTableKey `protobuf:"bytes,22,rep,name=res_tag_map,json=resTagMap,proto3" json:"res_tag_map,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Secrets required to access cloudlet, will be saved in encrypted storage
	AccessVars map[string]string `protobuf:"bytes,23,rep,name=access_vars,json=accessVars,proto3" json:"access_vars,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// EdgeCloud baseimage version where CRM services reside
	VmImageVersion string `protobuf:"bytes,24,opt,name=vm_image_version,json=vmImageVersion,proto3" json:"vm_image_version,omitempty"`
	// Deployment type to bring up CRM services (docker, kubernetes)
	Deployment string `protobuf:"bytes,26,opt,name=deployment,proto3" json:"deployment,omitempty"`
	// Infra Access Type is the type of access available to Infra API Endpoint
	InfraApiAccess InfraApiAccess `protobuf:"varint,27,opt,name=infra_api_access,json=infraApiAccess,proto3,enum=edgeproto.InfraApiAccess" json:"infra_api_access,omitempty"`
	// Infra specific config
	InfraConfig InfraConfig `protobuf:"bytes,28,opt,name=infra_config,json=infraConfig,proto3" json:"infra_config"`
	// State for maintenance
	MaintenanceState distributed_match_engine.MaintenanceState `protobuf:"varint,30,opt,name=maintenance_state,json=maintenanceState,proto3,enum=distributed_match_engine.MaintenanceState" json:"maintenance_state,omitempty"`
	// Override container version from policy file
	OverridePolicyContainerVersion bool `protobuf:"varint,31,opt,name=override_policy_container_version,json=overridePolicyContainerVersion,proto3" json:"override_policy_container_version,omitempty"`
	// VM Pool
	VmPool string `protobuf:"bytes,32,opt,name=vm_pool,json=vmPool,proto3" json:"vm_pool,omitempty"`
	// CRM access public key
	CrmAccessPublicKey string `protobuf:"bytes,33,opt,name=crm_access_public_key,json=crmAccessPublicKey,proto3" json:"crm_access_public_key,omitempty"`
	// CRM access key upgrade required
	CrmAccessKeyUpgradeRequired bool `protobuf:"varint,34,opt,name=crm_access_key_upgrade_required,json=crmAccessKeyUpgradeRequired,proto3" json:"crm_access_key_upgrade_required,omitempty"`
	// Created at time
	CreatedAt distributed_match_engine.Timestamp `protobuf:"bytes,35,opt,name=created_at,json=createdAt,proto3" json:"created_at"`
	// Updated at time
	UpdatedAt distributed_match_engine.Timestamp `protobuf:"bytes,36,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at"`
	// Optional Trust Policy
	TrustPolicy string `protobuf:"bytes,37,opt,name=trust_policy,json=trustPolicy,proto3" json:"trust_policy,omitempty"`
	// State of trust policy
	TrustPolicyState TrackedState `protobuf:"varint,38,opt,name=trust_policy_state,json=trustPolicyState,proto3,enum=edgeproto.TrackedState" json:"trust_policy_state,omitempty"`
	// Resource quotas
	ResourceQuotas []ResourceQuota `protobuf:"bytes,39,rep,name=resource_quotas,json=resourceQuotas,proto3" json:"resource_quotas"`
	// Default resource alert threshold percentage
	DefaultResourceAlertThreshold int32 `protobuf:"varint,40,opt,name=default_resource_alert_threshold,json=defaultResourceAlertThreshold,proto3" json:"default_resource_alert_threshold,omitempty"`
	// Address of the controller hosting the cloudlet services if it is running locally
	HostController string `protobuf:"bytes,41,opt,name=HostController,proto3" json:"HostController,omitempty"`
	// Operator provided kafka cluster endpoint to push events to
	KafkaCluster string `protobuf:"bytes,42,opt,name=kafka_cluster,json=kafkaCluster,proto3" json:"kafka_cluster,omitempty"`
	// Username for kafka SASL/PLAIN authentification, stored securely in secret storage and never visible externally
	KafkaUser string `protobuf:"bytes,43,opt,name=kafka_user,json=kafkaUser,proto3" json:"kafka_user,omitempty"`
	// Password for kafka SASL/PLAIN authentification, stored securely in secret storage and never visible externally
	KafkaPassword string `protobuf:"bytes,44,opt,name=kafka_password,json=kafkaPassword,proto3" json:"kafka_password,omitempty"`
	// GPU Configuration associated with cloudlet
	GpuConfig GPUConfig `protobuf:"bytes,45,opt,name=gpu_config,json=gpuConfig,proto3" json:"gpu_config"`
	// Enable experimental default multitenant (serverless) cluster
	EnableDefaultServerlessCluster bool `protobuf:"varint,46,opt,name=enable_default_serverless_cluster,json=enableDefaultServerlessCluster,proto3" json:"enable_default_serverless_cluster,omitempty"`
	// This cloudlet will be treated as directly connected to these additional operator organizations for the purposes of FindCloudlet
	AllianceOrgs []string `protobuf:"bytes,47,rep,name=alliance_orgs,json=allianceOrgs,proto3" json:"alliance_orgs,omitempty"`
	// For single kubernetes cluster cloudlet platforms, cluster is owned by this organization instead of multi-tenant
	SingleKubernetesClusterOwner string `protobuf:"bytes,48,opt,name=single_kubernetes_cluster_owner,json=singleKubernetesClusterOwner,proto3" json:"single_kubernetes_cluster_owner,omitempty"`
	// Preparing to be deleted
	DeletePrepare bool `protobuf:"varint,49,opt,name=delete_prepare,json=deletePrepare,proto3" json:"delete_prepare,omitempty"`
	// Enable platform H/A
	PlatformHighAvailability bool `protobuf:"varint,50,opt,name=platform_high_availability,json=platformHighAvailability,proto3" json:"platform_high_availability,omitempty"`
	// CRM secondary access public key for H/A
	SecondaryCrmAccessPublicKey string `protobuf:"bytes,51,opt,name=secondary_crm_access_public_key,json=secondaryCrmAccessPublicKey,proto3" json:"secondary_crm_access_public_key,omitempty"`
	// CRM secondary access key upgrade required for H/A
	SecondaryCrmAccessKeyUpgradeRequired bool `protobuf:"varint,52,opt,name=secondary_crm_access_key_upgrade_required,json=secondaryCrmAccessKeyUpgradeRequired,proto3" json:"secondary_crm_access_key_upgrade_required,omitempty"`
	// Address for the secondary CRM notify listener to run on
	SecondaryNotifySrvAddr string `protobuf:"bytes,53,opt,name=secondary_notify_srv_addr,json=secondaryNotifySrvAddr,proto3" json:"secondary_notify_srv_addr,omitempty"`
	// DNS label that is unique within the region
	DnsLabel string `protobuf:"bytes,54,opt,name=dns_label,json=dnsLabel,proto3" json:"dns_label,omitempty"`
	// Root LB FQDN which is globally unique
	RootLbFqdn string `protobuf:"bytes,55,opt,name=root_lb_fqdn,json=rootLbFqdn,proto3" json:"root_lb_fqdn,omitempty"`
	// Federation config for a federated cloudlet
	FederationConfig FederationConfig `protobuf:"bytes,56,opt,name=federation_config,json=federationConfig,proto3" json:"federation_config"`
	// GPU driver license config storage path
	LicenseConfigStoragePath string `protobuf:"bytes,57,opt,name=license_config_storage_path,json=licenseConfigStoragePath,proto3" json:"license_config_storage_path,omitempty"`
	// Cloudlet-specific flavors
	InfraFlavors []*FlavorInfo `protobuf:"bytes,58,rep,name=infra_flavors,json=infraFlavors,proto3" json:"infra_flavors,omitempty"`
	// Edgebox only cloudlets allow for developers to set up cloudlets anywhere (laptop, etc) but can only use public images and do not support DNS mapping.
	EdgeboxOnly bool `protobuf:"varint,59,opt,name=edgebox_only,json=edgeboxOnly,proto3" json:"edgebox_only,omitempty"`
}

func (m *Cloudlet) Reset()         { *m = Cloudlet{} }
func (m *Cloudlet) String() string { return proto.CompactTextString(m) }
func (*Cloudlet) ProtoMessage()    {}
func (*Cloudlet) Descriptor() ([]byte, []int) {
	return fileDescriptor_3aea31a648a25d86, []int{14}
}
func (m *Cloudlet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Cloudlet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Cloudlet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Cloudlet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Cloudlet.Merge(m, src)
}
func (m *Cloudlet) XXX_Size() int {
	return m.Size()
}
func (m *Cloudlet) XXX_DiscardUnknown() {
	xxx_messageInfo_Cloudlet.DiscardUnknown(m)
}

var xxx_messageInfo_Cloudlet proto.InternalMessageInfo

type FlavorMatch struct {
	// Cloudlet ctx
	Key CloudletKey `protobuf:"bytes,1,opt,name=key,proto3" json:"key"`
	// Flavor name to lookup
	FlavorName string `protobuf:"bytes,3,opt,name=flavor_name,json=flavorName,proto3" json:"flavor_name,omitempty"`
	// availability zone for optional resources if any
	AvailabilityZone string `protobuf:"bytes,4,opt,name=availability_zone,json=availabilityZone,proto3" json:"availability_zone,omitempty"`
}

func (m *FlavorMatch) Reset()         { *m = FlavorMatch{} }
func (m *FlavorMatch) String() string { return proto.CompactTextString(m) }
func (*FlavorMatch) ProtoMessage()    {}
func (*FlavorMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_3aea31a648a25d86, []int{15}
}
func (m *FlavorMatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FlavorMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FlavorMatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FlavorMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlavorMatch.Merge(m, src)
}
func (m *FlavorMatch) XXX_Size() int {
	return m.Size()
}
func (m *FlavorMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_FlavorMatch.DiscardUnknown(m)
}

var xxx_messageInfo_FlavorMatch proto.InternalMessageInfo

type CloudletManifest struct {
	// Manifest to bringup cloudlet VM and services.
	Manifest string `protobuf:"bytes,2,opt,name=manifest,proto3" json:"manifest,omitempty"`
}

func (m *CloudletManifest) Reset()         { *m = CloudletManifest{} }
func (m *CloudletManifest) String() string { return proto.CompactTextString(m) }
func (*CloudletManifest) ProtoMessage()    {}
func (*CloudletManifest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3aea31a648a25d86, []int{16}
}
func (m *CloudletManifest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CloudletManifest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CloudletManifest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CloudletManifest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloudletManifest.Merge(m, src)
}
func (m *CloudletManifest) XXX_Size() int {
	return m.Size()
}
func (m *CloudletManifest) XXX_DiscardUnknown() {
	xxx_messageInfo_CloudletManifest.DiscardUnknown(m)
}

var xxx_messageInfo_CloudletManifest proto.InternalMessageInfo

type PropertyInfo struct {
	// Name of the property
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Description of the property
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// Default value of the property
	Value string `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
	// Is the property a secret value, will be hidden
	Secret bool `protobuf:"varint,4,opt,name=secret,proto3" json:"secret,omitempty"`
	// Is the property mandatory
	Mandatory bool `protobuf:"varint,5,opt,name=mandatory,proto3" json:"mandatory,omitempty"`
	// Is the property internal, not to be set by Operator
	Internal bool `protobuf:"varint,6,opt,name=internal,proto3" json:"internal,omitempty"`
	// The property is a time-based one-time password (TOTP, RFC 6238) secret key that will be used to generate TOTP codes, and never leaves Vault.
	TotpSecret bool `protobuf:"varint,7,opt,name=totp_secret,json=totpSecret,proto3" json:"totp_secret,omitempty"`
}

func (m *PropertyInfo) Reset()         { *m = PropertyInfo{} }
func (m *PropertyInfo) String() string { return proto.CompactTextString(m) }
func (*PropertyInfo) ProtoMessage()    {}
func (*PropertyInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3aea31a648a25d86, []int{17}
}
func (m *PropertyInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PropertyInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PropertyInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PropertyInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PropertyInfo.Merge(m, src)
}
func (m *PropertyInfo) XXX_Size() int {
	return m.Size()
}
func (m *PropertyInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PropertyInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PropertyInfo proto.InternalMessageInfo

// Infra properties used to set up cloudlet
type CloudletProps struct {
	// Platform type
	PlatformType string `protobuf:"bytes,1,opt,name=platform_type,json=platformType,proto3" json:"platform_type,omitempty"`
	// Single Key-Value pair of env var to be passed to CRM
	Properties map[string]*PropertyInfo `protobuf:"bytes,2,rep,name=properties,proto3" json:"properties,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Organization
	Organization string `protobuf:"bytes,3,opt,name=organization,proto3" json:"organization,omitempty"`
}

func (m *CloudletProps) Reset()         { *m = CloudletProps{} }
func (m *CloudletProps) String() string { return proto.CompactTextString(m) }
func (*CloudletProps) ProtoMessage()    {}
func (*CloudletProps) Descriptor() ([]byte, []int) {
	return fileDescriptor_3aea31a648a25d86, []int{18}
}
func (m *CloudletProps) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CloudletProps) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CloudletProps.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CloudletProps) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloudletProps.Merge(m, src)
}
func (m *CloudletProps) XXX_Size() int {
	return m.Size()
}
func (m *CloudletProps) XXX_DiscardUnknown() {
	xxx_messageInfo_CloudletProps.DiscardUnknown(m)
}

var xxx_messageInfo_CloudletProps proto.InternalMessageInfo

type CloudletResourceQuotaProps struct {
	// Platform type
	PlatformType string `protobuf:"bytes,1,opt,name=platform_type,json=platformType,proto3" json:"platform_type,omitempty"`
	// Cloudlet resource properties
	Properties []InfraResource `protobuf:"bytes,2,rep,name=properties,proto3" json:"properties"`
	// Organization
	Organization string `protobuf:"bytes,3,opt,name=organization,proto3" json:"organization,omitempty"`
}

func (m *CloudletResourceQuotaProps) Reset()         { *m = CloudletResourceQuotaProps{} }
func (m *CloudletResourceQuotaProps) String() string { return proto.CompactTextString(m) }
func (*CloudletResourceQuotaProps) ProtoMessage()    {}
func (*CloudletResourceQuotaProps) Descriptor() ([]byte, []int) {
	return fileDescriptor_3aea31a648a25d86, []int{19}
}
func (m *CloudletResourceQuotaProps) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CloudletResourceQuotaProps) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CloudletResourceQuotaProps.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CloudletResourceQuotaProps) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloudletResourceQuotaProps.Merge(m, src)
}
func (m *CloudletResourceQuotaProps) XXX_Size() int {
	return m.Size()
}
func (m *CloudletResourceQuotaProps) XXX_DiscardUnknown() {
	xxx_messageInfo_CloudletResourceQuotaProps.DiscardUnknown(m)
}

var xxx_messageInfo_CloudletResourceQuotaProps proto.InternalMessageInfo

type CloudletResourceUsage struct {
	// Cloudlet Key
	Key CloudletKey `protobuf:"bytes,1,opt,name=key,proto3" json:"key"`
	// Show Infra based usage
	InfraUsage bool `protobuf:"varint,2,opt,name=infra_usage,json=infraUsage,proto3" json:"infra_usage,omitempty"`
	// Infra Resource information
	Info []InfraResource `protobuf:"bytes,3,rep,name=info,proto3" json:"info"`
}

func (m *CloudletResourceUsage) Reset()         { *m = CloudletResourceUsage{} }
func (m *CloudletResourceUsage) String() string { return proto.CompactTextString(m) }
func (*CloudletResourceUsage) ProtoMessage()    {}
func (*CloudletResourceUsage) Descriptor() ([]byte, []int) {
	return fileDescriptor_3aea31a648a25d86, []int{20}
}
func (m *CloudletResourceUsage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CloudletResourceUsage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CloudletResourceUsage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CloudletResourceUsage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloudletResourceUsage.Merge(m, src)
}
func (m *CloudletResourceUsage) XXX_Size() int {
	return m.Size()
}
func (m *CloudletResourceUsage) XXX_DiscardUnknown() {
	xxx_messageInfo_CloudletResourceUsage.DiscardUnknown(m)
}

var xxx_messageInfo_CloudletResourceUsage proto.InternalMessageInfo

type CloudletAllianceOrg struct {
	// Cloudlet Key
	Key CloudletKey `protobuf:"bytes,1,opt,name=key,proto3" json:"key"`
	// Alliance organization
	Organization string `protobuf:"bytes,2,opt,name=organization,proto3" json:"organization,omitempty"`
}

func (m *CloudletAllianceOrg) Reset()         { *m = CloudletAllianceOrg{} }
func (m *CloudletAllianceOrg) String() string { return proto.CompactTextString(m) }
func (*CloudletAllianceOrg) ProtoMessage()    {}
func (*CloudletAllianceOrg) Descriptor() ([]byte, []int) {
	return fileDescriptor_3aea31a648a25d86, []int{21}
}
func (m *CloudletAllianceOrg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CloudletAllianceOrg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CloudletAllianceOrg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CloudletAllianceOrg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloudletAllianceOrg.Merge(m, src)
}
func (m *CloudletAllianceOrg) XXX_Size() int {
	return m.Size()
}
func (m *CloudletAllianceOrg) XXX_DiscardUnknown() {
	xxx_messageInfo_CloudletAllianceOrg.DiscardUnknown(m)
}

var xxx_messageInfo_CloudletAllianceOrg proto.InternalMessageInfo

// Flavor details from the Cloudlet
type FlavorInfo struct {
	// Name of the flavor on the Cloudlet
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Number of VCPU cores on the Cloudlet
	Vcpus uint64 `protobuf:"varint,2,opt,name=vcpus,proto3" json:"vcpus,omitempty"`
	// Ram in MB on the Cloudlet
	Ram uint64 `protobuf:"varint,3,opt,name=ram,proto3" json:"ram,omitempty"`
	// Amount of disk in GB on the Cloudlet
	Disk uint64 `protobuf:"varint,4,opt,name=disk,proto3" json:"disk,omitempty"`
	// OS Flavor Properties, if any
	PropMap map[string]string `protobuf:"bytes,5,rep,name=prop_map,json=propMap,proto3" json:"prop_map,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *FlavorInfo) Reset()         { *m = FlavorInfo{} }
func (m *FlavorInfo) String() string { return proto.CompactTextString(m) }
func (*FlavorInfo) ProtoMessage()    {}
func (*FlavorInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3aea31a648a25d86, []int{22}
}
func (m *FlavorInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FlavorInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FlavorInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FlavorInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlavorInfo.Merge(m, src)
}
func (m *FlavorInfo) XXX_Size() int {
	return m.Size()
}
func (m *FlavorInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_FlavorInfo.DiscardUnknown(m)
}

var xxx_messageInfo_FlavorInfo proto.InternalMessageInfo

type OSAZone struct {
	// OpenStack availability zone name
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// OpenStack availability zone status
	Status string `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *OSAZone) Reset()         { *m = OSAZone{} }
func (m *OSAZone) String() string { return proto.CompactTextString(m) }
func (*OSAZone) ProtoMessage()    {}
func (*OSAZone) Descriptor() ([]byte, []int) {
	return fileDescriptor_3aea31a648a25d86, []int{23}
}
func (m *OSAZone) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OSAZone) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OSAZone.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OSAZone) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OSAZone.Merge(m, src)
}
func (m *OSAZone) XXX_Size() int {
	return m.Size()
}
func (m *OSAZone) XXX_DiscardUnknown() {
	xxx_messageInfo_OSAZone.DiscardUnknown(m)
}

var xxx_messageInfo_OSAZone proto.InternalMessageInfo

type OSImage struct {
	// image name
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// optional tags present on image
	Tags string `protobuf:"bytes,2,opt,name=tags,proto3" json:"tags,omitempty"`
	// image properties/metadata
	Properties string `protobuf:"bytes,3,opt,name=properties,proto3" json:"properties,omitempty"`
	// format qcow2, img, etc
	DiskFormat string `protobuf:"bytes,4,opt,name=disk_format,json=diskFormat,proto3" json:"disk_format,omitempty"`
}

func (m *OSImage) Reset()         { *m = OSImage{} }
func (m *OSImage) String() string { return proto.CompactTextString(m) }
func (*OSImage) ProtoMessage()    {}
func (*OSImage) Descriptor() ([]byte, []int) {
	return fileDescriptor_3aea31a648a25d86, []int{24}
}
func (m *OSImage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OSImage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OSImage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OSImage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OSImage.Merge(m, src)
}
func (m *OSImage) XXX_Size() int {
	return m.Size()
}
func (m *OSImage) XXX_DiscardUnknown() {
	xxx_messageInfo_OSImage.DiscardUnknown(m)
}

var xxx_messageInfo_OSImage proto.InternalMessageInfo

// CloudletOnboardingInfo messages are sent from CCRM to the Controller.
type CloudletOnboardingInfo struct {
	// Unique identifier key
	Key CloudletKey `protobuf:"bytes,1,opt,name=key,proto3" json:"key"`
	// Onboarding state of the cloudlet
	OnboardingState TrackedState `protobuf:"varint,2,opt,name=onboarding_state,json=onboardingState,proto3,enum=edgeproto.TrackedState" json:"onboarding_state,omitempty"`
	// status is used to reflect progress of creation or other events
	Status StatusInfo `protobuf:"bytes,3,opt,name=status,proto3" json:"status"`
	// Any errors encountered while making changes to the Cloudlet
	Errors []string `protobuf:"bytes,4,rep,name=errors,proto3" json:"errors,omitempty"`
}

func (m *CloudletOnboardingInfo) Reset()         { *m = CloudletOnboardingInfo{} }
func (m *CloudletOnboardingInfo) String() string { return proto.CompactTextString(m) }
func (*CloudletOnboardingInfo) ProtoMessage()    {}
func (*CloudletOnboardingInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3aea31a648a25d86, []int{25}
}
func (m *CloudletOnboardingInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CloudletOnboardingInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CloudletOnboardingInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CloudletOnboardingInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloudletOnboardingInfo.Merge(m, src)
}
func (m *CloudletOnboardingInfo) XXX_Size() int {
	return m.Size()
}
func (m *CloudletOnboardingInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CloudletOnboardingInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CloudletOnboardingInfo proto.InternalMessageInfo

// CloudletInfo provides information from the Cloudlet Resource Manager about the state of the Cloudlet.
type CloudletInfo struct {
	// Fields are used for the Update API to specify which fields to apply
	Fields []string `protobuf:"bytes,1,rep,name=fields,proto3" json:"fields,omitempty"`
	// Unique identifier key
	Key CloudletKey `protobuf:"bytes,2,opt,name=key,proto3" json:"key"`
	// State of cloudlet
	State distributed_match_engine.CloudletState `protobuf:"varint,3,opt,name=state,proto3,enum=distributed_match_engine.CloudletState" json:"state,omitempty"`
	// Id of client assigned by server (internal use only)
	NotifyId int64 `protobuf:"varint,4,opt,name=notify_id,json=notifyId,proto3" json:"notify_id,omitempty"`
	// Connected controller unique id
	Controller string `protobuf:"bytes,5,opt,name=controller,proto3" json:"controller,omitempty"`
	// Maximum Ram in MB on the Cloudlet
	OsMaxRam uint64 `protobuf:"varint,6,opt,name=os_max_ram,json=osMaxRam,proto3" json:"os_max_ram,omitempty"`
	// Maximum number of VCPU cores on the Cloudlet
	OsMaxVcores uint64 `protobuf:"varint,7,opt,name=os_max_vcores,json=osMaxVcores,proto3" json:"os_max_vcores,omitempty"`
	// Maximum amount of disk in GB on the Cloudlet
	OsMaxVolGb uint64 `protobuf:"varint,8,opt,name=os_max_vol_gb,json=osMaxVolGb,proto3" json:"os_max_vol_gb,omitempty"`
	// Any errors encountered while making changes to the Cloudlet
	Errors []string `protobuf:"bytes,9,rep,name=errors,proto3" json:"errors,omitempty"`
	// Supported flavors by the Cloudlet
	Flavors []*FlavorInfo `protobuf:"bytes,10,rep,name=flavors,proto3" json:"flavors,omitempty"`
	// status is used to reflect progress of creation or other events
	// hidden: true (stored in redis only)
	Status StatusInfo `protobuf:"bytes,11,opt,name=status,proto3" json:"status"`
	// Cloudlet container version
	ContainerVersion string `protobuf:"bytes,12,opt,name=container_version,json=containerVersion,proto3" json:"container_version,omitempty"`
	// Availability Zones if any
	AvailabilityZones []*OSAZone `protobuf:"bytes,13,rep,name=availability_zones,json=availabilityZones,proto3" json:"availability_zones,omitempty"`
	// Local Images availble to cloudlet
	OsImages []*OSImage `protobuf:"bytes,14,rep,name=os_images,json=osImages,proto3" json:"os_images,omitempty"`
	// Indicates all controller data has been sent to CRM
	ControllerCacheReceived bool `protobuf:"varint,15,opt,name=controller_cache_received,json=controllerCacheReceived,proto3" json:"controller_cache_received,omitempty"`
	// State for maintenance
	MaintenanceState distributed_match_engine.MaintenanceState `protobuf:"varint,16,opt,name=maintenance_state,json=maintenanceState,proto3,enum=distributed_match_engine.MaintenanceState" json:"maintenance_state,omitempty"`
	// Snapshot of resources used by cloudlet
	ResourcesSnapshot InfraResourcesSnapshot `protobuf:"bytes,17,opt,name=resources_snapshot,json=resourcesSnapshot,proto3" json:"resources_snapshot"`
	// Trust Policy State
	TrustPolicyState TrackedState `protobuf:"varint,18,opt,name=trust_policy_state,json=trustPolicyState,proto3,enum=edgeproto.TrackedState" json:"trust_policy_state,omitempty"`
	// Version for compatibility tracking
	CompatibilityVersion uint32 `protobuf:"varint,19,opt,name=compatibility_version,json=compatibilityVersion,proto3" json:"compatibility_version,omitempty"`
	// Cloudlet properties
	Properties map[string]string `protobuf:"bytes,20,rep,name=properties,proto3" json:"properties,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Cluster node info for serverless platforms (k8s multi-tenant cluster)
	NodeInfos []*NodeInfo `protobuf:"bytes,21,rep,name=node_infos,json=nodeInfos,proto3" json:"node_infos,omitempty"`
	// Active HA instance
	ActiveCrmInstance string `protobuf:"bytes,22,opt,name=active_crm_instance,json=activeCrmInstance,proto3" json:"active_crm_instance,omitempty"`
	// Denotes if info was reported by inactive
	StandbyCrm bool `protobuf:"varint,23,opt,name=standby_crm,json=standbyCrm,proto3" json:"standby_crm,omitempty"`
	// Cloudlet release version
	ReleaseVersion string `protobuf:"bytes,24,opt,name=release_version,json=releaseVersion,proto3" json:"release_version,omitempty"`
}

func (m *CloudletInfo) Reset()         { *m = CloudletInfo{} }
func (m *CloudletInfo) String() string { return proto.CompactTextString(m) }
func (*CloudletInfo) ProtoMessage()    {}
func (*CloudletInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3aea31a648a25d86, []int{26}
}
func (m *CloudletInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CloudletInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CloudletInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CloudletInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloudletInfo.Merge(m, src)
}
func (m *CloudletInfo) XXX_Size() int {
	return m.Size()
}
func (m *CloudletInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CloudletInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CloudletInfo proto.InternalMessageInfo

// (TODO) CloudletMetrics provide metrics collected about the Cloudlet. They are sent to a metrics collector for analytics. They are not stored in the persistent distributed database, but are stored as a time series in some other database or files.
type CloudletMetrics struct {
	// what goes here?
	Foo uint64 `protobuf:"varint,5,opt,name=foo,proto3" json:"foo,omitempty"`
}

func (m *CloudletMetrics) Reset()         { *m = CloudletMetrics{} }
func (m *CloudletMetrics) String() string { return proto.CompactTextString(m) }
func (*CloudletMetrics) ProtoMessage()    {}
func (*CloudletMetrics) Descriptor() ([]byte, []int) {
	return fileDescriptor_3aea31a648a25d86, []int{27}
}
func (m *CloudletMetrics) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CloudletMetrics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CloudletMetrics.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CloudletMetrics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloudletMetrics.Merge(m, src)
}
func (m *CloudletMetrics) XXX_Size() int {
	return m.Size()
}
func (m *CloudletMetrics) XXX_DiscardUnknown() {
	xxx_messageInfo_CloudletMetrics.DiscardUnknown(m)
}

var xxx_messageInfo_CloudletMetrics proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("edgeproto.InfraApiAccess", InfraApiAccess_name, InfraApiAccess_value)
	proto.RegisterEnum("edgeproto.OSType", OSType_name, OSType_value)
	proto.RegisterEnum("edgeproto.ReportSchedule", ReportSchedule_name, ReportSchedule_value)
	proto.RegisterType((*OperationTimeLimits)(nil), "edgeproto.OperationTimeLimits")
	proto.RegisterType((*CloudletInternal)(nil), "edgeproto.CloudletInternal")
	proto.RegisterMapType((map[string]string)(nil), "edgeproto.CloudletInternal.PropsEntry")
	proto.RegisterType((*PlatformConfig)(nil), "edgeproto.PlatformConfig")
	proto.RegisterMapType((map[string]string)(nil), "edgeproto.PlatformConfig.EnvVarEntry")
	proto.RegisterType((*FederationConfig)(nil), "edgeproto.FederationConfig")
	proto.RegisterType((*PlatformFeatures)(nil), "edgeproto.PlatformFeatures")
	proto.RegisterMapType((map[string]*PropertyInfo)(nil), "edgeproto.PlatformFeatures.AccessVarsEntry")
	proto.RegisterMapType((map[string]*PropertyInfo)(nil), "edgeproto.PlatformFeatures.PropertiesEntry")
	proto.RegisterType((*CloudletResMap)(nil), "edgeproto.CloudletResMap")
	proto.RegisterMapType((map[string]string)(nil), "edgeproto.CloudletResMap.MappingEntry")
	proto.RegisterType((*InfraConfig)(nil), "edgeproto.InfraConfig")
	proto.RegisterType((*ResourceQuota)(nil), "edgeproto.ResourceQuota")
	proto.RegisterType((*GPUDriverKey)(nil), "edgeproto.GPUDriverKey")
	proto.RegisterType((*GPUDriverBuild)(nil), "edgeproto.GPUDriverBuild")
	proto.RegisterType((*GPUDriverBuildMember)(nil), "edgeproto.GPUDriverBuildMember")
	proto.RegisterType((*GPUDriverBuildURL)(nil), "edgeproto.GPUDriverBuildURL")
	proto.RegisterType((*GPUDriver)(nil), "edgeproto.GPUDriver")
	proto.RegisterMapType((map[string]string)(nil), "edgeproto.GPUDriver.PropertiesEntry")
	proto.RegisterType((*GPUConfig)(nil), "edgeproto.GPUConfig")
	proto.RegisterMapType((map[string]string)(nil), "edgeproto.GPUConfig.PropertiesEntry")
	proto.RegisterType((*Cloudlet)(nil), "edgeproto.Cloudlet")
	proto.RegisterMapType((map[string]string)(nil), "edgeproto.Cloudlet.AccessVarsEntry")
	proto.RegisterMapType((map[string]string)(nil), "edgeproto.Cloudlet.EnvVarEntry")
	proto.RegisterMapType((map[string]*ResTagTableKey)(nil), "edgeproto.Cloudlet.ResTagMapEntry")
	proto.RegisterType((*FlavorMatch)(nil), "edgeproto.FlavorMatch")
	proto.RegisterType((*CloudletManifest)(nil), "edgeproto.CloudletManifest")
	proto.RegisterType((*PropertyInfo)(nil), "edgeproto.PropertyInfo")
	proto.RegisterType((*CloudletProps)(nil), "edgeproto.CloudletProps")
	proto.RegisterMapType((map[string]*PropertyInfo)(nil), "edgeproto.CloudletProps.PropertiesEntry")
	proto.RegisterType((*CloudletResourceQuotaProps)(nil), "edgeproto.CloudletResourceQuotaProps")
	proto.RegisterType((*CloudletResourceUsage)(nil), "edgeproto.CloudletResourceUsage")
	proto.RegisterType((*CloudletAllianceOrg)(nil), "edgeproto.CloudletAllianceOrg")
	proto.RegisterType((*FlavorInfo)(nil), "edgeproto.FlavorInfo")
	proto.RegisterMapType((map[string]string)(nil), "edgeproto.FlavorInfo.PropMapEntry")
	proto.RegisterType((*OSAZone)(nil), "edgeproto.OSAZone")
	proto.RegisterType((*OSImage)(nil), "edgeproto.OSImage")
	proto.RegisterType((*CloudletOnboardingInfo)(nil), "edgeproto.CloudletOnboardingInfo")
	proto.RegisterType((*CloudletInfo)(nil), "edgeproto.CloudletInfo")
	proto.RegisterMapType((map[string]string)(nil), "edgeproto.CloudletInfo.PropertiesEntry")
	proto.RegisterType((*CloudletMetrics)(nil), "edgeproto.CloudletMetrics")
}

func init() { proto.RegisterFile("cloudlet.proto", fileDescriptor_3aea31a648a25d86) }

var fileDescriptor_3aea31a648a25d86 = []byte{
	// 6385 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x7c, 0x5b, 0x6c, 0x24, 0xc7,
	0x75, 0xe8, 0x36, 0xc9, 0xe5, 0xce, 0x9c, 0x21, 0x87, 0xc3, 0xe6, 0x63, 0x9b, 0x5c, 0x2e, 0x97,
	0x3b, 0x7a, 0xad, 0x56, 0x23, 0xd2, 0xa2, 0xb4, 0xb2, 0x44, 0x4b, 0xb2, 0xf8, 0xd8, 0x07, 0xbd,
	0xcb, 0x25, 0xd5, 0xe4, 0xee, 0x5e, 0xeb, 0xe2, 0xde, 0x4e, 0xb3, 0xbb, 0x38, 0xec, 0xb0, 0xa7,
	0xab, 0x55, 0xd5, 0x33, 0xd2, 0xe8, 0x27, 0xb6, 0x7f, 0x9c, 0x20, 0x40, 0xe0, 0x28, 0x4e, 0xec,
	0x28, 0x01, 0xe2, 0x38, 0x36, 0x62, 0x04, 0x09, 0x60, 0x28, 0xf9, 0xb1, 0x93, 0x0f, 0x27, 0xf9,
	0x51, 0x1c, 0x04, 0x90, 0x91, 0x04, 0x30, 0x14, 0xc4, 0x76, 0xa4, 0x7c, 0x24, 0x9b, 0x8f, 0x04,
	0x30, 0xb9, 0x32, 0xfc, 0x93, 0xa0, 0x1e, 0xfd, 0x9a, 0xe9, 0xe1, 0x6b, 0xd7, 0xf1, 0xdf, 0xf4,
	0xa9, 0x53, 0xa7, 0x4f, 0x9d, 0x3a, 0x75, 0x9e, 0xd5, 0x03, 0x45, 0xcb, 0xc5, 0x75, 0xdb, 0x45,
	0xc1, 0xb4, 0x4f, 0x70, 0x80, 0xd5, 0x3c, 0xb2, 0xab, 0x88, 0xff, 0x1c, 0x9f, 0xa8, 0x62, 0x5c,
	0x75, 0xd1, 0x8c, 0xe9, 0x3b, 0x33, 0xa6, 0xe7, 0xe1, 0xc0, 0x0c, 0x1c, 0xec, 0x51, 0x81, 0x38,
	0x7e, 0x36, 0xc0, 0xd8, 0xa5, 0x33, 0xfc, 0xa1, 0x8a, 0xbc, 0xe8, 0x87, 0x1c, 0x1e, 0x0c, 0xe9,
	0xee, 0xa0, 0xa6, 0x04, 0xf5, 0x6d, 0xb9, 0x66, 0x03, 0x93, 0xf0, 0x89, 0x20, 0x5a, 0x77, 0x83,
	0x10, 0x9d, 0x20, 0x1a, 0x98, 0xd5, 0xc0, 0xdc, 0x74, 0x51, 0x88, 0x60, 0xe1, 0x5a, 0x0d, 0x87,
	0xf4, 0x86, 0x1d, 0x6f, 0x8b, 0x98, 0x04, 0x51, 0x5c, 0x27, 0x16, 0x0a, 0x99, 0xc8, 0x63, 0x52,
	0x95, 0x3f, 0xfb, 0xed, 0x1a, 0x9a, 0x71, 0xb1, 0x15, 0xe2, 0x57, 0x71, 0x15, 0xf3, 0x9f, 0x33,
	0xec, 0x97, 0x84, 0x0e, 0x31, 0x24, 0xd3, 0xf7, 0x93, 0xa4, 0xcb, 0x7f, 0xdb, 0x0d, 0x43, 0xab,
	0x3e, 0x22, 0x7c, 0x79, 0x1b, 0x4e, 0x0d, 0xdd, 0x70, 0x6a, 0x4e, 0x40, 0xd5, 0xeb, 0x70, 0xc6,
	0x22, 0xc8, 0x0c, 0x90, 0x61, 0xb9, 0x75, 0x1a, 0x20, 0x62, 0x38, 0x1e, 0x0d, 0x8c, 0xc0, 0xa9,
	0x21, 0x5c, 0x0f, 0x34, 0x65, 0x4a, 0xb9, 0xd0, 0xbd, 0xd0, 0xf7, 0xd3, 0x1f, 0x9c, 0xcb, 0x2d,
	0xd5, 0xc5, 0x64, 0x5d, 0x13, 0x13, 0x16, 0x05, 0xfe, 0xb2, 0x47, 0x83, 0x0d, 0x81, 0xcd, 0x88,
	0xd5, 0x7d, 0xbb, 0x23, 0xb1, 0xae, 0x2c, 0x62, 0x62, 0x42, 0x36, 0x31, 0x1b, 0xb9, 0xa8, 0x13,
	0xb1, 0xee, 0x2c, 0x62, 0x62, 0x42, 0x06, 0xb1, 0x45, 0x38, 0x2d, 0x97, 0x69, 0xfa, 0x7e, 0x9a,
	0x50, 0x4f, 0x06, 0xa1, 0x61, 0x81, 0x3c, 0xef, 0xfb, 0x2d, 0x44, 0xe4, 0xf2, 0xda, 0x88, 0x9c,
	0xcc, 0x22, 0x22, 0x90, 0xdb, 0x89, 0xc8, 0x65, 0xb5, 0x11, 0xe9, 0xcd, 0x22, 0x22, 0x90, 0xd3,
	0x44, 0xca, 0x3f, 0x51, 0xa0, 0xb4, 0x28, 0x75, 0x6f, 0xd9, 0x0b, 0x10, 0xf1, 0x4c, 0x57, 0x1d,
	0x85, 0xde, 0x2d, 0x07, 0xb9, 0x36, 0xd5, 0x94, 0xa9, 0xee, 0x0b, 0x79, 0x5d, 0x3e, 0xa9, 0xd3,
	0xd0, 0xbd, 0x83, 0x9a, 0x5c, 0xfa, 0x85, 0xd9, 0xd1, 0xe9, 0x48, 0xf7, 0xa7, 0x43, 0x0a, 0xd7,
	0x51, 0x73, 0xa1, 0xe7, 0xdd, 0x1f, 0x9c, 0x3b, 0xa1, 0x33, 0x44, 0xf5, 0x05, 0x38, 0xe9, 0x13,
	0xec, 0x53, 0xad, 0x7b, 0xaa, 0xfb, 0x42, 0x61, 0xf6, 0xd1, 0x8c, 0x19, 0xe1, 0x3b, 0xa7, 0xd7,
	0x18, 0xe2, 0x65, 0x2f, 0x20, 0x4d, 0x5d, 0x4c, 0x1a, 0x7f, 0x0e, 0x20, 0x06, 0xaa, 0x25, 0xf1,
	0x6e, 0xa6, 0x46, 0x79, 0x41, 0x7d, 0x18, 0x4e, 0x36, 0x4c, 0xb7, 0x8e, 0x38, 0x3f, 0x79, 0x5d,
	0x3c, 0xcc, 0x75, 0x3d, 0xa7, 0xcc, 0x3d, 0xfc, 0x6f, 0x3f, 0xd6, 0x94, 0xff, 0xfa, 0xb1, 0xa6,
	0x7c, 0x66, 0x57, 0x53, 0xbe, 0xb0, 0xab, 0x29, 0xef, 0xdc, 0xd3, 0x4a, 0x3b, 0xa8, 0xf9, 0xe2,
	0x2a, 0xa9, 0x9a, 0x9e, 0xf3, 0x26, 0x17, 0x48, 0xf9, 0xb3, 0x79, 0x28, 0xae, 0xb9, 0x66, 0xb0,
	0x85, 0x49, 0x6d, 0x11, 0x7b, 0x5b, 0x4e, 0x55, 0x7d, 0x16, 0x4e, 0x5b, 0xd8, 0x0b, 0x4c, 0xc7,
	0x43, 0xc4, 0x20, 0xa8, 0xea, 0xd0, 0x80, 0x34, 0x0d, 0xdf, 0x0c, 0xb6, 0xe5, 0x8b, 0x47, 0xa2,
	0x61, 0x5d, 0x8e, 0xae, 0x99, 0xc1, 0xb6, 0xfa, 0x34, 0x8c, 0x86, 0x07, 0xd8, 0x68, 0xd4, 0x0c,
	0xa7, 0x66, 0x56, 0x91, 0x98, 0x26, 0x78, 0x1b, 0x0a, 0x47, 0x6f, 0xd7, 0x96, 0xd9, 0x18, 0x9f,
	0x74, 0x09, 0x06, 0x3d, 0x1c, 0x38, 0x5b, 0x4d, 0xc3, 0x0a, 0x88, 0x6b, 0x98, 0xb6, 0x4d, 0x28,
	0x57, 0xc6, 0xfc, 0x42, 0xfe, 0xad, 0x77, 0xc6, 0x4e, 0x7a, 0xd8, 0xaa, 0xf9, 0xfa, 0x80, 0xc0,
	0x59, 0x0c, 0x88, 0x3b, 0xcf, 0x30, 0xd4, 0x32, 0xf4, 0x07, 0x2e, 0x35, 0x2c, 0x44, 0x02, 0x63,
	0xcb, 0x71, 0x11, 0xd7, 0x98, 0xbc, 0x5e, 0x08, 0x5c, 0xba, 0x88, 0x48, 0x70, 0xc5, 0x71, 0x91,
	0x3a, 0x05, 0x7d, 0x0c, 0x67, 0x07, 0x35, 0x05, 0xca, 0x30, 0x47, 0x81, 0xc0, 0xa5, 0xd7, 0x51,
	0x93, 0x63, 0x4c, 0x42, 0x81, 0x53, 0x31, 0x05, 0xc2, 0x08, 0x47, 0xc8, 0x33, 0x1a, 0x26, 0x1f,
	0x7f, 0x09, 0x4e, 0x21, 0xaf, 0x61, 0x34, 0x4c, 0xa2, 0xf5, 0xf2, 0xcd, 0x7b, 0x24, 0xb1, 0x79,
	0x69, 0xa9, 0x4d, 0x5f, 0xf6, 0x1a, 0xb7, 0x4d, 0x22, 0xf6, 0xae, 0x17, 0xf1, 0x07, 0xb5, 0x02,
	0x7d, 0xbe, 0xc4, 0x32, 0x02, 0xb3, 0xaa, 0xe5, 0x5a, 0xd7, 0x55, 0x08, 0x87, 0x37, 0xcc, 0xaa,
	0x7a, 0x06, 0xf2, 0x01, 0xa2, 0x81, 0x51, 0xc3, 0x36, 0xd2, 0xf2, 0x53, 0xca, 0x85, 0x9c, 0x9e,
	0x63, 0x80, 0x15, 0x6c, 0x23, 0xf5, 0x2c, 0xf4, 0x50, 0xdf, 0xf4, 0x34, 0x68, 0x25, 0xc1, 0xc1,
	0xea, 0x79, 0xe8, 0xb3, 0x5c, 0x64, 0x7a, 0x75, 0x5f, 0x4c, 0x2f, 0xf0, 0xe9, 0x05, 0x09, 0xe3,
	0x14, 0x46, 0xa1, 0x97, 0x6d, 0x26, 0xf6, 0xb4, 0x3e, 0xbe, 0x4e, 0xf9, 0xa4, 0x3e, 0x0e, 0x25,
	0x66, 0xda, 0x10, 0xb1, 0x1c, 0xd3, 0xe5, 0x12, 0xa5, 0x5a, 0x3f, 0x9f, 0x3e, 0x10, 0xc3, 0x99,
	0x50, 0xb9, 0xd4, 0xeb, 0x14, 0x19, 0x0d, 0xb3, 0xee, 0x06, 0x86, 0xbf, 0xe3, 0x68, 0x45, 0xf1,
	0x9a, 0x3a, 0x45, 0xb7, 0x19, 0x6c, 0x6d, 0xc7, 0x61, 0x52, 0x67, 0x27, 0xd1, 0xf6, 0xa8, 0x41,
	0x30, 0x0e, 0xb4, 0x92, 0x90, 0xba, 0xe9, 0xfb, 0x4b, 0x1e, 0xd5, 0x31, 0x0e, 0xd4, 0x47, 0xa0,
	0x68, 0x23, 0xdf, 0xc5, 0xcd, 0x1a, 0xf2, 0x02, 0x2e, 0x97, 0x21, 0x8e, 0xd3, 0x1f, 0x43, 0x99,
	0x38, 0x5e, 0x82, 0x51, 0x8b, 0xd4, 0x0c, 0xd3, 0xb2, 0x10, 0xa5, 0x86, 0x4f, 0x9c, 0x06, 0x33,
	0x15, 0x4c, 0xfd, 0x47, 0x5b, 0x65, 0x30, 0x64, 0x91, 0xda, 0x3c, 0xc7, 0x5b, 0x13, 0x68, 0xd7,
	0x51, 0x53, 0x7d, 0x0a, 0x06, 0xe4, 0x5c, 0xd3, 0x77, 0xb8, 0x62, 0x69, 0xa7, 0x5b, 0x27, 0xf6,
	0x0b, 0x8c, 0x79, 0xdf, 0x61, 0x6a, 0xc5, 0x76, 0xc0, 0x32, 0xad, 0x6d, 0x64, 0xd8, 0x0e, 0xd1,
	0x34, 0xce, 0x54, 0x8e, 0x03, 0x96, 0x1c, 0xa2, 0xbe, 0x02, 0x53, 0x14, 0x59, 0xd8, 0xb3, 0x4d,
	0xd2, 0x34, 0x3a, 0x70, 0x36, 0xd6, 0xfa, 0x82, 0x89, 0x68, 0xca, 0x62, 0x06, 0x8b, 0x17, 0xa0,
	0x14, 0x6c, 0x9b, 0x1e, 0xa6, 0x06, 0x41, 0x56, 0x43, 0xf0, 0x38, 0xce, 0x5f, 0x5b, 0x14, 0x70,
	0x1d, 0x59, 0x0d, 0xce, 0xd9, 0x34, 0x0c, 0x99, 0x1e, 0x75, 0x36, 0x5d, 0x64, 0xf8, 0xf5, 0x4d,
	0xd7, 0xb1, 0x04, 0xf2, 0x19, 0x8e, 0x3c, 0x28, 0x87, 0xd6, 0xf8, 0x08, 0xc7, 0x7f, 0x0a, 0x46,
	0x90, 0xd7, 0xc0, 0x4d, 0xe3, 0x75, 0x27, 0xd8, 0x36, 0xac, 0x3a, 0x71, 0xc5, 0x79, 0xd4, 0xce,
	0xf2, 0x19, 0x2a, 0x1f, 0xbc, 0xe3, 0x04, 0xdb, 0x8b, 0x75, 0xe2, 0xf2, 0xd3, 0xc8, 0xa6, 0x78,
	0x55, 0xc7, 0x7b, 0xa3, 0x6d, 0xca, 0xa4, 0x98, 0xc2, 0x07, 0x53, 0x53, 0xc6, 0x9f, 0x87, 0x42,
	0x42, 0xed, 0x8f, 0x62, 0x9d, 0x3e, 0xd5, 0x93, 0xeb, 0x29, 0x9d, 0xfc, 0x54, 0x4f, 0x6e, 0xa2,
	0x74, 0xb6, 0xfc, 0x3d, 0x05, 0x4a, 0x57, 0x90, 0x2d, 0xbd, 0xa9, 0xb4, 0x42, 0xb3, 0x30, 0xb2,
	0x15, 0xc1, 0x0c, 0x66, 0x71, 0xd0, 0x1b, 0x81, 0xe1, 0xd8, 0x92, 0xfc, 0xd0, 0x56, 0x72, 0x02,
	0x1b, 0x5b, 0xb6, 0x99, 0xe5, 0xf2, 0x4d, 0x12, 0x30, 0xbb, 0x95, 0x98, 0xcb, 0x25, 0x25, 0x18,
	0x18, 0x91, 0xc3, 0xf1, 0xdb, 0xb8, 0xb4, 0x2e, 0x40, 0x29, 0x81, 0x6f, 0x6f, 0xb2, 0xd7, 0x30,
	0x1b, 0xd4, 0xa3, 0x17, 0x63, 0xf8, 0xd2, 0xe6, 0xb2, 0xad, 0x3e, 0x06, 0x03, 0x09, 0x4c, 0xcf,
	0xac, 0x21, 0xee, 0xf0, 0xf2, 0x49, 0xc4, 0x9b, 0x66, 0x0d, 0x95, 0xff, 0xb4, 0x08, 0xa5, 0xd0,
	0x42, 0x5c, 0x41, 0x66, 0x50, 0x27, 0x88, 0xaa, 0x0f, 0x41, 0x7f, 0x6c, 0x0f, 0x9a, 0x3e, 0x92,
	0x6b, 0x89, 0x8c, 0xc4, 0x46, 0xd3, 0x47, 0x4c, 0x09, 0x3d, 0x6c, 0x23, 0x81, 0x30, 0x26, 0x94,
	0x90, 0x01, 0xf8, 0xe0, 0x3c, 0x9c, 0xa5, 0x75, 0xdf, 0xc7, 0x24, 0xa0, 0x46, 0xad, 0xee, 0x06,
	0x8e, 0x11, 0x20, 0xcf, 0xf4, 0x82, 0xd0, 0xa9, 0xf3, 0x75, 0xe6, 0xf4, 0xf1, 0x10, 0x69, 0x85,
	0xe1, 0x6c, 0x70, 0x14, 0xe9, 0xc6, 0xd5, 0x67, 0x60, 0x34, 0x22, 0x41, 0xb7, 0x4d, 0x82, 0x6c,
	0xa3, 0x81, 0xdd, 0x7a, 0x0d, 0xf1, 0x25, 0xe7, 0xf4, 0xe1, 0x70, 0x74, 0x9d, 0x0f, 0xde, 0xe6,
	0x63, 0x6c, 0x3b, 0xa2, 0x59, 0x01, 0xa9, 0xd3, 0xc0, 0xf0, 0xb1, 0xeb, 0x58, 0x4d, 0xbe, 0xfc,
	0x9c, 0x3e, 0x14, 0x0e, 0x6e, 0xb0, 0xb1, 0x35, 0x3e, 0xa4, 0x3e, 0x07, 0x5a, 0x34, 0x67, 0xa7,
	0xbe, 0x89, 0x88, 0x87, 0x02, 0x44, 0x0d, 0xec, 0xb9, 0x4d, 0x6e, 0xaf, 0x73, 0x7a, 0xc4, 0xc9,
	0xf5, 0x68, 0x78, 0xd5, 0x73, 0x9b, 0xea, 0x55, 0x98, 0x4a, 0x4c, 0x20, 0xe8, 0xb5, 0xba, 0x43,
	0x10, 0x35, 0x5e, 0xc7, 0x64, 0x07, 0x11, 0x83, 0x49, 0x83, 0x72, 0xf7, 0x9e, 0xd3, 0xcf, 0xc6,
	0x78, 0xba, 0x44, 0xbb, 0xc3, 0xb1, 0x6e, 0x32, 0x24, 0xee, 0xcb, 0x42, 0x9f, 0x44, 0x11, 0x69,
	0x38, 0x16, 0xa2, 0x86, 0x8b, 0x2d, 0xd3, 0xd5, 0x4e, 0xf1, 0xf9, 0x23, 0xe1, 0xf0, 0xba, 0x1c,
	0xbd, 0xc1, 0x06, 0xd5, 0x8f, 0x83, 0xe6, 0xf8, 0x86, 0xe9, 0x32, 0xd4, 0x00, 0xd9, 0x86, 0x8f,
	0x48, 0x38, 0x9f, 0x5b, 0xf1, 0x9c, 0x3e, 0xe2, 0xf8, 0xf3, 0xe1, 0xf0, 0x1a, 0x22, 0x72, 0xba,
	0x7a, 0x09, 0x4e, 0x47, 0x6b, 0x16, 0x1e, 0x90, 0xed, 0xa3, 0x81, 0x1b, 0x5b, 0xd2, 0xa4, 0x47,
	0xe2, 0xe5, 0x47, 0x88, 0x6d, 0xea, 0x6a, 0x63, 0xab, 0xf3, 0x34, 0x93, 0x1b, 0xc7, 0xec, 0x69,
	0xa6, 0x3a, 0x01, 0xe0, 0x50, 0xe6, 0x6c, 0x7d, 0x8c, 0x5d, 0xee, 0x1b, 0x72, 0x7a, 0xce, 0xa1,
	0xb7, 0x6b, 0x6b, 0x18, 0xbb, 0xea, 0x69, 0x38, 0xe5, 0x50, 0x63, 0xcb, 0xdc, 0x09, 0xfd, 0x41,
	0xaf, 0x43, 0xaf, 0x98, 0x3b, 0x48, 0x0e, 0xd4, 0xb0, 0xb5, 0xc3, 0xcd, 0x0d, 0x1f, 0x58, 0xc1,
	0xd6, 0x8e, 0xfa, 0x32, 0x4c, 0x44, 0x6c, 0x98, 0xb6, 0xed, 0x30, 0x75, 0x36, 0x5d, 0xc3, 0x43,
	0x01, 0x13, 0x3d, 0xe5, 0x9e, 0x23, 0xa1, 0x5d, 0xf3, 0x11, 0xca, 0x4d, 0x89, 0xa1, 0x7e, 0x12,
	0x26, 0x1c, 0x6a, 0x50, 0xc7, 0xab, 0xba, 0x28, 0xb9, 0xe9, 0xa1, 0x7e, 0x0a, 0xcf, 0x32, 0xe6,
	0xd0, 0x75, 0x8e, 0x12, 0xef, 0x7b, 0xa8, 0x9e, 0x0b, 0x30, 0x19, 0xb3, 0x10, 0x86, 0x74, 0x36,
	0xb2, 0x1d, 0xb1, 0x11, 0x8e, 0x2f, 0x9d, 0x4e, 0xcc, 0x84, 0x88, 0xe5, 0x96, 0x42, 0x94, 0x65,
	0x5f, 0xfd, 0x34, 0x5c, 0x8c, 0x68, 0x44, 0x07, 0x6e, 0xdb, 0xa9, 0x6e, 0x1b, 0x66, 0xc3, 0x74,
	0x5c, 0x73, 0xd3, 0x71, 0x9d, 0xa0, 0x69, 0x60, 0xcf, 0xd8, 0x79, 0x8e, 0x6a, 0x03, 0x9c, 0xde,
	0x23, 0xe1, 0x8c, 0xf0, 0xd4, 0x5e, 0x73, 0xaa, 0xdb, 0xf3, 0x09, 0xf4, 0x55, 0xef, 0xfa, 0x73,
	0x54, 0x35, 0xe0, 0xc9, 0x43, 0x92, 0xb6, 0xb1, 0xb5, 0x83, 0x08, 0xf7, 0x7f, 0x39, 0xfd, 0xc2,
	0xc1, 0xd4, 0x97, 0x38, 0xbe, 0x7a, 0x05, 0xa6, 0x3c, 0x9c, 0x21, 0x39, 0xc3, 0xac, 0x07, 0xd8,
	0xa0, 0x96, 0xe9, 0x22, 0x6d, 0x90, 0xd3, 0x9c, 0xf0, 0x70, 0x9b, 0xf8, 0xe6, 0xeb, 0x01, 0x5e,
	0x67, 0x38, 0xea, 0x22, 0x4c, 0x3a, 0xcc, 0x39, 0xa1, 0xcd, 0xba, 0xe3, 0x06, 0x59, 0x5b, 0xa1,
	0x72, 0x2a, 0x67, 0x1c, 0xba, 0x26, 0x91, 0xda, 0x37, 0xa3, 0x02, 0xaa, 0x87, 0x23, 0x0e, 0xe4,
	0x1a, 0x78, 0x20, 0x95, 0xd3, 0x4b, 0x1e, 0x96, 0x68, 0xeb, 0x02, 0xae, 0x9e, 0xe5, 0xda, 0xc8,
	0x22, 0xa4, 0x4d, 0xfc, 0x06, 0x8f, 0xa6, 0x72, 0x7a, 0xde, 0xa1, 0x97, 0x05, 0x80, 0x59, 0xbf,
	0x58, 0xc7, 0xfd, 0xc6, 0xb3, 0xdc, 0x7b, 0xe5, 0xf4, 0xbe, 0x48, 0xb3, 0xfd, 0xc6, 0xb3, 0xea,
	0x0d, 0x28, 0x48, 0xbf, 0xda, 0x30, 0x09, 0xd5, 0x46, 0x79, 0xd8, 0xf5, 0x44, 0x46, 0xd8, 0x15,
	0x1a, 0xd5, 0x69, 0xe1, 0x55, 0x6f, 0x9b, 0x44, 0x06, 0xce, 0x60, 0x46, 0x00, 0xf5, 0x3a, 0x00,
	0x0b, 0xa3, 0x11, 0x09, 0x1c, 0x44, 0xb5, 0xd3, 0x07, 0x13, 0x5b, 0x8b, 0xb0, 0x25, 0xb1, 0x78,
	0xba, 0xfa, 0x2a, 0x8c, 0x85, 0xb9, 0xa4, 0xf1, 0x5a, 0x1d, 0x07, 0xa6, 0x91, 0xa0, 0xad, 0x71,
	0xda, 0x5a, 0x82, 0xf6, 0x32, 0x4b, 0x3e, 0x75, 0x39, 0x41, 0x26, 0x04, 0xa7, 0x43, 0x02, 0xaf,
	0xb0, 0xf9, 0xf1, 0xcb, 0xd4, 0x27, 0x58, 0x4c, 0xc4, 0xd3, 0x18, 0x9f, 0x20, 0xdf, 0x24, 0x48,
	0xb3, 0x98, 0x70, 0x16, 0x7a, 0xbe, 0xb1, 0xab, 0x29, 0x2c, 0x32, 0x62, 0x63, 0x6b, 0x62, 0x68,
	0xfc, 0x36, 0x0c, 0xb4, 0x2c, 0x3a, 0xc3, 0xf5, 0x3e, 0x99, 0x74, 0xbd, 0x85, 0xd9, 0xd3, 0xc9,
	0x55, 0x8b, 0xf7, 0x36, 0x97, 0xbd, 0x2d, 0x9c, 0xf0, 0xc9, 0x8c, 0x6e, 0xcb, 0xfa, 0x1f, 0x08,
	0xdd, 0xb9, 0x0b, 0x19, 0x99, 0x48, 0x8f, 0x87, 0x3d, 0xf4, 0x57, 0x1f, 0x69, 0x7d, 0x6b, 0x09,
	0xdf, 0x57, 0xfe, 0x61, 0x17, 0x14, 0xc3, 0xa4, 0x48, 0x47, 0x74, 0xc5, 0xf4, 0xd5, 0xb9, 0x98,
	0x83, 0xce, 0xe9, 0x56, 0xe9, 0xee, 0x3d, 0x2d, 0x17, 0x02, 0xe2, 0xd4, 0xeb, 0x15, 0x38, 0x55,
	0x33, 0x7d, 0xdf, 0xf1, 0xaa, 0x5a, 0x57, 0xc7, 0xe4, 0x4b, 0xbc, 0x67, 0x7a, 0x45, 0x20, 0xf2,
	0x65, 0x2f, 0x0c, 0xdc, 0xbd, 0xa7, 0x15, 0x74, 0x44, 0x37, 0xcc, 0xea, 0x86, 0xb9, 0xe9, 0x22,
	0x3d, 0xa4, 0x33, 0x3e, 0x07, 0x7d, 0x49, 0xcc, 0x23, 0x65, 0x64, 0x9f, 0x55, 0xde, 0xde, 0xd3,
	0x6e, 0x85, 0x0e, 0xe7, 0xc5, 0xeb, 0xa8, 0x39, 0xcd, 0x62, 0x85, 0x4a, 0x08, 0xc1, 0xa4, 0xca,
	0x81, 0xc9, 0x04, 0xad, 0x22, 0xe3, 0x0a, 0x64, 0x87, 0xa3, 0x57, 0x42, 0x40, 0x12, 0xed, 0xab,
	0x7b, 0xda, 0x58, 0xc7, 0xc1, 0xef, 0xee, 0x69, 0xa7, 0x24, 0xd3, 0xe5, 0x4d, 0x28, 0x70, 0xc5,
	0x8c, 0xa3, 0x2c, 0xf4, 0x86, 0x48, 0x3e, 0x43, 0x2b, 0x2f, 0xa2, 0x1a, 0x19, 0x65, 0x85, 0x83,
	0xd2, 0xbe, 0x33, 0x76, 0xd5, 0x73, 0x50, 0x10, 0x55, 0x19, 0x81, 0x29, 0x96, 0x09, 0x02, 0xc4,
	0x63, 0x9f, 0x4d, 0xe8, 0xd7, 0x93, 0x7a, 0xae, 0xaa, 0xd0, 0x93, 0x20, 0xca, 0x7f, 0xa7, 0xc5,
	0xd4, 0x23, 0xc5, 0xc4, 0xe2, 0x2b, 0xd3, 0x65, 0x49, 0x5d, 0xb0, 0x4d, 0x10, 0xdd, 0xc6, 0xae,
	0x08, 0xc4, 0x4e, 0xea, 0x45, 0x0e, 0xde, 0x08, 0xa1, 0xe5, 0x3a, 0xf4, 0x5d, 0x5d, 0xbb, 0xb5,
	0x44, 0x9c, 0x06, 0x22, 0x2c, 0x94, 0x3e, 0x9f, 0x7c, 0xc5, 0x42, 0xff, 0xb7, 0xef, 0x69, 0xf9,
	0xaa, 0x5f, 0xb7, 0xf9, 0xb8, 0x7c, 0xe3, 0x33, 0xd0, 0x87, 0x13, 0x52, 0x11, 0x8c, 0x2f, 0x94,
	0xbe, 0x7d, 0x4f, 0xeb, 0x8b, 0x50, 0x31, 0xa9, 0xea, 0x29, 0xac, 0xb9, 0x3e, 0xa6, 0xbc, 0x3f,
	0xf9, 0xb1, 0xa6, 0x7c, 0xf3, 0x2b, 0xe7, 0x94, 0xf2, 0xf7, 0xba, 0xa0, 0x18, 0xbd, 0x77, 0xa1,
	0xee, 0xb8, 0x76, 0xe6, 0xe2, 0xce, 0x41, 0x41, 0xd0, 0x4b, 0xe6, 0xbf, 0x20, 0x40, 0x3c, 0xed,
	0xbd, 0x08, 0x83, 0x09, 0x04, 0xc3, 0x22, 0xc8, 0x96, 0x69, 0xaf, 0x3e, 0x10, 0xa3, 0x2d, 0x32,
	0xb0, 0xfa, 0x02, 0x94, 0xb0, 0x28, 0x35, 0x79, 0x55, 0x83, 0x36, 0x69, 0x80, 0x6a, 0x3c, 0xea,
	0x2a, 0xce, 0x0e, 0x26, 0xd4, 0x79, 0x75, 0x9d, 0x9d, 0x20, 0x7d, 0x20, 0x42, 0x5d, 0xe7, 0x98,
	0x2c, 0xdb, 0xda, 0x61, 0x56, 0xdd, 0x35, 0x1a, 0x88, 0x50, 0xb6, 0x6e, 0x91, 0x2a, 0xf7, 0x0b,
	0xe8, 0x6d, 0x01, 0x64, 0x82, 0xdf, 0x6e, 0xfa, 0x2c, 0x88, 0xa1, 0x98, 0x18, 0x8e, 0xb7, 0x85,
	0x79, 0x80, 0x95, 0xd7, 0x8b, 0x31, 0x98, 0x9d, 0x6b, 0x96, 0x46, 0xd6, 0xec, 0x4b, 0xb4, 0x5e,
	0xe3, 0x01, 0x54, 0x5e, 0x97, 0x4f, 0xea, 0x63, 0xd0, 0x47, 0x03, 0x4c, 0xa2, 0x9c, 0x5f, 0xe4,
	0xba, 0xc2, 0x7e, 0x15, 0xe4, 0x08, 0x5b, 0xd3, 0xdc, 0xc0, 0x5b, 0x7b, 0x5a, 0x61, 0x3d, 0x06,
	0x94, 0xff, 0x53, 0x81, 0xe1, 0xb4, 0x4c, 0x57, 0x50, 0x6d, 0x13, 0x11, 0x75, 0x26, 0x79, 0xf4,
	0x93, 0x86, 0x26, 0xb9, 0xf3, 0xc9, 0x52, 0xcb, 0x25, 0x38, 0xc9, 0x1c, 0x99, 0x2d, 0x6d, 0xd3,
	0x58, 0xd6, 0x14, 0xfe, 0x02, 0x39, 0x49, 0x60, 0xb3, 0xe4, 0xd9, 0xa9, 0x7a, 0x98, 0x20, 0x83,
	0x06, 0x66, 0x10, 0xc6, 0xc1, 0x05, 0x01, 0x5b, 0x67, 0xa0, 0xb9, 0x1b, 0x6f, 0xef, 0x69, 0xcf,
	0x44, 0x5a, 0xc2, 0xf6, 0x38, 0x3e, 0xbe, 0x49, 0xe5, 0x69, 0x3b, 0xbf, 0x99, 0x45, 0x17, 0x0b,
	0x06, 0xd3, 0xfc, 0xdc, 0xd2, 0x6f, 0xa8, 0x0f, 0x43, 0x91, 0xb3, 0x63, 0xb0, 0xcc, 0x2b, 0x51,
	0x6d, 0xe9, 0xe3, 0xd0, 0x5b, 0xc4, 0xe5, 0x8a, 0x73, 0x01, 0x72, 0x0d, 0xd3, 0x75, 0x6c, 0x27,
	0x68, 0x66, 0x16, 0x00, 0xa3, 0xd1, 0xf2, 0x9f, 0xf7, 0x42, 0x3e, 0x7a, 0x4b, 0xc7, 0x6a, 0xd6,
	0x4c, 0xb2, 0x9a, 0x75, 0x18, 0x19, 0x7f, 0x1c, 0x7a, 0x39, 0x43, 0x61, 0x3d, 0xeb, 0x40, 0x21,
	0x4b, 0x74, 0xa6, 0x88, 0xae, 0x63, 0x21, 0x8f, 0x22, 0x96, 0xcd, 0x6d, 0x39, 0x55, 0x99, 0x39,
	0xf5, 0x4b, 0x68, 0x6c, 0x91, 0xd2, 0x68, 0x86, 0x54, 0x37, 0xa1, 0xb6, 0x43, 0x29, 0xec, 0x15,
	0xa1, 0x7b, 0x4b, 0x29, 0x37, 0x2f, 0x4a, 0x35, 0x0f, 0x67, 0xf1, 0xb5, 0xaf, 0x7f, 0x1f, 0x86,
	0x93, 0x62, 0xff, 0x85, 0x62, 0x8b, 0x87, 0x36, 0xe5, 0xc8, 0xb5, 0x29, 0x47, 0x86, 0xf3, 0xce,
	0x77, 0x74, 0xde, 0xea, 0x33, 0x30, 0x14, 0x9e, 0x93, 0xcd, 0xba, 0xb5, 0x83, 0x02, 0x61, 0x45,
	0x21, 0x71, 0x5c, 0x06, 0x25, 0xc2, 0x02, 0x1f, 0xe7, 0x36, 0x77, 0x11, 0xce, 0xb4, 0x48, 0x25,
	0x75, 0xd8, 0x0a, 0x89, 0xd9, 0x5a, 0x4a, 0x42, 0x89, 0x83, 0x36, 0xfe, 0xe2, 0x61, 0xfc, 0x7b,
	0x67, 0xf7, 0x75, 0x57, 0x69, 0xf5, 0xe3, 0x5f, 0xde, 0xd5, 0x94, 0x6f, 0xee, 0x6a, 0xca, 0xbb,
	0xbb, 0x9a, 0xf2, 0xfd, 0x5d, 0x4d, 0x79, 0x6b, 0x4f, 0xd3, 0xb9, 0x48, 0x2a, 0x37, 0x5a, 0x76,
	0x69, 0xbd, 0x5e, 0xab, 0x2c, 0x25, 0xe5, 0x50, 0x59, 0x6f, 0x5d, 0x63, 0x7a, 0x4e, 0x82, 0xef,
	0xe3, 0x1e, 0xbd, 0xaf, 0xee, 0x69, 0xa5, 0xc3, 0x1c, 0xc7, 0xcf, 0x7d, 0xc4, 0x1d, 0x80, 0xd0,
	0x90, 0x79, 0xdf, 0xf9, 0xca, 0x47, 0x9a, 0x52, 0x7e, 0xb7, 0x8b, 0x9f, 0x1e, 0xa9, 0x94, 0x0b,
	0xd0, 0x2b, 0xde, 0x73, 0x90, 0x31, 0x1a, 0xbc, 0x7b, 0x4f, 0x8b, 0x4f, 0x9d, 0xd0, 0x7f, 0x31,
	0xb3, 0x45, 0x49, 0xbb, 0xb2, 0x94, 0x54, 0x96, 0x12, 0xf7, 0x53, 0xd2, 0xf6, 0x53, 0xd4, 0x7d,
	0xa4, 0x53, 0xd4, 0xd3, 0xf1, 0x14, 0xdd, 0xaf, 0x7a, 0x9c, 0x7e, 0x6b, 0x4f, 0x1b, 0xca, 0xd8,
	0xf7, 0xf2, 0x3f, 0x9e, 0x83, 0x28, 0x36, 0x7b, 0x60, 0x55, 0xf5, 0x4f, 0x42, 0x8e, 0x27, 0xdf,
	0xa1, 0x43, 0x2b, 0xcc, 0x9e, 0x9d, 0xb6, 0x1d, 0x1a, 0x10, 0x67, 0xb3, 0xce, 0xf2, 0xc4, 0x9a,
	0x19, 0x58, 0xdb, 0x06, 0xf2, 0xaa, 0x8e, 0x87, 0xa6, 0x6f, 0x60, 0x4b, 0xce, 0x8d, 0x26, 0xa9,
	0x4f, 0x03, 0x38, 0x7e, 0x94, 0xd2, 0xf4, 0x72, 0x7f, 0x3a, 0x9c, 0x0c, 0xdf, 0x7d, 0x99, 0xd6,
	0xe8, 0x79, 0xc7, 0x4f, 0x64, 0x38, 0xcc, 0x0a, 0x38, 0x96, 0xe1, 0xf8, 0x54, 0xda, 0x89, 0xbc,
	0x80, 0x2c, 0xfb, 0x54, 0x7d, 0x14, 0x06, 0xbc, 0x7a, 0xcd, 0xb0, 0x9b, 0x9e, 0x59, 0x93, 0x38,
	0x39, 0x1e, 0xbd, 0xf4, 0x7b, 0xf5, 0xda, 0x92, 0x80, 0x32, 0xbc, 0xcb, 0x50, 0x08, 0x9c, 0x1a,
	0x32, 0x5c, 0xde, 0x34, 0xe2, 0xd6, 0xa2, 0x30, 0x3b, 0x99, 0x74, 0xe6, 0xed, 0xad, 0x25, 0xb9,
	0x00, 0x08, 0xe2, 0x66, 0xd3, 0x23, 0xd0, 0x8b, 0x08, 0xc1, 0x84, 0x6a, 0xc0, 0x64, 0xb9, 0xd0,
	0xcf, 0xce, 0x7f, 0x5c, 0x7b, 0x94, 0x83, 0xea, 0x35, 0x28, 0x61, 0x6f, 0x13, 0x9b, 0xc4, 0xe6,
	0x01, 0x04, 0xb7, 0x62, 0x2f, 0xf0, 0xf5, 0x26, 0xd5, 0x78, 0x83, 0x98, 0xd6, 0x0e, 0xb2, 0xf9,
	0xf1, 0x95, 0x96, 0x64, 0x20, 0x9e, 0x26, 0x0c, 0xdd, 0xd3, 0xa1, 0x85, 0xec, 0x3b, 0xcc, 0x74,
	0x69, 0x40, 0x3f, 0x09, 0x7d, 0x16, 0xa9, 0x19, 0xb8, 0x81, 0x08, 0x71, 0x6c, 0xc4, 0x2b, 0x00,
	0xc5, 0xf4, 0x16, 0xeb, 0x2b, 0xab, 0x72, 0x34, 0x0c, 0x18, 0x2c, 0x52, 0x0b, 0x41, 0xea, 0x0c,
	0x94, 0x12, 0xf5, 0x62, 0x51, 0xbc, 0x29, 0x26, 0x0c, 0xec, 0x40, 0x3c, 0x2a, 0x8a, 0x37, 0xcf,
	0xb7, 0x96, 0xd9, 0x06, 0xb8, 0x79, 0x1c, 0xbe, 0x7b, 0x4f, 0x6b, 0xab, 0xc9, 0xb5, 0x14, 0xdf,
	0x2e, 0x81, 0x6c, 0x35, 0x18, 0x94, 0xc8, 0x82, 0x6c, 0x49, 0x44, 0x94, 0x69, 0xd9, 0xf6, 0x0b,
	0xac, 0x75, 0x22, 0xca, 0xb3, 0x2f, 0x40, 0xaf, 0x88, 0x7f, 0x79, 0x6a, 0x5e, 0x48, 0x29, 0xd2,
	0x15, 0x3e, 0xc0, 0xd4, 0xb7, 0x78, 0xf7, 0x9e, 0xd6, 0x2b, 0x1e, 0x85, 0x65, 0x10, 0x73, 0x78,
	0x59, 0x70, 0xbb, 0x49, 0x1d, 0x8b, 0x05, 0xe1, 0xcc, 0x19, 0xa8, 0xb2, 0x2c, 0x28, 0x81, 0xdc,
	0x03, 0x3c, 0x17, 0xf7, 0x22, 0x86, 0xb8, 0xed, 0x38, 0x97, 0x71, 0x48, 0x32, 0xbb, 0x10, 0x4f,
	0xc0, 0x60, 0xdc, 0xcf, 0x09, 0x83, 0x40, 0xd1, 0x0c, 0x29, 0x45, 0x03, 0x61, 0x1c, 0xf8, 0x09,
	0xe8, 0x95, 0x76, 0x65, 0xa4, 0x2d, 0x86, 0x4a, 0x77, 0x3c, 0x16, 0x72, 0x4c, 0x24, 0x62, 0x21,
	0x62, 0x8a, 0x7a, 0x07, 0x0a, 0x04, 0x51, 0x23, 0x30, 0xab, 0x46, 0xcd, 0xf4, 0x65, 0xf2, 0x5e,
	0xce, 0xe2, 0x53, 0xe4, 0x56, 0x2b, 0xa6, 0x2f, 0xf2, 0xad, 0x21, 0x46, 0xaa, 0x35, 0xe7, 0xca,
	0x93, 0x10, 0x49, 0x5d, 0x4a, 0x57, 0x05, 0x44, 0x22, 0xff, 0x50, 0x16, 0xe1, 0xfd, 0xaa, 0x01,
	0x17, 0xa0, 0x14, 0xf5, 0xa5, 0x42, 0x39, 0x88, 0x2a, 0x7f, 0xb1, 0x21, 0x5a, 0x52, 0xa1, 0x14,
	0x26, 0x01, 0x62, 0xa5, 0x92, 0x25, 0xf9, 0x04, 0x44, 0x5d, 0x84, 0x12, 0xef, 0x2d, 0x8b, 0xd6,
	0x02, 0x7f, 0x03, 0xaf, 0x66, 0x14, 0x53, 0xf2, 0xe2, 0x89, 0xd6, 0xbc, 0xef, 0x08, 0x9e, 0xf4,
	0xa2, 0x93, 0x7a, 0x66, 0x07, 0x43, 0x10, 0x91, 0x02, 0x9f, 0x68, 0xb3, 0x7d, 0x89, 0x4c, 0x4d,
	0x1e, 0xff, 0x82, 0x93, 0x48, 0xde, 0xee, 0xc0, 0x60, 0xcd, 0x74, 0x3c, 0x5e, 0x01, 0xb6, 0xc2,
	0xf8, 0x64, 0x92, 0xb3, 0x71, 0xb1, 0xb3, 0x31, 0x5c, 0x89, 0xa7, 0xf0, 0xd3, 0xaa, 0x97, 0x6a,
	0x2d, 0x10, 0x75, 0x19, 0xce, 0x87, 0xc7, 0x55, 0x96, 0x79, 0x8d, 0x76, 0x0d, 0x3a, 0xc7, 0x03,
	0xa1, 0xc9, 0x10, 0x51, 0xd4, 0x7c, 0x17, 0x5b, 0xf5, 0xe9, 0x21, 0x38, 0x15, 0x96, 0x27, 0xa7,
	0xf8, 0x41, 0x02, 0x76, 0x08, 0x6e, 0xaf, 0xac, 0x61, 0xec, 0xea, 0xbd, 0x0d, 0x51, 0xa8, 0x7c,
	0x19, 0x46, 0x92, 0x0d, 0x15, 0xd1, 0xe0, 0x60, 0xee, 0xe0, 0x7c, 0xd6, 0xd9, 0x53, 0xe3, 0x6e,
	0x0f, 0xc7, 0x64, 0xe9, 0xdf, 0xa7, 0xe0, 0x5c, 0x82, 0xc2, 0x0e, 0x6a, 0x1a, 0x75, 0xbf, 0x4a,
	0x4c, 0x1b, 0x85, 0xc5, 0x63, 0x5b, 0x2b, 0x27, 0x4c, 0xc6, 0x99, 0x88, 0xc4, 0x75, 0xd4, 0xbc,
	0x25, 0x30, 0x65, 0xf9, 0xd8, 0x56, 0x3f, 0x0d, 0x20, 0xfa, 0xd5, 0xb6, 0x61, 0x06, 0xda, 0x43,
	0x7c, 0x57, 0x1e, 0xea, 0x2c, 0x4f, 0x66, 0xa2, 0x69, 0x60, 0xd6, 0xfc, 0x85, 0x11, 0xc9, 0x67,
	0x3e, 0x08, 0x41, 0x7c, 0xcf, 0xf2, 0x92, 0xda, 0x7c, 0xc0, 0x48, 0x8b, 0x2e, 0x36, 0x27, 0xfd,
	0xf0, 0xfd, 0x93, 0x96, 0xd4, 0xe6, 0x03, 0x75, 0x16, 0xfa, 0x52, 0x75, 0xf9, 0x47, 0xb8, 0xe8,
	0x78, 0x21, 0x23, 0x51, 0x93, 0xd7, 0x0b, 0x41, 0xa2, 0x40, 0x7f, 0x1d, 0xd4, 0xe4, 0x1c, 0xa9,
	0x41, 0x8f, 0x1e, 0xc6, 0xb8, 0x97, 0x12, 0x74, 0x84, 0xd2, 0x5c, 0x85, 0x81, 0x74, 0x79, 0x8c,
	0x6a, 0x8f, 0xb5, 0x15, 0xc5, 0x52, 0x75, 0x01, 0xa9, 0xd3, 0xc5, 0x54, 0x51, 0x8c, 0xaa, 0x57,
	0x61, 0xca, 0x46, 0x5b, 0xbc, 0xc7, 0x18, 0x11, 0x6c, 0x2d, 0x0a, 0x5c, 0xe0, 0x6e, 0xf5, 0xac,
	0xc4, 0x0b, 0xa9, 0xce, 0xa7, 0x6a, 0x04, 0xea, 0x25, 0x28, 0x5e, 0xc3, 0x34, 0x60, 0x3a, 0x49,
	0xb0, 0xeb, 0x22, 0xa2, 0x3d, 0x9e, 0xa5, 0x4f, 0x2d, 0x48, 0xcc, 0x1c, 0xef, 0x98, 0x5b, 0x3b,
	0x66, 0x54, 0x28, 0xbd, 0x28, 0xcc, 0x31, 0x07, 0x86, 0x95, 0xd1, 0xb3, 0x00, 0x02, 0xa9, 0x4e,
	0x11, 0xd1, 0x9e, 0x10, 0x91, 0x00, 0x87, 0xdc, 0xa2, 0x88, 0xf0, 0xac, 0x9b, 0x0f, 0xfb, 0x26,
	0xa5, 0xaf, 0x63, 0x62, 0x6b, 0x15, 0x99, 0x75, 0x33, 0xe8, 0x9a, 0x04, 0xaa, 0xcf, 0x03, 0x54,
	0xfd, 0x7a, 0x68, 0x00, 0x9e, 0x6c, 0xf3, 0x1d, 0x51, 0x4c, 0x28, 0x45, 0x95, 0xaf, 0xfa, 0x75,
	0x79, 0xf8, 0x97, 0xe1, 0x3c, 0xf2, 0x98, 0x9d, 0x34, 0x42, 0x61, 0x51, 0x44, 0x1a, 0x88, 0xb8,
	0xec, 0x00, 0x84, 0x9c, 0x4f, 0x8b, 0x33, 0x2a, 0x10, 0x97, 0x04, 0xde, 0x7a, 0x84, 0x16, 0xae,
	0xe5, 0x21, 0xe8, 0x37, 0x5d, 0xd7, 0xe1, 0x46, 0x04, 0x93, 0x2a, 0xd5, 0x66, 0x78, 0x68, 0xd6,
	0x17, 0x02, 0x57, 0x49, 0x95, 0xc5, 0x2c, 0xe7, 0x3a, 0x56, 0xf5, 0x0d, 0xfc, 0xba, 0x87, 0x88,
	0xf6, 0x31, 0xbe, 0xc4, 0x09, 0x9a, 0x5d, 0xd9, 0x5f, 0x65, 0x38, 0x19, 0xb9, 0xd2, 0x53, 0x9d,
	0x73, 0xa5, 0x17, 0x60, 0xbc, 0x73, 0x8d, 0x5d, 0x9b, 0xe5, 0x8b, 0xd3, 0xfc, 0x0e, 0x15, 0x75,
	0x75, 0x1d, 0xce, 0x65, 0x37, 0x6c, 0x63, 0xfb, 0xf2, 0x74, 0x96, 0x3e, 0x9c, 0xc9, 0xe8, 0xd9,
	0x46, 0x86, 0xe6, 0xff, 0xc1, 0xe3, 0x99, 0x44, 0x33, 0x4d, 0xce, 0x33, 0x89, 0xa5, 0x3d, 0xdc,
	0x4e, 0x35, 0xc3, 0xf6, 0x5c, 0x83, 0xb1, 0x98, 0x7c, 0x6b, 0x24, 0x72, 0x29, 0x8b, 0xdb, 0xd1,
	0x08, 0xff, 0x66, 0x2a, 0x24, 0x39, 0x0f, 0x79, 0xdb, 0xa3, 0x86, 0x6b, 0x6e, 0x22, 0x57, 0x7b,
	0x36, 0x91, 0x1f, 0xe6, 0x6c, 0x8f, 0xde, 0x60, 0x50, 0xf5, 0x51, 0xe8, 0x23, 0x18, 0x07, 0x86,
	0xbb, 0x69, 0x6c, 0xbd, 0x66, 0x7b, 0xda, 0xc7, 0x13, 0x58, 0xc0, 0x46, 0x6e, 0x6c, 0x5e, 0x79,
	0xcd, 0xf6, 0x54, 0x1d, 0x06, 0xd3, 0xad, 0x58, 0xa6, 0xac, 0xcf, 0x71, 0x65, 0x3d, 0x93, 0x0c,
	0x74, 0x5a, 0x5a, 0xb8, 0x89, 0x00, 0xa1, 0xb4, 0xd5, 0xda, 0xde, 0x3d, 0x20, 0xa1, 0x7d, 0xfe,
	0x30, 0x09, 0xad, 0xfa, 0x32, 0xf4, 0x0b, 0x0f, 0x2a, 0x02, 0x29, 0xaa, 0xcd, 0x71, 0x83, 0x33,
	0xd2, 0x16, 0x7d, 0x2d, 0x7b, 0x5b, 0x58, 0x52, 0x13, 0x3e, 0x57, 0x80, 0x29, 0xcb, 0xee, 0x65,
	0xbf, 0x42, 0xb4, 0x25, 0x3f, 0x21, 0xb2, 0x7b, 0x09, 0x5b, 0xf5, 0xdc, 0xe6, 0x7d, 0x34, 0xb9,
	0xc7, 0xef, 0x40, 0x31, 0x1d, 0xe8, 0x64, 0xcc, 0x9e, 0x49, 0xd7, 0xd3, 0xc7, 0xd2, 0xc6, 0x32,
	0x0c, 0x86, 0xae, 0xa3, 0x66, 0x92, 0xf0, 0x8b, 0x87, 0xe9, 0x00, 0x74, 0x4e, 0xd5, 0xfe, 0xba,
	0x67, 0xbf, 0x4c, 0xfe, 0x3d, 0x91, 0xc9, 0xff, 0x4a, 0xf7, 0x0d, 0x99, 0x2b, 0x4d, 0x5f, 0xc3,
	0xc4, 0x79, 0x93, 0x79, 0x76, 0x77, 0xde, 0xb2, 0xea, 0xc4, 0xb4, 0x9a, 0x95, 0x68, 0xec, 0x36,
	0xcb, 0x17, 0xad, 0xac, 0x91, 0x45, 0x5c, 0x27, 0x14, 0xc5, 0xcf, 0xeb, 0x3e, 0x42, 0x76, 0xfc,
	0x18, 0x39, 0xb7, 0x8a, 0xd8, 0xd8, 0x8a, 0xa8, 0x1c, 0x5c, 0xe6, 0x49, 0x4b, 0xa5, 0xfd, 0xe8,
	0x55, 0xf6, 0x39, 0x37, 0x95, 0xf5, 0xce, 0x47, 0x36, 0x63, 0x2c, 0x83, 0xc0, 0x62, 0xe8, 0xa3,
	0x2b, 0xb7, 0x42, 0x97, 0x5a, 0xd9, 0x68, 0x71, 0x71, 0x95, 0xb4, 0xa3, 0x68, 0x29, 0x68, 0x5c,
	0x0d, 0x4d, 0xf3, 0x74, 0x66, 0xf1, 0x43, 0x1e, 0xba, 0x8a, 0x1e, 0x9d, 0xab, 0x4a, 0xeb, 0x81,
	0xd9, 0xaf, 0x02, 0xf2, 0x73, 0x68, 0x1b, 0xbc, 0xbf, 0xa7, 0x75, 0x5f, 0x47, 0xcd, 0xac, 0x92,
	0x09, 0x2f, 0x91, 0x7c, 0xad, 0x0b, 0x0a, 0xe2, 0x1c, 0xad, 0xb0, 0xa0, 0x25, 0x4c, 0xe1, 0x95,
	0xc3, 0xa6, 0xf0, 0x2d, 0x7d, 0x84, 0xee, 0xd6, 0x3e, 0x02, 0x4b, 0x5c, 0x52, 0x4d, 0xd5, 0x37,
	0xb1, 0x17, 0x5e, 0xb7, 0x28, 0x25, 0x07, 0x5e, 0xc5, 0x1e, 0x9a, 0xfb, 0x2d, 0xe5, 0xed, 0x3d,
	0xad, 0x7a, 0x54, 0x29, 0xf1, 0x97, 0xbd, 0x78, 0x25, 0x7a, 0xe7, 0x03, 0x6a, 0xb7, 0x40, 0x4c,
	0xb1, 0x3c, 0x1d, 0xdf, 0x2d, 0x5c, 0x31, 0x3d, 0x67, 0x0b, 0xd1, 0x40, 0x1d, 0x87, 0x5c, 0x4d,
	0xfe, 0x96, 0xa7, 0x33, 0x7a, 0x2e, 0xff, 0x9d, 0x02, 0x7d, 0xc9, 0x4e, 0x5a, 0x66, 0x83, 0x61,
	0x0a, 0x0a, 0x36, 0xa2, 0x16, 0x71, 0xfc, 0xb8, 0x95, 0xa1, 0x27, 0x41, 0xf1, 0xe9, 0xef, 0x4e,
	0x9c, 0x7e, 0x75, 0x14, 0x7a, 0x29, 0xb2, 0x08, 0x0a, 0xe4, 0xbd, 0x0d, 0xf9, 0xa4, 0x4e, 0x40,
	0xbe, 0x66, 0x7a, 0xb6, 0x19, 0x60, 0x12, 0xde, 0xcd, 0x88, 0x01, 0x8c, 0x5d, 0x47, 0x5e, 0x51,
	0x94, 0xd7, 0x2e, 0xa2, 0x67, 0xb6, 0x8b, 0x01, 0x0e, 0x7c, 0x43, 0x92, 0x15, 0xb7, 0x2a, 0x80,
	0x81, 0xd6, 0x39, 0xa4, 0xfc, 0x53, 0x05, 0xfa, 0x43, 0x01, 0xf0, 0xab, 0x8c, 0x87, 0xbb, 0x06,
	0x73, 0x2d, 0xa3, 0x5c, 0x76, 0x21, 0x43, 0xa9, 0x38, 0xc9, 0x7d, 0x4b, 0x66, 0xe5, 0x96, 0xbe,
	0x8f, 0x10, 0x48, 0x0a, 0xf6, 0xb3, 0x6a, 0x7d, 0x96, 0xbf, 0xae, 0xc0, 0x78, 0xa2, 0xd1, 0x98,
	0xee, 0xfd, 0x1e, 0x52, 0x12, 0x2f, 0x65, 0x48, 0xe2, 0xa0, 0x46, 0xf3, 0x11, 0xd7, 0x5f, 0xfe,
	0x62, 0x17, 0x8c, 0xb4, 0xf2, 0x79, 0x8b, 0x9a, 0x55, 0x74, 0x9c, 0x53, 0x2d, 0x7c, 0x72, 0x9d,
	0x4d, 0x97, 0xf7, 0x91, 0x80, 0x83, 0x04, 0xc1, 0x59, 0xe8, 0xe1, 0xed, 0xa5, 0xee, 0x43, 0x2d,
	0x84, 0xe3, 0xce, 0x35, 0x7e, 0x3e, 0x16, 0xb0, 0xfc, 0xab, 0x5d, 0x30, 0x14, 0xae, 0x73, 0x3e,
	0x8e, 0x86, 0x8f, 0x2c, 0x94, 0x72, 0x56, 0xeb, 0xb1, 0xa5, 0xd1, 0xf8, 0x7b, 0xcc, 0x80, 0x79,
	0x47, 0x5c, 0x64, 0x18, 0xa2, 0xb3, 0x41, 0xfc, 0xe0, 0xdb, 0xc6, 0x7d, 0x29, 0x69, 0xfc, 0xb3,
	0x02, 0x10, 0xc7, 0x53, 0x1d, 0xbb, 0xba, 0x96, 0x5f, 0xa7, 0x51, 0x57, 0x97, 0x3d, 0xb0, 0xa3,
	0x44, 0xcc, 0x9a, 0xbc, 0x52, 0xc7, 0x7e, 0xb2, 0xb9, 0xb6, 0x43, 0x77, 0xb8, 0x15, 0xea, 0xd1,
	0xf9, 0x6f, 0x75, 0x11, 0x72, 0x4c, 0x6b, 0x79, 0xe9, 0xe8, 0x64, 0x5b, 0xe9, 0x28, 0x7e, 0x31,
	0x3f, 0x6c, 0x51, 0xe9, 0x48, 0x44, 0x75, 0xa7, 0x7c, 0x01, 0x1b, 0x9f, 0x13, 0xc6, 0x73, 0x9f,
	0x80, 0xab, 0x63, 0x58, 0x54, 0xbe, 0x04, 0xa7, 0x56, 0xd7, 0xe7, 0x99, 0x37, 0xc9, 0x5c, 0x1b,
	0xb3, 0x9d, 0x81, 0x19, 0xc8, 0xc5, 0xe5, 0x75, 0xf9, 0x54, 0x26, 0x6c, 0x9a, 0xb8, 0x43, 0x99,
	0x35, 0x4d, 0x85, 0x9e, 0xc0, 0xac, 0x86, 0x93, 0xf8, 0x6f, 0x75, 0x32, 0x75, 0xa4, 0xa5, 0xe7,
	0x4b, 0x1c, 0xd9, 0x73, 0x50, 0x60, 0x22, 0x31, 0x98, 0x0d, 0x30, 0x03, 0xe9, 0xf3, 0x80, 0x81,
	0xae, 0x70, 0x48, 0xf9, 0x87, 0x0a, 0x8c, 0x86, 0xba, 0xb6, 0x1a, 0x55, 0x69, 0xf9, 0xb6, 0x1c,
	0x55, 0x37, 0x17, 0x32, 0xca, 0xc3, 0x5d, 0xfb, 0x96, 0x00, 0xb2, 0x0a, 0xc3, 0xa1, 0x68, 0xba,
	0xf9, 0x6b, 0x93, 0x11, 0xf8, 0x3a, 0x1f, 0x10, 0x11, 0xb8, 0xa8, 0x16, 0x0a, 0x54, 0x26, 0x4f,
	0x59, 0xbe, 0xee, 0x11, 0xad, 0x00, 0xf1, 0x34, 0xd7, 0xf3, 0x9d, 0x5d, 0x4d, 0x29, 0xff, 0x47,
	0x01, 0xfa, 0xe2, 0xfb, 0xf1, 0xa2, 0xf1, 0xfc, 0x40, 0x3a, 0x07, 0x2f, 0x86, 0x45, 0xec, 0x6e,
	0xbe, 0xc8, 0xc7, 0x3a, 0x97, 0x5f, 0x42, 0x02, 0x62, 0xd1, 0xb2, 0x9c, 0xfd, 0x28, 0xe4, 0x65,
	0x5e, 0xe6, 0xd8, 0xf2, 0x63, 0x87, 0xc4, 0x7d, 0xdf, 0x9c, 0x18, 0x5b, 0xb6, 0xd5, 0xc7, 0x01,
	0xac, 0xb8, 0xf0, 0x70, 0xb2, 0xf5, 0x62, 0x70, 0x62, 0x50, 0x9d, 0x00, 0xc0, 0xd4, 0xa8, 0x99,
	0x6f, 0x18, 0xec, 0x94, 0xf4, 0xf2, 0x23, 0x91, 0xc3, 0x74, 0xc5, 0x7c, 0x43, 0x37, 0x6b, 0x6a,
	0x19, 0xfa, 0xe5, 0x68, 0xc3, 0xc2, 0x04, 0x89, 0xb6, 0x43, 0x8f, 0x5e, 0xe0, 0x08, 0xb7, 0x39,
	0x48, 0x3d, 0x1f, 0xe3, 0x60, 0xd7, 0xa8, 0x6e, 0xf2, 0xb6, 0x43, 0x8f, 0x0e, 0x02, 0x07, 0xbb,
	0x57, 0x37, 0x13, 0xd2, 0xce, 0x27, 0xa5, 0xad, 0xce, 0xc0, 0xa9, 0x30, 0x7b, 0x82, 0x7d, 0xb2,
	0x27, 0x3d, 0xc4, 0x52, 0x5f, 0x8e, 0xf6, 0xba, 0xb0, 0xdf, 0x5e, 0x0f, 0x7e, 0xf9, 0xa3, 0x44,
	0x9a, 0x9a, 0xda, 0xf8, 0xcc, 0x82, 0x74, 0x5f, 0x87, 0x82, 0xf4, 0x3c, 0xa8, 0x6d, 0x41, 0x20,
	0xd5, 0xfa, 0x39, 0xab, 0x6a, 0xea, 0xfe, 0x03, 0x3f, 0xb9, 0xfa, 0x60, 0x6b, 0x64, 0xc8, 0x96,
	0x98, 0xc7, 0xf2, 0x5a, 0x25, 0xd5, 0x8a, 0x19, 0x33, 0xf9, 0xe1, 0x65, 0x22, 0xe7, 0x3f, 0xa8,
	0x3a, 0x07, 0x63, 0xf1, 0xf6, 0x18, 0xe2, 0x4a, 0x38, 0x41, 0x16, 0x72, 0x1a, 0xc8, 0x96, 0xd7,
	0x05, 0x4f, 0xc7, 0x08, 0x8b, 0x6c, 0x5c, 0x97, 0xc3, 0xd9, 0x45, 0xd9, 0xd2, 0x03, 0x28, 0xca,
	0xbe, 0x0a, 0x6a, 0xf4, 0x29, 0x93, 0x41, 0x3d, 0xd3, 0xa7, 0xdb, 0x38, 0x90, 0xfd, 0x86, 0xf3,
	0x9d, 0xbc, 0x28, 0x5d, 0x97, 0x88, 0x89, 0x64, 0x7c, 0x90, 0xb4, 0x0e, 0xaa, 0x97, 0x33, 0x0b,
	0x81, 0xea, 0xfe, 0x56, 0xa0, 0xbd, 0x04, 0xf8, 0x12, 0x8c, 0x58, 0xb8, 0xe6, 0x9b, 0x81, 0x23,
	0x37, 0x2b, 0xdc, 0xdc, 0xa1, 0x29, 0xe5, 0x42, 0x7f, 0x52, 0xfd, 0x87, 0x53, 0x78, 0xe1, 0x5e,
	0x5f, 0x4d, 0x99, 0xc5, 0x61, 0xbe, 0x53, 0x8f, 0x65, 0x7e, 0x2f, 0xb3, 0x85, 0xf7, 0x0d, 0xf9,
	0x66, 0x01, 0xf8, 0x1d, 0x6a, 0x16, 0x3c, 0x50, 0x6d, 0x84, 0x13, 0x1a, 0x4a, 0x10, 0xba, 0x89,
	0x6d, 0xc4, 0xb5, 0x9a, 0x5f, 0xb5, 0x66, 0xbf, 0x28, 0xbf, 0x62, 0x6f, 0x05, 0x4e, 0x03, 0xf1,
	0xb2, 0x8e, 0xe3, 0xd1, 0x80, 0xc9, 0x5e, 0x7c, 0x6c, 0xa0, 0x0f, 0x8a, 0xa1, 0x45, 0x52, 0x5b,
	0x96, 0x03, 0xcc, 0x46, 0xb3, 0x5f, 0xf6, 0x26, 0xaf, 0x03, 0xf1, 0x6f, 0x0b, 0x72, 0x3a, 0x48,
	0xd0, 0x22, 0xa9, 0xa9, 0x8f, 0xc1, 0x00, 0x41, 0x2e, 0x32, 0x69, 0x5b, 0xb7, 0x41, 0x82, 0xe5,
	0xb2, 0xef, 0xb7, 0xf1, 0xfa, 0x97, 0x6d, 0x7d, 0xf9, 0xaf, 0xec, 0x6a, 0xca, 0xb7, 0x77, 0xb5,
	0xfe, 0x94, 0x01, 0x63, 0x69, 0xfd, 0x8f, 0x44, 0x6a, 0xdf, 0x2b, 0xce, 0xe9, 0xcf, 0x27, 0xa8,
	0x0a, 0x2f, 0xff, 0xbd, 0xf3, 0x51, 0x7c, 0x65, 0xaf, 0xfc, 0x10, 0x0c, 0x44, 0x49, 0x12, 0x0a,
	0x88, 0x63, 0xf1, 0xa0, 0x61, 0x0b, 0x63, 0x6e, 0x39, 0x7b, 0x74, 0xf6, 0xf3, 0xe2, 0x1c, 0x14,
	0xd3, 0x2d, 0x15, 0x75, 0x10, 0xfa, 0x97, 0x96, 0xf5, 0xcb, 0x8b, 0x1b, 0xc6, 0xfc, 0xe2, 0xe2,
	0xe5, 0xf5, 0xf5, 0xd2, 0x09, 0x75, 0x04, 0x06, 0xf5, 0xcb, 0xeb, 0x1b, 0xfa, 0xf2, 0xe2, 0xc6,
	0xe5, 0xa5, 0x10, 0xac, 0x5c, 0xac, 0x40, 0xaf, 0xb8, 0x21, 0xa5, 0xe6, 0xe1, 0xe4, 0x8d, 0xe5,
	0x9b, 0xb7, 0xfe, 0x4f, 0xe9, 0x84, 0x5a, 0x80, 0x53, 0x77, 0x96, 0x6f, 0x2e, 0xad, 0xde, 0x59,
	0x2f, 0x29, 0x2a, 0x40, 0xef, 0xea, 0xc6, 0xb5, 0xcb, 0xfa, 0x7a, 0x69, 0xf8, 0xe2, 0x15, 0x28,
	0xea, 0xc8, 0xc7, 0x24, 0x58, 0xb7, 0xb6, 0x91, 0x5d, 0x77, 0x91, 0xda, 0x0f, 0xf9, 0xcb, 0x0d,
	0x44, 0x9a, 0x77, 0x10, 0xda, 0x29, 0x9d, 0x50, 0x07, 0xa0, 0xc0, 0x1f, 0x9f, 0xba, 0xb4, 0x64,
	0x36, 0x69, 0x49, 0x51, 0x8b, 0x00, 0x1c, 0xb0, 0x82, 0xbd, 0x60, 0xbb, 0xd4, 0x3d, 0xde, 0xf3,
	0xfe, 0x3d, 0xed, 0xc4, 0xec, 0x77, 0xbb, 0x60, 0xa8, 0xb5, 0xe3, 0x38, 0xef, 0x3b, 0xea, 0xef,
	0x2b, 0x30, 0xbc, 0xbe, 0x8d, 0x5f, 0x6f, 0xfb, 0x42, 0xe0, 0xcc, 0x3e, 0x97, 0x53, 0xc7, 0xf7,
	0x1b, 0x2c, 0xaf, 0xdc, 0xdd, 0xd5, 0x2e, 0x84, 0xc7, 0x3e, 0x94, 0x25, 0xad, 0xcc, 0x5b, 0x4c,
	0xe6, 0xb7, 0x1d, 0xf4, 0x7a, 0x85, 0xee, 0x38, 0x3e, 0xf2, 0xb6, 0x30, 0xb1, 0xd0, 0xe7, 0xfe,
	0xfe, 0x5f, 0x7f, 0xa3, 0xeb, 0x4c, 0x79, 0x74, 0x86, 0x6e, 0xe3, 0xd7, 0x67, 0xc2, 0x6c, 0x63,
	0x4b, 0xd2, 0x9a, 0x53, 0x2e, 0x7e, 0x4c, 0x51, 0x7f, 0x4d, 0x81, 0x51, 0x59, 0xe1, 0x38, 0x12,
	0x97, 0x83, 0xe9, 0x0a, 0x56, 0xdd, 0x0d, 0xca, 0x4b, 0x77, 0x77, 0xb5, 0xb3, 0xfb, 0xf2, 0xc6,
	0x19, 0x3a, 0x5b, 0xd6, 0x66, 0x44, 0x01, 0x38, 0x8b, 0xa5, 0xd9, 0x7f, 0xea, 0x4b, 0xdc, 0xf9,
	0x63, 0x52, 0xfc, 0xba, 0x02, 0x03, 0xa2, 0x6e, 0x13, 0xdf, 0x73, 0x1a, 0xce, 0xba, 0x99, 0x91,
	0xc5, 0x53, 0xf5, 0xee, 0xae, 0x36, 0xd3, 0x89, 0xa7, 0x15, 0xd3, 0x33, 0xab, 0xa8, 0xd2, 0xaa,
	0xfe, 0xdf, 0xd8, 0xd3, 0x94, 0x3f, 0xba, 0xd7, 0x7e, 0xab, 0x84, 0x73, 0x3f, 0x5a, 0x1e, 0x9c,
	0x11, 0x9d, 0x9e, 0x99, 0xe8, 0x5a, 0x8a, 0x90, 0xe4, 0xaf, 0x2b, 0x30, 0x20, 0x24, 0x79, 0x0c,
	0x3e, 0xd7, 0x8f, 0xc9, 0x67, 0xc4, 0x93, 0x94, 0x68, 0x0b, 0x4f, 0x7f, 0xac, 0xc0, 0x80, 0xa8,
	0x74, 0x1d, 0x83, 0x27, 0xef, 0x98, 0x3c, 0xbd, 0xbf, 0xa7, 0x9d, 0xe6, 0x57, 0xc3, 0x68, 0x85,
	0x1d, 0xc5, 0xca, 0x72, 0x7c, 0x89, 0x2a, 0x62, 0x57, 0x74, 0xb4, 0x5a, 0xd9, 0x7d, 0x4b, 0x81,
	0x7e, 0x76, 0x60, 0x0e, 0x62, 0x36, 0x13, 0xca, 0x65, 0xf8, 0xe4, 0xbe, 0xfa, 0x97, 0xc5, 0xed,
	0x7b, 0xa1, 0x14, 0x87, 0xcb, 0x03, 0xe2, 0xa0, 0xb4, 0x30, 0xf5, 0xa1, 0x02, 0x83, 0xf3, 0xb6,
	0xdd, 0x72, 0x1f, 0xf4, 0x5c, 0xc7, 0x0b, 0x71, 0xe2, 0x5a, 0x63, 0x96, 0x40, 0xbf, 0xa4, 0x1c,
	0x53, 0xa2, 0x1f, 0xec, 0x69, 0x2f, 0x71, 0xda, 0xc2, 0x76, 0x8b, 0x9f, 0x4b, 0xd1, 0x05, 0x52,
	0x09, 0x90, 0x35, 0x48, 0xf1, 0xb0, 0x9a, 0xbe, 0x20, 0xca, 0x57, 0xa8, 0x95, 0x87, 0x66, 0x4c,
	0xdb, 0x8e, 0x17, 0xc8, 0xef, 0xec, 0x89, 0x55, 0xfe, 0x72, 0x17, 0x0c, 0xeb, 0xa8, 0x86, 0x1b,
	0xe8, 0x01, 0x2c, 0xf4, 0x5b, 0xca, 0xf1, 0x55, 0x67, 0xb5, 0xc3, 0xea, 0x5a, 0x16, 0x24, 0xa1,
	0xd7, 0x93, 0xd7, 0x5b, 0x25, 0xec, 0x5a, 0xea, 0x2a, 0xeb, 0x07, 0x7b, 0x1a, 0xc4, 0xb2, 0x8b,
	0x4c, 0x22, 0xe1, 0x6b, 0xcd, 0x14, 0xc5, 0x3b, 0x5d, 0x30, 0x7c, 0x15, 0x05, 0xed, 0x77, 0x37,
	0x0f, 0x14, 0xc5, 0x44, 0x47, 0x84, 0x5b, 0xfa, 0x8d, 0xf2, 0xfb, 0xca, 0x91, 0x15, 0xf4, 0x3d,
	0x21, 0x13, 0xf2, 0x80, 0x65, 0xd2, 0xa6, 0x41, 0xfc, 0x0a, 0x72, 0x4a, 0x8d, 0x3a, 0x88, 0xad,
	0x8a, 0x82, 0x16, 0x99, 0xd5, 0x89, 0x3b, 0xa7, 0x5c, 0x54, 0xbf, 0xa6, 0xc0, 0x58, 0x52, 0x68,
	0xa9, 0x22, 0xb7, 0xda, 0xe9, 0x26, 0x5d, 0x96, 0xf2, 0xfc, 0xdf, 0xbb, 0xbb, 0xda, 0x53, 0xad,
	0x52, 0x9a, 0xf7, 0x4c, 0xb7, 0x19, 0x38, 0x56, 0x4a, 0x5a, 0x6d, 0xc6, 0x79, 0xaa, 0x7c, 0x26,
	0xcd, 0xa1, 0xec, 0x29, 0x89, 0xde, 0x13, 0xf3, 0x2e, 0xff, 0x3d, 0x06, 0x85, 0x88, 0xa6, 0xef,
	0xa8, 0x77, 0x15, 0x28, 0x2e, 0xca, 0x2f, 0xf3, 0xe5, 0xdd, 0xb5, 0xa1, 0x8c, 0x50, 0x34, 0x8b,
	0xcf, 0x3f, 0x39, 0xae, 0x92, 0xcb, 0x4d, 0xcd, 0x47, 0x4d, 0xa3, 0x0f, 0xf6, 0xb4, 0xd9, 0x9b,
	0xc9, 0xab, 0x63, 0x71, 0xfb, 0xe4, 0x86, 0x19, 0x38, 0x41, 0xdd, 0x4e, 0xf4, 0x57, 0x6e, 0x60,
	0xaf, 0xca, 0x41, 0x1d, 0x5d, 0xd4, 0x48, 0xb9, 0x14, 0xba, 0xa8, 0x30, 0xca, 0x13, 0x8a, 0xfd,
	0xb6, 0x02, 0xc5, 0x25, 0xf9, 0xb1, 0xff, 0x11, 0x17, 0xfb, 0xff, 0x8f, 0x7f, 0xa0, 0xe3, 0x75,
	0x46, 0x66, 0x56, 0x3a, 0x2b, 0xce, 0x5d, 0xc8, 0xdc, 0x3f, 0x74, 0x41, 0xf1, 0x96, 0xfc, 0x5b,
	0x83, 0x23, 0x32, 0xf7, 0xa5, 0xae, 0xfb, 0xdb, 0x89, 0xbf, 0x50, 0x92, 0x9f, 0xa7, 0x54, 0x96,
	0xd2, 0x17, 0xcd, 0x2a, 0x22, 0x3d, 0xae, 0xac, 0x25, 0xee, 0x69, 0x55, 0x5a, 0x6f, 0xc0, 0x54,
	0xa2, 0x45, 0x56, 0x6e, 0xa7, 0x2e, 0x19, 0x25, 0xa8, 0x55, 0xd2, 0x61, 0x6d, 0x25, 0x71, 0xef,
	0xa7, 0xb2, 0xba, 0xef, 0xfd, 0x9a, 0x8a, 0xf8, 0xd4, 0x2f, 0xf1, 0x92, 0xcb, 0x71, 0xeb, 0x32,
	0xda, 0x73, 0xe9, 0x53, 0xd3, 0x7b, 0xfe, 0x79, 0x05, 0xfa, 0x98, 0x4b, 0xdd, 0x5f, 0xa8, 0x59,
	0xc0, 0xf2, 0xf5, 0x03, 0xe3, 0xb9, 0xf7, 0x32, 0x77, 0x78, 0xa8, 0x5c, 0x14, 0x8e, 0x34, 0xcd,
	0xc9, 0xef, 0x2a, 0x30, 0x74, 0x15, 0x05, 0x6d, 0x5d, 0x92, 0x0e, 0xc5, 0x9c, 0x54, 0x1c, 0xdc,
	0x3a, 0xa9, 0xbc, 0x76, 0x77, 0x57, 0x7b, 0xe2, 0x80, 0x1d, 0x6f, 0x3b, 0x18, 0xa1, 0x01, 0x0b,
	0xf9, 0x9a, 0x09, 0xbb, 0x31, 0xcc, 0x80, 0x7d, 0x4b, 0x81, 0x52, 0x82, 0x3d, 0x51, 0xb9, 0xd7,
	0x3a, 0xb5, 0x22, 0xc6, 0x3b, 0x8e, 0x94, 0x5f, 0x3b, 0x96, 0xfd, 0x7a, 0x7f, 0x4f, 0x83, 0x38,
	0x3d, 0xfc, 0x60, 0x2f, 0xfd, 0xc9, 0x54, 0xe4, 0xbe, 0x53, 0xec, 0xf3, 0xff, 0x8e, 0x60, 0xbc,
	0xff, 0xbb, 0x02, 0x67, 0x13, 0xbc, 0x67, 0xb4, 0x20, 0x1e, 0xc9, 0xfe, 0x24, 0xaa, 0x05, 0x6d,
	0xfc, 0x70, 0x68, 0xe5, 0x37, 0x7f, 0x56, 0x4b, 0x3c, 0x5f, 0x9e, 0x48, 0x2f, 0x31, 0x2c, 0x62,
	0xc4, 0x6b, 0xfd, 0x8e, 0x02, 0x5a, 0xc6, 0x5a, 0x45, 0xd7, 0x61, 0x6a, 0x1f, 0xfe, 0x39, 0xc6,
	0xf8, 0x81, 0x18, 0xe5, 0x5f, 0x38, 0xb2, 0x97, 0x7e, 0x7f, 0x4f, 0xeb, 0x61, 0x6e, 0xf5, 0x80,
	0x25, 0xf0, 0x56, 0x09, 0x5b, 0xc2, 0x6f, 0x2b, 0x30, 0x32, 0x6f, 0xdb, 0xe9, 0x4f, 0xd3, 0x7c,
	0xc7, 0xab, 0xaa, 0x63, 0x1d, 0xbf, 0x5c, 0xcb, 0xb2, 0x7b, 0xfa, 0x31, 0xcc, 0x1e, 0xe7, 0x71,
	0xac, 0x3c, 0xcc, 0x02, 0x41, 0xf9, 0xb5, 0x5b, 0xf2, 0x9c, 0xaa, 0xbf, 0xa3, 0x80, 0x26, 0xe2,
	0xc0, 0xfb, 0x66, 0xef, 0x95, 0xe3, 0xb2, 0xc7, 0x14, 0x9d, 0xd4, 0xb2, 0xb8, 0xfb, 0x43, 0x05,
	0x46, 0x13, 0x92, 0x4b, 0x36, 0x6b, 0x26, 0x33, 0x78, 0x4b, 0x8c, 0x67, 0x31, 0xf8, 0xea, 0x31,
	0x18, 0x8c, 0xd2, 0x05, 0x96, 0xc6, 0x9a, 0xb6, 0x9d, 0x68, 0xcd, 0xa4, 0x38, 0xfd, 0xba, 0x02,
	0x63, 0x69, 0x39, 0xde, 0x27, 0xb3, 0xb7, 0x8e, 0x2b, 0xcd, 0x89, 0xf2, 0xe9, 0x19, 0x52, 0xeb,
	0xc4, 0xe7, 0x17, 0x15, 0x18, 0xb8, 0xe2, 0x78, 0x76, 0xb2, 0xc5, 0x3f, 0xda, 0x56, 0x1b, 0xe6,
	0xf0, 0xf1, 0x0e, 0x70, 0xbe, 0xd1, 0x47, 0x3b, 0x31, 0x9c, 0xb1, 0xf1, 0xf2, 0xc8, 0xcc, 0x96,
	0xe3, 0x65, 0xaa, 0xe1, 0xdf, 0x28, 0x30, 0xca, 0xdc, 0x96, 0xbc, 0xc1, 0x73, 0x05, 0x93, 0xf8,
	0xdb, 0x82, 0x0e, 0xfe, 0x22, 0xf3, 0x36, 0x76, 0xf9, 0x97, 0x0e, 0x74, 0x62, 0x61, 0x20, 0x70,
	0x77, 0x4f, 0x7b, 0x2c, 0x55, 0x05, 0xe3, 0x8e, 0x3e, 0xb3, 0xb8, 0xf5, 0x99, 0x7b, 0x52, 0x09,
	0xd8, 0x61, 0x67, 0xae, 0xae, 0x75, 0x09, 0xb2, 0x8a, 0x2e, 0x1c, 0xdf, 0x37, 0x14, 0x18, 0xbf,
	0x8a, 0x82, 0x24, 0x01, 0xba, 0xea, 0x1d, 0xb8, 0x9e, 0x64, 0xcc, 0x9c, 0x6a, 0xd0, 0xdd, 0xb9,
	0xbb, 0xab, 0x3d, 0xbe, 0xef, 0x92, 0x32, 0xab, 0x04, 0x61, 0x70, 0x1c, 0x19, 0xa6, 0x64, 0x27,
	0x91, 0xc6, 0x35, 0x0c, 0x1d, 0x35, 0xf0, 0x0e, 0x8a, 0xae, 0xd0, 0x74, 0xe4, 0xaf, 0x43, 0x15,
	0xe3, 0xc8, 0x5e, 0x79, 0xb2, 0x3c, 0x36, 0x43, 0xf8, 0x3b, 0x23, 0xd6, 0xc4, 0x6d, 0xbb, 0x1d,
	0xd4, 0x64, 0xaa, 0xf0, 0x9b, 0x0a, 0x0c, 0x5e, 0x45, 0x1e, 0xdf, 0x85, 0x63, 0x71, 0x75, 0xeb,
	0x38, 0x5c, 0x09, 0x69, 0x89, 0xb7, 0x66, 0xf3, 0xf5, 0x67, 0x0a, 0x9c, 0x4f, 0x38, 0xa2, 0x0e,
	0x99, 0xcf, 0x11, 0xf8, 0xb4, 0x8f, 0x9f, 0xf8, 0x3c, 0x5e, 0x7e, 0x38, 0xbd, 0xb7, 0x9d, 0x33,
	0xa0, 0x3f, 0xe8, 0x8e, 0x8b, 0xb0, 0xcc, 0x69, 0xb1, 0x2c, 0xe8, 0xab, 0x0a, 0x94, 0x92, 0x41,
	0x22, 0xef, 0xc4, 0x9d, 0xee, 0x50, 0x92, 0x1f, 0xef, 0x34, 0xc0, 0xed, 0xe9, 0xa5, 0x43, 0x2d,
	0xa0, 0xa3, 0x55, 0x3d, 0x5d, 0x56, 0xd3, 0xb1, 0x23, 0xbf, 0x18, 0xc0, 0x75, 0xb3, 0x0e, 0xea,
	0xb2, 0xf7, 0x8b, 0xc8, 0x0a, 0x0e, 0xc7, 0x65, 0x86, 0x80, 0x9f, 0x3e, 0x86, 0x09, 0x55, 0x03,
	0x18, 0xbc, 0xdc, 0x70, 0xfe, 0x97, 0xdf, 0x3a, 0xfb, 0x79, 0x05, 0xd4, 0x96, 0x52, 0x39, 0xdb,
	0xa8, 0xd7, 0x60, 0x28, 0xb9, 0x4f, 0x61, 0x11, 0x7d, 0x3c, 0x2b, 0x54, 0x16, 0x63, 0xe3, 0xfb,
	0x8c, 0x95, 0xa7, 0x22, 0x3b, 0x9c, 0x92, 0x79, 0x4d, 0x0c, 0x73, 0xb1, 0x2f, 0x4c, 0xbc, 0xfb,
	0x2f, 0x93, 0x27, 0xde, 0xfd, 0x60, 0x52, 0x79, 0xef, 0x83, 0x49, 0xe5, 0x47, 0x1f, 0x4c, 0x2a,
	0x5f, 0xf8, 0x70, 0xf2, 0xc4, 0x7b, 0x1f, 0x4e, 0x9e, 0xf8, 0xfe, 0x87, 0x93, 0x27, 0x36, 0x7b,
	0x39, 0xe1, 0xa7, 0xff, 0x27, 0x00, 0x00, 0xff, 0xff, 0xcf, 0x82, 0xbf, 0x29, 0x2d, 0x50, 0x00,
	0x00,
}

func (this *GPUDriverKey) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&edgeproto.GPUDriverKey{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Organization: "+fmt.Sprintf("%#v", this.Organization)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringCloudlet(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// PlatformFeaturesApiClient is the client API for PlatformFeaturesApi service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type PlatformFeaturesApiClient interface {
	// Show Platform Features. Shows supported cloudlet platform types and their features.
	ShowPlatformFeatures(ctx context.Context, in *PlatformFeatures, opts ...grpc.CallOption) (PlatformFeaturesApi_ShowPlatformFeaturesClient, error)
	// Delete Platform Features. Removes a no-longer supported platform type. Admin only.
	DeletePlatformFeatures(ctx context.Context, in *PlatformFeatures, opts ...grpc.CallOption) (*Result, error)
}

type platformFeaturesApiClient struct {
	cc *grpc.ClientConn
}

func NewPlatformFeaturesApiClient(cc *grpc.ClientConn) PlatformFeaturesApiClient {
	return &platformFeaturesApiClient{cc}
}

func (c *platformFeaturesApiClient) ShowPlatformFeatures(ctx context.Context, in *PlatformFeatures, opts ...grpc.CallOption) (PlatformFeaturesApi_ShowPlatformFeaturesClient, error) {
	stream, err := c.cc.NewStream(ctx, &_PlatformFeaturesApi_serviceDesc.Streams[0], "/edgeproto.PlatformFeaturesApi/ShowPlatformFeatures", opts...)
	if err != nil {
		return nil, err
	}
	x := &platformFeaturesApiShowPlatformFeaturesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type PlatformFeaturesApi_ShowPlatformFeaturesClient interface {
	Recv() (*PlatformFeatures, error)
	grpc.ClientStream
}

type platformFeaturesApiShowPlatformFeaturesClient struct {
	grpc.ClientStream
}

func (x *platformFeaturesApiShowPlatformFeaturesClient) Recv() (*PlatformFeatures, error) {
	m := new(PlatformFeatures)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *platformFeaturesApiClient) DeletePlatformFeatures(ctx context.Context, in *PlatformFeatures, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/edgeproto.PlatformFeaturesApi/DeletePlatformFeatures", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PlatformFeaturesApiServer is the server API for PlatformFeaturesApi service.
type PlatformFeaturesApiServer interface {
	// Show Platform Features. Shows supported cloudlet platform types and their features.
	ShowPlatformFeatures(*PlatformFeatures, PlatformFeaturesApi_ShowPlatformFeaturesServer) error
	// Delete Platform Features. Removes a no-longer supported platform type. Admin only.
	DeletePlatformFeatures(context.Context, *PlatformFeatures) (*Result, error)
}

// UnimplementedPlatformFeaturesApiServer can be embedded to have forward compatible implementations.
type UnimplementedPlatformFeaturesApiServer struct {
}

func (*UnimplementedPlatformFeaturesApiServer) ShowPlatformFeatures(req *PlatformFeatures, srv PlatformFeaturesApi_ShowPlatformFeaturesServer) error {
	return status.Errorf(codes.Unimplemented, "method ShowPlatformFeatures not implemented")
}
func (*UnimplementedPlatformFeaturesApiServer) DeletePlatformFeatures(ctx context.Context, req *PlatformFeatures) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletePlatformFeatures not implemented")
}

func RegisterPlatformFeaturesApiServer(s *grpc.Server, srv PlatformFeaturesApiServer) {
	s.RegisterService(&_PlatformFeaturesApi_serviceDesc, srv)
}

func _PlatformFeaturesApi_ShowPlatformFeatures_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PlatformFeatures)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(PlatformFeaturesApiServer).ShowPlatformFeatures(m, &platformFeaturesApiShowPlatformFeaturesServer{stream})
}

type PlatformFeaturesApi_ShowPlatformFeaturesServer interface {
	Send(*PlatformFeatures) error
	grpc.ServerStream
}

type platformFeaturesApiShowPlatformFeaturesServer struct {
	grpc.ServerStream
}

func (x *platformFeaturesApiShowPlatformFeaturesServer) Send(m *PlatformFeatures) error {
	return x.ServerStream.SendMsg(m)
}

func _PlatformFeaturesApi_DeletePlatformFeatures_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlatformFeatures)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformFeaturesApiServer).DeletePlatformFeatures(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.PlatformFeaturesApi/DeletePlatformFeatures",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformFeaturesApiServer).DeletePlatformFeatures(ctx, req.(*PlatformFeatures))
	}
	return interceptor(ctx, in, info, handler)
}

var _PlatformFeaturesApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "edgeproto.PlatformFeaturesApi",
	HandlerType: (*PlatformFeaturesApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "DeletePlatformFeatures",
			Handler:    _PlatformFeaturesApi_DeletePlatformFeatures_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ShowPlatformFeatures",
			Handler:       _PlatformFeaturesApi_ShowPlatformFeatures_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "cloudlet.proto",
}

// GPUDriverApiClient is the client API for GPUDriverApi service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type GPUDriverApiClient interface {
	// Create GPU Driver. Creates GPU driver with all the config
	// required to install it.
	CreateGPUDriver(ctx context.Context, in *GPUDriver, opts ...grpc.CallOption) (GPUDriverApi_CreateGPUDriverClient, error)
	// Delete GPU Driver. Deletes GPU driver given that it is not
	// used by any cloudlet.
	DeleteGPUDriver(ctx context.Context, in *GPUDriver, opts ...grpc.CallOption) (GPUDriverApi_DeleteGPUDriverClient, error)
	// Update GPU Driver. Updates GPU driver config.
	UpdateGPUDriver(ctx context.Context, in *GPUDriver, opts ...grpc.CallOption) (GPUDriverApi_UpdateGPUDriverClient, error)
	// Show GPU Drivers. Lists all the EdgeCloud created GPU drivers and operator
	// created GPU drivers.
	ShowGPUDriver(ctx context.Context, in *GPUDriver, opts ...grpc.CallOption) (GPUDriverApi_ShowGPUDriverClient, error)
	// Add GPU Driver Build. Adds new build to GPU driver.
	AddGPUDriverBuild(ctx context.Context, in *GPUDriverBuildMember, opts ...grpc.CallOption) (GPUDriverApi_AddGPUDriverBuildClient, error)
	// Remove GPU Driver Build. Removes build from GPU driver.
	RemoveGPUDriverBuild(ctx context.Context, in *GPUDriverBuildMember, opts ...grpc.CallOption) (GPUDriverApi_RemoveGPUDriverBuildClient, error)
	// (Deprecated) Get GPU Driver Build URL. Returns a time-limited signed URL to download GPU driver.
	GetGPUDriverBuildURL(ctx context.Context, in *GPUDriverBuildMember, opts ...grpc.CallOption) (*GPUDriverBuildURL, error)
	// (Deprecated) Get GPU Driver License Config. Returns the license config specific to GPU driver
	GetGPUDriverLicenseConfig(ctx context.Context, in *GPUDriverKey, opts ...grpc.CallOption) (*Result, error)
}

type gPUDriverApiClient struct {
	cc *grpc.ClientConn
}

func NewGPUDriverApiClient(cc *grpc.ClientConn) GPUDriverApiClient {
	return &gPUDriverApiClient{cc}
}

func (c *gPUDriverApiClient) CreateGPUDriver(ctx context.Context, in *GPUDriver, opts ...grpc.CallOption) (GPUDriverApi_CreateGPUDriverClient, error) {
	stream, err := c.cc.NewStream(ctx, &_GPUDriverApi_serviceDesc.Streams[0], "/edgeproto.GPUDriverApi/CreateGPUDriver", opts...)
	if err != nil {
		return nil, err
	}
	x := &gPUDriverApiCreateGPUDriverClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type GPUDriverApi_CreateGPUDriverClient interface {
	Recv() (*Result, error)
	grpc.ClientStream
}

type gPUDriverApiCreateGPUDriverClient struct {
	grpc.ClientStream
}

func (x *gPUDriverApiCreateGPUDriverClient) Recv() (*Result, error) {
	m := new(Result)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *gPUDriverApiClient) DeleteGPUDriver(ctx context.Context, in *GPUDriver, opts ...grpc.CallOption) (GPUDriverApi_DeleteGPUDriverClient, error) {
	stream, err := c.cc.NewStream(ctx, &_GPUDriverApi_serviceDesc.Streams[1], "/edgeproto.GPUDriverApi/DeleteGPUDriver", opts...)
	if err != nil {
		return nil, err
	}
	x := &gPUDriverApiDeleteGPUDriverClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type GPUDriverApi_DeleteGPUDriverClient interface {
	Recv() (*Result, error)
	grpc.ClientStream
}

type gPUDriverApiDeleteGPUDriverClient struct {
	grpc.ClientStream
}

func (x *gPUDriverApiDeleteGPUDriverClient) Recv() (*Result, error) {
	m := new(Result)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *gPUDriverApiClient) UpdateGPUDriver(ctx context.Context, in *GPUDriver, opts ...grpc.CallOption) (GPUDriverApi_UpdateGPUDriverClient, error) {
	stream, err := c.cc.NewStream(ctx, &_GPUDriverApi_serviceDesc.Streams[2], "/edgeproto.GPUDriverApi/UpdateGPUDriver", opts...)
	if err != nil {
		return nil, err
	}
	x := &gPUDriverApiUpdateGPUDriverClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type GPUDriverApi_UpdateGPUDriverClient interface {
	Recv() (*Result, error)
	grpc.ClientStream
}

type gPUDriverApiUpdateGPUDriverClient struct {
	grpc.ClientStream
}

func (x *gPUDriverApiUpdateGPUDriverClient) Recv() (*Result, error) {
	m := new(Result)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *gPUDriverApiClient) ShowGPUDriver(ctx context.Context, in *GPUDriver, opts ...grpc.CallOption) (GPUDriverApi_ShowGPUDriverClient, error) {
	stream, err := c.cc.NewStream(ctx, &_GPUDriverApi_serviceDesc.Streams[3], "/edgeproto.GPUDriverApi/ShowGPUDriver", opts...)
	if err != nil {
		return nil, err
	}
	x := &gPUDriverApiShowGPUDriverClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type GPUDriverApi_ShowGPUDriverClient interface {
	Recv() (*GPUDriver, error)
	grpc.ClientStream
}

type gPUDriverApiShowGPUDriverClient struct {
	grpc.ClientStream
}

func (x *gPUDriverApiShowGPUDriverClient) Recv() (*GPUDriver, error) {
	m := new(GPUDriver)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *gPUDriverApiClient) AddGPUDriverBuild(ctx context.Context, in *GPUDriverBuildMember, opts ...grpc.CallOption) (GPUDriverApi_AddGPUDriverBuildClient, error) {
	stream, err := c.cc.NewStream(ctx, &_GPUDriverApi_serviceDesc.Streams[4], "/edgeproto.GPUDriverApi/AddGPUDriverBuild", opts...)
	if err != nil {
		return nil, err
	}
	x := &gPUDriverApiAddGPUDriverBuildClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type GPUDriverApi_AddGPUDriverBuildClient interface {
	Recv() (*Result, error)
	grpc.ClientStream
}

type gPUDriverApiAddGPUDriverBuildClient struct {
	grpc.ClientStream
}

func (x *gPUDriverApiAddGPUDriverBuildClient) Recv() (*Result, error) {
	m := new(Result)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *gPUDriverApiClient) RemoveGPUDriverBuild(ctx context.Context, in *GPUDriverBuildMember, opts ...grpc.CallOption) (GPUDriverApi_RemoveGPUDriverBuildClient, error) {
	stream, err := c.cc.NewStream(ctx, &_GPUDriverApi_serviceDesc.Streams[5], "/edgeproto.GPUDriverApi/RemoveGPUDriverBuild", opts...)
	if err != nil {
		return nil, err
	}
	x := &gPUDriverApiRemoveGPUDriverBuildClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type GPUDriverApi_RemoveGPUDriverBuildClient interface {
	Recv() (*Result, error)
	grpc.ClientStream
}

type gPUDriverApiRemoveGPUDriverBuildClient struct {
	grpc.ClientStream
}

func (x *gPUDriverApiRemoveGPUDriverBuildClient) Recv() (*Result, error) {
	m := new(Result)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *gPUDriverApiClient) GetGPUDriverBuildURL(ctx context.Context, in *GPUDriverBuildMember, opts ...grpc.CallOption) (*GPUDriverBuildURL, error) {
	out := new(GPUDriverBuildURL)
	err := c.cc.Invoke(ctx, "/edgeproto.GPUDriverApi/GetGPUDriverBuildURL", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gPUDriverApiClient) GetGPUDriverLicenseConfig(ctx context.Context, in *GPUDriverKey, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/edgeproto.GPUDriverApi/GetGPUDriverLicenseConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GPUDriverApiServer is the server API for GPUDriverApi service.
type GPUDriverApiServer interface {
	// Create GPU Driver. Creates GPU driver with all the config
	// required to install it.
	CreateGPUDriver(*GPUDriver, GPUDriverApi_CreateGPUDriverServer) error
	// Delete GPU Driver. Deletes GPU driver given that it is not
	// used by any cloudlet.
	DeleteGPUDriver(*GPUDriver, GPUDriverApi_DeleteGPUDriverServer) error
	// Update GPU Driver. Updates GPU driver config.
	UpdateGPUDriver(*GPUDriver, GPUDriverApi_UpdateGPUDriverServer) error
	// Show GPU Drivers. Lists all the EdgeCloud created GPU drivers and operator
	// created GPU drivers.
	ShowGPUDriver(*GPUDriver, GPUDriverApi_ShowGPUDriverServer) error
	// Add GPU Driver Build. Adds new build to GPU driver.
	AddGPUDriverBuild(*GPUDriverBuildMember, GPUDriverApi_AddGPUDriverBuildServer) error
	// Remove GPU Driver Build. Removes build from GPU driver.
	RemoveGPUDriverBuild(*GPUDriverBuildMember, GPUDriverApi_RemoveGPUDriverBuildServer) error
	// (Deprecated) Get GPU Driver Build URL. Returns a time-limited signed URL to download GPU driver.
	GetGPUDriverBuildURL(context.Context, *GPUDriverBuildMember) (*GPUDriverBuildURL, error)
	// (Deprecated) Get GPU Driver License Config. Returns the license config specific to GPU driver
	GetGPUDriverLicenseConfig(context.Context, *GPUDriverKey) (*Result, error)
}

// UnimplementedGPUDriverApiServer can be embedded to have forward compatible implementations.
type UnimplementedGPUDriverApiServer struct {
}

func (*UnimplementedGPUDriverApiServer) CreateGPUDriver(req *GPUDriver, srv GPUDriverApi_CreateGPUDriverServer) error {
	return status.Errorf(codes.Unimplemented, "method CreateGPUDriver not implemented")
}
func (*UnimplementedGPUDriverApiServer) DeleteGPUDriver(req *GPUDriver, srv GPUDriverApi_DeleteGPUDriverServer) error {
	return status.Errorf(codes.Unimplemented, "method DeleteGPUDriver not implemented")
}
func (*UnimplementedGPUDriverApiServer) UpdateGPUDriver(req *GPUDriver, srv GPUDriverApi_UpdateGPUDriverServer) error {
	return status.Errorf(codes.Unimplemented, "method UpdateGPUDriver not implemented")
}
func (*UnimplementedGPUDriverApiServer) ShowGPUDriver(req *GPUDriver, srv GPUDriverApi_ShowGPUDriverServer) error {
	return status.Errorf(codes.Unimplemented, "method ShowGPUDriver not implemented")
}
func (*UnimplementedGPUDriverApiServer) AddGPUDriverBuild(req *GPUDriverBuildMember, srv GPUDriverApi_AddGPUDriverBuildServer) error {
	return status.Errorf(codes.Unimplemented, "method AddGPUDriverBuild not implemented")
}
func (*UnimplementedGPUDriverApiServer) RemoveGPUDriverBuild(req *GPUDriverBuildMember, srv GPUDriverApi_RemoveGPUDriverBuildServer) error {
	return status.Errorf(codes.Unimplemented, "method RemoveGPUDriverBuild not implemented")
}
func (*UnimplementedGPUDriverApiServer) GetGPUDriverBuildURL(ctx context.Context, req *GPUDriverBuildMember) (*GPUDriverBuildURL, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGPUDriverBuildURL not implemented")
}
func (*UnimplementedGPUDriverApiServer) GetGPUDriverLicenseConfig(ctx context.Context, req *GPUDriverKey) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGPUDriverLicenseConfig not implemented")
}

func RegisterGPUDriverApiServer(s *grpc.Server, srv GPUDriverApiServer) {
	s.RegisterService(&_GPUDriverApi_serviceDesc, srv)
}

func _GPUDriverApi_CreateGPUDriver_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GPUDriver)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GPUDriverApiServer).CreateGPUDriver(m, &gPUDriverApiCreateGPUDriverServer{stream})
}

type GPUDriverApi_CreateGPUDriverServer interface {
	Send(*Result) error
	grpc.ServerStream
}

type gPUDriverApiCreateGPUDriverServer struct {
	grpc.ServerStream
}

func (x *gPUDriverApiCreateGPUDriverServer) Send(m *Result) error {
	return x.ServerStream.SendMsg(m)
}

func _GPUDriverApi_DeleteGPUDriver_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GPUDriver)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GPUDriverApiServer).DeleteGPUDriver(m, &gPUDriverApiDeleteGPUDriverServer{stream})
}

type GPUDriverApi_DeleteGPUDriverServer interface {
	Send(*Result) error
	grpc.ServerStream
}

type gPUDriverApiDeleteGPUDriverServer struct {
	grpc.ServerStream
}

func (x *gPUDriverApiDeleteGPUDriverServer) Send(m *Result) error {
	return x.ServerStream.SendMsg(m)
}

func _GPUDriverApi_UpdateGPUDriver_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GPUDriver)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GPUDriverApiServer).UpdateGPUDriver(m, &gPUDriverApiUpdateGPUDriverServer{stream})
}

type GPUDriverApi_UpdateGPUDriverServer interface {
	Send(*Result) error
	grpc.ServerStream
}

type gPUDriverApiUpdateGPUDriverServer struct {
	grpc.ServerStream
}

func (x *gPUDriverApiUpdateGPUDriverServer) Send(m *Result) error {
	return x.ServerStream.SendMsg(m)
}

func _GPUDriverApi_ShowGPUDriver_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GPUDriver)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GPUDriverApiServer).ShowGPUDriver(m, &gPUDriverApiShowGPUDriverServer{stream})
}

type GPUDriverApi_ShowGPUDriverServer interface {
	Send(*GPUDriver) error
	grpc.ServerStream
}

type gPUDriverApiShowGPUDriverServer struct {
	grpc.ServerStream
}

func (x *gPUDriverApiShowGPUDriverServer) Send(m *GPUDriver) error {
	return x.ServerStream.SendMsg(m)
}

func _GPUDriverApi_AddGPUDriverBuild_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GPUDriverBuildMember)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GPUDriverApiServer).AddGPUDriverBuild(m, &gPUDriverApiAddGPUDriverBuildServer{stream})
}

type GPUDriverApi_AddGPUDriverBuildServer interface {
	Send(*Result) error
	grpc.ServerStream
}

type gPUDriverApiAddGPUDriverBuildServer struct {
	grpc.ServerStream
}

func (x *gPUDriverApiAddGPUDriverBuildServer) Send(m *Result) error {
	return x.ServerStream.SendMsg(m)
}

func _GPUDriverApi_RemoveGPUDriverBuild_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GPUDriverBuildMember)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GPUDriverApiServer).RemoveGPUDriverBuild(m, &gPUDriverApiRemoveGPUDriverBuildServer{stream})
}

type GPUDriverApi_RemoveGPUDriverBuildServer interface {
	Send(*Result) error
	grpc.ServerStream
}

type gPUDriverApiRemoveGPUDriverBuildServer struct {
	grpc.ServerStream
}

func (x *gPUDriverApiRemoveGPUDriverBuildServer) Send(m *Result) error {
	return x.ServerStream.SendMsg(m)
}

func _GPUDriverApi_GetGPUDriverBuildURL_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GPUDriverBuildMember)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GPUDriverApiServer).GetGPUDriverBuildURL(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.GPUDriverApi/GetGPUDriverBuildURL",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GPUDriverApiServer).GetGPUDriverBuildURL(ctx, req.(*GPUDriverBuildMember))
	}
	return interceptor(ctx, in, info, handler)
}

func _GPUDriverApi_GetGPUDriverLicenseConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GPUDriverKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GPUDriverApiServer).GetGPUDriverLicenseConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.GPUDriverApi/GetGPUDriverLicenseConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GPUDriverApiServer).GetGPUDriverLicenseConfig(ctx, req.(*GPUDriverKey))
	}
	return interceptor(ctx, in, info, handler)
}

var _GPUDriverApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "edgeproto.GPUDriverApi",
	HandlerType: (*GPUDriverApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetGPUDriverBuildURL",
			Handler:    _GPUDriverApi_GetGPUDriverBuildURL_Handler,
		},
		{
			MethodName: "GetGPUDriverLicenseConfig",
			Handler:    _GPUDriverApi_GetGPUDriverLicenseConfig_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "CreateGPUDriver",
			Handler:       _GPUDriverApi_CreateGPUDriver_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "DeleteGPUDriver",
			Handler:       _GPUDriverApi_DeleteGPUDriver_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "UpdateGPUDriver",
			Handler:       _GPUDriverApi_UpdateGPUDriver_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ShowGPUDriver",
			Handler:       _GPUDriverApi_ShowGPUDriver_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "AddGPUDriverBuild",
			Handler:       _GPUDriverApi_AddGPUDriverBuild_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "RemoveGPUDriverBuild",
			Handler:       _GPUDriverApi_RemoveGPUDriverBuild_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "cloudlet.proto",
}

// CloudletApiClient is the client API for CloudletApi service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type CloudletApiClient interface {
	// Create Cloudlet. Sets up Cloudlet services on the Operator's compute resources,
	// and integrated as part of EdgeCloud edge resource portfolio.
	// These resources are managed from the Edge Controller.
	CreateCloudlet(ctx context.Context, in *Cloudlet, opts ...grpc.CallOption) (CloudletApi_CreateCloudletClient, error)
	// Delete Cloudlet. Removes the Cloudlet services where they are no longer managed
	// from the Edge Controller.
	DeleteCloudlet(ctx context.Context, in *Cloudlet, opts ...grpc.CallOption) (CloudletApi_DeleteCloudletClient, error)
	// Update Cloudlet. Updates the Cloudlet configuration and manages the upgrade of Cloudlet services.
	UpdateCloudlet(ctx context.Context, in *Cloudlet, opts ...grpc.CallOption) (CloudletApi_UpdateCloudletClient, error)
	// Show Cloudlets. Lists all the cloudlets managed from Edge Controller.
	ShowCloudlet(ctx context.Context, in *Cloudlet, opts ...grpc.CallOption) (CloudletApi_ShowCloudletClient, error)
	// Get Cloudlet Manifest. Shows deployment manifest required to setup cloudlet
	GetCloudletManifest(ctx context.Context, in *CloudletKey, opts ...grpc.CallOption) (*CloudletManifest, error)
	// Get Cloudlet Properties. Shows all the infra properties used to setup cloudlet
	GetCloudletProps(ctx context.Context, in *CloudletProps, opts ...grpc.CallOption) (*CloudletProps, error)
	// Get Cloudlet Resource Quota Properties. Shows all the resource quota properties of the cloudlet
	GetCloudletResourceQuotaProps(ctx context.Context, in *CloudletResourceQuotaProps, opts ...grpc.CallOption) (*CloudletResourceQuotaProps, error)
	// Get Cloudlet resource information. Shows cloudlet resources used and their limits
	GetCloudletResourceUsage(ctx context.Context, in *CloudletResourceUsage, opts ...grpc.CallOption) (*CloudletResourceUsage, error)
	// Add Optional Resource tag table
	AddCloudletResMapping(ctx context.Context, in *CloudletResMap, opts ...grpc.CallOption) (*Result, error)
	// Remove Optional Resource tag table
	RemoveCloudletResMapping(ctx context.Context, in *CloudletResMap, opts ...grpc.CallOption) (*Result, error)
	// Add alliance organization to the cloudlet
	AddCloudletAllianceOrg(ctx context.Context, in *CloudletAllianceOrg, opts ...grpc.CallOption) (*Result, error)
	// Remove alliance organization from the cloudlet
	RemoveCloudletAllianceOrg(ctx context.Context, in *CloudletAllianceOrg, opts ...grpc.CallOption) (*Result, error)
	// Discover if flavor produces a matching platform flavor
	FindFlavorMatch(ctx context.Context, in *FlavorMatch, opts ...grpc.CallOption) (*FlavorMatch, error)
	// Find all meta flavors viable on cloudlet
	ShowFlavorsForCloudlet(ctx context.Context, in *CloudletKey, opts ...grpc.CallOption) (CloudletApi_ShowFlavorsForCloudletClient, error)
	// Get organizations of ClusterInsts and AppInsts on cloudlet
	GetOrganizationsOnCloudlet(ctx context.Context, in *CloudletKey, opts ...grpc.CallOption) (CloudletApi_GetOrganizationsOnCloudletClient, error)
	// Revoke crm access key
	RevokeAccessKey(ctx context.Context, in *CloudletKey, opts ...grpc.CallOption) (*Result, error)
	// Generate new crm access key
	GenerateAccessKey(ctx context.Context, in *CloudletKey, opts ...grpc.CallOption) (*Result, error)
	// Get Cloudlet Specific GPU Driver License Config. Returns the license config associated with the cloudlet
	GetCloudletGPUDriverLicenseConfig(ctx context.Context, in *CloudletKey, opts ...grpc.CallOption) (*Result, error)
}

type cloudletApiClient struct {
	cc *grpc.ClientConn
}

func NewCloudletApiClient(cc *grpc.ClientConn) CloudletApiClient {
	return &cloudletApiClient{cc}
}

func (c *cloudletApiClient) CreateCloudlet(ctx context.Context, in *Cloudlet, opts ...grpc.CallOption) (CloudletApi_CreateCloudletClient, error) {
	stream, err := c.cc.NewStream(ctx, &_CloudletApi_serviceDesc.Streams[0], "/edgeproto.CloudletApi/CreateCloudlet", opts...)
	if err != nil {
		return nil, err
	}
	x := &cloudletApiCreateCloudletClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CloudletApi_CreateCloudletClient interface {
	Recv() (*Result, error)
	grpc.ClientStream
}

type cloudletApiCreateCloudletClient struct {
	grpc.ClientStream
}

func (x *cloudletApiCreateCloudletClient) Recv() (*Result, error) {
	m := new(Result)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *cloudletApiClient) DeleteCloudlet(ctx context.Context, in *Cloudlet, opts ...grpc.CallOption) (CloudletApi_DeleteCloudletClient, error) {
	stream, err := c.cc.NewStream(ctx, &_CloudletApi_serviceDesc.Streams[1], "/edgeproto.CloudletApi/DeleteCloudlet", opts...)
	if err != nil {
		return nil, err
	}
	x := &cloudletApiDeleteCloudletClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CloudletApi_DeleteCloudletClient interface {
	Recv() (*Result, error)
	grpc.ClientStream
}

type cloudletApiDeleteCloudletClient struct {
	grpc.ClientStream
}

func (x *cloudletApiDeleteCloudletClient) Recv() (*Result, error) {
	m := new(Result)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *cloudletApiClient) UpdateCloudlet(ctx context.Context, in *Cloudlet, opts ...grpc.CallOption) (CloudletApi_UpdateCloudletClient, error) {
	stream, err := c.cc.NewStream(ctx, &_CloudletApi_serviceDesc.Streams[2], "/edgeproto.CloudletApi/UpdateCloudlet", opts...)
	if err != nil {
		return nil, err
	}
	x := &cloudletApiUpdateCloudletClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CloudletApi_UpdateCloudletClient interface {
	Recv() (*Result, error)
	grpc.ClientStream
}

type cloudletApiUpdateCloudletClient struct {
	grpc.ClientStream
}

func (x *cloudletApiUpdateCloudletClient) Recv() (*Result, error) {
	m := new(Result)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *cloudletApiClient) ShowCloudlet(ctx context.Context, in *Cloudlet, opts ...grpc.CallOption) (CloudletApi_ShowCloudletClient, error) {
	stream, err := c.cc.NewStream(ctx, &_CloudletApi_serviceDesc.Streams[3], "/edgeproto.CloudletApi/ShowCloudlet", opts...)
	if err != nil {
		return nil, err
	}
	x := &cloudletApiShowCloudletClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CloudletApi_ShowCloudletClient interface {
	Recv() (*Cloudlet, error)
	grpc.ClientStream
}

type cloudletApiShowCloudletClient struct {
	grpc.ClientStream
}

func (x *cloudletApiShowCloudletClient) Recv() (*Cloudlet, error) {
	m := new(Cloudlet)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *cloudletApiClient) GetCloudletManifest(ctx context.Context, in *CloudletKey, opts ...grpc.CallOption) (*CloudletManifest, error) {
	out := new(CloudletManifest)
	err := c.cc.Invoke(ctx, "/edgeproto.CloudletApi/GetCloudletManifest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cloudletApiClient) GetCloudletProps(ctx context.Context, in *CloudletProps, opts ...grpc.CallOption) (*CloudletProps, error) {
	out := new(CloudletProps)
	err := c.cc.Invoke(ctx, "/edgeproto.CloudletApi/GetCloudletProps", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cloudletApiClient) GetCloudletResourceQuotaProps(ctx context.Context, in *CloudletResourceQuotaProps, opts ...grpc.CallOption) (*CloudletResourceQuotaProps, error) {
	out := new(CloudletResourceQuotaProps)
	err := c.cc.Invoke(ctx, "/edgeproto.CloudletApi/GetCloudletResourceQuotaProps", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cloudletApiClient) GetCloudletResourceUsage(ctx context.Context, in *CloudletResourceUsage, opts ...grpc.CallOption) (*CloudletResourceUsage, error) {
	out := new(CloudletResourceUsage)
	err := c.cc.Invoke(ctx, "/edgeproto.CloudletApi/GetCloudletResourceUsage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cloudletApiClient) AddCloudletResMapping(ctx context.Context, in *CloudletResMap, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/edgeproto.CloudletApi/AddCloudletResMapping", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cloudletApiClient) RemoveCloudletResMapping(ctx context.Context, in *CloudletResMap, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/edgeproto.CloudletApi/RemoveCloudletResMapping", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cloudletApiClient) AddCloudletAllianceOrg(ctx context.Context, in *CloudletAllianceOrg, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/edgeproto.CloudletApi/AddCloudletAllianceOrg", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cloudletApiClient) RemoveCloudletAllianceOrg(ctx context.Context, in *CloudletAllianceOrg, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/edgeproto.CloudletApi/RemoveCloudletAllianceOrg", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cloudletApiClient) FindFlavorMatch(ctx context.Context, in *FlavorMatch, opts ...grpc.CallOption) (*FlavorMatch, error) {
	out := new(FlavorMatch)
	err := c.cc.Invoke(ctx, "/edgeproto.CloudletApi/FindFlavorMatch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cloudletApiClient) ShowFlavorsForCloudlet(ctx context.Context, in *CloudletKey, opts ...grpc.CallOption) (CloudletApi_ShowFlavorsForCloudletClient, error) {
	stream, err := c.cc.NewStream(ctx, &_CloudletApi_serviceDesc.Streams[4], "/edgeproto.CloudletApi/ShowFlavorsForCloudlet", opts...)
	if err != nil {
		return nil, err
	}
	x := &cloudletApiShowFlavorsForCloudletClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CloudletApi_ShowFlavorsForCloudletClient interface {
	Recv() (*FlavorKey, error)
	grpc.ClientStream
}

type cloudletApiShowFlavorsForCloudletClient struct {
	grpc.ClientStream
}

func (x *cloudletApiShowFlavorsForCloudletClient) Recv() (*FlavorKey, error) {
	m := new(FlavorKey)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *cloudletApiClient) GetOrganizationsOnCloudlet(ctx context.Context, in *CloudletKey, opts ...grpc.CallOption) (CloudletApi_GetOrganizationsOnCloudletClient, error) {
	stream, err := c.cc.NewStream(ctx, &_CloudletApi_serviceDesc.Streams[5], "/edgeproto.CloudletApi/GetOrganizationsOnCloudlet", opts...)
	if err != nil {
		return nil, err
	}
	x := &cloudletApiGetOrganizationsOnCloudletClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CloudletApi_GetOrganizationsOnCloudletClient interface {
	Recv() (*Organization, error)
	grpc.ClientStream
}

type cloudletApiGetOrganizationsOnCloudletClient struct {
	grpc.ClientStream
}

func (x *cloudletApiGetOrganizationsOnCloudletClient) Recv() (*Organization, error) {
	m := new(Organization)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *cloudletApiClient) RevokeAccessKey(ctx context.Context, in *CloudletKey, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/edgeproto.CloudletApi/RevokeAccessKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cloudletApiClient) GenerateAccessKey(ctx context.Context, in *CloudletKey, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/edgeproto.CloudletApi/GenerateAccessKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cloudletApiClient) GetCloudletGPUDriverLicenseConfig(ctx context.Context, in *CloudletKey, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/edgeproto.CloudletApi/GetCloudletGPUDriverLicenseConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CloudletApiServer is the server API for CloudletApi service.
type CloudletApiServer interface {
	// Create Cloudlet. Sets up Cloudlet services on the Operator's compute resources,
	// and integrated as part of EdgeCloud edge resource portfolio.
	// These resources are managed from the Edge Controller.
	CreateCloudlet(*Cloudlet, CloudletApi_CreateCloudletServer) error
	// Delete Cloudlet. Removes the Cloudlet services where they are no longer managed
	// from the Edge Controller.
	DeleteCloudlet(*Cloudlet, CloudletApi_DeleteCloudletServer) error
	// Update Cloudlet. Updates the Cloudlet configuration and manages the upgrade of Cloudlet services.
	UpdateCloudlet(*Cloudlet, CloudletApi_UpdateCloudletServer) error
	// Show Cloudlets. Lists all the cloudlets managed from Edge Controller.
	ShowCloudlet(*Cloudlet, CloudletApi_ShowCloudletServer) error
	// Get Cloudlet Manifest. Shows deployment manifest required to setup cloudlet
	GetCloudletManifest(context.Context, *CloudletKey) (*CloudletManifest, error)
	// Get Cloudlet Properties. Shows all the infra properties used to setup cloudlet
	GetCloudletProps(context.Context, *CloudletProps) (*CloudletProps, error)
	// Get Cloudlet Resource Quota Properties. Shows all the resource quota properties of the cloudlet
	GetCloudletResourceQuotaProps(context.Context, *CloudletResourceQuotaProps) (*CloudletResourceQuotaProps, error)
	// Get Cloudlet resource information. Shows cloudlet resources used and their limits
	GetCloudletResourceUsage(context.Context, *CloudletResourceUsage) (*CloudletResourceUsage, error)
	// Add Optional Resource tag table
	AddCloudletResMapping(context.Context, *CloudletResMap) (*Result, error)
	// Remove Optional Resource tag table
	RemoveCloudletResMapping(context.Context, *CloudletResMap) (*Result, error)
	// Add alliance organization to the cloudlet
	AddCloudletAllianceOrg(context.Context, *CloudletAllianceOrg) (*Result, error)
	// Remove alliance organization from the cloudlet
	RemoveCloudletAllianceOrg(context.Context, *CloudletAllianceOrg) (*Result, error)
	// Discover if flavor produces a matching platform flavor
	FindFlavorMatch(context.Context, *FlavorMatch) (*FlavorMatch, error)
	// Find all meta flavors viable on cloudlet
	ShowFlavorsForCloudlet(*CloudletKey, CloudletApi_ShowFlavorsForCloudletServer) error
	// Get organizations of ClusterInsts and AppInsts on cloudlet
	GetOrganizationsOnCloudlet(*CloudletKey, CloudletApi_GetOrganizationsOnCloudletServer) error
	// Revoke crm access key
	RevokeAccessKey(context.Context, *CloudletKey) (*Result, error)
	// Generate new crm access key
	GenerateAccessKey(context.Context, *CloudletKey) (*Result, error)
	// Get Cloudlet Specific GPU Driver License Config. Returns the license config associated with the cloudlet
	GetCloudletGPUDriverLicenseConfig(context.Context, *CloudletKey) (*Result, error)
}

// UnimplementedCloudletApiServer can be embedded to have forward compatible implementations.
type UnimplementedCloudletApiServer struct {
}

func (*UnimplementedCloudletApiServer) CreateCloudlet(req *Cloudlet, srv CloudletApi_CreateCloudletServer) error {
	return status.Errorf(codes.Unimplemented, "method CreateCloudlet not implemented")
}
func (*UnimplementedCloudletApiServer) DeleteCloudlet(req *Cloudlet, srv CloudletApi_DeleteCloudletServer) error {
	return status.Errorf(codes.Unimplemented, "method DeleteCloudlet not implemented")
}
func (*UnimplementedCloudletApiServer) UpdateCloudlet(req *Cloudlet, srv CloudletApi_UpdateCloudletServer) error {
	return status.Errorf(codes.Unimplemented, "method UpdateCloudlet not implemented")
}
func (*UnimplementedCloudletApiServer) ShowCloudlet(req *Cloudlet, srv CloudletApi_ShowCloudletServer) error {
	return status.Errorf(codes.Unimplemented, "method ShowCloudlet not implemented")
}
func (*UnimplementedCloudletApiServer) GetCloudletManifest(ctx context.Context, req *CloudletKey) (*CloudletManifest, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCloudletManifest not implemented")
}
func (*UnimplementedCloudletApiServer) GetCloudletProps(ctx context.Context, req *CloudletProps) (*CloudletProps, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCloudletProps not implemented")
}
func (*UnimplementedCloudletApiServer) GetCloudletResourceQuotaProps(ctx context.Context, req *CloudletResourceQuotaProps) (*CloudletResourceQuotaProps, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCloudletResourceQuotaProps not implemented")
}
func (*UnimplementedCloudletApiServer) GetCloudletResourceUsage(ctx context.Context, req *CloudletResourceUsage) (*CloudletResourceUsage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCloudletResourceUsage not implemented")
}
func (*UnimplementedCloudletApiServer) AddCloudletResMapping(ctx context.Context, req *CloudletResMap) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddCloudletResMapping not implemented")
}
func (*UnimplementedCloudletApiServer) RemoveCloudletResMapping(ctx context.Context, req *CloudletResMap) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveCloudletResMapping not implemented")
}
func (*UnimplementedCloudletApiServer) AddCloudletAllianceOrg(ctx context.Context, req *CloudletAllianceOrg) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddCloudletAllianceOrg not implemented")
}
func (*UnimplementedCloudletApiServer) RemoveCloudletAllianceOrg(ctx context.Context, req *CloudletAllianceOrg) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveCloudletAllianceOrg not implemented")
}
func (*UnimplementedCloudletApiServer) FindFlavorMatch(ctx context.Context, req *FlavorMatch) (*FlavorMatch, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindFlavorMatch not implemented")
}
func (*UnimplementedCloudletApiServer) ShowFlavorsForCloudlet(req *CloudletKey, srv CloudletApi_ShowFlavorsForCloudletServer) error {
	return status.Errorf(codes.Unimplemented, "method ShowFlavorsForCloudlet not implemented")
}
func (*UnimplementedCloudletApiServer) GetOrganizationsOnCloudlet(req *CloudletKey, srv CloudletApi_GetOrganizationsOnCloudletServer) error {
	return status.Errorf(codes.Unimplemented, "method GetOrganizationsOnCloudlet not implemented")
}
func (*UnimplementedCloudletApiServer) RevokeAccessKey(ctx context.Context, req *CloudletKey) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RevokeAccessKey not implemented")
}
func (*UnimplementedCloudletApiServer) GenerateAccessKey(ctx context.Context, req *CloudletKey) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateAccessKey not implemented")
}
func (*UnimplementedCloudletApiServer) GetCloudletGPUDriverLicenseConfig(ctx context.Context, req *CloudletKey) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCloudletGPUDriverLicenseConfig not implemented")
}

func RegisterCloudletApiServer(s *grpc.Server, srv CloudletApiServer) {
	s.RegisterService(&_CloudletApi_serviceDesc, srv)
}

func _CloudletApi_CreateCloudlet_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Cloudlet)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CloudletApiServer).CreateCloudlet(m, &cloudletApiCreateCloudletServer{stream})
}

type CloudletApi_CreateCloudletServer interface {
	Send(*Result) error
	grpc.ServerStream
}

type cloudletApiCreateCloudletServer struct {
	grpc.ServerStream
}

func (x *cloudletApiCreateCloudletServer) Send(m *Result) error {
	return x.ServerStream.SendMsg(m)
}

func _CloudletApi_DeleteCloudlet_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Cloudlet)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CloudletApiServer).DeleteCloudlet(m, &cloudletApiDeleteCloudletServer{stream})
}

type CloudletApi_DeleteCloudletServer interface {
	Send(*Result) error
	grpc.ServerStream
}

type cloudletApiDeleteCloudletServer struct {
	grpc.ServerStream
}

func (x *cloudletApiDeleteCloudletServer) Send(m *Result) error {
	return x.ServerStream.SendMsg(m)
}

func _CloudletApi_UpdateCloudlet_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Cloudlet)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CloudletApiServer).UpdateCloudlet(m, &cloudletApiUpdateCloudletServer{stream})
}

type CloudletApi_UpdateCloudletServer interface {
	Send(*Result) error
	grpc.ServerStream
}

type cloudletApiUpdateCloudletServer struct {
	grpc.ServerStream
}

func (x *cloudletApiUpdateCloudletServer) Send(m *Result) error {
	return x.ServerStream.SendMsg(m)
}

func _CloudletApi_ShowCloudlet_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Cloudlet)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CloudletApiServer).ShowCloudlet(m, &cloudletApiShowCloudletServer{stream})
}

type CloudletApi_ShowCloudletServer interface {
	Send(*Cloudlet) error
	grpc.ServerStream
}

type cloudletApiShowCloudletServer struct {
	grpc.ServerStream
}

func (x *cloudletApiShowCloudletServer) Send(m *Cloudlet) error {
	return x.ServerStream.SendMsg(m)
}

func _CloudletApi_GetCloudletManifest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloudletKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CloudletApiServer).GetCloudletManifest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.CloudletApi/GetCloudletManifest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CloudletApiServer).GetCloudletManifest(ctx, req.(*CloudletKey))
	}
	return interceptor(ctx, in, info, handler)
}

func _CloudletApi_GetCloudletProps_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloudletProps)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CloudletApiServer).GetCloudletProps(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.CloudletApi/GetCloudletProps",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CloudletApiServer).GetCloudletProps(ctx, req.(*CloudletProps))
	}
	return interceptor(ctx, in, info, handler)
}

func _CloudletApi_GetCloudletResourceQuotaProps_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloudletResourceQuotaProps)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CloudletApiServer).GetCloudletResourceQuotaProps(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.CloudletApi/GetCloudletResourceQuotaProps",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CloudletApiServer).GetCloudletResourceQuotaProps(ctx, req.(*CloudletResourceQuotaProps))
	}
	return interceptor(ctx, in, info, handler)
}

func _CloudletApi_GetCloudletResourceUsage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloudletResourceUsage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CloudletApiServer).GetCloudletResourceUsage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.CloudletApi/GetCloudletResourceUsage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CloudletApiServer).GetCloudletResourceUsage(ctx, req.(*CloudletResourceUsage))
	}
	return interceptor(ctx, in, info, handler)
}

func _CloudletApi_AddCloudletResMapping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloudletResMap)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CloudletApiServer).AddCloudletResMapping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.CloudletApi/AddCloudletResMapping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CloudletApiServer).AddCloudletResMapping(ctx, req.(*CloudletResMap))
	}
	return interceptor(ctx, in, info, handler)
}

func _CloudletApi_RemoveCloudletResMapping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloudletResMap)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CloudletApiServer).RemoveCloudletResMapping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.CloudletApi/RemoveCloudletResMapping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CloudletApiServer).RemoveCloudletResMapping(ctx, req.(*CloudletResMap))
	}
	return interceptor(ctx, in, info, handler)
}

func _CloudletApi_AddCloudletAllianceOrg_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloudletAllianceOrg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CloudletApiServer).AddCloudletAllianceOrg(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.CloudletApi/AddCloudletAllianceOrg",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CloudletApiServer).AddCloudletAllianceOrg(ctx, req.(*CloudletAllianceOrg))
	}
	return interceptor(ctx, in, info, handler)
}

func _CloudletApi_RemoveCloudletAllianceOrg_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloudletAllianceOrg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CloudletApiServer).RemoveCloudletAllianceOrg(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.CloudletApi/RemoveCloudletAllianceOrg",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CloudletApiServer).RemoveCloudletAllianceOrg(ctx, req.(*CloudletAllianceOrg))
	}
	return interceptor(ctx, in, info, handler)
}

func _CloudletApi_FindFlavorMatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FlavorMatch)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CloudletApiServer).FindFlavorMatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.CloudletApi/FindFlavorMatch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CloudletApiServer).FindFlavorMatch(ctx, req.(*FlavorMatch))
	}
	return interceptor(ctx, in, info, handler)
}

func _CloudletApi_ShowFlavorsForCloudlet_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(CloudletKey)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CloudletApiServer).ShowFlavorsForCloudlet(m, &cloudletApiShowFlavorsForCloudletServer{stream})
}

type CloudletApi_ShowFlavorsForCloudletServer interface {
	Send(*FlavorKey) error
	grpc.ServerStream
}

type cloudletApiShowFlavorsForCloudletServer struct {
	grpc.ServerStream
}

func (x *cloudletApiShowFlavorsForCloudletServer) Send(m *FlavorKey) error {
	return x.ServerStream.SendMsg(m)
}

func _CloudletApi_GetOrganizationsOnCloudlet_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(CloudletKey)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CloudletApiServer).GetOrganizationsOnCloudlet(m, &cloudletApiGetOrganizationsOnCloudletServer{stream})
}

type CloudletApi_GetOrganizationsOnCloudletServer interface {
	Send(*Organization) error
	grpc.ServerStream
}

type cloudletApiGetOrganizationsOnCloudletServer struct {
	grpc.ServerStream
}

func (x *cloudletApiGetOrganizationsOnCloudletServer) Send(m *Organization) error {
	return x.ServerStream.SendMsg(m)
}

func _CloudletApi_RevokeAccessKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloudletKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CloudletApiServer).RevokeAccessKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.CloudletApi/RevokeAccessKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CloudletApiServer).RevokeAccessKey(ctx, req.(*CloudletKey))
	}
	return interceptor(ctx, in, info, handler)
}

func _CloudletApi_GenerateAccessKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloudletKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CloudletApiServer).GenerateAccessKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.CloudletApi/GenerateAccessKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CloudletApiServer).GenerateAccessKey(ctx, req.(*CloudletKey))
	}
	return interceptor(ctx, in, info, handler)
}

func _CloudletApi_GetCloudletGPUDriverLicenseConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloudletKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CloudletApiServer).GetCloudletGPUDriverLicenseConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.CloudletApi/GetCloudletGPUDriverLicenseConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CloudletApiServer).GetCloudletGPUDriverLicenseConfig(ctx, req.(*CloudletKey))
	}
	return interceptor(ctx, in, info, handler)
}

var _CloudletApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "edgeproto.CloudletApi",
	HandlerType: (*CloudletApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetCloudletManifest",
			Handler:    _CloudletApi_GetCloudletManifest_Handler,
		},
		{
			MethodName: "GetCloudletProps",
			Handler:    _CloudletApi_GetCloudletProps_Handler,
		},
		{
			MethodName: "GetCloudletResourceQuotaProps",
			Handler:    _CloudletApi_GetCloudletResourceQuotaProps_Handler,
		},
		{
			MethodName: "GetCloudletResourceUsage",
			Handler:    _CloudletApi_GetCloudletResourceUsage_Handler,
		},
		{
			MethodName: "AddCloudletResMapping",
			Handler:    _CloudletApi_AddCloudletResMapping_Handler,
		},
		{
			MethodName: "RemoveCloudletResMapping",
			Handler:    _CloudletApi_RemoveCloudletResMapping_Handler,
		},
		{
			MethodName: "AddCloudletAllianceOrg",
			Handler:    _CloudletApi_AddCloudletAllianceOrg_Handler,
		},
		{
			MethodName: "RemoveCloudletAllianceOrg",
			Handler:    _CloudletApi_RemoveCloudletAllianceOrg_Handler,
		},
		{
			MethodName: "FindFlavorMatch",
			Handler:    _CloudletApi_FindFlavorMatch_Handler,
		},
		{
			MethodName: "RevokeAccessKey",
			Handler:    _CloudletApi_RevokeAccessKey_Handler,
		},
		{
			MethodName: "GenerateAccessKey",
			Handler:    _CloudletApi_GenerateAccessKey_Handler,
		},
		{
			MethodName: "GetCloudletGPUDriverLicenseConfig",
			Handler:    _CloudletApi_GetCloudletGPUDriverLicenseConfig_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "CreateCloudlet",
			Handler:       _CloudletApi_CreateCloudlet_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "DeleteCloudlet",
			Handler:       _CloudletApi_DeleteCloudlet_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "UpdateCloudlet",
			Handler:       _CloudletApi_UpdateCloudlet_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ShowCloudlet",
			Handler:       _CloudletApi_ShowCloudlet_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ShowFlavorsForCloudlet",
			Handler:       _CloudletApi_ShowFlavorsForCloudlet_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetOrganizationsOnCloudlet",
			Handler:       _CloudletApi_GetOrganizationsOnCloudlet_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "cloudlet.proto",
}

// CloudletInfoApiClient is the client API for CloudletInfoApi service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type CloudletInfoApiClient interface {
	// Show CloudletInfos
	ShowCloudletInfo(ctx context.Context, in *CloudletInfo, opts ...grpc.CallOption) (CloudletInfoApi_ShowCloudletInfoClient, error)
	// Inject (create) a CloudletInfo for regression testing
	InjectCloudletInfo(ctx context.Context, in *CloudletInfo, opts ...grpc.CallOption) (*Result, error)
	// Evict (delete) a CloudletInfo for regression testing
	EvictCloudletInfo(ctx context.Context, in *CloudletInfo, opts ...grpc.CallOption) (*Result, error)
}

type cloudletInfoApiClient struct {
	cc *grpc.ClientConn
}

func NewCloudletInfoApiClient(cc *grpc.ClientConn) CloudletInfoApiClient {
	return &cloudletInfoApiClient{cc}
}

func (c *cloudletInfoApiClient) ShowCloudletInfo(ctx context.Context, in *CloudletInfo, opts ...grpc.CallOption) (CloudletInfoApi_ShowCloudletInfoClient, error) {
	stream, err := c.cc.NewStream(ctx, &_CloudletInfoApi_serviceDesc.Streams[0], "/edgeproto.CloudletInfoApi/ShowCloudletInfo", opts...)
	if err != nil {
		return nil, err
	}
	x := &cloudletInfoApiShowCloudletInfoClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CloudletInfoApi_ShowCloudletInfoClient interface {
	Recv() (*CloudletInfo, error)
	grpc.ClientStream
}

type cloudletInfoApiShowCloudletInfoClient struct {
	grpc.ClientStream
}

func (x *cloudletInfoApiShowCloudletInfoClient) Recv() (*CloudletInfo, error) {
	m := new(CloudletInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *cloudletInfoApiClient) InjectCloudletInfo(ctx context.Context, in *CloudletInfo, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/edgeproto.CloudletInfoApi/InjectCloudletInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cloudletInfoApiClient) EvictCloudletInfo(ctx context.Context, in *CloudletInfo, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/edgeproto.CloudletInfoApi/EvictCloudletInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CloudletInfoApiServer is the server API for CloudletInfoApi service.
type CloudletInfoApiServer interface {
	// Show CloudletInfos
	ShowCloudletInfo(*CloudletInfo, CloudletInfoApi_ShowCloudletInfoServer) error
	// Inject (create) a CloudletInfo for regression testing
	InjectCloudletInfo(context.Context, *CloudletInfo) (*Result, error)
	// Evict (delete) a CloudletInfo for regression testing
	EvictCloudletInfo(context.Context, *CloudletInfo) (*Result, error)
}

// UnimplementedCloudletInfoApiServer can be embedded to have forward compatible implementations.
type UnimplementedCloudletInfoApiServer struct {
}

func (*UnimplementedCloudletInfoApiServer) ShowCloudletInfo(req *CloudletInfo, srv CloudletInfoApi_ShowCloudletInfoServer) error {
	return status.Errorf(codes.Unimplemented, "method ShowCloudletInfo not implemented")
}
func (*UnimplementedCloudletInfoApiServer) InjectCloudletInfo(ctx context.Context, req *CloudletInfo) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InjectCloudletInfo not implemented")
}
func (*UnimplementedCloudletInfoApiServer) EvictCloudletInfo(ctx context.Context, req *CloudletInfo) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EvictCloudletInfo not implemented")
}

func RegisterCloudletInfoApiServer(s *grpc.Server, srv CloudletInfoApiServer) {
	s.RegisterService(&_CloudletInfoApi_serviceDesc, srv)
}

func _CloudletInfoApi_ShowCloudletInfo_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(CloudletInfo)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CloudletInfoApiServer).ShowCloudletInfo(m, &cloudletInfoApiShowCloudletInfoServer{stream})
}

type CloudletInfoApi_ShowCloudletInfoServer interface {
	Send(*CloudletInfo) error
	grpc.ServerStream
}

type cloudletInfoApiShowCloudletInfoServer struct {
	grpc.ServerStream
}

func (x *cloudletInfoApiShowCloudletInfoServer) Send(m *CloudletInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _CloudletInfoApi_InjectCloudletInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloudletInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CloudletInfoApiServer).InjectCloudletInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.CloudletInfoApi/InjectCloudletInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CloudletInfoApiServer).InjectCloudletInfo(ctx, req.(*CloudletInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _CloudletInfoApi_EvictCloudletInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloudletInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CloudletInfoApiServer).EvictCloudletInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.CloudletInfoApi/EvictCloudletInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CloudletInfoApiServer).EvictCloudletInfo(ctx, req.(*CloudletInfo))
	}
	return interceptor(ctx, in, info, handler)
}

var _CloudletInfoApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "edgeproto.CloudletInfoApi",
	HandlerType: (*CloudletInfoApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "InjectCloudletInfo",
			Handler:    _CloudletInfoApi_InjectCloudletInfo_Handler,
		},
		{
			MethodName: "EvictCloudletInfo",
			Handler:    _CloudletInfoApi_EvictCloudletInfo_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ShowCloudletInfo",
			Handler:       _CloudletInfoApi_ShowCloudletInfo_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "cloudlet.proto",
}

// CloudletMetricsApiClient is the client API for CloudletMetricsApi service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type CloudletMetricsApiClient interface {
	// Show Cloudlet metrics
	ShowCloudletMetrics(ctx context.Context, in *CloudletMetrics, opts ...grpc.CallOption) (CloudletMetricsApi_ShowCloudletMetricsClient, error)
}

type cloudletMetricsApiClient struct {
	cc *grpc.ClientConn
}

func NewCloudletMetricsApiClient(cc *grpc.ClientConn) CloudletMetricsApiClient {
	return &cloudletMetricsApiClient{cc}
}

func (c *cloudletMetricsApiClient) ShowCloudletMetrics(ctx context.Context, in *CloudletMetrics, opts ...grpc.CallOption) (CloudletMetricsApi_ShowCloudletMetricsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_CloudletMetricsApi_serviceDesc.Streams[0], "/edgeproto.CloudletMetricsApi/ShowCloudletMetrics", opts...)
	if err != nil {
		return nil, err
	}
	x := &cloudletMetricsApiShowCloudletMetricsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CloudletMetricsApi_ShowCloudletMetricsClient interface {
	Recv() (*CloudletMetrics, error)
	grpc.ClientStream
}

type cloudletMetricsApiShowCloudletMetricsClient struct {
	grpc.ClientStream
}

func (x *cloudletMetricsApiShowCloudletMetricsClient) Recv() (*CloudletMetrics, error) {
	m := new(CloudletMetrics)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// CloudletMetricsApiServer is the server API for CloudletMetricsApi service.
type CloudletMetricsApiServer interface {
	// Show Cloudlet metrics
	ShowCloudletMetrics(*CloudletMetrics, CloudletMetricsApi_ShowCloudletMetricsServer) error
}

// UnimplementedCloudletMetricsApiServer can be embedded to have forward compatible implementations.
type UnimplementedCloudletMetricsApiServer struct {
}

func (*UnimplementedCloudletMetricsApiServer) ShowCloudletMetrics(req *CloudletMetrics, srv CloudletMetricsApi_ShowCloudletMetricsServer) error {
	return status.Errorf(codes.Unimplemented, "method ShowCloudletMetrics not implemented")
}

func RegisterCloudletMetricsApiServer(s *grpc.Server, srv CloudletMetricsApiServer) {
	s.RegisterService(&_CloudletMetricsApi_serviceDesc, srv)
}

func _CloudletMetricsApi_ShowCloudletMetrics_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(CloudletMetrics)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CloudletMetricsApiServer).ShowCloudletMetrics(m, &cloudletMetricsApiShowCloudletMetricsServer{stream})
}

type CloudletMetricsApi_ShowCloudletMetricsServer interface {
	Send(*CloudletMetrics) error
	grpc.ServerStream
}

type cloudletMetricsApiShowCloudletMetricsServer struct {
	grpc.ServerStream
}

func (x *cloudletMetricsApiShowCloudletMetricsServer) Send(m *CloudletMetrics) error {
	return x.ServerStream.SendMsg(m)
}

var _CloudletMetricsApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "edgeproto.CloudletMetricsApi",
	HandlerType: (*CloudletMetricsApiServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ShowCloudletMetrics",
			Handler:       _CloudletMetricsApi_ShowCloudletMetrics_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "cloudlet.proto",
}

func (m *OperationTimeLimits) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OperationTimeLimits) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OperationTimeLimits) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DeleteAppInstTimeout != 0 {
		i = encodeVarintCloudlet(dAtA, i, uint64(m.DeleteAppInstTimeout))
		i--
		dAtA[i] = 0x30
	}
	if m.UpdateAppInstTimeout != 0 {
		i = encodeVarintCloudlet(dAtA, i, uint64(m.UpdateAppInstTimeout))
		i--
		dAtA[i] = 0x28
	}
	if m.CreateAppInstTimeout != 0 {
		i = encodeVarintCloudlet(dAtA, i, uint64(m.CreateAppInstTimeout))
		i--
		dAtA[i] = 0x20
	}
	if m.DeleteClusterInstTimeout != 0 {
		i = encodeVarintCloudlet(dAtA, i, uint64(m.DeleteClusterInstTimeout))
		i--
		dAtA[i] = 0x18
	}
	if m.UpdateClusterInstTimeout != 0 {
		i = encodeVarintCloudlet(dAtA, i, uint64(m.UpdateClusterInstTimeout))
		i--
		dAtA[i] = 0x10
	}
	if m.CreateClusterInstTimeout != 0 {
		i = encodeVarintCloudlet(dAtA, i, uint64(m.CreateClusterInstTimeout))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CloudletInternal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloudletInternal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudletInternal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Props) > 0 {
		for k := range m.Props {
			v := m.Props[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintCloudlet(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCloudlet(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCloudlet(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	{
		size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintCloudlet(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Fields) > 0 {
		for iNdEx := len(m.Fields) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Fields[iNdEx])
			copy(dAtA[i:], m.Fields[iNdEx])
			i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Fields[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PlatformConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlatformConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PlatformConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NginxWithCurlImage) > 0 {
		i -= len(m.NginxWithCurlImage)
		copy(dAtA[i:], m.NginxWithCurlImage)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.NginxWithCurlImage)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	if len(m.EnvoyWithCurlImage) > 0 {
		i -= len(m.EnvoyWithCurlImage)
		copy(dAtA[i:], m.EnvoyWithCurlImage)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.EnvoyWithCurlImage)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xea
	}
	if len(m.AnsiblePublicAddr) > 0 {
		i -= len(m.AnsiblePublicAddr)
		copy(dAtA[i:], m.AnsiblePublicAddr)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.AnsiblePublicAddr)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	if len(m.ThanosRecvAddr) > 0 {
		i -= len(m.ThanosRecvAddr)
		copy(dAtA[i:], m.ThanosRecvAddr)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.ThanosRecvAddr)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	if len(m.SecondaryCrmAccessPrivateKey) > 0 {
		i -= len(m.SecondaryCrmAccessPrivateKey)
		copy(dAtA[i:], m.SecondaryCrmAccessPrivateKey)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.SecondaryCrmAccessPrivateKey)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if len(m.CacheDir) > 0 {
		i -= len(m.CacheDir)
		copy(dAtA[i:], m.CacheDir)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.CacheDir)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if len(m.AccessApiAddr) > 0 {
		i -= len(m.AccessApiAddr)
		copy(dAtA[i:], m.AccessApiAddr)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.AccessApiAddr)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if len(m.CrmAccessPrivateKey) > 0 {
		i -= len(m.CrmAccessPrivateKey)
		copy(dAtA[i:], m.CrmAccessPrivateKey)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.CrmAccessPrivateKey)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if len(m.TlsCaFile) > 0 {
		i -= len(m.TlsCaFile)
		copy(dAtA[i:], m.TlsCaFile)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.TlsCaFile)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if len(m.TlsKeyFile) > 0 {
		i -= len(m.TlsKeyFile)
		copy(dAtA[i:], m.TlsKeyFile)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.TlsKeyFile)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if len(m.DeploymentTag) > 0 {
		i -= len(m.DeploymentTag)
		copy(dAtA[i:], m.DeploymentTag)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.DeploymentTag)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if len(m.AppDnsRoot) > 0 {
		i -= len(m.AppDnsRoot)
		copy(dAtA[i:], m.AppDnsRoot)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.AppDnsRoot)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.UseVaultPki {
		i--
		if m.UseVaultPki {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x70
	}
	if m.CommercialCerts {
		i--
		if m.CommercialCerts {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if len(m.Region) > 0 {
		i -= len(m.Region)
		copy(dAtA[i:], m.Region)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Region)))
		i--
		dAtA[i] = 0x62
	}
	if m.CleanupMode {
		i--
		if m.CleanupMode {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if len(m.Span) > 0 {
		i -= len(m.Span)
		copy(dAtA[i:], m.Span)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Span)))
		i--
		dAtA[i] = 0x52
	}
	if m.TestMode {
		i--
		if m.TestMode {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if len(m.PlatformTag) > 0 {
		i -= len(m.PlatformTag)
		copy(dAtA[i:], m.PlatformTag)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.PlatformTag)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.EnvVar) > 0 {
		for k := range m.EnvVar {
			v := m.EnvVar[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintCloudlet(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCloudlet(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCloudlet(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.TlsCertFile) > 0 {
		i -= len(m.TlsCertFile)
		copy(dAtA[i:], m.TlsCertFile)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.TlsCertFile)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.NotifyCtrlAddrs) > 0 {
		i -= len(m.NotifyCtrlAddrs)
		copy(dAtA[i:], m.NotifyCtrlAddrs)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.NotifyCtrlAddrs)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.CloudletVmImagePath) > 0 {
		i -= len(m.CloudletVmImagePath)
		copy(dAtA[i:], m.CloudletVmImagePath)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.CloudletVmImagePath)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContainerRegistryPath) > 0 {
		i -= len(m.ContainerRegistryPath)
		copy(dAtA[i:], m.ContainerRegistryPath)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.ContainerRegistryPath)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FederationConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FederationConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FederationConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FederationName) > 0 {
		i -= len(m.FederationName)
		copy(dAtA[i:], m.FederationName)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.FederationName)))
		i--
		dAtA[i] = 0x22
	}
	if m.FederationDbId != 0 {
		i = encodeVarintCloudlet(dAtA, i, uint64(m.FederationDbId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.PartnerFederationAddr) > 0 {
		i -= len(m.PartnerFederationAddr)
		copy(dAtA[i:], m.PartnerFederationAddr)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.PartnerFederationAddr)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.FederationContextId) > 0 {
		i -= len(m.FederationContextId)
		copy(dAtA[i:], m.FederationContextId)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.FederationContextId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PlatformFeatures) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlatformFeatures) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PlatformFeatures) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DeletePrepare {
		i--
		if m.DeletePrepare {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0x98
	}
	if m.SupportsIpv6 {
		i--
		if m.SupportsIpv6 {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if m.IsMock {
		i--
		if m.IsMock {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if len(m.NodeType) > 0 {
		i -= len(m.NodeType)
		copy(dAtA[i:], m.NodeType)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.NodeType)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if len(m.ResourceQuotaProperties) > 0 {
		for iNdEx := len(m.ResourceQuotaProperties) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ResourceQuotaProperties[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCloudlet(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xc2
		}
	}
	if len(m.Properties) > 0 {
		for k := range m.Properties {
			v := m.Properties[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintCloudlet(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCloudlet(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCloudlet(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xba
		}
	}
	if len(m.AccessVars) > 0 {
		for k := range m.AccessVars {
			v := m.AccessVars[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintCloudlet(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCloudlet(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCloudlet(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xb2
		}
	}
	if m.IsEdgebox {
		i--
		if m.IsEdgebox {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.NoClusterSupport {
		i--
		if m.NoClusterSupport {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.SupportsImageTypeOva {
		i--
		if m.SupportsImageTypeOva {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.IsPrebuiltKubernetesCluster {
		i--
		if m.IsPrebuiltKubernetesCluster {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.NoKubernetesClusterAutoScale {
		i--
		if m.NoKubernetesClusterAutoScale {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.SupportsPlatformHighAvailabilityOnDocker {
		i--
		if m.SupportsPlatformHighAvailabilityOnDocker {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.SupportsPlatformHighAvailabilityOnK8S {
		i--
		if m.SupportsPlatformHighAvailabilityOnK8S {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x78
	}
	if m.SupportsAppInstDedicatedIp {
		i--
		if m.SupportsAppInstDedicatedIp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x70
	}
	if m.IsSingleKubernetesCluster {
		i--
		if m.IsSingleKubernetesCluster {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.SupportsAdditionalNetworks {
		i--
		if m.SupportsAdditionalNetworks {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.IsFake {
		i--
		if m.IsFake {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.IsVmPool {
		i--
		if m.IsVmPool {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.SupportsImageTypeOvf {
		i--
		if m.SupportsImageTypeOvf {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.IpAllocatedPerService {
		i--
		if m.IpAllocatedPerService {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.CloudletServicesLocal {
		i--
		if m.CloudletServicesLocal {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.KubernetesRequiresWorkerNodes {
		i--
		if m.KubernetesRequiresWorkerNodes {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.SupportsKubernetesOnly {
		i--
		if m.SupportsKubernetesOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.SupportsTrustPolicy {
		i--
		if m.SupportsTrustPolicy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.SupportsSharedVolume {
		i--
		if m.SupportsSharedVolume {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.SupportsMultiTenantCluster {
		i--
		if m.SupportsMultiTenantCluster {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.PlatformType) > 0 {
		i -= len(m.PlatformType)
		copy(dAtA[i:], m.PlatformType)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.PlatformType)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CloudletResMap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloudletResMap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudletResMap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Mapping) > 0 {
		for k := range m.Mapping {
			v := m.Mapping[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintCloudlet(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCloudlet(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCloudlet(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintCloudlet(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *InfraConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InfraConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InfraConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FlavorName) > 0 {
		i -= len(m.FlavorName)
		copy(dAtA[i:], m.FlavorName)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.FlavorName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ExternalNetworkName) > 0 {
		i -= len(m.ExternalNetworkName)
		copy(dAtA[i:], m.ExternalNetworkName)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.ExternalNetworkName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResourceQuota) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourceQuota) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResourceQuota) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AlertThreshold != 0 {
		i = encodeVarintCloudlet(dAtA, i, uint64(m.AlertThreshold))
		i--
		dAtA[i] = 0x18
	}
	if m.Value != 0 {
		i = encodeVarintCloudlet(dAtA, i, uint64(m.Value))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GPUDriverKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GPUDriverKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GPUDriverKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Organization) > 0 {
		i -= len(m.Organization)
		copy(dAtA[i:], m.Organization)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Organization)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GPUDriverBuild) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GPUDriverBuild) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GPUDriverBuild) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.StoragePath) > 0 {
		i -= len(m.StoragePath)
		copy(dAtA[i:], m.StoragePath)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.StoragePath)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Md5Sum) > 0 {
		i -= len(m.Md5Sum)
		copy(dAtA[i:], m.Md5Sum)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Md5Sum)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.HypervisorInfo) > 0 {
		i -= len(m.HypervisorInfo)
		copy(dAtA[i:], m.HypervisorInfo)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.HypervisorInfo)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.KernelVersion) > 0 {
		i -= len(m.KernelVersion)
		copy(dAtA[i:], m.KernelVersion)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.KernelVersion)))
		i--
		dAtA[i] = 0x2a
	}
	if m.OperatingSystem != 0 {
		i = encodeVarintCloudlet(dAtA, i, uint64(m.OperatingSystem))
		i--
		dAtA[i] = 0x20
	}
	if len(m.DriverPathCreds) > 0 {
		i -= len(m.DriverPathCreds)
		copy(dAtA[i:], m.DriverPathCreds)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.DriverPathCreds)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DriverPath) > 0 {
		i -= len(m.DriverPath)
		copy(dAtA[i:], m.DriverPath)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.DriverPath)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GPUDriverBuildMember) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GPUDriverBuildMember) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GPUDriverBuildMember) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IgnoreState {
		i--
		if m.IgnoreState {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.Build.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintCloudlet(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintCloudlet(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *GPUDriverBuildURL) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GPUDriverBuildURL) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GPUDriverBuildURL) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Validity != 0 {
		i = encodeVarintCloudlet(dAtA, i, uint64(m.Validity))
		i--
		dAtA[i] = 0x10
	}
	if len(m.BuildUrlPath) > 0 {
		i -= len(m.BuildUrlPath)
		copy(dAtA[i:], m.BuildUrlPath)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.BuildUrlPath)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GPUDriver) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GPUDriver) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GPUDriver) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LicenseConfigStoragePath) > 0 {
		i -= len(m.LicenseConfigStoragePath)
		copy(dAtA[i:], m.LicenseConfigStoragePath)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.LicenseConfigStoragePath)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.StorageBucketName) > 0 {
		i -= len(m.StorageBucketName)
		copy(dAtA[i:], m.StorageBucketName)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.StorageBucketName)))
		i--
		dAtA[i] = 0x52
	}
	if m.DeletePrepare {
		i--
		if m.DeletePrepare {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.IgnoreState {
		i--
		if m.IgnoreState {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.State) > 0 {
		i -= len(m.State)
		copy(dAtA[i:], m.State)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.State)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Properties) > 0 {
		for k := range m.Properties {
			v := m.Properties[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintCloudlet(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCloudlet(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCloudlet(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.LicenseConfigMd5Sum) > 0 {
		i -= len(m.LicenseConfigMd5Sum)
		copy(dAtA[i:], m.LicenseConfigMd5Sum)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.LicenseConfigMd5Sum)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.LicenseConfig) > 0 {
		i -= len(m.LicenseConfig)
		copy(dAtA[i:], m.LicenseConfig)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.LicenseConfig)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Builds) > 0 {
		for iNdEx := len(m.Builds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Builds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCloudlet(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	{
		size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintCloudlet(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Fields) > 0 {
		for iNdEx := len(m.Fields) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Fields[iNdEx])
			copy(dAtA[i:], m.Fields[iNdEx])
			i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Fields[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GPUConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GPUConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GPUConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LicenseConfigMd5Sum) > 0 {
		i -= len(m.LicenseConfigMd5Sum)
		copy(dAtA[i:], m.LicenseConfigMd5Sum)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.LicenseConfigMd5Sum)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.LicenseConfig) > 0 {
		i -= len(m.LicenseConfig)
		copy(dAtA[i:], m.LicenseConfig)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.LicenseConfig)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Properties) > 0 {
		for k := range m.Properties {
			v := m.Properties[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintCloudlet(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCloudlet(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCloudlet(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.Driver.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintCloudlet(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Cloudlet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cloudlet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Cloudlet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OnboardingState != 0 {
		i = encodeVarintCloudlet(dAtA, i, uint64(m.OnboardingState))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xe0
	}
	if m.EdgeboxOnly {
		i--
		if m.EdgeboxOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xd8
	}
	if len(m.InfraFlavors) > 0 {
		for iNdEx := len(m.InfraFlavors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InfraFlavors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCloudlet(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xd2
		}
	}
	if len(m.LicenseConfigStoragePath) > 0 {
		i -= len(m.LicenseConfigStoragePath)
		copy(dAtA[i:], m.LicenseConfigStoragePath)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.LicenseConfigStoragePath)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xca
	}
	{
		size, err := m.FederationConfig.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintCloudlet(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3
	i--
	dAtA[i] = 0xc2
	if len(m.RootLbFqdn) > 0 {
		i -= len(m.RootLbFqdn)
		copy(dAtA[i:], m.RootLbFqdn)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.RootLbFqdn)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xba
	}
	if len(m.DnsLabel) > 0 {
		i -= len(m.DnsLabel)
		copy(dAtA[i:], m.DnsLabel)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.DnsLabel)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xb2
	}
	if len(m.SecondaryNotifySrvAddr) > 0 {
		i -= len(m.SecondaryNotifySrvAddr)
		copy(dAtA[i:], m.SecondaryNotifySrvAddr)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.SecondaryNotifySrvAddr)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xaa
	}
	if m.SecondaryCrmAccessKeyUpgradeRequired {
		i--
		if m.SecondaryCrmAccessKeyUpgradeRequired {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa0
	}
	if len(m.SecondaryCrmAccessPublicKey) > 0 {
		i -= len(m.SecondaryCrmAccessPublicKey)
		copy(dAtA[i:], m.SecondaryCrmAccessPublicKey)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.SecondaryCrmAccessPublicKey)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x9a
	}
	if m.PlatformHighAvailability {
		i--
		if m.PlatformHighAvailability {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x90
	}
	if m.DeletePrepare {
		i--
		if m.DeletePrepare {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x88
	}
	if len(m.SingleKubernetesClusterOwner) > 0 {
		i -= len(m.SingleKubernetesClusterOwner)
		copy(dAtA[i:], m.SingleKubernetesClusterOwner)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.SingleKubernetesClusterOwner)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x82
	}
	if len(m.AllianceOrgs) > 0 {
		for iNdEx := len(m.AllianceOrgs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AllianceOrgs[iNdEx])
			copy(dAtA[i:], m.AllianceOrgs[iNdEx])
			i = encodeVarintCloudlet(dAtA, i, uint64(len(m.AllianceOrgs[iNdEx])))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xfa
		}
	}
	if m.EnableDefaultServerlessCluster {
		i--
		if m.EnableDefaultServerlessCluster {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf0
	}
	{
		size, err := m.GpuConfig.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintCloudlet(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0xea
	if len(m.KafkaPassword) > 0 {
		i -= len(m.KafkaPassword)
		copy(dAtA[i:], m.KafkaPassword)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.KafkaPassword)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe2
	}
	if len(m.KafkaUser) > 0 {
		i -= len(m.KafkaUser)
		copy(dAtA[i:], m.KafkaUser)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.KafkaUser)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xda
	}
	if len(m.KafkaCluster) > 0 {
		i -= len(m.KafkaCluster)
		copy(dAtA[i:], m.KafkaCluster)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.KafkaCluster)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd2
	}
	if len(m.HostController) > 0 {
		i -= len(m.HostController)
		copy(dAtA[i:], m.HostController)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.HostController)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xca
	}
	if m.DefaultResourceAlertThreshold != 0 {
		i = encodeVarintCloudlet(dAtA, i, uint64(m.DefaultResourceAlertThreshold))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc0
	}
	if len(m.ResourceQuotas) > 0 {
		for iNdEx := len(m.ResourceQuotas) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ResourceQuotas[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCloudlet(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xba
		}
	}
	if m.TrustPolicyState != 0 {
		i = encodeVarintCloudlet(dAtA, i, uint64(m.TrustPolicyState))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb0
	}
	if len(m.TrustPolicy) > 0 {
		i -= len(m.TrustPolicy)
		copy(dAtA[i:], m.TrustPolicy)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.TrustPolicy)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xaa
	}
	{
		size, err := m.UpdatedAt.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintCloudlet(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0xa2
	{
		size, err := m.CreatedAt.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintCloudlet(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0x9a
	if m.CrmAccessKeyUpgradeRequired {
		i--
		if m.CrmAccessKeyUpgradeRequired {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x90
	}
	if len(m.CrmAccessPublicKey) > 0 {
		i -= len(m.CrmAccessPublicKey)
		copy(dAtA[i:], m.CrmAccessPublicKey)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.CrmAccessPublicKey)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x8a
	}
	if len(m.VmPool) > 0 {
		i -= len(m.VmPool)
		copy(dAtA[i:], m.VmPool)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.VmPool)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
	}
	if m.OverridePolicyContainerVersion {
		i--
		if m.OverridePolicyContainerVersion {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if m.MaintenanceState != 0 {
		i = encodeVarintCloudlet(dAtA, i, uint64(m.MaintenanceState))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	{
		size, err := m.InfraConfig.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintCloudlet(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xe2
	if m.InfraApiAccess != 0 {
		i = encodeVarintCloudlet(dAtA, i, uint64(m.InfraApiAccess))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if len(m.Deployment) > 0 {
		i -= len(m.Deployment)
		copy(dAtA[i:], m.Deployment)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Deployment)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	if len(m.VmImageVersion) > 0 {
		i -= len(m.VmImageVersion)
		copy(dAtA[i:], m.VmImageVersion)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.VmImageVersion)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if len(m.AccessVars) > 0 {
		for k := range m.AccessVars {
			v := m.AccessVars[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintCloudlet(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCloudlet(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCloudlet(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xba
		}
	}
	if len(m.ResTagMap) > 0 {
		for k := range m.ResTagMap {
			v := m.ResTagMap[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintCloudlet(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCloudlet(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCloudlet(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xb2
		}
	}
	{
		size, err := m.Config.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintCloudlet(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xaa
	if len(m.ContainerVersion) > 0 {
		i -= len(m.ContainerVersion)
		copy(dAtA[i:], m.ContainerVersion)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.ContainerVersion)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if len(m.EnvVar) > 0 {
		for k := range m.EnvVar {
			v := m.EnvVar[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintCloudlet(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCloudlet(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCloudlet(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x9a
		}
	}
	if len(m.PhysicalName) > 0 {
		i -= len(m.PhysicalName)
		copy(dAtA[i:], m.PhysicalName)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.PhysicalName)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	{
		size, err := m.Flavor.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintCloudlet(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x8a
	if len(m.NotifySrvAddr) > 0 {
		i -= len(m.NotifySrvAddr)
		copy(dAtA[i:], m.NotifySrvAddr)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.NotifySrvAddr)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.PlatformType) > 0 {
		i -= len(m.PlatformType)
		copy(dAtA[i:], m.PlatformType)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.PlatformType)))
		i--
		dAtA[i] = 0x7a
	}
	if m.DeploymentLocal {
		i--
		if m.DeploymentLocal {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x70
	}
	if m.CrmOverride != 0 {
		i = encodeVarintCloudlet(dAtA, i, uint64(m.CrmOverride))
		i--
		dAtA[i] = 0x68
	}
	if m.State != 0 {
		i = encodeVarintCloudlet(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x60
	}
	if len(m.Errors) > 0 {
		for iNdEx := len(m.Errors) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Errors[iNdEx])
			copy(dAtA[i:], m.Errors[iNdEx])
			i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Errors[iNdEx])))
			i--
			dAtA[i] = 0x52
		}
	}
	{
		size, err := m.TimeLimits.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintCloudlet(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	if m.NumDynamicIps != 0 {
		i = encodeVarintCloudlet(dAtA, i, uint64(m.NumDynamicIps))
		i--
		dAtA[i] = 0x40
	}
	if len(m.StaticIps) > 0 {
		i -= len(m.StaticIps)
		copy(dAtA[i:], m.StaticIps)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.StaticIps)))
		i--
		dAtA[i] = 0x3a
	}
	if m.IpSupport != 0 {
		i = encodeVarintCloudlet(dAtA, i, uint64(m.IpSupport))
		i--
		dAtA[i] = 0x30
	}
	{
		size, err := m.Location.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintCloudlet(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintCloudlet(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Fields) > 0 {
		for iNdEx := len(m.Fields) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Fields[iNdEx])
			copy(dAtA[i:], m.Fields[iNdEx])
			i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Fields[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *FlavorMatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlavorMatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FlavorMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AvailabilityZone) > 0 {
		i -= len(m.AvailabilityZone)
		copy(dAtA[i:], m.AvailabilityZone)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.AvailabilityZone)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.FlavorName) > 0 {
		i -= len(m.FlavorName)
		copy(dAtA[i:], m.FlavorName)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.FlavorName)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintCloudlet(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *CloudletManifest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloudletManifest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudletManifest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Manifest) > 0 {
		i -= len(m.Manifest)
		copy(dAtA[i:], m.Manifest)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Manifest)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *PropertyInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PropertyInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PropertyInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TotpSecret {
		i--
		if m.TotpSecret {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.Internal {
		i--
		if m.Internal {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.Mandatory {
		i--
		if m.Mandatory {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Secret {
		i--
		if m.Secret {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CloudletProps) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloudletProps) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudletProps) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Organization) > 0 {
		i -= len(m.Organization)
		copy(dAtA[i:], m.Organization)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Organization)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Properties) > 0 {
		for k := range m.Properties {
			v := m.Properties[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintCloudlet(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCloudlet(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCloudlet(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.PlatformType) > 0 {
		i -= len(m.PlatformType)
		copy(dAtA[i:], m.PlatformType)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.PlatformType)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CloudletResourceQuotaProps) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloudletResourceQuotaProps) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudletResourceQuotaProps) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Organization) > 0 {
		i -= len(m.Organization)
		copy(dAtA[i:], m.Organization)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Organization)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Properties) > 0 {
		for iNdEx := len(m.Properties) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Properties[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCloudlet(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.PlatformType) > 0 {
		i -= len(m.PlatformType)
		copy(dAtA[i:], m.PlatformType)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.PlatformType)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CloudletResourceUsage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloudletResourceUsage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudletResourceUsage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Info) > 0 {
		for iNdEx := len(m.Info) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Info[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCloudlet(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.InfraUsage {
		i--
		if m.InfraUsage {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintCloudlet(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *CloudletAllianceOrg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloudletAllianceOrg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudletAllianceOrg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Organization) > 0 {
		i -= len(m.Organization)
		copy(dAtA[i:], m.Organization)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Organization)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintCloudlet(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *FlavorInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlavorInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FlavorInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PropMap) > 0 {
		for k := range m.PropMap {
			v := m.PropMap[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintCloudlet(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCloudlet(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCloudlet(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Disk != 0 {
		i = encodeVarintCloudlet(dAtA, i, uint64(m.Disk))
		i--
		dAtA[i] = 0x20
	}
	if m.Ram != 0 {
		i = encodeVarintCloudlet(dAtA, i, uint64(m.Ram))
		i--
		dAtA[i] = 0x18
	}
	if m.Vcpus != 0 {
		i = encodeVarintCloudlet(dAtA, i, uint64(m.Vcpus))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OSAZone) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OSAZone) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OSAZone) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OSImage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OSImage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OSImage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DiskFormat) > 0 {
		i -= len(m.DiskFormat)
		copy(dAtA[i:], m.DiskFormat)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.DiskFormat)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Properties) > 0 {
		i -= len(m.Properties)
		copy(dAtA[i:], m.Properties)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Properties)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Tags) > 0 {
		i -= len(m.Tags)
		copy(dAtA[i:], m.Tags)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Tags)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CloudletOnboardingInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloudletOnboardingInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudletOnboardingInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Errors) > 0 {
		for iNdEx := len(m.Errors) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Errors[iNdEx])
			copy(dAtA[i:], m.Errors[iNdEx])
			i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Errors[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	{
		size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintCloudlet(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.OnboardingState != 0 {
		i = encodeVarintCloudlet(dAtA, i, uint64(m.OnboardingState))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintCloudlet(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *CloudletInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloudletInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudletInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ReleaseVersion) > 0 {
		i -= len(m.ReleaseVersion)
		copy(dAtA[i:], m.ReleaseVersion)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.ReleaseVersion)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.StandbyCrm {
		i--
		if m.StandbyCrm {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if len(m.ActiveCrmInstance) > 0 {
		i -= len(m.ActiveCrmInstance)
		copy(dAtA[i:], m.ActiveCrmInstance)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.ActiveCrmInstance)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if len(m.NodeInfos) > 0 {
		for iNdEx := len(m.NodeInfos) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NodeInfos[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCloudlet(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xaa
		}
	}
	if len(m.Properties) > 0 {
		for k := range m.Properties {
			v := m.Properties[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintCloudlet(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCloudlet(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCloudlet(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xa2
		}
	}
	if m.CompatibilityVersion != 0 {
		i = encodeVarintCloudlet(dAtA, i, uint64(m.CompatibilityVersion))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.TrustPolicyState != 0 {
		i = encodeVarintCloudlet(dAtA, i, uint64(m.TrustPolicyState))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	{
		size, err := m.ResourcesSnapshot.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintCloudlet(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x8a
	if m.MaintenanceState != 0 {
		i = encodeVarintCloudlet(dAtA, i, uint64(m.MaintenanceState))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.ControllerCacheReceived {
		i--
		if m.ControllerCacheReceived {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x78
	}
	if len(m.OsImages) > 0 {
		for iNdEx := len(m.OsImages) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OsImages[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCloudlet(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x72
		}
	}
	if len(m.AvailabilityZones) > 0 {
		for iNdEx := len(m.AvailabilityZones) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AvailabilityZones[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCloudlet(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6a
		}
	}
	if len(m.ContainerVersion) > 0 {
		i -= len(m.ContainerVersion)
		copy(dAtA[i:], m.ContainerVersion)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.ContainerVersion)))
		i--
		dAtA[i] = 0x62
	}
	{
		size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintCloudlet(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x5a
	if len(m.Flavors) > 0 {
		for iNdEx := len(m.Flavors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Flavors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCloudlet(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.Errors) > 0 {
		for iNdEx := len(m.Errors) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Errors[iNdEx])
			copy(dAtA[i:], m.Errors[iNdEx])
			i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Errors[iNdEx])))
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.OsMaxVolGb != 0 {
		i = encodeVarintCloudlet(dAtA, i, uint64(m.OsMaxVolGb))
		i--
		dAtA[i] = 0x40
	}
	if m.OsMaxVcores != 0 {
		i = encodeVarintCloudlet(dAtA, i, uint64(m.OsMaxVcores))
		i--
		dAtA[i] = 0x38
	}
	if m.OsMaxRam != 0 {
		i = encodeVarintCloudlet(dAtA, i, uint64(m.OsMaxRam))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Controller) > 0 {
		i -= len(m.Controller)
		copy(dAtA[i:], m.Controller)
		i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Controller)))
		i--
		dAtA[i] = 0x2a
	}
	if m.NotifyId != 0 {
		i = encodeVarintCloudlet(dAtA, i, uint64(m.NotifyId))
		i--
		dAtA[i] = 0x20
	}
	if m.State != 0 {
		i = encodeVarintCloudlet(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintCloudlet(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Fields) > 0 {
		for iNdEx := len(m.Fields) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Fields[iNdEx])
			copy(dAtA[i:], m.Fields[iNdEx])
			i = encodeVarintCloudlet(dAtA, i, uint64(len(m.Fields[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CloudletMetrics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloudletMetrics) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudletMetrics) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Foo != 0 {
		i = encodeVarintCloudlet(dAtA, i, uint64(m.Foo))
		i--
		dAtA[i] = 0x28
	}
	return len(dAtA) - i, nil
}

func encodeVarintCloudlet(dAtA []byte, offset int, v uint64) int {
	offset -= sovCloudlet(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *OperationTimeLimits) Clone() *OperationTimeLimits {
	cp := &OperationTimeLimits{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *OperationTimeLimits) CopyInFields(src *OperationTimeLimits) int {
	changed := 0
	if m.CreateClusterInstTimeout != src.CreateClusterInstTimeout {
		m.CreateClusterInstTimeout = src.CreateClusterInstTimeout
		changed++
	}
	if m.UpdateClusterInstTimeout != src.UpdateClusterInstTimeout {
		m.UpdateClusterInstTimeout = src.UpdateClusterInstTimeout
		changed++
	}
	if m.DeleteClusterInstTimeout != src.DeleteClusterInstTimeout {
		m.DeleteClusterInstTimeout = src.DeleteClusterInstTimeout
		changed++
	}
	if m.CreateAppInstTimeout != src.CreateAppInstTimeout {
		m.CreateAppInstTimeout = src.CreateAppInstTimeout
		changed++
	}
	if m.UpdateAppInstTimeout != src.UpdateAppInstTimeout {
		m.UpdateAppInstTimeout = src.UpdateAppInstTimeout
		changed++
	}
	if m.DeleteAppInstTimeout != src.DeleteAppInstTimeout {
		m.DeleteAppInstTimeout = src.DeleteAppInstTimeout
		changed++
	}
	return changed
}

func (m *OperationTimeLimits) DeepCopyIn(src *OperationTimeLimits) {
	m.CreateClusterInstTimeout = src.CreateClusterInstTimeout
	m.UpdateClusterInstTimeout = src.UpdateClusterInstTimeout
	m.DeleteClusterInstTimeout = src.DeleteClusterInstTimeout
	m.CreateAppInstTimeout = src.CreateAppInstTimeout
	m.UpdateAppInstTimeout = src.UpdateAppInstTimeout
	m.DeleteAppInstTimeout = src.DeleteAppInstTimeout
}

// Helper method to check that enums have valid values
func (m *OperationTimeLimits) ValidateEnums() error {
	return nil
}

func (s *OperationTimeLimits) ClearTagged(tags map[string]struct{}) {
}

func (m *CloudletInternal) Matches(o *CloudletInternal, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !m.Key.Matches(&o.Key, fopts...) {
		return false
	}
	if !opts.Filter || o.Props != nil {
		if len(m.Props) == 0 && len(o.Props) > 0 || len(m.Props) > 0 && len(o.Props) == 0 {
			return false
		} else if m.Props != nil && o.Props != nil {
			if !opts.Filter && len(m.Props) != len(o.Props) {
				return false
			}
			for k, _ := range o.Props {
				_, ok := m.Props[k]
				if !ok {
					return false
				}
				if o.Props[k] != m.Props[k] {
					return false
				}
			}
		}
	}
	return true
}

const CloudletInternalFieldKey = "2"
const CloudletInternalFieldKeyOrganization = "2.1"
const CloudletInternalFieldKeyName = "2.2"
const CloudletInternalFieldKeyFederatedOrganization = "2.3"
const CloudletInternalFieldProps = "3"
const CloudletInternalFieldPropsKey = "3.1"
const CloudletInternalFieldPropsValue = "3.2"

var CloudletInternalAllFields = []string{
	CloudletInternalFieldKeyOrganization,
	CloudletInternalFieldKeyName,
	CloudletInternalFieldKeyFederatedOrganization,
	CloudletInternalFieldPropsKey,
	CloudletInternalFieldPropsValue,
}

var CloudletInternalAllFieldsMap = map[string]struct{}{
	CloudletInternalFieldKeyOrganization:          struct{}{},
	CloudletInternalFieldKeyName:                  struct{}{},
	CloudletInternalFieldKeyFederatedOrganization: struct{}{},
	CloudletInternalFieldPropsKey:                 struct{}{},
	CloudletInternalFieldPropsValue:               struct{}{},
}

var CloudletInternalAllFieldsStringMap = map[string]string{
	CloudletInternalFieldKeyOrganization:          "Key Organization",
	CloudletInternalFieldKeyName:                  "Key Name",
	CloudletInternalFieldKeyFederatedOrganization: "Key Federated Organization",
	CloudletInternalFieldPropsKey:                 "Props Key",
	CloudletInternalFieldPropsValue:               "Props Value",
}

func (m *CloudletInternal) IsKeyField(s string) bool {
	return strings.HasPrefix(s, CloudletInternalFieldKey+".") || s == CloudletInternalFieldKey
}

func (m *CloudletInternal) DiffFields(o *CloudletInternal, fields map[string]struct{}) {
	if m.Key.Organization != o.Key.Organization {
		fields[CloudletInternalFieldKeyOrganization] = struct{}{}
		fields[CloudletInternalFieldKey] = struct{}{}
	}
	if m.Key.Name != o.Key.Name {
		fields[CloudletInternalFieldKeyName] = struct{}{}
		fields[CloudletInternalFieldKey] = struct{}{}
	}
	if m.Key.FederatedOrganization != o.Key.FederatedOrganization {
		fields[CloudletInternalFieldKeyFederatedOrganization] = struct{}{}
		fields[CloudletInternalFieldKey] = struct{}{}
	}
	if m.Props != nil && o.Props != nil {
		if len(m.Props) != len(o.Props) {
			fields[CloudletInternalFieldProps] = struct{}{}
		} else {
			for k0, _ := range m.Props {
				_, vok0 := o.Props[k0]
				if !vok0 {
					fields[CloudletInternalFieldProps] = struct{}{}
				} else {
					if m.Props[k0] != o.Props[k0] {
						fields[CloudletInternalFieldProps] = struct{}{}
						break
					}
				}
			}
		}
	} else if (m.Props != nil && o.Props == nil) || (m.Props == nil && o.Props != nil) {
		fields[CloudletInternalFieldProps] = struct{}{}
	}
}

func (m *CloudletInternal) Clone() *CloudletInternal {
	cp := &CloudletInternal{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *CloudletInternal) CopyInFields(src *CloudletInternal) int {
	updateListAction := "replace"
	changed := 0
	fmap := MakeFieldMap(src.Fields)
	if _, set := fmap["2"]; set {
		if _, set := fmap["2.1"]; set {
			if m.Key.Organization != src.Key.Organization {
				m.Key.Organization = src.Key.Organization
				changed++
			}
		}
		if _, set := fmap["2.2"]; set {
			if m.Key.Name != src.Key.Name {
				m.Key.Name = src.Key.Name
				changed++
			}
		}
		if _, set := fmap["2.3"]; set {
			if m.Key.FederatedOrganization != src.Key.FederatedOrganization {
				m.Key.FederatedOrganization = src.Key.FederatedOrganization
				changed++
			}
		}
	}
	if _, set := fmap["3"]; set {
		if src.Props != nil {
			if updateListAction == "add" {
				for k0, v := range src.Props {
					m.Props[k0] = v
					changed++
				}
			} else if updateListAction == "remove" {
				for k0, _ := range src.Props {
					if _, ok := m.Props[k0]; ok {
						delete(m.Props, k0)
						changed++
					}
				}
			} else {
				m.Props = make(map[string]string)
				for k0, v := range src.Props {
					m.Props[k0] = v
				}
				changed++
			}
		} else if m.Props != nil {
			m.Props = nil
			changed++
		}
	}
	return changed
}

func (m *CloudletInternal) DeepCopyIn(src *CloudletInternal) {
	m.Key.DeepCopyIn(&src.Key)
	if src.Props != nil {
		m.Props = make(map[string]string)
		for k, v := range src.Props {
			m.Props[k] = v
		}
	} else {
		m.Props = nil
	}
}

func (s *CloudletInternal) HasFields() bool {
	return true
}

type CloudletInternalStore interface {
	Create(ctx context.Context, m *CloudletInternal, wait func(int64)) (*Result, error)
	Update(ctx context.Context, m *CloudletInternal, wait func(int64)) (*Result, error)
	Delete(ctx context.Context, m *CloudletInternal, wait func(int64)) (*Result, error)
	Put(ctx context.Context, m *CloudletInternal, wait func(int64), ops ...objstore.KVOp) (*Result, error)
	LoadOne(key string) (*CloudletInternal, int64, error)
	Get(ctx context.Context, key *CloudletKey, buf *CloudletInternal) bool
	STMGet(stm concurrency.STM, key *CloudletKey, buf *CloudletInternal) bool
	STMPut(stm concurrency.STM, obj *CloudletInternal, ops ...objstore.KVOp)
	STMDel(stm concurrency.STM, key *CloudletKey)
	STMHas(stm concurrency.STM, key *CloudletKey) bool
}

type CloudletInternalStoreImpl struct {
	kvstore objstore.KVStore
}

func NewCloudletInternalStore(kvstore objstore.KVStore) *CloudletInternalStoreImpl {
	return &CloudletInternalStoreImpl{kvstore: kvstore}
}

func (s *CloudletInternalStoreImpl) Create(ctx context.Context, m *CloudletInternal, wait func(int64)) (*Result, error) {
	err := m.Validate(CloudletInternalAllFieldsMap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("CloudletInternal", m.GetKey())
	val, err := json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Create(ctx, key, string(val))
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *CloudletInternalStoreImpl) Update(ctx context.Context, m *CloudletInternal, wait func(int64)) (*Result, error) {
	fmap := MakeFieldMap(m.Fields)
	err := m.Validate(fmap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("CloudletInternal", m.GetKey())
	var vers int64 = 0
	curBytes, vers, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, err
	}
	var cur CloudletInternal
	err = json.Unmarshal(curBytes, &cur)
	if err != nil {
		return nil, err
	}
	cur.CopyInFields(m)
	// never save fields
	cur.Fields = nil
	val, err := json.Marshal(cur)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Update(ctx, key, string(val), vers)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *CloudletInternalStoreImpl) Put(ctx context.Context, m *CloudletInternal, wait func(int64), ops ...objstore.KVOp) (*Result, error) {
	err := m.Validate(CloudletInternalAllFieldsMap)
	m.Fields = nil
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("CloudletInternal", m.GetKey())
	var val []byte
	val, err = json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Put(ctx, key, string(val), ops...)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *CloudletInternalStoreImpl) Delete(ctx context.Context, m *CloudletInternal, wait func(int64)) (*Result, error) {
	err := m.GetKey().ValidateKey()
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("CloudletInternal", m.GetKey())
	rev, err := s.kvstore.Delete(ctx, key)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *CloudletInternalStoreImpl) LoadOne(key string) (*CloudletInternal, int64, error) {
	val, rev, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, 0, err
	}
	var obj CloudletInternal
	err = json.Unmarshal(val, &obj)
	if err != nil {
		log.DebugLog(log.DebugLevelApi, "Failed to parse CloudletInternal data", "val", string(val), "err", err)
		return nil, 0, err
	}
	return &obj, rev, nil
}

func (s *CloudletInternalStoreImpl) Get(ctx context.Context, key *CloudletKey, buf *CloudletInternal) bool {
	keystr := objstore.DbKeyString("CloudletInternal", key)
	val, _, _, err := s.kvstore.Get(keystr)
	if err != nil {
		return false
	}
	return s.parseGetData(val, buf)
}

func (s *CloudletInternalStoreImpl) STMGet(stm concurrency.STM, key *CloudletKey, buf *CloudletInternal) bool {
	keystr := objstore.DbKeyString("CloudletInternal", key)
	valstr := stm.Get(keystr)
	return s.parseGetData([]byte(valstr), buf)
}

func (s *CloudletInternalStoreImpl) STMHas(stm concurrency.STM, key *CloudletKey) bool {
	keystr := objstore.DbKeyString("CloudletInternal", key)
	return stm.Get(keystr) != ""
}

func (s *CloudletInternalStoreImpl) parseGetData(val []byte, buf *CloudletInternal) bool {
	if len(val) == 0 {
		return false
	}
	if buf != nil {
		// clear buf, because empty values in val won't
		// overwrite non-empty values in buf.
		*buf = CloudletInternal{}
		err := json.Unmarshal(val, buf)
		if err != nil {
			return false
		}
	}
	return true
}

func (s *CloudletInternalStoreImpl) STMPut(stm concurrency.STM, obj *CloudletInternal, ops ...objstore.KVOp) {
	keystr := objstore.DbKeyString("CloudletInternal", obj.GetKey())

	val, err := json.Marshal(obj)
	if err != nil {
		log.InfoLog("CloudletInternal json marshal failed", "obj", obj, "err", err)
	}
	v3opts := GetSTMOpts(ops...)
	stm.Put(keystr, string(val), v3opts...)
}

func (s *CloudletInternalStoreImpl) STMDel(stm concurrency.STM, key *CloudletKey) {
	keystr := objstore.DbKeyString("CloudletInternal", key)
	stm.Del(keystr)
}

type CloudletInternalKeyWatcher struct {
	cb func(ctx context.Context)
}

type CloudletInternalCacheData struct {
	Obj    *CloudletInternal
	ModRev int64
}

func (s *CloudletInternalCacheData) Clone() *CloudletInternalCacheData {
	cp := CloudletInternalCacheData{}
	if s.Obj != nil {
		cp.Obj = &CloudletInternal{}
		cp.Obj.DeepCopyIn(s.Obj)
	}
	cp.ModRev = s.ModRev
	return &cp
}

// CloudletInternalCache caches CloudletInternal objects in memory in a hash table
// and keeps them in sync with the database.
type CloudletInternalCache struct {
	Objs          map[CloudletKey]*CloudletInternalCacheData
	Mux           util.Mutex
	List          map[CloudletKey]struct{}
	FlushAll      bool
	NotifyCbs     []func(ctx context.Context, obj *CloudletInternal, modRev int64)
	UpdatedCbs    []func(ctx context.Context, old *CloudletInternal, new *CloudletInternal)
	DeletedCbs    []func(ctx context.Context, old *CloudletInternal)
	KeyWatchers   map[CloudletKey][]*CloudletInternalKeyWatcher
	UpdatedKeyCbs []func(ctx context.Context, key *CloudletKey)
	DeletedKeyCbs []func(ctx context.Context, key *CloudletKey)
}

func NewCloudletInternalCache() *CloudletInternalCache {
	cache := CloudletInternalCache{}
	InitCloudletInternalCache(&cache)
	return &cache
}

func InitCloudletInternalCache(cache *CloudletInternalCache) {
	cache.Objs = make(map[CloudletKey]*CloudletInternalCacheData)
	cache.KeyWatchers = make(map[CloudletKey][]*CloudletInternalKeyWatcher)
	cache.NotifyCbs = nil
	cache.UpdatedCbs = nil
	cache.DeletedCbs = nil
	cache.UpdatedKeyCbs = nil
	cache.DeletedKeyCbs = nil
}

func (c *CloudletInternalCache) GetTypeString() string {
	return "CloudletInternal"
}

func (c *CloudletInternalCache) Get(key *CloudletKey, valbuf *CloudletInternal) bool {
	var modRev int64
	return c.GetWithRev(key, valbuf, &modRev)
}

func (c *CloudletInternalCache) GetWithRev(key *CloudletKey, valbuf *CloudletInternal, modRev *int64) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	inst, found := c.Objs[*key]
	if found {
		valbuf.DeepCopyIn(inst.Obj)
		*modRev = inst.ModRev
	}
	return found
}

func (c *CloudletInternalCache) HasKey(key *CloudletKey) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	_, found := c.Objs[*key]
	return found
}

func (c *CloudletInternalCache) GetAllKeys(ctx context.Context, cb func(key *CloudletKey, modRev int64)) {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for key, data := range c.Objs {
		cb(&key, data.ModRev)
	}
}

func (c *CloudletInternalCache) GetAllLocked(ctx context.Context, cb func(obj *CloudletInternal, modRev int64)) {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for _, data := range c.Objs {
		cb(data.Obj, data.ModRev)
	}
}

func (c *CloudletInternalCache) Update(ctx context.Context, in *CloudletInternal, modRev int64) {
	c.UpdateModFunc(ctx, in.GetKey(), modRev, func(old *CloudletInternal) (*CloudletInternal, bool) {
		return in, true
	})
}

func (c *CloudletInternalCache) UpdateModFunc(ctx context.Context, key *CloudletKey, modRev int64, modFunc func(old *CloudletInternal) (new *CloudletInternal, changed bool)) {
	c.Mux.Lock()
	var old *CloudletInternal
	if oldData, found := c.Objs[*key]; found {
		old = oldData.Obj
	}
	new, changed := modFunc(old)
	if !changed {
		c.Mux.Unlock()
		return
	}
	if len(c.UpdatedCbs) > 0 || len(c.NotifyCbs) > 0 {
		newCopy := &CloudletInternal{}
		newCopy.DeepCopyIn(new)
		for _, cb := range c.UpdatedCbs {
			defer cb(ctx, old, newCopy)
		}
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				defer cb(ctx, newCopy, modRev)
			}
		}
	}
	for _, cb := range c.UpdatedKeyCbs {
		defer cb(ctx, key)
	}
	store := &CloudletInternal{}
	store.DeepCopyIn(new)
	c.Objs[new.GetKeyVal()] = &CloudletInternalCacheData{
		Obj:    store,
		ModRev: modRev,
	}
	log.SpanLog(ctx, log.DebugLevelApi, "cache update", "new", store)
	c.Mux.Unlock()
	c.TriggerKeyWatchers(ctx, new.GetKey())
}

func (c *CloudletInternalCache) Delete(ctx context.Context, in *CloudletInternal, modRev int64) {
	c.DeleteCondFunc(ctx, in, modRev, func(old *CloudletInternal) bool {
		return true
	})
}

func (c *CloudletInternalCache) DeleteCondFunc(ctx context.Context, in *CloudletInternal, modRev int64, condFunc func(old *CloudletInternal) bool) {
	c.Mux.Lock()
	var old *CloudletInternal
	oldData, found := c.Objs[in.GetKeyVal()]
	if found {
		old = oldData.Obj
		if !condFunc(old) {
			c.Mux.Unlock()
			return
		}
	}
	delete(c.Objs, in.GetKeyVal())
	log.SpanLog(ctx, log.DebugLevelApi, "cache delete", "key", in.GetKeyVal())
	c.Mux.Unlock()
	obj := old
	if obj == nil {
		obj = in
	}
	for _, cb := range c.NotifyCbs {
		if cb != nil {
			cb(ctx, obj, modRev)
		}
	}
	if old != nil {
		for _, cb := range c.DeletedCbs {
			cb(ctx, old)
		}
	}
	for _, cb := range c.DeletedKeyCbs {
		cb(ctx, in.GetKey())
	}
	c.TriggerKeyWatchers(ctx, in.GetKey())
}

func (c *CloudletInternalCache) Prune(ctx context.Context, validKeys map[CloudletKey]struct{}) {
	log.SpanLog(ctx, log.DebugLevelApi, "Prune CloudletInternal", "numValidKeys", len(validKeys))
	notify := make(map[CloudletKey]*CloudletInternalCacheData)
	c.Mux.Lock()
	for key, _ := range c.Objs {
		if _, ok := validKeys[key]; !ok {
			if len(c.NotifyCbs) > 0 || len(c.DeletedKeyCbs) > 0 || len(c.DeletedCbs) > 0 {
				notify[key] = c.Objs[key]
			}
			delete(c.Objs, key)
		}
	}
	c.Mux.Unlock()
	for key, old := range notify {
		obj := old.Obj
		if obj == nil {
			obj = &CloudletInternal{}
			obj.SetKey(&key)
		}
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, obj, old.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if old.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, old.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (c *CloudletInternalCache) GetCount() int {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	return len(c.Objs)
}

func (c *CloudletInternalCache) Flush(ctx context.Context, notifyId int64) {
}

func (c *CloudletInternalCache) Show(filter *CloudletInternal, cb func(ret *CloudletInternal) error) error {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for _, data := range c.Objs {
		if !data.Obj.Matches(filter, MatchFilter()) {
			continue
		}
		err := cb(data.Obj)
		if err != nil {
			return err
		}
	}
	return nil
}

func CloudletInternalGenericNotifyCb(fn func(key *CloudletKey, old *CloudletInternal)) func(objstore.ObjKey, objstore.Obj) {
	return func(objkey objstore.ObjKey, obj objstore.Obj) {
		fn(objkey.(*CloudletKey), obj.(*CloudletInternal))
	}
}

func (c *CloudletInternalCache) SetNotifyCb(fn func(ctx context.Context, obj *CloudletInternal, modRev int64)) {
	c.NotifyCbs = []func(ctx context.Context, obj *CloudletInternal, modRev int64){fn}
}

func (c *CloudletInternalCache) SetUpdatedCb(fn func(ctx context.Context, old *CloudletInternal, new *CloudletInternal)) {
	c.UpdatedCbs = []func(ctx context.Context, old *CloudletInternal, new *CloudletInternal){fn}
}

func (c *CloudletInternalCache) SetDeletedCb(fn func(ctx context.Context, old *CloudletInternal)) {
	c.DeletedCbs = []func(ctx context.Context, old *CloudletInternal){fn}
}

func (c *CloudletInternalCache) SetUpdatedKeyCb(fn func(ctx context.Context, key *CloudletKey)) {
	c.UpdatedKeyCbs = []func(ctx context.Context, key *CloudletKey){fn}
}

func (c *CloudletInternalCache) SetDeletedKeyCb(fn func(ctx context.Context, key *CloudletKey)) {
	c.DeletedKeyCbs = []func(ctx context.Context, key *CloudletKey){fn}
}

func (c *CloudletInternalCache) AddUpdatedCb(fn func(ctx context.Context, old *CloudletInternal, new *CloudletInternal)) {
	c.UpdatedCbs = append(c.UpdatedCbs, fn)
}

func (c *CloudletInternalCache) AddDeletedCb(fn func(ctx context.Context, old *CloudletInternal)) {
	c.DeletedCbs = append(c.DeletedCbs, fn)
}

func (c *CloudletInternalCache) AddNotifyCb(fn func(ctx context.Context, obj *CloudletInternal, modRev int64)) {
	c.NotifyCbs = append(c.NotifyCbs, fn)
}

func (c *CloudletInternalCache) AddUpdatedKeyCb(fn func(ctx context.Context, key *CloudletKey)) {
	c.UpdatedKeyCbs = append(c.UpdatedKeyCbs, fn)
}

func (c *CloudletInternalCache) AddDeletedKeyCb(fn func(ctx context.Context, key *CloudletKey)) {
	c.DeletedKeyCbs = append(c.DeletedKeyCbs, fn)
}

func (c *CloudletInternalCache) SetFlushAll() {
	c.FlushAll = true
}

func (c *CloudletInternalCache) WatchKey(key *CloudletKey, cb func(ctx context.Context)) context.CancelFunc {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	list, ok := c.KeyWatchers[*key]
	if !ok {
		list = make([]*CloudletInternalKeyWatcher, 0)
	}
	watcher := CloudletInternalKeyWatcher{cb: cb}
	c.KeyWatchers[*key] = append(list, &watcher)
	log.DebugLog(log.DebugLevelApi, "Watching CloudletInternal", "key", key)
	return func() {
		c.Mux.Lock()
		defer c.Mux.Unlock()
		list, ok := c.KeyWatchers[*key]
		if !ok {
			return
		}
		for ii, _ := range list {
			if list[ii] != &watcher {
				continue
			}
			if len(list) == 1 {
				delete(c.KeyWatchers, *key)
				return
			}
			list[ii] = list[len(list)-1]
			list[len(list)-1] = nil
			c.KeyWatchers[*key] = list[:len(list)-1]
			return
		}
	}
}

func (c *CloudletInternalCache) TriggerKeyWatchers(ctx context.Context, key *CloudletKey) {
	watchers := make([]*CloudletInternalKeyWatcher, 0)
	c.Mux.Lock()
	if list, ok := c.KeyWatchers[*key]; ok {
		watchers = append(watchers, list...)
	}
	c.Mux.Unlock()
	for ii, _ := range watchers {
		watchers[ii].cb(ctx)
	}
}

// Note that we explicitly ignore the global revision number, because of the way
// the notify framework sends updates (by hashing keys and doing lookups, instead
// of sequentially through a history buffer), updates may be done out-of-order
// or multiple updates compressed into one update, so the state of the cache at
// any point in time may not by in sync with a particular database revision number.

func (c *CloudletInternalCache) SyncUpdate(ctx context.Context, key, val []byte, rev, modRev int64) {
	obj := CloudletInternal{}
	err := json.Unmarshal(val, &obj)
	if err != nil {
		log.WarnLog("Failed to parse CloudletInternal data", "val", string(val), "err", err)
		return
	}
	c.Update(ctx, &obj, modRev)
	c.Mux.Lock()
	if c.List != nil {
		c.List[obj.GetKeyVal()] = struct{}{}
	}
	c.Mux.Unlock()
}

func (c *CloudletInternalCache) SyncDelete(ctx context.Context, key []byte, rev, modRev int64) {
	obj := CloudletInternal{}
	keystr := objstore.DbKeyPrefixRemove(string(key))
	CloudletKeyStringParse(keystr, obj.GetKey())
	c.Delete(ctx, &obj, modRev)
}

func (c *CloudletInternalCache) SyncListStart(ctx context.Context) {
	c.List = make(map[CloudletKey]struct{})
}

func (c *CloudletInternalCache) SyncListEnd(ctx context.Context) {
	deleted := make(map[CloudletKey]*CloudletInternalCacheData)
	c.Mux.Lock()
	for key, val := range c.Objs {
		if _, found := c.List[key]; !found {
			deleted[key] = val
			delete(c.Objs, key)
		}
	}
	c.List = nil
	c.Mux.Unlock()
	for key, val := range deleted {
		obj := val.Obj
		if obj == nil {
			obj = &CloudletInternal{}
			obj.SetKey(&key)
		}
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, obj, val.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if val.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, val.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (c *CloudletInternalCache) UsesOrg(org string) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for key, _ := range c.Objs {
		if key.Organization == org {
			return true
		}
	}
	return false
}

func (m *CloudletInternal) GetObjKey() objstore.ObjKey {
	return m.GetKey()
}

func (m *CloudletInternal) GetKey() *CloudletKey {
	return &m.Key
}

func (m *CloudletInternal) GetKeyVal() CloudletKey {
	return m.Key
}

func (m *CloudletInternal) SetKey(key *CloudletKey) {
	m.Key = *key
}

func CmpSortCloudletInternal(a CloudletInternal, b CloudletInternal) bool {
	return a.Key.GetKeyString() < b.Key.GetKeyString()
}

// Helper method to check that enums have valid values
// NOTE: ValidateEnums checks all Fields even if some are not set
func (m *CloudletInternal) ValidateEnums() error {
	if err := m.Key.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func (s *CloudletInternal) ClearTagged(tags map[string]struct{}) {
	s.Key.ClearTagged(tags)
}

func (m *PlatformConfig) Clone() *PlatformConfig {
	cp := &PlatformConfig{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *PlatformConfig) CopyInFields(src *PlatformConfig) int {
	updateListAction := "replace"
	changed := 0
	if m.ContainerRegistryPath != src.ContainerRegistryPath {
		m.ContainerRegistryPath = src.ContainerRegistryPath
		changed++
	}
	if m.CloudletVmImagePath != src.CloudletVmImagePath {
		m.CloudletVmImagePath = src.CloudletVmImagePath
		changed++
	}
	if m.NotifyCtrlAddrs != src.NotifyCtrlAddrs {
		m.NotifyCtrlAddrs = src.NotifyCtrlAddrs
		changed++
	}
	if m.TlsCertFile != src.TlsCertFile {
		m.TlsCertFile = src.TlsCertFile
		changed++
	}
	if src.EnvVar != nil {
		if updateListAction == "add" {
			for k0, v := range src.EnvVar {
				m.EnvVar[k0] = v
				changed++
			}
		} else if updateListAction == "remove" {
			for k0, _ := range src.EnvVar {
				if _, ok := m.EnvVar[k0]; ok {
					delete(m.EnvVar, k0)
					changed++
				}
			}
		} else {
			m.EnvVar = make(map[string]string)
			for k0, v := range src.EnvVar {
				m.EnvVar[k0] = v
			}
			changed++
		}
	} else if m.EnvVar != nil {
		m.EnvVar = nil
		changed++
	}
	if m.PlatformTag != src.PlatformTag {
		m.PlatformTag = src.PlatformTag
		changed++
	}
	if m.TestMode != src.TestMode {
		m.TestMode = src.TestMode
		changed++
	}
	if m.Span != src.Span {
		m.Span = src.Span
		changed++
	}
	if m.CleanupMode != src.CleanupMode {
		m.CleanupMode = src.CleanupMode
		changed++
	}
	if m.Region != src.Region {
		m.Region = src.Region
		changed++
	}
	if m.CommercialCerts != src.CommercialCerts {
		m.CommercialCerts = src.CommercialCerts
		changed++
	}
	if m.UseVaultPki != src.UseVaultPki {
		m.UseVaultPki = src.UseVaultPki
		changed++
	}
	if m.AppDnsRoot != src.AppDnsRoot {
		m.AppDnsRoot = src.AppDnsRoot
		changed++
	}
	if m.DeploymentTag != src.DeploymentTag {
		m.DeploymentTag = src.DeploymentTag
		changed++
	}
	if m.TlsKeyFile != src.TlsKeyFile {
		m.TlsKeyFile = src.TlsKeyFile
		changed++
	}
	if m.TlsCaFile != src.TlsCaFile {
		m.TlsCaFile = src.TlsCaFile
		changed++
	}
	if m.CrmAccessPrivateKey != src.CrmAccessPrivateKey {
		m.CrmAccessPrivateKey = src.CrmAccessPrivateKey
		changed++
	}
	if m.AccessApiAddr != src.AccessApiAddr {
		m.AccessApiAddr = src.AccessApiAddr
		changed++
	}
	if m.CacheDir != src.CacheDir {
		m.CacheDir = src.CacheDir
		changed++
	}
	if m.SecondaryCrmAccessPrivateKey != src.SecondaryCrmAccessPrivateKey {
		m.SecondaryCrmAccessPrivateKey = src.SecondaryCrmAccessPrivateKey
		changed++
	}
	if m.ThanosRecvAddr != src.ThanosRecvAddr {
		m.ThanosRecvAddr = src.ThanosRecvAddr
		changed++
	}
	if m.AnsiblePublicAddr != src.AnsiblePublicAddr {
		m.AnsiblePublicAddr = src.AnsiblePublicAddr
		changed++
	}
	if m.EnvoyWithCurlImage != src.EnvoyWithCurlImage {
		m.EnvoyWithCurlImage = src.EnvoyWithCurlImage
		changed++
	}
	if m.NginxWithCurlImage != src.NginxWithCurlImage {
		m.NginxWithCurlImage = src.NginxWithCurlImage
		changed++
	}
	return changed
}

func (m *PlatformConfig) DeepCopyIn(src *PlatformConfig) {
	m.ContainerRegistryPath = src.ContainerRegistryPath
	m.CloudletVmImagePath = src.CloudletVmImagePath
	m.NotifyCtrlAddrs = src.NotifyCtrlAddrs
	m.TlsCertFile = src.TlsCertFile
	if src.EnvVar != nil {
		m.EnvVar = make(map[string]string)
		for k, v := range src.EnvVar {
			m.EnvVar[k] = v
		}
	} else {
		m.EnvVar = nil
	}
	m.PlatformTag = src.PlatformTag
	m.TestMode = src.TestMode
	m.Span = src.Span
	m.CleanupMode = src.CleanupMode
	m.Region = src.Region
	m.CommercialCerts = src.CommercialCerts
	m.UseVaultPki = src.UseVaultPki
	m.AppDnsRoot = src.AppDnsRoot
	m.DeploymentTag = src.DeploymentTag
	m.TlsKeyFile = src.TlsKeyFile
	m.TlsCaFile = src.TlsCaFile
	m.CrmAccessPrivateKey = src.CrmAccessPrivateKey
	m.AccessApiAddr = src.AccessApiAddr
	m.CacheDir = src.CacheDir
	m.SecondaryCrmAccessPrivateKey = src.SecondaryCrmAccessPrivateKey
	m.ThanosRecvAddr = src.ThanosRecvAddr
	m.AnsiblePublicAddr = src.AnsiblePublicAddr
	m.EnvoyWithCurlImage = src.EnvoyWithCurlImage
	m.NginxWithCurlImage = src.NginxWithCurlImage
}

// Helper method to check that enums have valid values
func (m *PlatformConfig) ValidateEnums() error {
	return nil
}

func (s *PlatformConfig) ClearTagged(tags map[string]struct{}) {
	if _, found := tags["nocmp"]; found {
		s.NotifyCtrlAddrs = ""
	}
	if _, found := tags["nocmp"]; found {
		s.PlatformTag = ""
	}
	if _, found := tags["nocmp"]; found {
		s.Span = ""
	}
	if _, found := tags["nocmp"]; found {
		s.CrmAccessPrivateKey = ""
	}
	if _, found := tags["nocmp"]; found {
		s.AccessApiAddr = ""
	}
	if _, found := tags["nocmp"]; found {
		s.SecondaryCrmAccessPrivateKey = ""
	}
}

func IgnorePlatformConfigFields(taglist string) cmp.Option {
	names := []string{}
	tags := make(map[string]struct{})
	for _, tag := range strings.Split(taglist, ",") {
		tags[tag] = struct{}{}
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "NotifyCtrlAddrs")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "PlatformTag")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Span")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "CrmAccessPrivateKey")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "AccessApiAddr")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "SecondaryCrmAccessPrivateKey")
	}
	return cmpopts.IgnoreFields(PlatformConfig{}, names...)
}

func (m *FederationConfig) Clone() *FederationConfig {
	cp := &FederationConfig{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *FederationConfig) CopyInFields(src *FederationConfig) int {
	changed := 0
	if m.FederationContextId != src.FederationContextId {
		m.FederationContextId = src.FederationContextId
		changed++
	}
	if m.PartnerFederationAddr != src.PartnerFederationAddr {
		m.PartnerFederationAddr = src.PartnerFederationAddr
		changed++
	}
	if m.FederationDbId != src.FederationDbId {
		m.FederationDbId = src.FederationDbId
		changed++
	}
	if m.FederationName != src.FederationName {
		m.FederationName = src.FederationName
		changed++
	}
	return changed
}

func (m *FederationConfig) DeepCopyIn(src *FederationConfig) {
	m.FederationContextId = src.FederationContextId
	m.PartnerFederationAddr = src.PartnerFederationAddr
	m.FederationDbId = src.FederationDbId
	m.FederationName = src.FederationName
}

// Helper method to check that enums have valid values
func (m *FederationConfig) ValidateEnums() error {
	return nil
}

func (s *FederationConfig) ClearTagged(tags map[string]struct{}) {
}

func (m *PlatformFeatures) Matches(o *PlatformFeatures, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !opts.Filter || o.PlatformType != "" {
		if o.PlatformType != m.PlatformType {
			return false
		}
	}
	if !opts.Filter || o.SupportsMultiTenantCluster != false {
		if o.SupportsMultiTenantCluster != m.SupportsMultiTenantCluster {
			return false
		}
	}
	if !opts.Filter || o.SupportsSharedVolume != false {
		if o.SupportsSharedVolume != m.SupportsSharedVolume {
			return false
		}
	}
	if !opts.Filter || o.SupportsTrustPolicy != false {
		if o.SupportsTrustPolicy != m.SupportsTrustPolicy {
			return false
		}
	}
	if !opts.Filter || o.SupportsKubernetesOnly != false {
		if o.SupportsKubernetesOnly != m.SupportsKubernetesOnly {
			return false
		}
	}
	if !opts.Filter || o.KubernetesRequiresWorkerNodes != false {
		if o.KubernetesRequiresWorkerNodes != m.KubernetesRequiresWorkerNodes {
			return false
		}
	}
	if !opts.Filter || o.CloudletServicesLocal != false {
		if o.CloudletServicesLocal != m.CloudletServicesLocal {
			return false
		}
	}
	if !opts.Filter || o.IpAllocatedPerService != false {
		if o.IpAllocatedPerService != m.IpAllocatedPerService {
			return false
		}
	}
	if !opts.Filter || o.SupportsImageTypeOvf != false {
		if o.SupportsImageTypeOvf != m.SupportsImageTypeOvf {
			return false
		}
	}
	if !opts.Filter || o.IsVmPool != false {
		if o.IsVmPool != m.IsVmPool {
			return false
		}
	}
	if !opts.Filter || o.IsFake != false {
		if o.IsFake != m.IsFake {
			return false
		}
	}
	if !opts.Filter || o.SupportsAdditionalNetworks != false {
		if o.SupportsAdditionalNetworks != m.SupportsAdditionalNetworks {
			return false
		}
	}
	if !opts.Filter || o.IsSingleKubernetesCluster != false {
		if o.IsSingleKubernetesCluster != m.IsSingleKubernetesCluster {
			return false
		}
	}
	if !opts.Filter || o.SupportsAppInstDedicatedIp != false {
		if o.SupportsAppInstDedicatedIp != m.SupportsAppInstDedicatedIp {
			return false
		}
	}
	if !opts.Filter || o.SupportsPlatformHighAvailabilityOnK8S != false {
		if o.SupportsPlatformHighAvailabilityOnK8S != m.SupportsPlatformHighAvailabilityOnK8S {
			return false
		}
	}
	if !opts.Filter || o.SupportsPlatformHighAvailabilityOnDocker != false {
		if o.SupportsPlatformHighAvailabilityOnDocker != m.SupportsPlatformHighAvailabilityOnDocker {
			return false
		}
	}
	if !opts.Filter || o.NoKubernetesClusterAutoScale != false {
		if o.NoKubernetesClusterAutoScale != m.NoKubernetesClusterAutoScale {
			return false
		}
	}
	if !opts.Filter || o.IsPrebuiltKubernetesCluster != false {
		if o.IsPrebuiltKubernetesCluster != m.IsPrebuiltKubernetesCluster {
			return false
		}
	}
	if !opts.Filter || o.SupportsImageTypeOva != false {
		if o.SupportsImageTypeOva != m.SupportsImageTypeOva {
			return false
		}
	}
	if !opts.Filter || o.NoClusterSupport != false {
		if o.NoClusterSupport != m.NoClusterSupport {
			return false
		}
	}
	if !opts.Filter || o.IsEdgebox != false {
		if o.IsEdgebox != m.IsEdgebox {
			return false
		}
	}
	if !opts.Filter || o.AccessVars != nil {
		if len(m.AccessVars) == 0 && len(o.AccessVars) > 0 || len(m.AccessVars) > 0 && len(o.AccessVars) == 0 {
			return false
		} else if m.AccessVars != nil && o.AccessVars != nil {
			if !opts.Filter && len(m.AccessVars) != len(o.AccessVars) {
				return false
			}
			for k, _ := range o.AccessVars {
				_, ok := m.AccessVars[k]
				if !ok {
					return false
				}
			}
		}
	}
	if !opts.Filter || o.Properties != nil {
		if len(m.Properties) == 0 && len(o.Properties) > 0 || len(m.Properties) > 0 && len(o.Properties) == 0 {
			return false
		} else if m.Properties != nil && o.Properties != nil {
			if !opts.Filter && len(m.Properties) != len(o.Properties) {
				return false
			}
			for k, _ := range o.Properties {
				_, ok := m.Properties[k]
				if !ok {
					return false
				}
			}
		}
	}
	if !opts.Filter || o.ResourceQuotaProperties != nil {
		if len(m.ResourceQuotaProperties) == 0 && len(o.ResourceQuotaProperties) > 0 || len(m.ResourceQuotaProperties) > 0 && len(o.ResourceQuotaProperties) == 0 {
			return false
		} else if m.ResourceQuotaProperties != nil && o.ResourceQuotaProperties != nil {
			if !opts.Filter && len(m.ResourceQuotaProperties) != len(o.ResourceQuotaProperties) {
				return false
			}
		}
	}
	if !opts.Filter || o.NodeType != "" {
		if o.NodeType != m.NodeType {
			return false
		}
	}
	if !opts.Filter || o.IsMock != false {
		if o.IsMock != m.IsMock {
			return false
		}
	}
	if !opts.Filter || o.SupportsIpv6 != false {
		if o.SupportsIpv6 != m.SupportsIpv6 {
			return false
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.DeletePrepare != false {
			if o.DeletePrepare != m.DeletePrepare {
				return false
			}
		}
	}
	return true
}

func (m *PlatformFeatures) Clone() *PlatformFeatures {
	cp := &PlatformFeatures{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *PlatformFeatures) AddResourceQuotaProperties(vals ...InfraResource) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.ResourceQuotaProperties {
		cur[v.String()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.String()]; found {
			continue // duplicate
		}
		m.ResourceQuotaProperties = append(m.ResourceQuotaProperties, v)
		changes++
	}
	return changes
}

func (m *PlatformFeatures) RemoveResourceQuotaProperties(vals ...InfraResource) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.String()] = struct{}{}
	}
	for i := len(m.ResourceQuotaProperties); i >= 0; i-- {
		if _, found := remove[m.ResourceQuotaProperties[i].String()]; found {
			m.ResourceQuotaProperties = append(m.ResourceQuotaProperties[:i], m.ResourceQuotaProperties[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *PlatformFeatures) CopyInFields(src *PlatformFeatures) int {
	updateListAction := "replace"
	changed := 0
	if m.PlatformType != src.PlatformType {
		m.PlatformType = src.PlatformType
		changed++
	}
	if m.SupportsMultiTenantCluster != src.SupportsMultiTenantCluster {
		m.SupportsMultiTenantCluster = src.SupportsMultiTenantCluster
		changed++
	}
	if m.SupportsSharedVolume != src.SupportsSharedVolume {
		m.SupportsSharedVolume = src.SupportsSharedVolume
		changed++
	}
	if m.SupportsTrustPolicy != src.SupportsTrustPolicy {
		m.SupportsTrustPolicy = src.SupportsTrustPolicy
		changed++
	}
	if m.SupportsKubernetesOnly != src.SupportsKubernetesOnly {
		m.SupportsKubernetesOnly = src.SupportsKubernetesOnly
		changed++
	}
	if m.KubernetesRequiresWorkerNodes != src.KubernetesRequiresWorkerNodes {
		m.KubernetesRequiresWorkerNodes = src.KubernetesRequiresWorkerNodes
		changed++
	}
	if m.CloudletServicesLocal != src.CloudletServicesLocal {
		m.CloudletServicesLocal = src.CloudletServicesLocal
		changed++
	}
	if m.IpAllocatedPerService != src.IpAllocatedPerService {
		m.IpAllocatedPerService = src.IpAllocatedPerService
		changed++
	}
	if m.SupportsImageTypeOvf != src.SupportsImageTypeOvf {
		m.SupportsImageTypeOvf = src.SupportsImageTypeOvf
		changed++
	}
	if m.IsVmPool != src.IsVmPool {
		m.IsVmPool = src.IsVmPool
		changed++
	}
	if m.IsFake != src.IsFake {
		m.IsFake = src.IsFake
		changed++
	}
	if m.SupportsAdditionalNetworks != src.SupportsAdditionalNetworks {
		m.SupportsAdditionalNetworks = src.SupportsAdditionalNetworks
		changed++
	}
	if m.IsSingleKubernetesCluster != src.IsSingleKubernetesCluster {
		m.IsSingleKubernetesCluster = src.IsSingleKubernetesCluster
		changed++
	}
	if m.SupportsAppInstDedicatedIp != src.SupportsAppInstDedicatedIp {
		m.SupportsAppInstDedicatedIp = src.SupportsAppInstDedicatedIp
		changed++
	}
	if m.SupportsPlatformHighAvailabilityOnK8S != src.SupportsPlatformHighAvailabilityOnK8S {
		m.SupportsPlatformHighAvailabilityOnK8S = src.SupportsPlatformHighAvailabilityOnK8S
		changed++
	}
	if m.SupportsPlatformHighAvailabilityOnDocker != src.SupportsPlatformHighAvailabilityOnDocker {
		m.SupportsPlatformHighAvailabilityOnDocker = src.SupportsPlatformHighAvailabilityOnDocker
		changed++
	}
	if m.NoKubernetesClusterAutoScale != src.NoKubernetesClusterAutoScale {
		m.NoKubernetesClusterAutoScale = src.NoKubernetesClusterAutoScale
		changed++
	}
	if m.IsPrebuiltKubernetesCluster != src.IsPrebuiltKubernetesCluster {
		m.IsPrebuiltKubernetesCluster = src.IsPrebuiltKubernetesCluster
		changed++
	}
	if m.SupportsImageTypeOva != src.SupportsImageTypeOva {
		m.SupportsImageTypeOva = src.SupportsImageTypeOva
		changed++
	}
	if m.NoClusterSupport != src.NoClusterSupport {
		m.NoClusterSupport = src.NoClusterSupport
		changed++
	}
	if m.IsEdgebox != src.IsEdgebox {
		m.IsEdgebox = src.IsEdgebox
		changed++
	}
	if src.AccessVars != nil {
		if updateListAction == "add" {
			for k0, v := range src.AccessVars {
				v = v.Clone()
				m.AccessVars[k0] = v
				changed++
			}
		} else if updateListAction == "remove" {
			for k0, _ := range src.AccessVars {
				if _, ok := m.AccessVars[k0]; ok {
					delete(m.AccessVars, k0)
					changed++
				}
			}
		} else {
			m.AccessVars = make(map[string]*PropertyInfo)
			for k0, v := range src.AccessVars {
				m.AccessVars[k0] = v.Clone()
			}
			changed++
		}
	} else if m.AccessVars != nil {
		m.AccessVars = nil
		changed++
	}
	if src.Properties != nil {
		if updateListAction == "add" {
			for k0, v := range src.Properties {
				v = v.Clone()
				m.Properties[k0] = v
				changed++
			}
		} else if updateListAction == "remove" {
			for k0, _ := range src.Properties {
				if _, ok := m.Properties[k0]; ok {
					delete(m.Properties, k0)
					changed++
				}
			}
		} else {
			m.Properties = make(map[string]*PropertyInfo)
			for k0, v := range src.Properties {
				m.Properties[k0] = v.Clone()
			}
			changed++
		}
	} else if m.Properties != nil {
		m.Properties = nil
		changed++
	}
	if src.ResourceQuotaProperties != nil {
		if updateListAction == "add" {
			changed += m.AddResourceQuotaProperties(src.ResourceQuotaProperties...)
		} else if updateListAction == "remove" {
			changed += m.RemoveResourceQuotaProperties(src.ResourceQuotaProperties...)
		} else {
			m.ResourceQuotaProperties = make([]InfraResource, 0)
			for k0, _ := range src.ResourceQuotaProperties {
				m.ResourceQuotaProperties = append(m.ResourceQuotaProperties, *src.ResourceQuotaProperties[k0].Clone())
			}
			changed++
		}
	} else if m.ResourceQuotaProperties != nil {
		m.ResourceQuotaProperties = nil
		changed++
	}
	if m.NodeType != src.NodeType {
		m.NodeType = src.NodeType
		changed++
	}
	if m.IsMock != src.IsMock {
		m.IsMock = src.IsMock
		changed++
	}
	if m.SupportsIpv6 != src.SupportsIpv6 {
		m.SupportsIpv6 = src.SupportsIpv6
		changed++
	}
	if m.DeletePrepare != src.DeletePrepare {
		m.DeletePrepare = src.DeletePrepare
		changed++
	}
	return changed
}

func (m *PlatformFeatures) DeepCopyIn(src *PlatformFeatures) {
	m.PlatformType = src.PlatformType
	m.SupportsMultiTenantCluster = src.SupportsMultiTenantCluster
	m.SupportsSharedVolume = src.SupportsSharedVolume
	m.SupportsTrustPolicy = src.SupportsTrustPolicy
	m.SupportsKubernetesOnly = src.SupportsKubernetesOnly
	m.KubernetesRequiresWorkerNodes = src.KubernetesRequiresWorkerNodes
	m.CloudletServicesLocal = src.CloudletServicesLocal
	m.IpAllocatedPerService = src.IpAllocatedPerService
	m.SupportsImageTypeOvf = src.SupportsImageTypeOvf
	m.IsVmPool = src.IsVmPool
	m.IsFake = src.IsFake
	m.SupportsAdditionalNetworks = src.SupportsAdditionalNetworks
	m.IsSingleKubernetesCluster = src.IsSingleKubernetesCluster
	m.SupportsAppInstDedicatedIp = src.SupportsAppInstDedicatedIp
	m.SupportsPlatformHighAvailabilityOnK8S = src.SupportsPlatformHighAvailabilityOnK8S
	m.SupportsPlatformHighAvailabilityOnDocker = src.SupportsPlatformHighAvailabilityOnDocker
	m.NoKubernetesClusterAutoScale = src.NoKubernetesClusterAutoScale
	m.IsPrebuiltKubernetesCluster = src.IsPrebuiltKubernetesCluster
	m.SupportsImageTypeOva = src.SupportsImageTypeOva
	m.NoClusterSupport = src.NoClusterSupport
	m.IsEdgebox = src.IsEdgebox
	if src.AccessVars != nil {
		m.AccessVars = make(map[string]*PropertyInfo)
		for k, v := range src.AccessVars {
			var tmp_v PropertyInfo
			tmp_v.DeepCopyIn(v)
			m.AccessVars[k] = &tmp_v
		}
	} else {
		m.AccessVars = nil
	}
	if src.Properties != nil {
		m.Properties = make(map[string]*PropertyInfo)
		for k, v := range src.Properties {
			var tmp_v PropertyInfo
			tmp_v.DeepCopyIn(v)
			m.Properties[k] = &tmp_v
		}
	} else {
		m.Properties = nil
	}
	if src.ResourceQuotaProperties != nil {
		m.ResourceQuotaProperties = make([]InfraResource, len(src.ResourceQuotaProperties), len(src.ResourceQuotaProperties))
		for ii, s := range src.ResourceQuotaProperties {
			m.ResourceQuotaProperties[ii].DeepCopyIn(&s)
		}
	} else {
		m.ResourceQuotaProperties = nil
	}
	m.NodeType = src.NodeType
	m.IsMock = src.IsMock
	m.SupportsIpv6 = src.SupportsIpv6
	m.DeletePrepare = src.DeletePrepare
}

func (s *PlatformFeatures) HasFields() bool {
	return false
}

type PlatformFeaturesStore interface {
	Create(ctx context.Context, m *PlatformFeatures, wait func(int64)) (*Result, error)
	Update(ctx context.Context, m *PlatformFeatures, wait func(int64)) (*Result, error)
	Delete(ctx context.Context, m *PlatformFeatures, wait func(int64)) (*Result, error)
	Put(ctx context.Context, m *PlatformFeatures, wait func(int64), ops ...objstore.KVOp) (*Result, error)
	LoadOne(key string) (*PlatformFeatures, int64, error)
	Get(ctx context.Context, key *PlatformFeaturesKey, buf *PlatformFeatures) bool
	STMGet(stm concurrency.STM, key *PlatformFeaturesKey, buf *PlatformFeatures) bool
	STMPut(stm concurrency.STM, obj *PlatformFeatures, ops ...objstore.KVOp)
	STMDel(stm concurrency.STM, key *PlatformFeaturesKey)
	STMHas(stm concurrency.STM, key *PlatformFeaturesKey) bool
}

type PlatformFeaturesStoreImpl struct {
	kvstore objstore.KVStore
}

func NewPlatformFeaturesStore(kvstore objstore.KVStore) *PlatformFeaturesStoreImpl {
	return &PlatformFeaturesStoreImpl{kvstore: kvstore}
}

func (s *PlatformFeaturesStoreImpl) Create(ctx context.Context, m *PlatformFeatures, wait func(int64)) (*Result, error) {
	err := m.Validate(nil)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("PlatformFeatures", m.GetKey())
	val, err := json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Create(ctx, key, string(val))
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *PlatformFeaturesStoreImpl) Update(ctx context.Context, m *PlatformFeatures, wait func(int64)) (*Result, error) {
	err := m.Validate(nil)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("PlatformFeatures", m.GetKey())
	var vers int64 = 0
	val, err := json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Update(ctx, key, string(val), vers)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *PlatformFeaturesStoreImpl) Put(ctx context.Context, m *PlatformFeatures, wait func(int64), ops ...objstore.KVOp) (*Result, error) {
	err := m.Validate(nil)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("PlatformFeatures", m.GetKey())
	var val []byte
	val, err = json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Put(ctx, key, string(val), ops...)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *PlatformFeaturesStoreImpl) Delete(ctx context.Context, m *PlatformFeatures, wait func(int64)) (*Result, error) {
	err := m.GetKey().ValidateKey()
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("PlatformFeatures", m.GetKey())
	rev, err := s.kvstore.Delete(ctx, key)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *PlatformFeaturesStoreImpl) LoadOne(key string) (*PlatformFeatures, int64, error) {
	val, rev, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, 0, err
	}
	var obj PlatformFeatures
	err = json.Unmarshal(val, &obj)
	if err != nil {
		log.DebugLog(log.DebugLevelApi, "Failed to parse PlatformFeatures data", "val", string(val), "err", err)
		return nil, 0, err
	}
	return &obj, rev, nil
}

func (s *PlatformFeaturesStoreImpl) Get(ctx context.Context, key *PlatformFeaturesKey, buf *PlatformFeatures) bool {
	keystr := objstore.DbKeyString("PlatformFeatures", key)
	val, _, _, err := s.kvstore.Get(keystr)
	if err != nil {
		return false
	}
	return s.parseGetData(val, buf)
}

func (s *PlatformFeaturesStoreImpl) STMGet(stm concurrency.STM, key *PlatformFeaturesKey, buf *PlatformFeatures) bool {
	keystr := objstore.DbKeyString("PlatformFeatures", key)
	valstr := stm.Get(keystr)
	return s.parseGetData([]byte(valstr), buf)
}

func (s *PlatformFeaturesStoreImpl) STMHas(stm concurrency.STM, key *PlatformFeaturesKey) bool {
	keystr := objstore.DbKeyString("PlatformFeatures", key)
	return stm.Get(keystr) != ""
}

func (s *PlatformFeaturesStoreImpl) parseGetData(val []byte, buf *PlatformFeatures) bool {
	if len(val) == 0 {
		return false
	}
	if buf != nil {
		// clear buf, because empty values in val won't
		// overwrite non-empty values in buf.
		*buf = PlatformFeatures{}
		err := json.Unmarshal(val, buf)
		if err != nil {
			return false
		}
	}
	return true
}

func (s *PlatformFeaturesStoreImpl) STMPut(stm concurrency.STM, obj *PlatformFeatures, ops ...objstore.KVOp) {
	keystr := objstore.DbKeyString("PlatformFeatures", obj.GetKey())

	val, err := json.Marshal(obj)
	if err != nil {
		log.InfoLog("PlatformFeatures json marshal failed", "obj", obj, "err", err)
	}
	v3opts := GetSTMOpts(ops...)
	stm.Put(keystr, string(val), v3opts...)
}

func (s *PlatformFeaturesStoreImpl) STMDel(stm concurrency.STM, key *PlatformFeaturesKey) {
	keystr := objstore.DbKeyString("PlatformFeatures", key)
	stm.Del(keystr)
}

type PlatformFeaturesKeyWatcher struct {
	cb func(ctx context.Context)
}

type PlatformFeaturesCacheData struct {
	Obj    *PlatformFeatures
	ModRev int64
}

func (s *PlatformFeaturesCacheData) Clone() *PlatformFeaturesCacheData {
	cp := PlatformFeaturesCacheData{}
	if s.Obj != nil {
		cp.Obj = &PlatformFeatures{}
		cp.Obj.DeepCopyIn(s.Obj)
	}
	cp.ModRev = s.ModRev
	return &cp
}

// PlatformFeaturesCache caches PlatformFeatures objects in memory in a hash table
// and keeps them in sync with the database.
type PlatformFeaturesCache struct {
	Objs          map[PlatformFeaturesKey]*PlatformFeaturesCacheData
	Mux           util.Mutex
	List          map[PlatformFeaturesKey]struct{}
	FlushAll      bool
	NotifyCbs     []func(ctx context.Context, obj *PlatformFeatures, modRev int64)
	UpdatedCbs    []func(ctx context.Context, old *PlatformFeatures, new *PlatformFeatures)
	DeletedCbs    []func(ctx context.Context, old *PlatformFeatures)
	KeyWatchers   map[PlatformFeaturesKey][]*PlatformFeaturesKeyWatcher
	UpdatedKeyCbs []func(ctx context.Context, key *PlatformFeaturesKey)
	DeletedKeyCbs []func(ctx context.Context, key *PlatformFeaturesKey)
}

func NewPlatformFeaturesCache() *PlatformFeaturesCache {
	cache := PlatformFeaturesCache{}
	InitPlatformFeaturesCache(&cache)
	return &cache
}

func InitPlatformFeaturesCache(cache *PlatformFeaturesCache) {
	cache.Objs = make(map[PlatformFeaturesKey]*PlatformFeaturesCacheData)
	cache.KeyWatchers = make(map[PlatformFeaturesKey][]*PlatformFeaturesKeyWatcher)
	cache.NotifyCbs = nil
	cache.UpdatedCbs = nil
	cache.DeletedCbs = nil
	cache.UpdatedKeyCbs = nil
	cache.DeletedKeyCbs = nil
}

func (c *PlatformFeaturesCache) GetTypeString() string {
	return "PlatformFeatures"
}

func (c *PlatformFeaturesCache) Get(key *PlatformFeaturesKey, valbuf *PlatformFeatures) bool {
	var modRev int64
	return c.GetWithRev(key, valbuf, &modRev)
}

func (c *PlatformFeaturesCache) GetWithRev(key *PlatformFeaturesKey, valbuf *PlatformFeatures, modRev *int64) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	inst, found := c.Objs[*key]
	if found {
		valbuf.DeepCopyIn(inst.Obj)
		*modRev = inst.ModRev
	}
	return found
}

func (c *PlatformFeaturesCache) HasKey(key *PlatformFeaturesKey) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	_, found := c.Objs[*key]
	return found
}

func (c *PlatformFeaturesCache) GetAllKeys(ctx context.Context, cb func(key *PlatformFeaturesKey, modRev int64)) {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for key, data := range c.Objs {
		cb(&key, data.ModRev)
	}
}

func (c *PlatformFeaturesCache) GetAllLocked(ctx context.Context, cb func(obj *PlatformFeatures, modRev int64)) {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for _, data := range c.Objs {
		cb(data.Obj, data.ModRev)
	}
}

func (c *PlatformFeaturesCache) Update(ctx context.Context, in *PlatformFeatures, modRev int64) {
	c.UpdateModFunc(ctx, in.GetKey(), modRev, func(old *PlatformFeatures) (*PlatformFeatures, bool) {
		return in, true
	})
}

func (c *PlatformFeaturesCache) UpdateModFunc(ctx context.Context, key *PlatformFeaturesKey, modRev int64, modFunc func(old *PlatformFeatures) (new *PlatformFeatures, changed bool)) {
	c.Mux.Lock()
	var old *PlatformFeatures
	if oldData, found := c.Objs[*key]; found {
		old = oldData.Obj
	}
	new, changed := modFunc(old)
	if !changed {
		c.Mux.Unlock()
		return
	}
	if len(c.UpdatedCbs) > 0 || len(c.NotifyCbs) > 0 {
		newCopy := &PlatformFeatures{}
		newCopy.DeepCopyIn(new)
		for _, cb := range c.UpdatedCbs {
			defer cb(ctx, old, newCopy)
		}
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				defer cb(ctx, newCopy, modRev)
			}
		}
	}
	for _, cb := range c.UpdatedKeyCbs {
		defer cb(ctx, key)
	}
	store := &PlatformFeatures{}
	store.DeepCopyIn(new)
	c.Objs[new.GetKeyVal()] = &PlatformFeaturesCacheData{
		Obj:    store,
		ModRev: modRev,
	}
	log.SpanLog(ctx, log.DebugLevelApi, "cache update", "new", store)
	c.Mux.Unlock()
	c.TriggerKeyWatchers(ctx, new.GetKey())
}

func (c *PlatformFeaturesCache) Delete(ctx context.Context, in *PlatformFeatures, modRev int64) {
	c.DeleteCondFunc(ctx, in, modRev, func(old *PlatformFeatures) bool {
		return true
	})
}

func (c *PlatformFeaturesCache) DeleteCondFunc(ctx context.Context, in *PlatformFeatures, modRev int64, condFunc func(old *PlatformFeatures) bool) {
	c.Mux.Lock()
	var old *PlatformFeatures
	oldData, found := c.Objs[in.GetKeyVal()]
	if found {
		old = oldData.Obj
		if !condFunc(old) {
			c.Mux.Unlock()
			return
		}
	}
	delete(c.Objs, in.GetKeyVal())
	log.SpanLog(ctx, log.DebugLevelApi, "cache delete", "key", in.GetKeyVal())
	c.Mux.Unlock()
	obj := old
	if obj == nil {
		obj = in
	}
	for _, cb := range c.NotifyCbs {
		if cb != nil {
			cb(ctx, obj, modRev)
		}
	}
	if old != nil {
		for _, cb := range c.DeletedCbs {
			cb(ctx, old)
		}
	}
	for _, cb := range c.DeletedKeyCbs {
		cb(ctx, in.GetKey())
	}
	c.TriggerKeyWatchers(ctx, in.GetKey())
}

func (c *PlatformFeaturesCache) Prune(ctx context.Context, validKeys map[PlatformFeaturesKey]struct{}) {
	log.SpanLog(ctx, log.DebugLevelApi, "Prune PlatformFeatures", "numValidKeys", len(validKeys))
	notify := make(map[PlatformFeaturesKey]*PlatformFeaturesCacheData)
	c.Mux.Lock()
	for key, _ := range c.Objs {
		if _, ok := validKeys[key]; !ok {
			if len(c.NotifyCbs) > 0 || len(c.DeletedKeyCbs) > 0 || len(c.DeletedCbs) > 0 {
				notify[key] = c.Objs[key]
			}
			delete(c.Objs, key)
		}
	}
	c.Mux.Unlock()
	for key, old := range notify {
		obj := old.Obj
		if obj == nil {
			obj = &PlatformFeatures{}
			obj.SetKey(&key)
		}
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, obj, old.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if old.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, old.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (c *PlatformFeaturesCache) GetCount() int {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	return len(c.Objs)
}

func (c *PlatformFeaturesCache) Flush(ctx context.Context, notifyId int64) {
}

func (c *PlatformFeaturesCache) Show(filter *PlatformFeatures, cb func(ret *PlatformFeatures) error) error {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for _, data := range c.Objs {
		if !data.Obj.Matches(filter, MatchFilter()) {
			continue
		}
		err := cb(data.Obj)
		if err != nil {
			return err
		}
	}
	return nil
}

func PlatformFeaturesGenericNotifyCb(fn func(key *PlatformFeaturesKey, old *PlatformFeatures)) func(objstore.ObjKey, objstore.Obj) {
	return func(objkey objstore.ObjKey, obj objstore.Obj) {
		fn(objkey.(*PlatformFeaturesKey), obj.(*PlatformFeatures))
	}
}

func (c *PlatformFeaturesCache) SetNotifyCb(fn func(ctx context.Context, obj *PlatformFeatures, modRev int64)) {
	c.NotifyCbs = []func(ctx context.Context, obj *PlatformFeatures, modRev int64){fn}
}

func (c *PlatformFeaturesCache) SetUpdatedCb(fn func(ctx context.Context, old *PlatformFeatures, new *PlatformFeatures)) {
	c.UpdatedCbs = []func(ctx context.Context, old *PlatformFeatures, new *PlatformFeatures){fn}
}

func (c *PlatformFeaturesCache) SetDeletedCb(fn func(ctx context.Context, old *PlatformFeatures)) {
	c.DeletedCbs = []func(ctx context.Context, old *PlatformFeatures){fn}
}

func (c *PlatformFeaturesCache) SetUpdatedKeyCb(fn func(ctx context.Context, key *PlatformFeaturesKey)) {
	c.UpdatedKeyCbs = []func(ctx context.Context, key *PlatformFeaturesKey){fn}
}

func (c *PlatformFeaturesCache) SetDeletedKeyCb(fn func(ctx context.Context, key *PlatformFeaturesKey)) {
	c.DeletedKeyCbs = []func(ctx context.Context, key *PlatformFeaturesKey){fn}
}

func (c *PlatformFeaturesCache) AddUpdatedCb(fn func(ctx context.Context, old *PlatformFeatures, new *PlatformFeatures)) {
	c.UpdatedCbs = append(c.UpdatedCbs, fn)
}

func (c *PlatformFeaturesCache) AddDeletedCb(fn func(ctx context.Context, old *PlatformFeatures)) {
	c.DeletedCbs = append(c.DeletedCbs, fn)
}

func (c *PlatformFeaturesCache) AddNotifyCb(fn func(ctx context.Context, obj *PlatformFeatures, modRev int64)) {
	c.NotifyCbs = append(c.NotifyCbs, fn)
}

func (c *PlatformFeaturesCache) AddUpdatedKeyCb(fn func(ctx context.Context, key *PlatformFeaturesKey)) {
	c.UpdatedKeyCbs = append(c.UpdatedKeyCbs, fn)
}

func (c *PlatformFeaturesCache) AddDeletedKeyCb(fn func(ctx context.Context, key *PlatformFeaturesKey)) {
	c.DeletedKeyCbs = append(c.DeletedKeyCbs, fn)
}

func (c *PlatformFeaturesCache) SetFlushAll() {
	c.FlushAll = true
}

func (c *PlatformFeaturesCache) WatchKey(key *PlatformFeaturesKey, cb func(ctx context.Context)) context.CancelFunc {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	list, ok := c.KeyWatchers[*key]
	if !ok {
		list = make([]*PlatformFeaturesKeyWatcher, 0)
	}
	watcher := PlatformFeaturesKeyWatcher{cb: cb}
	c.KeyWatchers[*key] = append(list, &watcher)
	log.DebugLog(log.DebugLevelApi, "Watching PlatformFeatures", "key", key)
	return func() {
		c.Mux.Lock()
		defer c.Mux.Unlock()
		list, ok := c.KeyWatchers[*key]
		if !ok {
			return
		}
		for ii, _ := range list {
			if list[ii] != &watcher {
				continue
			}
			if len(list) == 1 {
				delete(c.KeyWatchers, *key)
				return
			}
			list[ii] = list[len(list)-1]
			list[len(list)-1] = nil
			c.KeyWatchers[*key] = list[:len(list)-1]
			return
		}
	}
}

func (c *PlatformFeaturesCache) TriggerKeyWatchers(ctx context.Context, key *PlatformFeaturesKey) {
	watchers := make([]*PlatformFeaturesKeyWatcher, 0)
	c.Mux.Lock()
	if list, ok := c.KeyWatchers[*key]; ok {
		watchers = append(watchers, list...)
	}
	c.Mux.Unlock()
	for ii, _ := range watchers {
		watchers[ii].cb(ctx)
	}
}

// Note that we explicitly ignore the global revision number, because of the way
// the notify framework sends updates (by hashing keys and doing lookups, instead
// of sequentially through a history buffer), updates may be done out-of-order
// or multiple updates compressed into one update, so the state of the cache at
// any point in time may not by in sync with a particular database revision number.

func (c *PlatformFeaturesCache) SyncUpdate(ctx context.Context, key, val []byte, rev, modRev int64) {
	obj := PlatformFeatures{}
	err := json.Unmarshal(val, &obj)
	if err != nil {
		log.WarnLog("Failed to parse PlatformFeatures data", "val", string(val), "err", err)
		return
	}
	c.Update(ctx, &obj, modRev)
	c.Mux.Lock()
	if c.List != nil {
		c.List[obj.GetKeyVal()] = struct{}{}
	}
	c.Mux.Unlock()
}

func (c *PlatformFeaturesCache) SyncDelete(ctx context.Context, key []byte, rev, modRev int64) {
	obj := PlatformFeatures{}
	keystr := objstore.DbKeyPrefixRemove(string(key))
	obj.PlatformType = keystr
	c.Delete(ctx, &obj, modRev)
}

func (c *PlatformFeaturesCache) SyncListStart(ctx context.Context) {
	c.List = make(map[PlatformFeaturesKey]struct{})
}

func (c *PlatformFeaturesCache) SyncListEnd(ctx context.Context) {
	deleted := make(map[PlatformFeaturesKey]*PlatformFeaturesCacheData)
	c.Mux.Lock()
	for key, val := range c.Objs {
		if _, found := c.List[key]; !found {
			deleted[key] = val
			delete(c.Objs, key)
		}
	}
	c.List = nil
	c.Mux.Unlock()
	for key, val := range deleted {
		obj := val.Obj
		if obj == nil {
			obj = &PlatformFeatures{}
			obj.SetKey(&key)
		}
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, obj, val.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if val.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, val.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (c *PlatformFeaturesCache) UsesOrg(org string) bool {
	return false
}

type PlatformFeaturesKey string

func (k PlatformFeaturesKey) GetKeyString() string {
	return string(k)
}

func PlatformFeaturesKeyStringParse(str string, key *PlatformFeaturesKey) {
	*key = PlatformFeaturesKey(str)
}

func (k PlatformFeaturesKey) NotFoundError() error {
	return fmt.Errorf("PlatformFeatures key %s not found", k.GetKeyString())
}

func (k PlatformFeaturesKey) ExistsError() error {
	return fmt.Errorf("PlatformFeatures key %s already exists", k.GetKeyString())
}

func (k PlatformFeaturesKey) BeingDeletedError() error {
	return fmt.Errorf("PlatformFeatures key %s is being deleted", k.GetKeyString())
}

func (k PlatformFeaturesKey) GetTags() map[string]string {
	return map[string]string{
		"platformtype": string(k),
	}
}

func (k PlatformFeaturesKey) AddTagsByFunc(addTag AddTagFunc) {
	addTag("platformtype", string(k))
}

func (k PlatformFeaturesKey) AddTags(tags map[string]string) {
	tagMap := TagMap(tags)
	k.AddTagsByFunc(tagMap.AddTag)
}

func (m *PlatformFeatures) GetObjKey() objstore.ObjKey {
	return m.GetKey()
}

func (m *PlatformFeatures) GetKey() *PlatformFeaturesKey {
	key := PlatformFeaturesKey(m.PlatformType)
	return &key
}

func (m *PlatformFeatures) GetKeyVal() PlatformFeaturesKey {
	return PlatformFeaturesKey(m.PlatformType)
}

func (m *PlatformFeatures) SetKey(key *PlatformFeaturesKey) {
	m.PlatformType = string(*key)
}

func CmpSortPlatformFeatures(a PlatformFeatures, b PlatformFeatures) bool {
	return a.PlatformType < b.PlatformType
}

// Helper method to check that enums have valid values
func (m *PlatformFeatures) ValidateEnums() error {
	for _, e := range m.ResourceQuotaProperties {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (s *PlatformFeatures) ClearTagged(tags map[string]struct{}) {
	if s.ResourceQuotaProperties != nil {
		for ii := 0; ii < len(s.ResourceQuotaProperties); ii++ {
			s.ResourceQuotaProperties[ii].ClearTagged(tags)
		}
	}
}

func (m *CloudletResMap) Clone() *CloudletResMap {
	cp := &CloudletResMap{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *CloudletResMap) CopyInFields(src *CloudletResMap) int {
	updateListAction := "replace"
	changed := 0
	if m.Key.Organization != src.Key.Organization {
		m.Key.Organization = src.Key.Organization
		changed++
	}
	if m.Key.Name != src.Key.Name {
		m.Key.Name = src.Key.Name
		changed++
	}
	if m.Key.FederatedOrganization != src.Key.FederatedOrganization {
		m.Key.FederatedOrganization = src.Key.FederatedOrganization
		changed++
	}
	if src.Mapping != nil {
		if updateListAction == "add" {
			for k0, v := range src.Mapping {
				m.Mapping[k0] = v
				changed++
			}
		} else if updateListAction == "remove" {
			for k0, _ := range src.Mapping {
				if _, ok := m.Mapping[k0]; ok {
					delete(m.Mapping, k0)
					changed++
				}
			}
		} else {
			m.Mapping = make(map[string]string)
			for k0, v := range src.Mapping {
				m.Mapping[k0] = v
			}
			changed++
		}
	} else if m.Mapping != nil {
		m.Mapping = nil
		changed++
	}
	return changed
}

func (m *CloudletResMap) DeepCopyIn(src *CloudletResMap) {
	m.Key.DeepCopyIn(&src.Key)
	if src.Mapping != nil {
		m.Mapping = make(map[string]string)
		for k, v := range src.Mapping {
			m.Mapping[k] = v
		}
	} else {
		m.Mapping = nil
	}
}

func (m *CloudletResMap) GetObjKey() objstore.ObjKey {
	return m.GetKey()
}

func (m *CloudletResMap) GetKey() *CloudletKey {
	return &m.Key
}

func (m *CloudletResMap) GetKeyVal() CloudletKey {
	return m.Key
}

func (m *CloudletResMap) SetKey(key *CloudletKey) {
	m.Key = *key
}

func CmpSortCloudletResMap(a CloudletResMap, b CloudletResMap) bool {
	return a.Key.GetKeyString() < b.Key.GetKeyString()
}

// Helper method to check that enums have valid values
func (m *CloudletResMap) ValidateEnums() error {
	if err := m.Key.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func (s *CloudletResMap) ClearTagged(tags map[string]struct{}) {
	s.Key.ClearTagged(tags)
}

func (m *InfraConfig) Clone() *InfraConfig {
	cp := &InfraConfig{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *InfraConfig) CopyInFields(src *InfraConfig) int {
	changed := 0
	if m.ExternalNetworkName != src.ExternalNetworkName {
		m.ExternalNetworkName = src.ExternalNetworkName
		changed++
	}
	if m.FlavorName != src.FlavorName {
		m.FlavorName = src.FlavorName
		changed++
	}
	return changed
}

func (m *InfraConfig) DeepCopyIn(src *InfraConfig) {
	m.ExternalNetworkName = src.ExternalNetworkName
	m.FlavorName = src.FlavorName
}

// Helper method to check that enums have valid values
func (m *InfraConfig) ValidateEnums() error {
	return nil
}

func (s *InfraConfig) ClearTagged(tags map[string]struct{}) {
}

func (m *ResourceQuota) Clone() *ResourceQuota {
	cp := &ResourceQuota{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *ResourceQuota) CopyInFields(src *ResourceQuota) int {
	changed := 0
	if m.Name != src.Name {
		m.Name = src.Name
		changed++
	}
	if m.Value != src.Value {
		m.Value = src.Value
		changed++
	}
	if m.AlertThreshold != src.AlertThreshold {
		m.AlertThreshold = src.AlertThreshold
		changed++
	}
	return changed
}

func (m *ResourceQuota) DeepCopyIn(src *ResourceQuota) {
	m.Name = src.Name
	m.Value = src.Value
	m.AlertThreshold = src.AlertThreshold
}

// Helper method to check that enums have valid values
func (m *ResourceQuota) ValidateEnums() error {
	return nil
}

func (s *ResourceQuota) ClearTagged(tags map[string]struct{}) {
}

func (m *GPUDriverKey) Matches(o *GPUDriverKey, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !opts.Filter || o.Name != "" {
		if o.Name != m.Name {
			return false
		}
	}
	if !opts.Filter || o.Organization != "" {
		if o.Organization != m.Organization {
			return false
		}
	}
	return true
}

func (m *GPUDriverKey) Clone() *GPUDriverKey {
	cp := &GPUDriverKey{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *GPUDriverKey) CopyInFields(src *GPUDriverKey) int {
	changed := 0
	if m.Name != src.Name {
		m.Name = src.Name
		changed++
	}
	if m.Organization != src.Organization {
		m.Organization = src.Organization
		changed++
	}
	return changed
}

func (m *GPUDriverKey) DeepCopyIn(src *GPUDriverKey) {
	m.Name = src.Name
	m.Organization = src.Organization
}

func (m *GPUDriverKey) GetKeyString() string {
	key, err := json.Marshal(m)
	if err != nil {
		log.FatalLog("Failed to marshal GPUDriverKey key string", "obj", m)
	}
	return string(key)
}

func GPUDriverKeyStringParse(str string, key *GPUDriverKey) {
	err := json.Unmarshal([]byte(str), key)
	if err != nil {
		log.FatalLog("Failed to unmarshal GPUDriverKey key string", "str", str)
	}
}

func (m *GPUDriverKey) NotFoundError() error {
	return fmt.Errorf("GPUDriver key %s not found", m.GetKeyString())
}

func (m *GPUDriverKey) ExistsError() error {
	return fmt.Errorf("GPUDriver key %s already exists", m.GetKeyString())
}

func (m *GPUDriverKey) BeingDeletedError() error {
	return fmt.Errorf("GPUDriver %s is being deleted", m.GetKeyString())
}

var GPUDriverKeyTagName = "gpudriver"
var GPUDriverKeyTagOrganization = "gpudriverorg"

func (m *GPUDriverKey) GetTags() map[string]string {
	tags := make(map[string]string)
	m.AddTags(tags)
	return tags
}

func (m *GPUDriverKey) AddTagsByFunc(addTag AddTagFunc) {
	addTag("gpudriver", m.Name)
	addTag("gpudriverorg", m.Organization)
}

func (m *GPUDriverKey) AddTags(tags map[string]string) {
	tagMap := TagMap(tags)
	m.AddTagsByFunc(tagMap.AddTag)
}

// Helper method to check that enums have valid values
func (m *GPUDriverKey) ValidateEnums() error {
	return nil
}

func (s *GPUDriverKey) ClearTagged(tags map[string]struct{}) {
}

func (m *GPUDriverBuild) Clone() *GPUDriverBuild {
	cp := &GPUDriverBuild{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *GPUDriverBuild) CopyInFields(src *GPUDriverBuild) int {
	changed := 0
	if m.Name != src.Name {
		m.Name = src.Name
		changed++
	}
	if m.DriverPath != src.DriverPath {
		m.DriverPath = src.DriverPath
		changed++
	}
	if m.DriverPathCreds != src.DriverPathCreds {
		m.DriverPathCreds = src.DriverPathCreds
		changed++
	}
	if m.OperatingSystem != src.OperatingSystem {
		m.OperatingSystem = src.OperatingSystem
		changed++
	}
	if m.KernelVersion != src.KernelVersion {
		m.KernelVersion = src.KernelVersion
		changed++
	}
	if m.HypervisorInfo != src.HypervisorInfo {
		m.HypervisorInfo = src.HypervisorInfo
		changed++
	}
	if m.Md5Sum != src.Md5Sum {
		m.Md5Sum = src.Md5Sum
		changed++
	}
	if m.StoragePath != src.StoragePath {
		m.StoragePath = src.StoragePath
		changed++
	}
	return changed
}

func (m *GPUDriverBuild) DeepCopyIn(src *GPUDriverBuild) {
	m.Name = src.Name
	m.DriverPath = src.DriverPath
	m.DriverPathCreds = src.DriverPathCreds
	m.OperatingSystem = src.OperatingSystem
	m.KernelVersion = src.KernelVersion
	m.HypervisorInfo = src.HypervisorInfo
	m.Md5Sum = src.Md5Sum
	m.StoragePath = src.StoragePath
}

// Helper method to check that enums have valid values
func (m *GPUDriverBuild) ValidateEnums() error {
	if _, ok := OSType_name[int32(m.OperatingSystem)]; !ok {
		return errors.New("invalid OperatingSystem")
	}
	return nil
}

func (s *GPUDriverBuild) ClearTagged(tags map[string]struct{}) {
}

func (m *GPUDriverBuildMember) Clone() *GPUDriverBuildMember {
	cp := &GPUDriverBuildMember{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *GPUDriverBuildMember) CopyInFields(src *GPUDriverBuildMember) int {
	changed := 0
	if m.Key.Name != src.Key.Name {
		m.Key.Name = src.Key.Name
		changed++
	}
	if m.Key.Organization != src.Key.Organization {
		m.Key.Organization = src.Key.Organization
		changed++
	}
	if m.Build.Name != src.Build.Name {
		m.Build.Name = src.Build.Name
		changed++
	}
	if m.Build.DriverPath != src.Build.DriverPath {
		m.Build.DriverPath = src.Build.DriverPath
		changed++
	}
	if m.Build.DriverPathCreds != src.Build.DriverPathCreds {
		m.Build.DriverPathCreds = src.Build.DriverPathCreds
		changed++
	}
	if m.Build.OperatingSystem != src.Build.OperatingSystem {
		m.Build.OperatingSystem = src.Build.OperatingSystem
		changed++
	}
	if m.Build.KernelVersion != src.Build.KernelVersion {
		m.Build.KernelVersion = src.Build.KernelVersion
		changed++
	}
	if m.Build.HypervisorInfo != src.Build.HypervisorInfo {
		m.Build.HypervisorInfo = src.Build.HypervisorInfo
		changed++
	}
	if m.Build.Md5Sum != src.Build.Md5Sum {
		m.Build.Md5Sum = src.Build.Md5Sum
		changed++
	}
	if m.Build.StoragePath != src.Build.StoragePath {
		m.Build.StoragePath = src.Build.StoragePath
		changed++
	}
	if m.IgnoreState != src.IgnoreState {
		m.IgnoreState = src.IgnoreState
		changed++
	}
	return changed
}

func (m *GPUDriverBuildMember) DeepCopyIn(src *GPUDriverBuildMember) {
	m.Key.DeepCopyIn(&src.Key)
	m.Build.DeepCopyIn(&src.Build)
	m.IgnoreState = src.IgnoreState
}

func (m *GPUDriverBuildMember) GetObjKey() objstore.ObjKey {
	return m.GetKey()
}

func (m *GPUDriverBuildMember) GetKey() *GPUDriverKey {
	return &m.Key
}

func (m *GPUDriverBuildMember) GetKeyVal() GPUDriverKey {
	return m.Key
}

func (m *GPUDriverBuildMember) SetKey(key *GPUDriverKey) {
	m.Key = *key
}

func CmpSortGPUDriverBuildMember(a GPUDriverBuildMember, b GPUDriverBuildMember) bool {
	return a.Key.GetKeyString() < b.Key.GetKeyString()
}

// Helper method to check that enums have valid values
func (m *GPUDriverBuildMember) ValidateEnums() error {
	if err := m.Key.ValidateEnums(); err != nil {
		return err
	}
	if err := m.Build.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func (s *GPUDriverBuildMember) ClearTagged(tags map[string]struct{}) {
	s.Key.ClearTagged(tags)
	s.Build.ClearTagged(tags)
}

func (m *GPUDriverBuildURL) Clone() *GPUDriverBuildURL {
	cp := &GPUDriverBuildURL{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *GPUDriverBuildURL) CopyInFields(src *GPUDriverBuildURL) int {
	changed := 0
	if m.BuildUrlPath != src.BuildUrlPath {
		m.BuildUrlPath = src.BuildUrlPath
		changed++
	}
	if m.Validity != src.Validity {
		m.Validity = src.Validity
		changed++
	}
	return changed
}

func (m *GPUDriverBuildURL) DeepCopyIn(src *GPUDriverBuildURL) {
	m.BuildUrlPath = src.BuildUrlPath
	m.Validity = src.Validity
}

// Helper method to check that enums have valid values
func (m *GPUDriverBuildURL) ValidateEnums() error {
	return nil
}

func (s *GPUDriverBuildURL) ClearTagged(tags map[string]struct{}) {
}

func (m *GPUDriver) Matches(o *GPUDriver, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !m.Key.Matches(&o.Key, fopts...) {
		return false
	}
	if !opts.Filter || o.Builds != nil {
		if len(m.Builds) == 0 && len(o.Builds) > 0 || len(m.Builds) > 0 && len(o.Builds) == 0 {
			return false
		} else if m.Builds != nil && o.Builds != nil {
			if !opts.Filter && len(m.Builds) != len(o.Builds) {
				return false
			}
		}
	}
	if !opts.Filter || o.LicenseConfig != "" {
		if o.LicenseConfig != m.LicenseConfig {
			return false
		}
	}
	if !opts.Filter || o.LicenseConfigMd5Sum != "" {
		if o.LicenseConfigMd5Sum != m.LicenseConfigMd5Sum {
			return false
		}
	}
	if !opts.Filter || o.Properties != nil {
		if len(m.Properties) == 0 && len(o.Properties) > 0 || len(m.Properties) > 0 && len(o.Properties) == 0 {
			return false
		} else if m.Properties != nil && o.Properties != nil {
			if !opts.Filter && len(m.Properties) != len(o.Properties) {
				return false
			}
			for k, _ := range o.Properties {
				_, ok := m.Properties[k]
				if !ok {
					return false
				}
				if o.Properties[k] != m.Properties[k] {
					return false
				}
			}
		}
	}
	if !opts.Filter || o.State != "" {
		if o.State != m.State {
			return false
		}
	}
	if !opts.Filter || o.IgnoreState != false {
		if o.IgnoreState != m.IgnoreState {
			return false
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.DeletePrepare != false {
			if o.DeletePrepare != m.DeletePrepare {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.StorageBucketName != "" {
			if o.StorageBucketName != m.StorageBucketName {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.LicenseConfigStoragePath != "" {
			if o.LicenseConfigStoragePath != m.LicenseConfigStoragePath {
				return false
			}
		}
	}
	return true
}

const GPUDriverFieldKey = "2"
const GPUDriverFieldKeyName = "2.1"
const GPUDriverFieldKeyOrganization = "2.2"
const GPUDriverFieldBuilds = "3"
const GPUDriverFieldBuildsName = "3.1"
const GPUDriverFieldBuildsDriverPath = "3.2"
const GPUDriverFieldBuildsDriverPathCreds = "3.3"
const GPUDriverFieldBuildsOperatingSystem = "3.4"
const GPUDriverFieldBuildsKernelVersion = "3.5"
const GPUDriverFieldBuildsHypervisorInfo = "3.6"
const GPUDriverFieldBuildsMd5Sum = "3.7"
const GPUDriverFieldBuildsStoragePath = "3.8"
const GPUDriverFieldLicenseConfig = "4"
const GPUDriverFieldLicenseConfigMd5Sum = "5"
const GPUDriverFieldProperties = "6"
const GPUDriverFieldPropertiesKey = "6.1"
const GPUDriverFieldPropertiesValue = "6.2"
const GPUDriverFieldState = "7"
const GPUDriverFieldIgnoreState = "8"
const GPUDriverFieldDeletePrepare = "9"
const GPUDriverFieldStorageBucketName = "10"
const GPUDriverFieldLicenseConfigStoragePath = "11"

var GPUDriverAllFields = []string{
	GPUDriverFieldKeyName,
	GPUDriverFieldKeyOrganization,
	GPUDriverFieldBuildsName,
	GPUDriverFieldBuildsDriverPath,
	GPUDriverFieldBuildsDriverPathCreds,
	GPUDriverFieldBuildsOperatingSystem,
	GPUDriverFieldBuildsKernelVersion,
	GPUDriverFieldBuildsHypervisorInfo,
	GPUDriverFieldBuildsMd5Sum,
	GPUDriverFieldBuildsStoragePath,
	GPUDriverFieldLicenseConfig,
	GPUDriverFieldLicenseConfigMd5Sum,
	GPUDriverFieldPropertiesKey,
	GPUDriverFieldPropertiesValue,
	GPUDriverFieldState,
	GPUDriverFieldIgnoreState,
	GPUDriverFieldDeletePrepare,
	GPUDriverFieldStorageBucketName,
	GPUDriverFieldLicenseConfigStoragePath,
}

var GPUDriverAllFieldsMap = map[string]struct{}{
	GPUDriverFieldKeyName:                  struct{}{},
	GPUDriverFieldKeyOrganization:          struct{}{},
	GPUDriverFieldBuildsName:               struct{}{},
	GPUDriverFieldBuildsDriverPath:         struct{}{},
	GPUDriverFieldBuildsDriverPathCreds:    struct{}{},
	GPUDriverFieldBuildsOperatingSystem:    struct{}{},
	GPUDriverFieldBuildsKernelVersion:      struct{}{},
	GPUDriverFieldBuildsHypervisorInfo:     struct{}{},
	GPUDriverFieldBuildsMd5Sum:             struct{}{},
	GPUDriverFieldBuildsStoragePath:        struct{}{},
	GPUDriverFieldLicenseConfig:            struct{}{},
	GPUDriverFieldLicenseConfigMd5Sum:      struct{}{},
	GPUDriverFieldPropertiesKey:            struct{}{},
	GPUDriverFieldPropertiesValue:          struct{}{},
	GPUDriverFieldState:                    struct{}{},
	GPUDriverFieldIgnoreState:              struct{}{},
	GPUDriverFieldDeletePrepare:            struct{}{},
	GPUDriverFieldStorageBucketName:        struct{}{},
	GPUDriverFieldLicenseConfigStoragePath: struct{}{},
}

var GPUDriverAllFieldsStringMap = map[string]string{
	GPUDriverFieldKeyName:                  "Key Name",
	GPUDriverFieldKeyOrganization:          "Key Organization",
	GPUDriverFieldBuildsName:               "Builds Name",
	GPUDriverFieldBuildsDriverPath:         "Builds Driver Path",
	GPUDriverFieldBuildsDriverPathCreds:    "Builds Driver Path Creds",
	GPUDriverFieldBuildsOperatingSystem:    "Builds Operating System",
	GPUDriverFieldBuildsKernelVersion:      "Builds Kernel Version",
	GPUDriverFieldBuildsHypervisorInfo:     "Builds Hypervisor Info",
	GPUDriverFieldBuildsMd5Sum:             "Builds Md5 Sum",
	GPUDriverFieldBuildsStoragePath:        "Builds Storage Path",
	GPUDriverFieldLicenseConfig:            "License Config",
	GPUDriverFieldLicenseConfigMd5Sum:      "License Config Md5 Sum",
	GPUDriverFieldPropertiesKey:            "Properties Key",
	GPUDriverFieldPropertiesValue:          "Properties Value",
	GPUDriverFieldState:                    "State",
	GPUDriverFieldIgnoreState:              "Ignore State",
	GPUDriverFieldDeletePrepare:            "Delete Prepare",
	GPUDriverFieldStorageBucketName:        "Storage Bucket Name",
	GPUDriverFieldLicenseConfigStoragePath: "License Config Storage Path",
}

func (m *GPUDriver) IsKeyField(s string) bool {
	return strings.HasPrefix(s, GPUDriverFieldKey+".") || s == GPUDriverFieldKey
}

func (m *GPUDriver) DiffFields(o *GPUDriver, fields map[string]struct{}) {
	if m.Key.Name != o.Key.Name {
		fields[GPUDriverFieldKeyName] = struct{}{}
		fields[GPUDriverFieldKey] = struct{}{}
	}
	if m.Key.Organization != o.Key.Organization {
		fields[GPUDriverFieldKeyOrganization] = struct{}{}
		fields[GPUDriverFieldKey] = struct{}{}
	}
	if len(m.Builds) != len(o.Builds) {
		fields[GPUDriverFieldBuilds] = struct{}{}
	} else {
		for i0 := 0; i0 < len(m.Builds); i0++ {
			if m.Builds[i0].Name != o.Builds[i0].Name {
				fields[GPUDriverFieldBuildsName] = struct{}{}
				fields[GPUDriverFieldBuilds] = struct{}{}
			}
			if m.Builds[i0].DriverPath != o.Builds[i0].DriverPath {
				fields[GPUDriverFieldBuildsDriverPath] = struct{}{}
				fields[GPUDriverFieldBuilds] = struct{}{}
			}
			if m.Builds[i0].DriverPathCreds != o.Builds[i0].DriverPathCreds {
				fields[GPUDriverFieldBuildsDriverPathCreds] = struct{}{}
				fields[GPUDriverFieldBuilds] = struct{}{}
			}
			if m.Builds[i0].OperatingSystem != o.Builds[i0].OperatingSystem {
				fields[GPUDriverFieldBuildsOperatingSystem] = struct{}{}
				fields[GPUDriverFieldBuilds] = struct{}{}
			}
			if m.Builds[i0].KernelVersion != o.Builds[i0].KernelVersion {
				fields[GPUDriverFieldBuildsKernelVersion] = struct{}{}
				fields[GPUDriverFieldBuilds] = struct{}{}
			}
			if m.Builds[i0].HypervisorInfo != o.Builds[i0].HypervisorInfo {
				fields[GPUDriverFieldBuildsHypervisorInfo] = struct{}{}
				fields[GPUDriverFieldBuilds] = struct{}{}
			}
			if m.Builds[i0].Md5Sum != o.Builds[i0].Md5Sum {
				fields[GPUDriverFieldBuildsMd5Sum] = struct{}{}
				fields[GPUDriverFieldBuilds] = struct{}{}
			}
			if m.Builds[i0].StoragePath != o.Builds[i0].StoragePath {
				fields[GPUDriverFieldBuildsStoragePath] = struct{}{}
				fields[GPUDriverFieldBuilds] = struct{}{}
			}
		}
	}
	if m.LicenseConfig != o.LicenseConfig {
		fields[GPUDriverFieldLicenseConfig] = struct{}{}
	}
	if m.LicenseConfigMd5Sum != o.LicenseConfigMd5Sum {
		fields[GPUDriverFieldLicenseConfigMd5Sum] = struct{}{}
	}
	if m.Properties != nil && o.Properties != nil {
		if len(m.Properties) != len(o.Properties) {
			fields[GPUDriverFieldProperties] = struct{}{}
		} else {
			for k0, _ := range m.Properties {
				_, vok0 := o.Properties[k0]
				if !vok0 {
					fields[GPUDriverFieldProperties] = struct{}{}
				} else {
					if m.Properties[k0] != o.Properties[k0] {
						fields[GPUDriverFieldProperties] = struct{}{}
						break
					}
				}
			}
		}
	} else if (m.Properties != nil && o.Properties == nil) || (m.Properties == nil && o.Properties != nil) {
		fields[GPUDriverFieldProperties] = struct{}{}
	}
	if m.State != o.State {
		fields[GPUDriverFieldState] = struct{}{}
	}
	if m.IgnoreState != o.IgnoreState {
		fields[GPUDriverFieldIgnoreState] = struct{}{}
	}
	if m.DeletePrepare != o.DeletePrepare {
		fields[GPUDriverFieldDeletePrepare] = struct{}{}
	}
	if m.StorageBucketName != o.StorageBucketName {
		fields[GPUDriverFieldStorageBucketName] = struct{}{}
	}
	if m.LicenseConfigStoragePath != o.LicenseConfigStoragePath {
		fields[GPUDriverFieldLicenseConfigStoragePath] = struct{}{}
	}
}

var UpdateGPUDriverFieldsMap = map[string]struct{}{
	GPUDriverFieldLicenseConfig:   struct{}{},
	GPUDriverFieldProperties:      struct{}{},
	GPUDriverFieldPropertiesKey:   struct{}{},
	GPUDriverFieldPropertiesValue: struct{}{},
}

func (m *GPUDriver) ValidateUpdateFields() error {
	if m.Fields == nil {
		return fmt.Errorf("nothing specified to update")
	}
	fmap := MakeFieldMap(m.Fields)
	badFieldStrs := []string{}
	for field, _ := range fmap {
		if m.IsKeyField(field) {
			continue
		}
		if _, ok := UpdateGPUDriverFieldsMap[field]; !ok {
			if _, ok := GPUDriverAllFieldsStringMap[field]; !ok {
				continue
			}
			badFieldStrs = append(badFieldStrs, GPUDriverAllFieldsStringMap[field])
		}
	}
	if len(badFieldStrs) > 0 {
		return fmt.Errorf("specified field(s) %s cannot be modified", strings.Join(badFieldStrs, ","))
	}
	return nil
}

func (m *GPUDriver) Clone() *GPUDriver {
	cp := &GPUDriver{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *GPUDriver) AddBuilds(vals ...GPUDriverBuild) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.Builds {
		cur[v.String()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.String()]; found {
			continue // duplicate
		}
		m.Builds = append(m.Builds, v)
		changes++
	}
	return changes
}

func (m *GPUDriver) RemoveBuilds(vals ...GPUDriverBuild) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.String()] = struct{}{}
	}
	for i := len(m.Builds); i >= 0; i-- {
		if _, found := remove[m.Builds[i].String()]; found {
			m.Builds = append(m.Builds[:i], m.Builds[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *GPUDriver) CopyInFields(src *GPUDriver) int {
	updateListAction := "replace"
	changed := 0
	fmap := MakeFieldMap(src.Fields)
	if _, set := fmap["2"]; set {
		if _, set := fmap["2.1"]; set {
			if m.Key.Name != src.Key.Name {
				m.Key.Name = src.Key.Name
				changed++
			}
		}
		if _, set := fmap["2.2"]; set {
			if m.Key.Organization != src.Key.Organization {
				m.Key.Organization = src.Key.Organization
				changed++
			}
		}
	}
	if _, set := fmap["3"]; set {
		if src.Builds != nil {
			if updateListAction == "add" {
				changed += m.AddBuilds(src.Builds...)
			} else if updateListAction == "remove" {
				changed += m.RemoveBuilds(src.Builds...)
			} else {
				m.Builds = make([]GPUDriverBuild, 0)
				for k0, _ := range src.Builds {
					m.Builds = append(m.Builds, *src.Builds[k0].Clone())
				}
				changed++
			}
		} else if m.Builds != nil {
			m.Builds = nil
			changed++
		}
	}
	if _, set := fmap["4"]; set {
		if m.LicenseConfig != src.LicenseConfig {
			m.LicenseConfig = src.LicenseConfig
			changed++
		}
	}
	if _, set := fmap["5"]; set {
		if m.LicenseConfigMd5Sum != src.LicenseConfigMd5Sum {
			m.LicenseConfigMd5Sum = src.LicenseConfigMd5Sum
			changed++
		}
	}
	if _, set := fmap["6"]; set {
		if src.Properties != nil {
			if updateListAction == "add" {
				for k0, v := range src.Properties {
					m.Properties[k0] = v
					changed++
				}
			} else if updateListAction == "remove" {
				for k0, _ := range src.Properties {
					if _, ok := m.Properties[k0]; ok {
						delete(m.Properties, k0)
						changed++
					}
				}
			} else {
				m.Properties = make(map[string]string)
				for k0, v := range src.Properties {
					m.Properties[k0] = v
				}
				changed++
			}
		} else if m.Properties != nil {
			m.Properties = nil
			changed++
		}
	}
	if _, set := fmap["7"]; set {
		if m.State != src.State {
			m.State = src.State
			changed++
		}
	}
	if _, set := fmap["8"]; set {
		if m.IgnoreState != src.IgnoreState {
			m.IgnoreState = src.IgnoreState
			changed++
		}
	}
	if _, set := fmap["9"]; set {
		if m.DeletePrepare != src.DeletePrepare {
			m.DeletePrepare = src.DeletePrepare
			changed++
		}
	}
	if _, set := fmap["10"]; set {
		if m.StorageBucketName != src.StorageBucketName {
			m.StorageBucketName = src.StorageBucketName
			changed++
		}
	}
	if _, set := fmap["11"]; set {
		if m.LicenseConfigStoragePath != src.LicenseConfigStoragePath {
			m.LicenseConfigStoragePath = src.LicenseConfigStoragePath
			changed++
		}
	}
	return changed
}

func (m *GPUDriver) DeepCopyIn(src *GPUDriver) {
	m.Key.DeepCopyIn(&src.Key)
	if src.Builds != nil {
		m.Builds = make([]GPUDriverBuild, len(src.Builds), len(src.Builds))
		for ii, s := range src.Builds {
			m.Builds[ii].DeepCopyIn(&s)
		}
	} else {
		m.Builds = nil
	}
	m.LicenseConfig = src.LicenseConfig
	m.LicenseConfigMd5Sum = src.LicenseConfigMd5Sum
	if src.Properties != nil {
		m.Properties = make(map[string]string)
		for k, v := range src.Properties {
			m.Properties[k] = v
		}
	} else {
		m.Properties = nil
	}
	m.State = src.State
	m.IgnoreState = src.IgnoreState
	m.DeletePrepare = src.DeletePrepare
	m.StorageBucketName = src.StorageBucketName
	m.LicenseConfigStoragePath = src.LicenseConfigStoragePath
}

func (s *GPUDriver) HasFields() bool {
	return true
}

type GPUDriverStore interface {
	Create(ctx context.Context, m *GPUDriver, wait func(int64)) (*Result, error)
	Update(ctx context.Context, m *GPUDriver, wait func(int64)) (*Result, error)
	Delete(ctx context.Context, m *GPUDriver, wait func(int64)) (*Result, error)
	Put(ctx context.Context, m *GPUDriver, wait func(int64), ops ...objstore.KVOp) (*Result, error)
	LoadOne(key string) (*GPUDriver, int64, error)
	Get(ctx context.Context, key *GPUDriverKey, buf *GPUDriver) bool
	STMGet(stm concurrency.STM, key *GPUDriverKey, buf *GPUDriver) bool
	STMPut(stm concurrency.STM, obj *GPUDriver, ops ...objstore.KVOp)
	STMDel(stm concurrency.STM, key *GPUDriverKey)
	STMHas(stm concurrency.STM, key *GPUDriverKey) bool
}

type GPUDriverStoreImpl struct {
	kvstore objstore.KVStore
}

func NewGPUDriverStore(kvstore objstore.KVStore) *GPUDriverStoreImpl {
	return &GPUDriverStoreImpl{kvstore: kvstore}
}

func (s *GPUDriverStoreImpl) Create(ctx context.Context, m *GPUDriver, wait func(int64)) (*Result, error) {
	err := m.Validate(GPUDriverAllFieldsMap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("GPUDriver", m.GetKey())
	val, err := json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Create(ctx, key, string(val))
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *GPUDriverStoreImpl) Update(ctx context.Context, m *GPUDriver, wait func(int64)) (*Result, error) {
	fmap := MakeFieldMap(m.Fields)
	err := m.Validate(fmap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("GPUDriver", m.GetKey())
	var vers int64 = 0
	curBytes, vers, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, err
	}
	var cur GPUDriver
	err = json.Unmarshal(curBytes, &cur)
	if err != nil {
		return nil, err
	}
	cur.CopyInFields(m)
	// never save fields
	cur.Fields = nil
	val, err := json.Marshal(cur)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Update(ctx, key, string(val), vers)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *GPUDriverStoreImpl) Put(ctx context.Context, m *GPUDriver, wait func(int64), ops ...objstore.KVOp) (*Result, error) {
	err := m.Validate(GPUDriverAllFieldsMap)
	m.Fields = nil
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("GPUDriver", m.GetKey())
	var val []byte
	val, err = json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Put(ctx, key, string(val), ops...)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *GPUDriverStoreImpl) Delete(ctx context.Context, m *GPUDriver, wait func(int64)) (*Result, error) {
	err := m.GetKey().ValidateKey()
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("GPUDriver", m.GetKey())
	rev, err := s.kvstore.Delete(ctx, key)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *GPUDriverStoreImpl) LoadOne(key string) (*GPUDriver, int64, error) {
	val, rev, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, 0, err
	}
	var obj GPUDriver
	err = json.Unmarshal(val, &obj)
	if err != nil {
		log.DebugLog(log.DebugLevelApi, "Failed to parse GPUDriver data", "val", string(val), "err", err)
		return nil, 0, err
	}
	return &obj, rev, nil
}

func (s *GPUDriverStoreImpl) Get(ctx context.Context, key *GPUDriverKey, buf *GPUDriver) bool {
	keystr := objstore.DbKeyString("GPUDriver", key)
	val, _, _, err := s.kvstore.Get(keystr)
	if err != nil {
		return false
	}
	return s.parseGetData(val, buf)
}

func (s *GPUDriverStoreImpl) STMGet(stm concurrency.STM, key *GPUDriverKey, buf *GPUDriver) bool {
	keystr := objstore.DbKeyString("GPUDriver", key)
	valstr := stm.Get(keystr)
	return s.parseGetData([]byte(valstr), buf)
}

func (s *GPUDriverStoreImpl) STMHas(stm concurrency.STM, key *GPUDriverKey) bool {
	keystr := objstore.DbKeyString("GPUDriver", key)
	return stm.Get(keystr) != ""
}

func (s *GPUDriverStoreImpl) parseGetData(val []byte, buf *GPUDriver) bool {
	if len(val) == 0 {
		return false
	}
	if buf != nil {
		// clear buf, because empty values in val won't
		// overwrite non-empty values in buf.
		*buf = GPUDriver{}
		err := json.Unmarshal(val, buf)
		if err != nil {
			return false
		}
	}
	return true
}

func (s *GPUDriverStoreImpl) STMPut(stm concurrency.STM, obj *GPUDriver, ops ...objstore.KVOp) {
	keystr := objstore.DbKeyString("GPUDriver", obj.GetKey())

	val, err := json.Marshal(obj)
	if err != nil {
		log.InfoLog("GPUDriver json marshal failed", "obj", obj, "err", err)
	}
	v3opts := GetSTMOpts(ops...)
	stm.Put(keystr, string(val), v3opts...)
}

func (s *GPUDriverStoreImpl) STMDel(stm concurrency.STM, key *GPUDriverKey) {
	keystr := objstore.DbKeyString("GPUDriver", key)
	stm.Del(keystr)
}

type GPUDriverKeyWatcher struct {
	cb func(ctx context.Context)
}

type GPUDriverCacheData struct {
	Obj    *GPUDriver
	ModRev int64
}

func (s *GPUDriverCacheData) Clone() *GPUDriverCacheData {
	cp := GPUDriverCacheData{}
	if s.Obj != nil {
		cp.Obj = &GPUDriver{}
		cp.Obj.DeepCopyIn(s.Obj)
	}
	cp.ModRev = s.ModRev
	return &cp
}

// GPUDriverCache caches GPUDriver objects in memory in a hash table
// and keeps them in sync with the database.
type GPUDriverCache struct {
	Objs          map[GPUDriverKey]*GPUDriverCacheData
	Mux           util.Mutex
	List          map[GPUDriverKey]struct{}
	FlushAll      bool
	NotifyCbs     []func(ctx context.Context, obj *GPUDriver, modRev int64)
	UpdatedCbs    []func(ctx context.Context, old *GPUDriver, new *GPUDriver)
	DeletedCbs    []func(ctx context.Context, old *GPUDriver)
	KeyWatchers   map[GPUDriverKey][]*GPUDriverKeyWatcher
	UpdatedKeyCbs []func(ctx context.Context, key *GPUDriverKey)
	DeletedKeyCbs []func(ctx context.Context, key *GPUDriverKey)
}

func NewGPUDriverCache() *GPUDriverCache {
	cache := GPUDriverCache{}
	InitGPUDriverCache(&cache)
	return &cache
}

func InitGPUDriverCache(cache *GPUDriverCache) {
	cache.Objs = make(map[GPUDriverKey]*GPUDriverCacheData)
	cache.KeyWatchers = make(map[GPUDriverKey][]*GPUDriverKeyWatcher)
	cache.NotifyCbs = nil
	cache.UpdatedCbs = nil
	cache.DeletedCbs = nil
	cache.UpdatedKeyCbs = nil
	cache.DeletedKeyCbs = nil
}

func (c *GPUDriverCache) GetTypeString() string {
	return "GPUDriver"
}

func (c *GPUDriverCache) Get(key *GPUDriverKey, valbuf *GPUDriver) bool {
	var modRev int64
	return c.GetWithRev(key, valbuf, &modRev)
}

func (c *GPUDriverCache) GetWithRev(key *GPUDriverKey, valbuf *GPUDriver, modRev *int64) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	inst, found := c.Objs[*key]
	if found {
		valbuf.DeepCopyIn(inst.Obj)
		*modRev = inst.ModRev
	}
	return found
}

func (c *GPUDriverCache) HasKey(key *GPUDriverKey) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	_, found := c.Objs[*key]
	return found
}

func (c *GPUDriverCache) GetAllKeys(ctx context.Context, cb func(key *GPUDriverKey, modRev int64)) {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for key, data := range c.Objs {
		cb(&key, data.ModRev)
	}
}

func (c *GPUDriverCache) GetAllLocked(ctx context.Context, cb func(obj *GPUDriver, modRev int64)) {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for _, data := range c.Objs {
		cb(data.Obj, data.ModRev)
	}
}

func (c *GPUDriverCache) Update(ctx context.Context, in *GPUDriver, modRev int64) {
	c.UpdateModFunc(ctx, in.GetKey(), modRev, func(old *GPUDriver) (*GPUDriver, bool) {
		return in, true
	})
}

func (c *GPUDriverCache) UpdateModFunc(ctx context.Context, key *GPUDriverKey, modRev int64, modFunc func(old *GPUDriver) (new *GPUDriver, changed bool)) {
	c.Mux.Lock()
	var old *GPUDriver
	if oldData, found := c.Objs[*key]; found {
		old = oldData.Obj
	}
	new, changed := modFunc(old)
	if !changed {
		c.Mux.Unlock()
		return
	}
	if len(c.UpdatedCbs) > 0 || len(c.NotifyCbs) > 0 {
		newCopy := &GPUDriver{}
		newCopy.DeepCopyIn(new)
		for _, cb := range c.UpdatedCbs {
			defer cb(ctx, old, newCopy)
		}
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				defer cb(ctx, newCopy, modRev)
			}
		}
	}
	for _, cb := range c.UpdatedKeyCbs {
		defer cb(ctx, key)
	}
	store := &GPUDriver{}
	store.DeepCopyIn(new)
	c.Objs[new.GetKeyVal()] = &GPUDriverCacheData{
		Obj:    store,
		ModRev: modRev,
	}
	log.SpanLog(ctx, log.DebugLevelApi, "cache update", "new", store)
	c.Mux.Unlock()
	c.TriggerKeyWatchers(ctx, new.GetKey())
}

func (c *GPUDriverCache) Delete(ctx context.Context, in *GPUDriver, modRev int64) {
	c.DeleteCondFunc(ctx, in, modRev, func(old *GPUDriver) bool {
		return true
	})
}

func (c *GPUDriverCache) DeleteCondFunc(ctx context.Context, in *GPUDriver, modRev int64, condFunc func(old *GPUDriver) bool) {
	c.Mux.Lock()
	var old *GPUDriver
	oldData, found := c.Objs[in.GetKeyVal()]
	if found {
		old = oldData.Obj
		if !condFunc(old) {
			c.Mux.Unlock()
			return
		}
	}
	delete(c.Objs, in.GetKeyVal())
	log.SpanLog(ctx, log.DebugLevelApi, "cache delete", "key", in.GetKeyVal())
	c.Mux.Unlock()
	obj := old
	if obj == nil {
		obj = in
	}
	for _, cb := range c.NotifyCbs {
		if cb != nil {
			cb(ctx, obj, modRev)
		}
	}
	if old != nil {
		for _, cb := range c.DeletedCbs {
			cb(ctx, old)
		}
	}
	for _, cb := range c.DeletedKeyCbs {
		cb(ctx, in.GetKey())
	}
	c.TriggerKeyWatchers(ctx, in.GetKey())
}

func (c *GPUDriverCache) Prune(ctx context.Context, validKeys map[GPUDriverKey]struct{}) {
	log.SpanLog(ctx, log.DebugLevelApi, "Prune GPUDriver", "numValidKeys", len(validKeys))
	notify := make(map[GPUDriverKey]*GPUDriverCacheData)
	c.Mux.Lock()
	for key, _ := range c.Objs {
		if _, ok := validKeys[key]; !ok {
			if len(c.NotifyCbs) > 0 || len(c.DeletedKeyCbs) > 0 || len(c.DeletedCbs) > 0 {
				notify[key] = c.Objs[key]
			}
			delete(c.Objs, key)
		}
	}
	c.Mux.Unlock()
	for key, old := range notify {
		obj := old.Obj
		if obj == nil {
			obj = &GPUDriver{}
			obj.SetKey(&key)
		}
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, obj, old.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if old.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, old.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (c *GPUDriverCache) GetCount() int {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	return len(c.Objs)
}

func (c *GPUDriverCache) Flush(ctx context.Context, notifyId int64) {
}

func (c *GPUDriverCache) Show(filter *GPUDriver, cb func(ret *GPUDriver) error) error {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for _, data := range c.Objs {
		if !data.Obj.Matches(filter, MatchFilter()) {
			continue
		}
		err := cb(data.Obj)
		if err != nil {
			return err
		}
	}
	return nil
}

func GPUDriverGenericNotifyCb(fn func(key *GPUDriverKey, old *GPUDriver)) func(objstore.ObjKey, objstore.Obj) {
	return func(objkey objstore.ObjKey, obj objstore.Obj) {
		fn(objkey.(*GPUDriverKey), obj.(*GPUDriver))
	}
}

func (c *GPUDriverCache) SetNotifyCb(fn func(ctx context.Context, obj *GPUDriver, modRev int64)) {
	c.NotifyCbs = []func(ctx context.Context, obj *GPUDriver, modRev int64){fn}
}

func (c *GPUDriverCache) SetUpdatedCb(fn func(ctx context.Context, old *GPUDriver, new *GPUDriver)) {
	c.UpdatedCbs = []func(ctx context.Context, old *GPUDriver, new *GPUDriver){fn}
}

func (c *GPUDriverCache) SetDeletedCb(fn func(ctx context.Context, old *GPUDriver)) {
	c.DeletedCbs = []func(ctx context.Context, old *GPUDriver){fn}
}

func (c *GPUDriverCache) SetUpdatedKeyCb(fn func(ctx context.Context, key *GPUDriverKey)) {
	c.UpdatedKeyCbs = []func(ctx context.Context, key *GPUDriverKey){fn}
}

func (c *GPUDriverCache) SetDeletedKeyCb(fn func(ctx context.Context, key *GPUDriverKey)) {
	c.DeletedKeyCbs = []func(ctx context.Context, key *GPUDriverKey){fn}
}

func (c *GPUDriverCache) AddUpdatedCb(fn func(ctx context.Context, old *GPUDriver, new *GPUDriver)) {
	c.UpdatedCbs = append(c.UpdatedCbs, fn)
}

func (c *GPUDriverCache) AddDeletedCb(fn func(ctx context.Context, old *GPUDriver)) {
	c.DeletedCbs = append(c.DeletedCbs, fn)
}

func (c *GPUDriverCache) AddNotifyCb(fn func(ctx context.Context, obj *GPUDriver, modRev int64)) {
	c.NotifyCbs = append(c.NotifyCbs, fn)
}

func (c *GPUDriverCache) AddUpdatedKeyCb(fn func(ctx context.Context, key *GPUDriverKey)) {
	c.UpdatedKeyCbs = append(c.UpdatedKeyCbs, fn)
}

func (c *GPUDriverCache) AddDeletedKeyCb(fn func(ctx context.Context, key *GPUDriverKey)) {
	c.DeletedKeyCbs = append(c.DeletedKeyCbs, fn)
}

func (c *GPUDriverCache) SetFlushAll() {
	c.FlushAll = true
}

func (c *GPUDriverCache) WatchKey(key *GPUDriverKey, cb func(ctx context.Context)) context.CancelFunc {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	list, ok := c.KeyWatchers[*key]
	if !ok {
		list = make([]*GPUDriverKeyWatcher, 0)
	}
	watcher := GPUDriverKeyWatcher{cb: cb}
	c.KeyWatchers[*key] = append(list, &watcher)
	log.DebugLog(log.DebugLevelApi, "Watching GPUDriver", "key", key)
	return func() {
		c.Mux.Lock()
		defer c.Mux.Unlock()
		list, ok := c.KeyWatchers[*key]
		if !ok {
			return
		}
		for ii, _ := range list {
			if list[ii] != &watcher {
				continue
			}
			if len(list) == 1 {
				delete(c.KeyWatchers, *key)
				return
			}
			list[ii] = list[len(list)-1]
			list[len(list)-1] = nil
			c.KeyWatchers[*key] = list[:len(list)-1]
			return
		}
	}
}

func (c *GPUDriverCache) TriggerKeyWatchers(ctx context.Context, key *GPUDriverKey) {
	watchers := make([]*GPUDriverKeyWatcher, 0)
	c.Mux.Lock()
	if list, ok := c.KeyWatchers[*key]; ok {
		watchers = append(watchers, list...)
	}
	c.Mux.Unlock()
	for ii, _ := range watchers {
		watchers[ii].cb(ctx)
	}
}

// Note that we explicitly ignore the global revision number, because of the way
// the notify framework sends updates (by hashing keys and doing lookups, instead
// of sequentially through a history buffer), updates may be done out-of-order
// or multiple updates compressed into one update, so the state of the cache at
// any point in time may not by in sync with a particular database revision number.

func (c *GPUDriverCache) SyncUpdate(ctx context.Context, key, val []byte, rev, modRev int64) {
	obj := GPUDriver{}
	err := json.Unmarshal(val, &obj)
	if err != nil {
		log.WarnLog("Failed to parse GPUDriver data", "val", string(val), "err", err)
		return
	}
	c.Update(ctx, &obj, modRev)
	c.Mux.Lock()
	if c.List != nil {
		c.List[obj.GetKeyVal()] = struct{}{}
	}
	c.Mux.Unlock()
}

func (c *GPUDriverCache) SyncDelete(ctx context.Context, key []byte, rev, modRev int64) {
	obj := GPUDriver{}
	keystr := objstore.DbKeyPrefixRemove(string(key))
	GPUDriverKeyStringParse(keystr, obj.GetKey())
	c.Delete(ctx, &obj, modRev)
}

func (c *GPUDriverCache) SyncListStart(ctx context.Context) {
	c.List = make(map[GPUDriverKey]struct{})
}

func (c *GPUDriverCache) SyncListEnd(ctx context.Context) {
	deleted := make(map[GPUDriverKey]*GPUDriverCacheData)
	c.Mux.Lock()
	for key, val := range c.Objs {
		if _, found := c.List[key]; !found {
			deleted[key] = val
			delete(c.Objs, key)
		}
	}
	c.List = nil
	c.Mux.Unlock()
	for key, val := range deleted {
		obj := val.Obj
		if obj == nil {
			obj = &GPUDriver{}
			obj.SetKey(&key)
		}
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, obj, val.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if val.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, val.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (c *GPUDriverCache) UsesOrg(org string) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for key, _ := range c.Objs {
		if key.Organization == org {
			return true
		}
	}
	return false
}

func (m *GPUDriver) GetObjKey() objstore.ObjKey {
	return m.GetKey()
}

func (m *GPUDriver) GetKey() *GPUDriverKey {
	return &m.Key
}

func (m *GPUDriver) GetKeyVal() GPUDriverKey {
	return m.Key
}

func (m *GPUDriver) SetKey(key *GPUDriverKey) {
	m.Key = *key
}

func CmpSortGPUDriver(a GPUDriver, b GPUDriver) bool {
	return a.Key.GetKeyString() < b.Key.GetKeyString()
}
func (m *GPUDriverKey) StreamKey() string {
	return fmt.Sprintf("GPUDriverStreamKey: %s", m.String())
}

// Helper method to check that enums have valid values
// NOTE: ValidateEnums checks all Fields even if some are not set
func (m *GPUDriver) ValidateEnums() error {
	if err := m.Key.ValidateEnums(); err != nil {
		return err
	}
	for _, e := range m.Builds {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (s *GPUDriver) ClearTagged(tags map[string]struct{}) {
	s.Key.ClearTagged(tags)
	if s.Builds != nil {
		for ii := 0; ii < len(s.Builds); ii++ {
			s.Builds[ii].ClearTagged(tags)
		}
	}
}

func (m *GPUConfig) Clone() *GPUConfig {
	cp := &GPUConfig{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *GPUConfig) CopyInFields(src *GPUConfig) int {
	updateListAction := "replace"
	changed := 0
	if m.Driver.Name != src.Driver.Name {
		m.Driver.Name = src.Driver.Name
		changed++
	}
	if m.Driver.Organization != src.Driver.Organization {
		m.Driver.Organization = src.Driver.Organization
		changed++
	}
	if src.Properties != nil {
		if updateListAction == "add" {
			for k0, v := range src.Properties {
				m.Properties[k0] = v
				changed++
			}
		} else if updateListAction == "remove" {
			for k0, _ := range src.Properties {
				if _, ok := m.Properties[k0]; ok {
					delete(m.Properties, k0)
					changed++
				}
			}
		} else {
			m.Properties = make(map[string]string)
			for k0, v := range src.Properties {
				m.Properties[k0] = v
			}
			changed++
		}
	} else if m.Properties != nil {
		m.Properties = nil
		changed++
	}
	if m.LicenseConfig != src.LicenseConfig {
		m.LicenseConfig = src.LicenseConfig
		changed++
	}
	if m.LicenseConfigMd5Sum != src.LicenseConfigMd5Sum {
		m.LicenseConfigMd5Sum = src.LicenseConfigMd5Sum
		changed++
	}
	return changed
}

func (m *GPUConfig) DeepCopyIn(src *GPUConfig) {
	m.Driver.DeepCopyIn(&src.Driver)
	if src.Properties != nil {
		m.Properties = make(map[string]string)
		for k, v := range src.Properties {
			m.Properties[k] = v
		}
	} else {
		m.Properties = nil
	}
	m.LicenseConfig = src.LicenseConfig
	m.LicenseConfigMd5Sum = src.LicenseConfigMd5Sum
}

// Helper method to check that enums have valid values
func (m *GPUConfig) ValidateEnums() error {
	if err := m.Driver.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func (s *GPUConfig) ClearTagged(tags map[string]struct{}) {
	s.Driver.ClearTagged(tags)
}

func (m *Cloudlet) Matches(o *Cloudlet, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !m.Key.Matches(&o.Key, fopts...) {
		return false
	}
	if !opts.Filter || o.IpSupport != 0 {
		if o.IpSupport != m.IpSupport {
			return false
		}
	}
	if !opts.Filter || o.StaticIps != "" {
		if o.StaticIps != m.StaticIps {
			return false
		}
	}
	if !opts.Filter || o.NumDynamicIps != 0 {
		if o.NumDynamicIps != m.NumDynamicIps {
			return false
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.Errors != nil {
			if len(m.Errors) == 0 && len(o.Errors) > 0 || len(m.Errors) > 0 && len(o.Errors) == 0 {
				return false
			} else if m.Errors != nil && o.Errors != nil {
				if !opts.Filter && len(m.Errors) != len(o.Errors) {
					return false
				}
				found := 0
				for oIndex, _ := range o.Errors {
					for mIndex, _ := range m.Errors {
						if o.Errors[oIndex] == m.Errors[mIndex] {
							found++
							break
						}
					}
				}
				if found != len(o.Errors) {
					return false
				}
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.State != 0 {
			if o.State != m.State {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.CrmOverride != 0 {
			if o.CrmOverride != m.CrmOverride {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.DeploymentLocal != false {
			if o.DeploymentLocal != m.DeploymentLocal {
				return false
			}
		}
	}
	if !opts.Filter || o.PlatformType != "" {
		if o.PlatformType != m.PlatformType {
			return false
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.NotifySrvAddr != "" {
			if o.NotifySrvAddr != m.NotifySrvAddr {
				return false
			}
		}
	}
	if !m.Flavor.Matches(&o.Flavor, fopts...) {
		return false
	}
	if !opts.Filter || o.PhysicalName != "" {
		if o.PhysicalName != m.PhysicalName {
			return false
		}
	}
	if !opts.Filter || o.EnvVar != nil {
		if len(m.EnvVar) == 0 && len(o.EnvVar) > 0 || len(m.EnvVar) > 0 && len(o.EnvVar) == 0 {
			return false
		} else if m.EnvVar != nil && o.EnvVar != nil {
			if !opts.Filter && len(m.EnvVar) != len(o.EnvVar) {
				return false
			}
			for k, _ := range o.EnvVar {
				_, ok := m.EnvVar[k]
				if !ok {
					return false
				}
				if o.EnvVar[k] != m.EnvVar[k] {
					return false
				}
			}
		}
	}
	if !opts.Filter || o.ContainerVersion != "" {
		if o.ContainerVersion != m.ContainerVersion {
			return false
		}
	}
	if !opts.IgnoreBackend {
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.ResTagMap != nil {
			if len(m.ResTagMap) == 0 && len(o.ResTagMap) > 0 || len(m.ResTagMap) > 0 && len(o.ResTagMap) == 0 {
				return false
			} else if m.ResTagMap != nil && o.ResTagMap != nil {
				if !opts.Filter && len(m.ResTagMap) != len(o.ResTagMap) {
					return false
				}
				for k, _ := range o.ResTagMap {
					_, ok := m.ResTagMap[k]
					if !ok {
						return false
					}
					if !m.ResTagMap[k].Matches(o.ResTagMap[k], fopts...) {
						return false
					}
				}
			}
		}
	}
	if !opts.Filter || o.AccessVars != nil {
		if len(m.AccessVars) == 0 && len(o.AccessVars) > 0 || len(m.AccessVars) > 0 && len(o.AccessVars) == 0 {
			return false
		} else if m.AccessVars != nil && o.AccessVars != nil {
			if !opts.Filter && len(m.AccessVars) != len(o.AccessVars) {
				return false
			}
			for k, _ := range o.AccessVars {
				_, ok := m.AccessVars[k]
				if !ok {
					return false
				}
				if o.AccessVars[k] != m.AccessVars[k] {
					return false
				}
			}
		}
	}
	if !opts.Filter || o.VmImageVersion != "" {
		if o.VmImageVersion != m.VmImageVersion {
			return false
		}
	}
	if !opts.Filter || o.Deployment != "" {
		if o.Deployment != m.Deployment {
			return false
		}
	}
	if !opts.Filter || o.InfraApiAccess != 0 {
		if o.InfraApiAccess != m.InfraApiAccess {
			return false
		}
	}
	if !opts.Filter || o.MaintenanceState != 0 {
		if o.MaintenanceState != m.MaintenanceState {
			return false
		}
	}
	if !opts.Filter || o.OverridePolicyContainerVersion != false {
		if o.OverridePolicyContainerVersion != m.OverridePolicyContainerVersion {
			return false
		}
	}
	if !opts.Filter || o.VmPool != "" {
		if o.VmPool != m.VmPool {
			return false
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.CrmAccessPublicKey != "" {
			if o.CrmAccessPublicKey != m.CrmAccessPublicKey {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.CrmAccessKeyUpgradeRequired != false {
			if o.CrmAccessKeyUpgradeRequired != m.CrmAccessKeyUpgradeRequired {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
	}
	if !opts.IgnoreBackend {
	}
	if !opts.Filter || o.TrustPolicy != "" {
		if o.TrustPolicy != m.TrustPolicy {
			return false
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.TrustPolicyState != 0 {
			if o.TrustPolicyState != m.TrustPolicyState {
				return false
			}
		}
	}
	if !opts.Filter || o.ResourceQuotas != nil {
		if len(m.ResourceQuotas) == 0 && len(o.ResourceQuotas) > 0 || len(m.ResourceQuotas) > 0 && len(o.ResourceQuotas) == 0 {
			return false
		} else if m.ResourceQuotas != nil && o.ResourceQuotas != nil {
			if !opts.Filter && len(m.ResourceQuotas) != len(o.ResourceQuotas) {
				return false
			}
		}
	}
	if !opts.Filter || o.DefaultResourceAlertThreshold != 0 {
		if o.DefaultResourceAlertThreshold != m.DefaultResourceAlertThreshold {
			return false
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.HostController != "" {
			if o.HostController != m.HostController {
				return false
			}
		}
	}
	if !opts.Filter || o.KafkaCluster != "" {
		if o.KafkaCluster != m.KafkaCluster {
			return false
		}
	}
	if !opts.Filter || o.KafkaUser != "" {
		if o.KafkaUser != m.KafkaUser {
			return false
		}
	}
	if !opts.Filter || o.KafkaPassword != "" {
		if o.KafkaPassword != m.KafkaPassword {
			return false
		}
	}
	if !opts.Filter || o.EnableDefaultServerlessCluster != false {
		if o.EnableDefaultServerlessCluster != m.EnableDefaultServerlessCluster {
			return false
		}
	}
	if !opts.Filter || o.AllianceOrgs != nil {
		if len(m.AllianceOrgs) == 0 && len(o.AllianceOrgs) > 0 || len(m.AllianceOrgs) > 0 && len(o.AllianceOrgs) == 0 {
			return false
		} else if m.AllianceOrgs != nil && o.AllianceOrgs != nil {
			if !opts.Filter && len(m.AllianceOrgs) != len(o.AllianceOrgs) {
				return false
			}
			found := 0
			for oIndex, _ := range o.AllianceOrgs {
				for mIndex, _ := range m.AllianceOrgs {
					if o.AllianceOrgs[oIndex] == m.AllianceOrgs[mIndex] {
						found++
						break
					}
				}
			}
			if found != len(o.AllianceOrgs) {
				return false
			}
		}
	}
	if !opts.Filter || o.SingleKubernetesClusterOwner != "" {
		if o.SingleKubernetesClusterOwner != m.SingleKubernetesClusterOwner {
			return false
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.DeletePrepare != false {
			if o.DeletePrepare != m.DeletePrepare {
				return false
			}
		}
	}
	if !opts.Filter || o.PlatformHighAvailability != false {
		if o.PlatformHighAvailability != m.PlatformHighAvailability {
			return false
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.SecondaryCrmAccessPublicKey != "" {
			if o.SecondaryCrmAccessPublicKey != m.SecondaryCrmAccessPublicKey {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.SecondaryCrmAccessKeyUpgradeRequired != false {
			if o.SecondaryCrmAccessKeyUpgradeRequired != m.SecondaryCrmAccessKeyUpgradeRequired {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.SecondaryNotifySrvAddr != "" {
			if o.SecondaryNotifySrvAddr != m.SecondaryNotifySrvAddr {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.DnsLabel != "" {
			if o.DnsLabel != m.DnsLabel {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.RootLbFqdn != "" {
			if o.RootLbFqdn != m.RootLbFqdn {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.LicenseConfigStoragePath != "" {
			if o.LicenseConfigStoragePath != m.LicenseConfigStoragePath {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.InfraFlavors != nil {
			if len(m.InfraFlavors) == 0 && len(o.InfraFlavors) > 0 || len(m.InfraFlavors) > 0 && len(o.InfraFlavors) == 0 {
				return false
			} else if m.InfraFlavors != nil && o.InfraFlavors != nil {
				if !opts.Filter && len(m.InfraFlavors) != len(o.InfraFlavors) {
					return false
				}
			}
		}
	}
	if !opts.Filter || o.EdgeboxOnly != false {
		if o.EdgeboxOnly != m.EdgeboxOnly {
			return false
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.OnboardingState != 0 {
			if o.OnboardingState != m.OnboardingState {
				return false
			}
		}
	}
	return true
}

const CloudletFieldKey = "2"
const CloudletFieldKeyOrganization = "2.1"
const CloudletFieldKeyName = "2.2"
const CloudletFieldKeyFederatedOrganization = "2.3"
const CloudletFieldLocation = "5"
const CloudletFieldLocationLatitude = "5.1"
const CloudletFieldLocationLongitude = "5.2"
const CloudletFieldLocationHorizontalAccuracy = "5.3"
const CloudletFieldLocationVerticalAccuracy = "5.4"
const CloudletFieldLocationAltitude = "5.5"
const CloudletFieldLocationCourse = "5.6"
const CloudletFieldLocationSpeed = "5.7"
const CloudletFieldLocationTimestamp = "5.8"
const CloudletFieldLocationTimestampSeconds = "5.8.1"
const CloudletFieldLocationTimestampNanos = "5.8.2"
const CloudletFieldIpSupport = "6"
const CloudletFieldStaticIps = "7"
const CloudletFieldNumDynamicIps = "8"
const CloudletFieldTimeLimits = "9"
const CloudletFieldTimeLimitsCreateClusterInstTimeout = "9.1"
const CloudletFieldTimeLimitsUpdateClusterInstTimeout = "9.2"
const CloudletFieldTimeLimitsDeleteClusterInstTimeout = "9.3"
const CloudletFieldTimeLimitsCreateAppInstTimeout = "9.4"
const CloudletFieldTimeLimitsUpdateAppInstTimeout = "9.5"
const CloudletFieldTimeLimitsDeleteAppInstTimeout = "9.6"
const CloudletFieldErrors = "10"
const CloudletFieldState = "12"
const CloudletFieldCrmOverride = "13"
const CloudletFieldDeploymentLocal = "14"
const CloudletFieldPlatformType = "15"
const CloudletFieldNotifySrvAddr = "16"
const CloudletFieldFlavor = "17"
const CloudletFieldFlavorName = "17.1"
const CloudletFieldPhysicalName = "18"
const CloudletFieldEnvVar = "19"
const CloudletFieldEnvVarKey = "19.1"
const CloudletFieldEnvVarValue = "19.2"
const CloudletFieldContainerVersion = "20"
const CloudletFieldConfig = "21"
const CloudletFieldConfigContainerRegistryPath = "21.1"
const CloudletFieldConfigCloudletVmImagePath = "21.2"
const CloudletFieldConfigNotifyCtrlAddrs = "21.3"
const CloudletFieldConfigTlsCertFile = "21.5"
const CloudletFieldConfigEnvVar = "21.6"
const CloudletFieldConfigEnvVarKey = "21.6.1"
const CloudletFieldConfigEnvVarValue = "21.6.2"
const CloudletFieldConfigPlatformTag = "21.8"
const CloudletFieldConfigTestMode = "21.9"
const CloudletFieldConfigSpan = "21.10"
const CloudletFieldConfigCleanupMode = "21.11"
const CloudletFieldConfigRegion = "21.12"
const CloudletFieldConfigCommercialCerts = "21.13"
const CloudletFieldConfigUseVaultPki = "21.14"
const CloudletFieldConfigAppDnsRoot = "21.16"
const CloudletFieldConfigDeploymentTag = "21.19"
const CloudletFieldConfigTlsKeyFile = "21.20"
const CloudletFieldConfigTlsCaFile = "21.21"
const CloudletFieldConfigCrmAccessPrivateKey = "21.22"
const CloudletFieldConfigAccessApiAddr = "21.23"
const CloudletFieldConfigCacheDir = "21.24"
const CloudletFieldConfigSecondaryCrmAccessPrivateKey = "21.25"
const CloudletFieldConfigThanosRecvAddr = "21.26"
const CloudletFieldConfigAnsiblePublicAddr = "21.27"
const CloudletFieldConfigEnvoyWithCurlImage = "21.29"
const CloudletFieldConfigNginxWithCurlImage = "21.30"
const CloudletFieldResTagMap = "22"
const CloudletFieldResTagMapKey = "22.1"
const CloudletFieldResTagMapValue = "22.2"
const CloudletFieldResTagMapValueName = "22.2.1"
const CloudletFieldResTagMapValueOrganization = "22.2.2"
const CloudletFieldAccessVars = "23"
const CloudletFieldAccessVarsKey = "23.1"
const CloudletFieldAccessVarsValue = "23.2"
const CloudletFieldVmImageVersion = "24"
const CloudletFieldDeployment = "26"
const CloudletFieldInfraApiAccess = "27"
const CloudletFieldInfraConfig = "28"
const CloudletFieldInfraConfigExternalNetworkName = "28.1"
const CloudletFieldInfraConfigFlavorName = "28.2"
const CloudletFieldMaintenanceState = "30"
const CloudletFieldOverridePolicyContainerVersion = "31"
const CloudletFieldVmPool = "32"
const CloudletFieldCrmAccessPublicKey = "33"
const CloudletFieldCrmAccessKeyUpgradeRequired = "34"
const CloudletFieldCreatedAt = "35"
const CloudletFieldCreatedAtSeconds = "35.1"
const CloudletFieldCreatedAtNanos = "35.2"
const CloudletFieldUpdatedAt = "36"
const CloudletFieldUpdatedAtSeconds = "36.1"
const CloudletFieldUpdatedAtNanos = "36.2"
const CloudletFieldTrustPolicy = "37"
const CloudletFieldTrustPolicyState = "38"
const CloudletFieldResourceQuotas = "39"
const CloudletFieldResourceQuotasName = "39.1"
const CloudletFieldResourceQuotasValue = "39.2"
const CloudletFieldResourceQuotasAlertThreshold = "39.3"
const CloudletFieldDefaultResourceAlertThreshold = "40"
const CloudletFieldHostController = "41"
const CloudletFieldKafkaCluster = "42"
const CloudletFieldKafkaUser = "43"
const CloudletFieldKafkaPassword = "44"
const CloudletFieldGpuConfig = "45"
const CloudletFieldGpuConfigDriver = "45.1"
const CloudletFieldGpuConfigDriverName = "45.1.1"
const CloudletFieldGpuConfigDriverOrganization = "45.1.2"
const CloudletFieldGpuConfigProperties = "45.2"
const CloudletFieldGpuConfigPropertiesKey = "45.2.1"
const CloudletFieldGpuConfigPropertiesValue = "45.2.2"
const CloudletFieldGpuConfigLicenseConfig = "45.3"
const CloudletFieldGpuConfigLicenseConfigMd5Sum = "45.4"
const CloudletFieldEnableDefaultServerlessCluster = "46"
const CloudletFieldAllianceOrgs = "47"
const CloudletFieldSingleKubernetesClusterOwner = "48"
const CloudletFieldDeletePrepare = "49"
const CloudletFieldPlatformHighAvailability = "50"
const CloudletFieldSecondaryCrmAccessPublicKey = "51"
const CloudletFieldSecondaryCrmAccessKeyUpgradeRequired = "52"
const CloudletFieldSecondaryNotifySrvAddr = "53"
const CloudletFieldDnsLabel = "54"
const CloudletFieldRootLbFqdn = "55"
const CloudletFieldFederationConfig = "56"
const CloudletFieldFederationConfigFederationContextId = "56.1"
const CloudletFieldFederationConfigPartnerFederationAddr = "56.2"
const CloudletFieldFederationConfigFederationDbId = "56.3"
const CloudletFieldFederationConfigFederationName = "56.4"
const CloudletFieldLicenseConfigStoragePath = "57"
const CloudletFieldInfraFlavors = "58"
const CloudletFieldInfraFlavorsName = "58.1"
const CloudletFieldInfraFlavorsVcpus = "58.2"
const CloudletFieldInfraFlavorsRam = "58.3"
const CloudletFieldInfraFlavorsDisk = "58.4"
const CloudletFieldInfraFlavorsPropMap = "58.5"
const CloudletFieldInfraFlavorsPropMapKey = "58.5.1"
const CloudletFieldInfraFlavorsPropMapValue = "58.5.2"
const CloudletFieldEdgeboxOnly = "59"
const CloudletFieldOnboardingState = "60"

var CloudletAllFields = []string{
	CloudletFieldKeyOrganization,
	CloudletFieldKeyName,
	CloudletFieldKeyFederatedOrganization,
	CloudletFieldLocationLatitude,
	CloudletFieldLocationLongitude,
	CloudletFieldLocationHorizontalAccuracy,
	CloudletFieldLocationVerticalAccuracy,
	CloudletFieldLocationAltitude,
	CloudletFieldLocationCourse,
	CloudletFieldLocationSpeed,
	CloudletFieldLocationTimestampSeconds,
	CloudletFieldLocationTimestampNanos,
	CloudletFieldIpSupport,
	CloudletFieldStaticIps,
	CloudletFieldNumDynamicIps,
	CloudletFieldTimeLimitsCreateClusterInstTimeout,
	CloudletFieldTimeLimitsUpdateClusterInstTimeout,
	CloudletFieldTimeLimitsDeleteClusterInstTimeout,
	CloudletFieldTimeLimitsCreateAppInstTimeout,
	CloudletFieldTimeLimitsUpdateAppInstTimeout,
	CloudletFieldTimeLimitsDeleteAppInstTimeout,
	CloudletFieldErrors,
	CloudletFieldState,
	CloudletFieldCrmOverride,
	CloudletFieldDeploymentLocal,
	CloudletFieldPlatformType,
	CloudletFieldNotifySrvAddr,
	CloudletFieldFlavorName,
	CloudletFieldPhysicalName,
	CloudletFieldEnvVarKey,
	CloudletFieldEnvVarValue,
	CloudletFieldContainerVersion,
	CloudletFieldConfigContainerRegistryPath,
	CloudletFieldConfigCloudletVmImagePath,
	CloudletFieldConfigNotifyCtrlAddrs,
	CloudletFieldConfigTlsCertFile,
	CloudletFieldConfigEnvVarKey,
	CloudletFieldConfigEnvVarValue,
	CloudletFieldConfigPlatformTag,
	CloudletFieldConfigTestMode,
	CloudletFieldConfigSpan,
	CloudletFieldConfigCleanupMode,
	CloudletFieldConfigRegion,
	CloudletFieldConfigCommercialCerts,
	CloudletFieldConfigUseVaultPki,
	CloudletFieldConfigAppDnsRoot,
	CloudletFieldConfigDeploymentTag,
	CloudletFieldConfigTlsKeyFile,
	CloudletFieldConfigTlsCaFile,
	CloudletFieldConfigCrmAccessPrivateKey,
	CloudletFieldConfigAccessApiAddr,
	CloudletFieldConfigCacheDir,
	CloudletFieldConfigSecondaryCrmAccessPrivateKey,
	CloudletFieldConfigThanosRecvAddr,
	CloudletFieldConfigAnsiblePublicAddr,
	CloudletFieldConfigEnvoyWithCurlImage,
	CloudletFieldConfigNginxWithCurlImage,
	CloudletFieldResTagMapKey,
	CloudletFieldResTagMapValueName,
	CloudletFieldResTagMapValueOrganization,
	CloudletFieldAccessVarsKey,
	CloudletFieldAccessVarsValue,
	CloudletFieldVmImageVersion,
	CloudletFieldDeployment,
	CloudletFieldInfraApiAccess,
	CloudletFieldInfraConfigExternalNetworkName,
	CloudletFieldInfraConfigFlavorName,
	CloudletFieldMaintenanceState,
	CloudletFieldOverridePolicyContainerVersion,
	CloudletFieldVmPool,
	CloudletFieldCrmAccessPublicKey,
	CloudletFieldCrmAccessKeyUpgradeRequired,
	CloudletFieldCreatedAtSeconds,
	CloudletFieldCreatedAtNanos,
	CloudletFieldUpdatedAtSeconds,
	CloudletFieldUpdatedAtNanos,
	CloudletFieldTrustPolicy,
	CloudletFieldTrustPolicyState,
	CloudletFieldResourceQuotasName,
	CloudletFieldResourceQuotasValue,
	CloudletFieldResourceQuotasAlertThreshold,
	CloudletFieldDefaultResourceAlertThreshold,
	CloudletFieldHostController,
	CloudletFieldKafkaCluster,
	CloudletFieldKafkaUser,
	CloudletFieldKafkaPassword,
	CloudletFieldGpuConfigDriverName,
	CloudletFieldGpuConfigDriverOrganization,
	CloudletFieldGpuConfigPropertiesKey,
	CloudletFieldGpuConfigPropertiesValue,
	CloudletFieldGpuConfigLicenseConfig,
	CloudletFieldGpuConfigLicenseConfigMd5Sum,
	CloudletFieldEnableDefaultServerlessCluster,
	CloudletFieldAllianceOrgs,
	CloudletFieldSingleKubernetesClusterOwner,
	CloudletFieldDeletePrepare,
	CloudletFieldPlatformHighAvailability,
	CloudletFieldSecondaryCrmAccessPublicKey,
	CloudletFieldSecondaryCrmAccessKeyUpgradeRequired,
	CloudletFieldSecondaryNotifySrvAddr,
	CloudletFieldDnsLabel,
	CloudletFieldRootLbFqdn,
	CloudletFieldFederationConfigFederationContextId,
	CloudletFieldFederationConfigPartnerFederationAddr,
	CloudletFieldFederationConfigFederationDbId,
	CloudletFieldFederationConfigFederationName,
	CloudletFieldLicenseConfigStoragePath,
	CloudletFieldInfraFlavorsName,
	CloudletFieldInfraFlavorsVcpus,
	CloudletFieldInfraFlavorsRam,
	CloudletFieldInfraFlavorsDisk,
	CloudletFieldInfraFlavorsPropMapKey,
	CloudletFieldInfraFlavorsPropMapValue,
	CloudletFieldEdgeboxOnly,
	CloudletFieldOnboardingState,
}

var CloudletAllFieldsMap = map[string]struct{}{
	CloudletFieldKeyOrganization:                       struct{}{},
	CloudletFieldKeyName:                               struct{}{},
	CloudletFieldKeyFederatedOrganization:              struct{}{},
	CloudletFieldLocationLatitude:                      struct{}{},
	CloudletFieldLocationLongitude:                     struct{}{},
	CloudletFieldLocationHorizontalAccuracy:            struct{}{},
	CloudletFieldLocationVerticalAccuracy:              struct{}{},
	CloudletFieldLocationAltitude:                      struct{}{},
	CloudletFieldLocationCourse:                        struct{}{},
	CloudletFieldLocationSpeed:                         struct{}{},
	CloudletFieldLocationTimestampSeconds:              struct{}{},
	CloudletFieldLocationTimestampNanos:                struct{}{},
	CloudletFieldIpSupport:                             struct{}{},
	CloudletFieldStaticIps:                             struct{}{},
	CloudletFieldNumDynamicIps:                         struct{}{},
	CloudletFieldTimeLimitsCreateClusterInstTimeout:    struct{}{},
	CloudletFieldTimeLimitsUpdateClusterInstTimeout:    struct{}{},
	CloudletFieldTimeLimitsDeleteClusterInstTimeout:    struct{}{},
	CloudletFieldTimeLimitsCreateAppInstTimeout:        struct{}{},
	CloudletFieldTimeLimitsUpdateAppInstTimeout:        struct{}{},
	CloudletFieldTimeLimitsDeleteAppInstTimeout:        struct{}{},
	CloudletFieldErrors:                                struct{}{},
	CloudletFieldState:                                 struct{}{},
	CloudletFieldCrmOverride:                           struct{}{},
	CloudletFieldDeploymentLocal:                       struct{}{},
	CloudletFieldPlatformType:                          struct{}{},
	CloudletFieldNotifySrvAddr:                         struct{}{},
	CloudletFieldFlavorName:                            struct{}{},
	CloudletFieldPhysicalName:                          struct{}{},
	CloudletFieldEnvVarKey:                             struct{}{},
	CloudletFieldEnvVarValue:                           struct{}{},
	CloudletFieldContainerVersion:                      struct{}{},
	CloudletFieldConfigContainerRegistryPath:           struct{}{},
	CloudletFieldConfigCloudletVmImagePath:             struct{}{},
	CloudletFieldConfigNotifyCtrlAddrs:                 struct{}{},
	CloudletFieldConfigTlsCertFile:                     struct{}{},
	CloudletFieldConfigEnvVarKey:                       struct{}{},
	CloudletFieldConfigEnvVarValue:                     struct{}{},
	CloudletFieldConfigPlatformTag:                     struct{}{},
	CloudletFieldConfigTestMode:                        struct{}{},
	CloudletFieldConfigSpan:                            struct{}{},
	CloudletFieldConfigCleanupMode:                     struct{}{},
	CloudletFieldConfigRegion:                          struct{}{},
	CloudletFieldConfigCommercialCerts:                 struct{}{},
	CloudletFieldConfigUseVaultPki:                     struct{}{},
	CloudletFieldConfigAppDnsRoot:                      struct{}{},
	CloudletFieldConfigDeploymentTag:                   struct{}{},
	CloudletFieldConfigTlsKeyFile:                      struct{}{},
	CloudletFieldConfigTlsCaFile:                       struct{}{},
	CloudletFieldConfigCrmAccessPrivateKey:             struct{}{},
	CloudletFieldConfigAccessApiAddr:                   struct{}{},
	CloudletFieldConfigCacheDir:                        struct{}{},
	CloudletFieldConfigSecondaryCrmAccessPrivateKey:    struct{}{},
	CloudletFieldConfigThanosRecvAddr:                  struct{}{},
	CloudletFieldConfigAnsiblePublicAddr:               struct{}{},
	CloudletFieldConfigEnvoyWithCurlImage:              struct{}{},
	CloudletFieldConfigNginxWithCurlImage:              struct{}{},
	CloudletFieldResTagMapKey:                          struct{}{},
	CloudletFieldResTagMapValueName:                    struct{}{},
	CloudletFieldResTagMapValueOrganization:            struct{}{},
	CloudletFieldAccessVarsKey:                         struct{}{},
	CloudletFieldAccessVarsValue:                       struct{}{},
	CloudletFieldVmImageVersion:                        struct{}{},
	CloudletFieldDeployment:                            struct{}{},
	CloudletFieldInfraApiAccess:                        struct{}{},
	CloudletFieldInfraConfigExternalNetworkName:        struct{}{},
	CloudletFieldInfraConfigFlavorName:                 struct{}{},
	CloudletFieldMaintenanceState:                      struct{}{},
	CloudletFieldOverridePolicyContainerVersion:        struct{}{},
	CloudletFieldVmPool:                                struct{}{},
	CloudletFieldCrmAccessPublicKey:                    struct{}{},
	CloudletFieldCrmAccessKeyUpgradeRequired:           struct{}{},
	CloudletFieldCreatedAtSeconds:                      struct{}{},
	CloudletFieldCreatedAtNanos:                        struct{}{},
	CloudletFieldUpdatedAtSeconds:                      struct{}{},
	CloudletFieldUpdatedAtNanos:                        struct{}{},
	CloudletFieldTrustPolicy:                           struct{}{},
	CloudletFieldTrustPolicyState:                      struct{}{},
	CloudletFieldResourceQuotasName:                    struct{}{},
	CloudletFieldResourceQuotasValue:                   struct{}{},
	CloudletFieldResourceQuotasAlertThreshold:          struct{}{},
	CloudletFieldDefaultResourceAlertThreshold:         struct{}{},
	CloudletFieldHostController:                        struct{}{},
	CloudletFieldKafkaCluster:                          struct{}{},
	CloudletFieldKafkaUser:                             struct{}{},
	CloudletFieldKafkaPassword:                         struct{}{},
	CloudletFieldGpuConfigDriverName:                   struct{}{},
	CloudletFieldGpuConfigDriverOrganization:           struct{}{},
	CloudletFieldGpuConfigPropertiesKey:                struct{}{},
	CloudletFieldGpuConfigPropertiesValue:              struct{}{},
	CloudletFieldGpuConfigLicenseConfig:                struct{}{},
	CloudletFieldGpuConfigLicenseConfigMd5Sum:          struct{}{},
	CloudletFieldEnableDefaultServerlessCluster:        struct{}{},
	CloudletFieldAllianceOrgs:                          struct{}{},
	CloudletFieldSingleKubernetesClusterOwner:          struct{}{},
	CloudletFieldDeletePrepare:                         struct{}{},
	CloudletFieldPlatformHighAvailability:              struct{}{},
	CloudletFieldSecondaryCrmAccessPublicKey:           struct{}{},
	CloudletFieldSecondaryCrmAccessKeyUpgradeRequired:  struct{}{},
	CloudletFieldSecondaryNotifySrvAddr:                struct{}{},
	CloudletFieldDnsLabel:                              struct{}{},
	CloudletFieldRootLbFqdn:                            struct{}{},
	CloudletFieldFederationConfigFederationContextId:   struct{}{},
	CloudletFieldFederationConfigPartnerFederationAddr: struct{}{},
	CloudletFieldFederationConfigFederationDbId:        struct{}{},
	CloudletFieldFederationConfigFederationName:        struct{}{},
	CloudletFieldLicenseConfigStoragePath:              struct{}{},
	CloudletFieldInfraFlavorsName:                      struct{}{},
	CloudletFieldInfraFlavorsVcpus:                     struct{}{},
	CloudletFieldInfraFlavorsRam:                       struct{}{},
	CloudletFieldInfraFlavorsDisk:                      struct{}{},
	CloudletFieldInfraFlavorsPropMapKey:                struct{}{},
	CloudletFieldInfraFlavorsPropMapValue:              struct{}{},
	CloudletFieldEdgeboxOnly:                           struct{}{},
	CloudletFieldOnboardingState:                       struct{}{},
}

var CloudletAllFieldsStringMap = map[string]string{
	CloudletFieldKeyOrganization:                       "Key Organization",
	CloudletFieldKeyName:                               "Key Name",
	CloudletFieldKeyFederatedOrganization:              "Key Federated Organization",
	CloudletFieldLocationLatitude:                      "Location Latitude",
	CloudletFieldLocationLongitude:                     "Location Longitude",
	CloudletFieldLocationHorizontalAccuracy:            "Location Horizontal Accuracy",
	CloudletFieldLocationVerticalAccuracy:              "Location Vertical Accuracy",
	CloudletFieldLocationAltitude:                      "Location Altitude",
	CloudletFieldLocationCourse:                        "Location Course",
	CloudletFieldLocationSpeed:                         "Location Speed",
	CloudletFieldLocationTimestampSeconds:              "Location Timestamp Seconds",
	CloudletFieldLocationTimestampNanos:                "Location Timestamp Nanos",
	CloudletFieldIpSupport:                             "Ip Support",
	CloudletFieldStaticIps:                             "Static Ips",
	CloudletFieldNumDynamicIps:                         "Num Dynamic Ips",
	CloudletFieldTimeLimitsCreateClusterInstTimeout:    "Time Limits Create Cluster Inst Timeout",
	CloudletFieldTimeLimitsUpdateClusterInstTimeout:    "Time Limits Update Cluster Inst Timeout",
	CloudletFieldTimeLimitsDeleteClusterInstTimeout:    "Time Limits Delete Cluster Inst Timeout",
	CloudletFieldTimeLimitsCreateAppInstTimeout:        "Time Limits Create App Inst Timeout",
	CloudletFieldTimeLimitsUpdateAppInstTimeout:        "Time Limits Update App Inst Timeout",
	CloudletFieldTimeLimitsDeleteAppInstTimeout:        "Time Limits Delete App Inst Timeout",
	CloudletFieldErrors:                                "Errors",
	CloudletFieldState:                                 "State",
	CloudletFieldCrmOverride:                           "Crm Override",
	CloudletFieldDeploymentLocal:                       "Deployment Local",
	CloudletFieldPlatformType:                          "Platform Type",
	CloudletFieldNotifySrvAddr:                         "Notify Srv Addr",
	CloudletFieldFlavorName:                            "Flavor Name",
	CloudletFieldPhysicalName:                          "Physical Name",
	CloudletFieldEnvVarKey:                             "Env Var Key",
	CloudletFieldEnvVarValue:                           "Env Var Value",
	CloudletFieldContainerVersion:                      "Container Version",
	CloudletFieldConfigContainerRegistryPath:           "Config Container Registry Path",
	CloudletFieldConfigCloudletVmImagePath:             "Config Cloudlet Vm Image Path",
	CloudletFieldConfigNotifyCtrlAddrs:                 "Config Notify Ctrl Addrs",
	CloudletFieldConfigTlsCertFile:                     "Config Tls Cert File",
	CloudletFieldConfigEnvVarKey:                       "Config Env Var Key",
	CloudletFieldConfigEnvVarValue:                     "Config Env Var Value",
	CloudletFieldConfigPlatformTag:                     "Config Platform Tag",
	CloudletFieldConfigTestMode:                        "Config Test Mode",
	CloudletFieldConfigSpan:                            "Config Span",
	CloudletFieldConfigCleanupMode:                     "Config Cleanup Mode",
	CloudletFieldConfigRegion:                          "Config Region",
	CloudletFieldConfigCommercialCerts:                 "Config Commercial Certs",
	CloudletFieldConfigUseVaultPki:                     "Config Use Vault Pki",
	CloudletFieldConfigAppDnsRoot:                      "Config App Dns Root",
	CloudletFieldConfigDeploymentTag:                   "Config Deployment Tag",
	CloudletFieldConfigTlsKeyFile:                      "Config Tls Key File",
	CloudletFieldConfigTlsCaFile:                       "Config Tls Ca File",
	CloudletFieldConfigCrmAccessPrivateKey:             "Config Crm Access Private Key",
	CloudletFieldConfigAccessApiAddr:                   "Config Access Api Addr",
	CloudletFieldConfigCacheDir:                        "Config Cache Dir",
	CloudletFieldConfigSecondaryCrmAccessPrivateKey:    "Config Secondary Crm Access Private Key",
	CloudletFieldConfigThanosRecvAddr:                  "Config Thanos Recv Addr",
	CloudletFieldConfigAnsiblePublicAddr:               "Config Ansible Public Addr",
	CloudletFieldConfigEnvoyWithCurlImage:              "Config Envoy With Curl Image",
	CloudletFieldConfigNginxWithCurlImage:              "Config Nginx With Curl Image",
	CloudletFieldResTagMapKey:                          "Res Tag Map Key",
	CloudletFieldResTagMapValueName:                    "Res Tag Map Value Name",
	CloudletFieldResTagMapValueOrganization:            "Res Tag Map Value Organization",
	CloudletFieldAccessVarsKey:                         "Access Vars Key",
	CloudletFieldAccessVarsValue:                       "Access Vars Value",
	CloudletFieldVmImageVersion:                        "Vm Image Version",
	CloudletFieldDeployment:                            "Deployment",
	CloudletFieldInfraApiAccess:                        "Infra Api Access",
	CloudletFieldInfraConfigExternalNetworkName:        "Infra Config External Network Name",
	CloudletFieldInfraConfigFlavorName:                 "Infra Config Flavor Name",
	CloudletFieldMaintenanceState:                      "Maintenance State",
	CloudletFieldOverridePolicyContainerVersion:        "Override Policy Container Version",
	CloudletFieldVmPool:                                "Vm Pool",
	CloudletFieldCrmAccessPublicKey:                    "Crm Access Public Key",
	CloudletFieldCrmAccessKeyUpgradeRequired:           "Crm Access Key Upgrade Required",
	CloudletFieldCreatedAtSeconds:                      "Created At Seconds",
	CloudletFieldCreatedAtNanos:                        "Created At Nanos",
	CloudletFieldUpdatedAtSeconds:                      "Updated At Seconds",
	CloudletFieldUpdatedAtNanos:                        "Updated At Nanos",
	CloudletFieldTrustPolicy:                           "Trust Policy",
	CloudletFieldTrustPolicyState:                      "Trust Policy State",
	CloudletFieldResourceQuotasName:                    "Resource Quotas Name",
	CloudletFieldResourceQuotasValue:                   "Resource Quotas Value",
	CloudletFieldResourceQuotasAlertThreshold:          "Resource Quotas Alert Threshold",
	CloudletFieldDefaultResourceAlertThreshold:         "Default Resource Alert Threshold",
	CloudletFieldHostController:                        "Host Controller",
	CloudletFieldKafkaCluster:                          "Kafka Cluster",
	CloudletFieldKafkaUser:                             "Kafka User",
	CloudletFieldKafkaPassword:                         "Kafka Password",
	CloudletFieldGpuConfigDriverName:                   "Gpu Config Driver Name",
	CloudletFieldGpuConfigDriverOrganization:           "Gpu Config Driver Organization",
	CloudletFieldGpuConfigPropertiesKey:                "Gpu Config Properties Key",
	CloudletFieldGpuConfigPropertiesValue:              "Gpu Config Properties Value",
	CloudletFieldGpuConfigLicenseConfig:                "Gpu Config License Config",
	CloudletFieldGpuConfigLicenseConfigMd5Sum:          "Gpu Config License Config Md5 Sum",
	CloudletFieldEnableDefaultServerlessCluster:        "Enable Default Serverless Cluster",
	CloudletFieldAllianceOrgs:                          "Alliance Orgs",
	CloudletFieldSingleKubernetesClusterOwner:          "Single Kubernetes Cluster Owner",
	CloudletFieldDeletePrepare:                         "Delete Prepare",
	CloudletFieldPlatformHighAvailability:              "Platform High Availability",
	CloudletFieldSecondaryCrmAccessPublicKey:           "Secondary Crm Access Public Key",
	CloudletFieldSecondaryCrmAccessKeyUpgradeRequired:  "Secondary Crm Access Key Upgrade Required",
	CloudletFieldSecondaryNotifySrvAddr:                "Secondary Notify Srv Addr",
	CloudletFieldDnsLabel:                              "Dns Label",
	CloudletFieldRootLbFqdn:                            "Root Lb Fqdn",
	CloudletFieldFederationConfigFederationContextId:   "Federation Config Federation Context Id",
	CloudletFieldFederationConfigPartnerFederationAddr: "Federation Config Partner Federation Addr",
	CloudletFieldFederationConfigFederationDbId:        "Federation Config Federation Db Id",
	CloudletFieldFederationConfigFederationName:        "Federation Config Federation Name",
	CloudletFieldLicenseConfigStoragePath:              "License Config Storage Path",
	CloudletFieldInfraFlavorsName:                      "Infra Flavors Name",
	CloudletFieldInfraFlavorsVcpus:                     "Infra Flavors Vcpus",
	CloudletFieldInfraFlavorsRam:                       "Infra Flavors Ram",
	CloudletFieldInfraFlavorsDisk:                      "Infra Flavors Disk",
	CloudletFieldInfraFlavorsPropMapKey:                "Infra Flavors Prop Map Key",
	CloudletFieldInfraFlavorsPropMapValue:              "Infra Flavors Prop Map Value",
	CloudletFieldEdgeboxOnly:                           "Edgebox Only",
	CloudletFieldOnboardingState:                       "Onboarding State",
}

func (m *Cloudlet) IsKeyField(s string) bool {
	return strings.HasPrefix(s, CloudletFieldKey+".") || s == CloudletFieldKey
}

func (m *Cloudlet) DiffFields(o *Cloudlet, fields map[string]struct{}) {
	if m.Key.Organization != o.Key.Organization {
		fields[CloudletFieldKeyOrganization] = struct{}{}
		fields[CloudletFieldKey] = struct{}{}
	}
	if m.Key.Name != o.Key.Name {
		fields[CloudletFieldKeyName] = struct{}{}
		fields[CloudletFieldKey] = struct{}{}
	}
	if m.Key.FederatedOrganization != o.Key.FederatedOrganization {
		fields[CloudletFieldKeyFederatedOrganization] = struct{}{}
		fields[CloudletFieldKey] = struct{}{}
	}
	if m.Location.Latitude != o.Location.Latitude {
		fields[CloudletFieldLocationLatitude] = struct{}{}
		fields[CloudletFieldLocation] = struct{}{}
	}
	if m.Location.Longitude != o.Location.Longitude {
		fields[CloudletFieldLocationLongitude] = struct{}{}
		fields[CloudletFieldLocation] = struct{}{}
	}
	if m.Location.HorizontalAccuracy != o.Location.HorizontalAccuracy {
		fields[CloudletFieldLocationHorizontalAccuracy] = struct{}{}
		fields[CloudletFieldLocation] = struct{}{}
	}
	if m.Location.VerticalAccuracy != o.Location.VerticalAccuracy {
		fields[CloudletFieldLocationVerticalAccuracy] = struct{}{}
		fields[CloudletFieldLocation] = struct{}{}
	}
	if m.Location.Altitude != o.Location.Altitude {
		fields[CloudletFieldLocationAltitude] = struct{}{}
		fields[CloudletFieldLocation] = struct{}{}
	}
	if m.Location.Course != o.Location.Course {
		fields[CloudletFieldLocationCourse] = struct{}{}
		fields[CloudletFieldLocation] = struct{}{}
	}
	if m.Location.Speed != o.Location.Speed {
		fields[CloudletFieldLocationSpeed] = struct{}{}
		fields[CloudletFieldLocation] = struct{}{}
	}
	if m.Location.Timestamp != nil && o.Location.Timestamp != nil {
		if m.Location.Timestamp.Seconds != o.Location.Timestamp.Seconds {
			fields[CloudletFieldLocationTimestampSeconds] = struct{}{}
			fields[CloudletFieldLocationTimestamp] = struct{}{}
			fields[CloudletFieldLocation] = struct{}{}
		}
		if m.Location.Timestamp.Nanos != o.Location.Timestamp.Nanos {
			fields[CloudletFieldLocationTimestampNanos] = struct{}{}
			fields[CloudletFieldLocationTimestamp] = struct{}{}
			fields[CloudletFieldLocation] = struct{}{}
		}
	} else if (m.Location.Timestamp != nil && o.Location.Timestamp == nil) || (m.Location.Timestamp == nil && o.Location.Timestamp != nil) {
		fields[CloudletFieldLocationTimestamp] = struct{}{}
		fields[CloudletFieldLocation] = struct{}{}
	}
	if m.IpSupport != o.IpSupport {
		fields[CloudletFieldIpSupport] = struct{}{}
	}
	if m.StaticIps != o.StaticIps {
		fields[CloudletFieldStaticIps] = struct{}{}
	}
	if m.NumDynamicIps != o.NumDynamicIps {
		fields[CloudletFieldNumDynamicIps] = struct{}{}
	}
	if m.TimeLimits.CreateClusterInstTimeout != o.TimeLimits.CreateClusterInstTimeout {
		fields[CloudletFieldTimeLimitsCreateClusterInstTimeout] = struct{}{}
		fields[CloudletFieldTimeLimits] = struct{}{}
	}
	if m.TimeLimits.UpdateClusterInstTimeout != o.TimeLimits.UpdateClusterInstTimeout {
		fields[CloudletFieldTimeLimitsUpdateClusterInstTimeout] = struct{}{}
		fields[CloudletFieldTimeLimits] = struct{}{}
	}
	if m.TimeLimits.DeleteClusterInstTimeout != o.TimeLimits.DeleteClusterInstTimeout {
		fields[CloudletFieldTimeLimitsDeleteClusterInstTimeout] = struct{}{}
		fields[CloudletFieldTimeLimits] = struct{}{}
	}
	if m.TimeLimits.CreateAppInstTimeout != o.TimeLimits.CreateAppInstTimeout {
		fields[CloudletFieldTimeLimitsCreateAppInstTimeout] = struct{}{}
		fields[CloudletFieldTimeLimits] = struct{}{}
	}
	if m.TimeLimits.UpdateAppInstTimeout != o.TimeLimits.UpdateAppInstTimeout {
		fields[CloudletFieldTimeLimitsUpdateAppInstTimeout] = struct{}{}
		fields[CloudletFieldTimeLimits] = struct{}{}
	}
	if m.TimeLimits.DeleteAppInstTimeout != o.TimeLimits.DeleteAppInstTimeout {
		fields[CloudletFieldTimeLimitsDeleteAppInstTimeout] = struct{}{}
		fields[CloudletFieldTimeLimits] = struct{}{}
	}
	if len(m.Errors) != len(o.Errors) {
		fields[CloudletFieldErrors] = struct{}{}
	} else {
		for i0 := 0; i0 < len(m.Errors); i0++ {
			if m.Errors[i0] != o.Errors[i0] {
				fields[CloudletFieldErrors] = struct{}{}
				break
			}
		}
	}
	if m.State != o.State {
		fields[CloudletFieldState] = struct{}{}
	}
	if m.CrmOverride != o.CrmOverride {
		fields[CloudletFieldCrmOverride] = struct{}{}
	}
	if m.DeploymentLocal != o.DeploymentLocal {
		fields[CloudletFieldDeploymentLocal] = struct{}{}
	}
	if m.PlatformType != o.PlatformType {
		fields[CloudletFieldPlatformType] = struct{}{}
	}
	if m.NotifySrvAddr != o.NotifySrvAddr {
		fields[CloudletFieldNotifySrvAddr] = struct{}{}
	}
	if m.Flavor.Name != o.Flavor.Name {
		fields[CloudletFieldFlavorName] = struct{}{}
		fields[CloudletFieldFlavor] = struct{}{}
	}
	if m.PhysicalName != o.PhysicalName {
		fields[CloudletFieldPhysicalName] = struct{}{}
	}
	if m.EnvVar != nil && o.EnvVar != nil {
		if len(m.EnvVar) != len(o.EnvVar) {
			fields[CloudletFieldEnvVar] = struct{}{}
		} else {
			for k0, _ := range m.EnvVar {
				_, vok0 := o.EnvVar[k0]
				if !vok0 {
					fields[CloudletFieldEnvVar] = struct{}{}
				} else {
					if m.EnvVar[k0] != o.EnvVar[k0] {
						fields[CloudletFieldEnvVar] = struct{}{}
						break
					}
				}
			}
		}
	} else if (m.EnvVar != nil && o.EnvVar == nil) || (m.EnvVar == nil && o.EnvVar != nil) {
		fields[CloudletFieldEnvVar] = struct{}{}
	}
	if m.ContainerVersion != o.ContainerVersion {
		fields[CloudletFieldContainerVersion] = struct{}{}
	}
	if m.Config.ContainerRegistryPath != o.Config.ContainerRegistryPath {
		fields[CloudletFieldConfigContainerRegistryPath] = struct{}{}
		fields[CloudletFieldConfig] = struct{}{}
	}
	if m.Config.CloudletVmImagePath != o.Config.CloudletVmImagePath {
		fields[CloudletFieldConfigCloudletVmImagePath] = struct{}{}
		fields[CloudletFieldConfig] = struct{}{}
	}
	if m.Config.NotifyCtrlAddrs != o.Config.NotifyCtrlAddrs {
		fields[CloudletFieldConfigNotifyCtrlAddrs] = struct{}{}
		fields[CloudletFieldConfig] = struct{}{}
	}
	if m.Config.TlsCertFile != o.Config.TlsCertFile {
		fields[CloudletFieldConfigTlsCertFile] = struct{}{}
		fields[CloudletFieldConfig] = struct{}{}
	}
	if m.Config.EnvVar != nil && o.Config.EnvVar != nil {
		if len(m.Config.EnvVar) != len(o.Config.EnvVar) {
			fields[CloudletFieldConfigEnvVar] = struct{}{}
			fields[CloudletFieldConfig] = struct{}{}
		} else {
			for k1, _ := range m.Config.EnvVar {
				_, vok1 := o.Config.EnvVar[k1]
				if !vok1 {
					fields[CloudletFieldConfigEnvVar] = struct{}{}
					fields[CloudletFieldConfig] = struct{}{}
				} else {
					if m.Config.EnvVar[k1] != o.Config.EnvVar[k1] {
						fields[CloudletFieldConfigEnvVar] = struct{}{}
						fields[CloudletFieldConfig] = struct{}{}
						break
					}
				}
			}
		}
	} else if (m.Config.EnvVar != nil && o.Config.EnvVar == nil) || (m.Config.EnvVar == nil && o.Config.EnvVar != nil) {
		fields[CloudletFieldConfigEnvVar] = struct{}{}
		fields[CloudletFieldConfig] = struct{}{}
	}
	if m.Config.PlatformTag != o.Config.PlatformTag {
		fields[CloudletFieldConfigPlatformTag] = struct{}{}
		fields[CloudletFieldConfig] = struct{}{}
	}
	if m.Config.TestMode != o.Config.TestMode {
		fields[CloudletFieldConfigTestMode] = struct{}{}
		fields[CloudletFieldConfig] = struct{}{}
	}
	if m.Config.Span != o.Config.Span {
		fields[CloudletFieldConfigSpan] = struct{}{}
		fields[CloudletFieldConfig] = struct{}{}
	}
	if m.Config.CleanupMode != o.Config.CleanupMode {
		fields[CloudletFieldConfigCleanupMode] = struct{}{}
		fields[CloudletFieldConfig] = struct{}{}
	}
	if m.Config.Region != o.Config.Region {
		fields[CloudletFieldConfigRegion] = struct{}{}
		fields[CloudletFieldConfig] = struct{}{}
	}
	if m.Config.CommercialCerts != o.Config.CommercialCerts {
		fields[CloudletFieldConfigCommercialCerts] = struct{}{}
		fields[CloudletFieldConfig] = struct{}{}
	}
	if m.Config.UseVaultPki != o.Config.UseVaultPki {
		fields[CloudletFieldConfigUseVaultPki] = struct{}{}
		fields[CloudletFieldConfig] = struct{}{}
	}
	if m.Config.AppDnsRoot != o.Config.AppDnsRoot {
		fields[CloudletFieldConfigAppDnsRoot] = struct{}{}
		fields[CloudletFieldConfig] = struct{}{}
	}
	if m.Config.DeploymentTag != o.Config.DeploymentTag {
		fields[CloudletFieldConfigDeploymentTag] = struct{}{}
		fields[CloudletFieldConfig] = struct{}{}
	}
	if m.Config.TlsKeyFile != o.Config.TlsKeyFile {
		fields[CloudletFieldConfigTlsKeyFile] = struct{}{}
		fields[CloudletFieldConfig] = struct{}{}
	}
	if m.Config.TlsCaFile != o.Config.TlsCaFile {
		fields[CloudletFieldConfigTlsCaFile] = struct{}{}
		fields[CloudletFieldConfig] = struct{}{}
	}
	if m.Config.CrmAccessPrivateKey != o.Config.CrmAccessPrivateKey {
		fields[CloudletFieldConfigCrmAccessPrivateKey] = struct{}{}
		fields[CloudletFieldConfig] = struct{}{}
	}
	if m.Config.AccessApiAddr != o.Config.AccessApiAddr {
		fields[CloudletFieldConfigAccessApiAddr] = struct{}{}
		fields[CloudletFieldConfig] = struct{}{}
	}
	if m.Config.CacheDir != o.Config.CacheDir {
		fields[CloudletFieldConfigCacheDir] = struct{}{}
		fields[CloudletFieldConfig] = struct{}{}
	}
	if m.Config.SecondaryCrmAccessPrivateKey != o.Config.SecondaryCrmAccessPrivateKey {
		fields[CloudletFieldConfigSecondaryCrmAccessPrivateKey] = struct{}{}
		fields[CloudletFieldConfig] = struct{}{}
	}
	if m.Config.ThanosRecvAddr != o.Config.ThanosRecvAddr {
		fields[CloudletFieldConfigThanosRecvAddr] = struct{}{}
		fields[CloudletFieldConfig] = struct{}{}
	}
	if m.Config.AnsiblePublicAddr != o.Config.AnsiblePublicAddr {
		fields[CloudletFieldConfigAnsiblePublicAddr] = struct{}{}
		fields[CloudletFieldConfig] = struct{}{}
	}
	if m.Config.EnvoyWithCurlImage != o.Config.EnvoyWithCurlImage {
		fields[CloudletFieldConfigEnvoyWithCurlImage] = struct{}{}
		fields[CloudletFieldConfig] = struct{}{}
	}
	if m.Config.NginxWithCurlImage != o.Config.NginxWithCurlImage {
		fields[CloudletFieldConfigNginxWithCurlImage] = struct{}{}
		fields[CloudletFieldConfig] = struct{}{}
	}
	if m.ResTagMap != nil && o.ResTagMap != nil {
		if len(m.ResTagMap) != len(o.ResTagMap) {
			fields[CloudletFieldResTagMap] = struct{}{}
		} else {
			for k0, _ := range m.ResTagMap {
				_, vok0 := o.ResTagMap[k0]
				if !vok0 {
					fields[CloudletFieldResTagMap] = struct{}{}
				} else {
					if m.ResTagMap[k0].Name != o.ResTagMap[k0].Name {
						fields[CloudletFieldResTagMapValueName] = struct{}{}
						fields[CloudletFieldResTagMapValue] = struct{}{}
						fields[CloudletFieldResTagMap] = struct{}{}
					}
					if m.ResTagMap[k0].Organization != o.ResTagMap[k0].Organization {
						fields[CloudletFieldResTagMapValueOrganization] = struct{}{}
						fields[CloudletFieldResTagMapValue] = struct{}{}
						fields[CloudletFieldResTagMap] = struct{}{}
					}
				}
			}
		}
	} else if (m.ResTagMap != nil && o.ResTagMap == nil) || (m.ResTagMap == nil && o.ResTagMap != nil) {
		fields[CloudletFieldResTagMap] = struct{}{}
	}
	if m.AccessVars != nil && o.AccessVars != nil {
		if len(m.AccessVars) != len(o.AccessVars) {
			fields[CloudletFieldAccessVars] = struct{}{}
		} else {
			for k0, _ := range m.AccessVars {
				_, vok0 := o.AccessVars[k0]
				if !vok0 {
					fields[CloudletFieldAccessVars] = struct{}{}
				} else {
					if m.AccessVars[k0] != o.AccessVars[k0] {
						fields[CloudletFieldAccessVars] = struct{}{}
						break
					}
				}
			}
		}
	} else if (m.AccessVars != nil && o.AccessVars == nil) || (m.AccessVars == nil && o.AccessVars != nil) {
		fields[CloudletFieldAccessVars] = struct{}{}
	}
	if m.VmImageVersion != o.VmImageVersion {
		fields[CloudletFieldVmImageVersion] = struct{}{}
	}
	if m.Deployment != o.Deployment {
		fields[CloudletFieldDeployment] = struct{}{}
	}
	if m.InfraApiAccess != o.InfraApiAccess {
		fields[CloudletFieldInfraApiAccess] = struct{}{}
	}
	if m.InfraConfig.ExternalNetworkName != o.InfraConfig.ExternalNetworkName {
		fields[CloudletFieldInfraConfigExternalNetworkName] = struct{}{}
		fields[CloudletFieldInfraConfig] = struct{}{}
	}
	if m.InfraConfig.FlavorName != o.InfraConfig.FlavorName {
		fields[CloudletFieldInfraConfigFlavorName] = struct{}{}
		fields[CloudletFieldInfraConfig] = struct{}{}
	}
	if m.MaintenanceState != o.MaintenanceState {
		fields[CloudletFieldMaintenanceState] = struct{}{}
	}
	if m.OverridePolicyContainerVersion != o.OverridePolicyContainerVersion {
		fields[CloudletFieldOverridePolicyContainerVersion] = struct{}{}
	}
	if m.VmPool != o.VmPool {
		fields[CloudletFieldVmPool] = struct{}{}
	}
	if m.CrmAccessPublicKey != o.CrmAccessPublicKey {
		fields[CloudletFieldCrmAccessPublicKey] = struct{}{}
	}
	if m.CrmAccessKeyUpgradeRequired != o.CrmAccessKeyUpgradeRequired {
		fields[CloudletFieldCrmAccessKeyUpgradeRequired] = struct{}{}
	}
	if m.CreatedAt.Seconds != o.CreatedAt.Seconds {
		fields[CloudletFieldCreatedAtSeconds] = struct{}{}
		fields[CloudletFieldCreatedAt] = struct{}{}
	}
	if m.CreatedAt.Nanos != o.CreatedAt.Nanos {
		fields[CloudletFieldCreatedAtNanos] = struct{}{}
		fields[CloudletFieldCreatedAt] = struct{}{}
	}
	if m.UpdatedAt.Seconds != o.UpdatedAt.Seconds {
		fields[CloudletFieldUpdatedAtSeconds] = struct{}{}
		fields[CloudletFieldUpdatedAt] = struct{}{}
	}
	if m.UpdatedAt.Nanos != o.UpdatedAt.Nanos {
		fields[CloudletFieldUpdatedAtNanos] = struct{}{}
		fields[CloudletFieldUpdatedAt] = struct{}{}
	}
	if m.TrustPolicy != o.TrustPolicy {
		fields[CloudletFieldTrustPolicy] = struct{}{}
	}
	if m.TrustPolicyState != o.TrustPolicyState {
		fields[CloudletFieldTrustPolicyState] = struct{}{}
	}
	if len(m.ResourceQuotas) != len(o.ResourceQuotas) {
		fields[CloudletFieldResourceQuotas] = struct{}{}
	} else {
		for i0 := 0; i0 < len(m.ResourceQuotas); i0++ {
			if m.ResourceQuotas[i0].Name != o.ResourceQuotas[i0].Name {
				fields[CloudletFieldResourceQuotasName] = struct{}{}
				fields[CloudletFieldResourceQuotas] = struct{}{}
			}
			if m.ResourceQuotas[i0].Value != o.ResourceQuotas[i0].Value {
				fields[CloudletFieldResourceQuotasValue] = struct{}{}
				fields[CloudletFieldResourceQuotas] = struct{}{}
			}
			if m.ResourceQuotas[i0].AlertThreshold != o.ResourceQuotas[i0].AlertThreshold {
				fields[CloudletFieldResourceQuotasAlertThreshold] = struct{}{}
				fields[CloudletFieldResourceQuotas] = struct{}{}
			}
		}
	}
	if m.DefaultResourceAlertThreshold != o.DefaultResourceAlertThreshold {
		fields[CloudletFieldDefaultResourceAlertThreshold] = struct{}{}
	}
	if m.HostController != o.HostController {
		fields[CloudletFieldHostController] = struct{}{}
	}
	if m.KafkaCluster != o.KafkaCluster {
		fields[CloudletFieldKafkaCluster] = struct{}{}
	}
	if m.KafkaUser != o.KafkaUser {
		fields[CloudletFieldKafkaUser] = struct{}{}
	}
	if m.KafkaPassword != o.KafkaPassword {
		fields[CloudletFieldKafkaPassword] = struct{}{}
	}
	if m.GpuConfig.Driver.Name != o.GpuConfig.Driver.Name {
		fields[CloudletFieldGpuConfigDriverName] = struct{}{}
		fields[CloudletFieldGpuConfigDriver] = struct{}{}
		fields[CloudletFieldGpuConfig] = struct{}{}
	}
	if m.GpuConfig.Driver.Organization != o.GpuConfig.Driver.Organization {
		fields[CloudletFieldGpuConfigDriverOrganization] = struct{}{}
		fields[CloudletFieldGpuConfigDriver] = struct{}{}
		fields[CloudletFieldGpuConfig] = struct{}{}
	}
	if m.GpuConfig.Properties != nil && o.GpuConfig.Properties != nil {
		if len(m.GpuConfig.Properties) != len(o.GpuConfig.Properties) {
			fields[CloudletFieldGpuConfigProperties] = struct{}{}
			fields[CloudletFieldGpuConfig] = struct{}{}
		} else {
			for k1, _ := range m.GpuConfig.Properties {
				_, vok1 := o.GpuConfig.Properties[k1]
				if !vok1 {
					fields[CloudletFieldGpuConfigProperties] = struct{}{}
					fields[CloudletFieldGpuConfig] = struct{}{}
				} else {
					if m.GpuConfig.Properties[k1] != o.GpuConfig.Properties[k1] {
						fields[CloudletFieldGpuConfigProperties] = struct{}{}
						fields[CloudletFieldGpuConfig] = struct{}{}
						break
					}
				}
			}
		}
	} else if (m.GpuConfig.Properties != nil && o.GpuConfig.Properties == nil) || (m.GpuConfig.Properties == nil && o.GpuConfig.Properties != nil) {
		fields[CloudletFieldGpuConfigProperties] = struct{}{}
		fields[CloudletFieldGpuConfig] = struct{}{}
	}
	if m.GpuConfig.LicenseConfig != o.GpuConfig.LicenseConfig {
		fields[CloudletFieldGpuConfigLicenseConfig] = struct{}{}
		fields[CloudletFieldGpuConfig] = struct{}{}
	}
	if m.GpuConfig.LicenseConfigMd5Sum != o.GpuConfig.LicenseConfigMd5Sum {
		fields[CloudletFieldGpuConfigLicenseConfigMd5Sum] = struct{}{}
		fields[CloudletFieldGpuConfig] = struct{}{}
	}
	if m.EnableDefaultServerlessCluster != o.EnableDefaultServerlessCluster {
		fields[CloudletFieldEnableDefaultServerlessCluster] = struct{}{}
	}
	if len(m.AllianceOrgs) != len(o.AllianceOrgs) {
		fields[CloudletFieldAllianceOrgs] = struct{}{}
	} else {
		for i0 := 0; i0 < len(m.AllianceOrgs); i0++ {
			if m.AllianceOrgs[i0] != o.AllianceOrgs[i0] {
				fields[CloudletFieldAllianceOrgs] = struct{}{}
				break
			}
		}
	}
	if m.SingleKubernetesClusterOwner != o.SingleKubernetesClusterOwner {
		fields[CloudletFieldSingleKubernetesClusterOwner] = struct{}{}
	}
	if m.DeletePrepare != o.DeletePrepare {
		fields[CloudletFieldDeletePrepare] = struct{}{}
	}
	if m.PlatformHighAvailability != o.PlatformHighAvailability {
		fields[CloudletFieldPlatformHighAvailability] = struct{}{}
	}
	if m.SecondaryCrmAccessPublicKey != o.SecondaryCrmAccessPublicKey {
		fields[CloudletFieldSecondaryCrmAccessPublicKey] = struct{}{}
	}
	if m.SecondaryCrmAccessKeyUpgradeRequired != o.SecondaryCrmAccessKeyUpgradeRequired {
		fields[CloudletFieldSecondaryCrmAccessKeyUpgradeRequired] = struct{}{}
	}
	if m.SecondaryNotifySrvAddr != o.SecondaryNotifySrvAddr {
		fields[CloudletFieldSecondaryNotifySrvAddr] = struct{}{}
	}
	if m.DnsLabel != o.DnsLabel {
		fields[CloudletFieldDnsLabel] = struct{}{}
	}
	if m.RootLbFqdn != o.RootLbFqdn {
		fields[CloudletFieldRootLbFqdn] = struct{}{}
	}
	if m.FederationConfig.FederationContextId != o.FederationConfig.FederationContextId {
		fields[CloudletFieldFederationConfigFederationContextId] = struct{}{}
		fields[CloudletFieldFederationConfig] = struct{}{}
	}
	if m.FederationConfig.PartnerFederationAddr != o.FederationConfig.PartnerFederationAddr {
		fields[CloudletFieldFederationConfigPartnerFederationAddr] = struct{}{}
		fields[CloudletFieldFederationConfig] = struct{}{}
	}
	if m.FederationConfig.FederationDbId != o.FederationConfig.FederationDbId {
		fields[CloudletFieldFederationConfigFederationDbId] = struct{}{}
		fields[CloudletFieldFederationConfig] = struct{}{}
	}
	if m.FederationConfig.FederationName != o.FederationConfig.FederationName {
		fields[CloudletFieldFederationConfigFederationName] = struct{}{}
		fields[CloudletFieldFederationConfig] = struct{}{}
	}
	if m.LicenseConfigStoragePath != o.LicenseConfigStoragePath {
		fields[CloudletFieldLicenseConfigStoragePath] = struct{}{}
	}
	if m.InfraFlavors != nil && o.InfraFlavors != nil {
		if len(m.InfraFlavors) != len(o.InfraFlavors) {
			fields[CloudletFieldInfraFlavors] = struct{}{}
		} else {
			for i0 := 0; i0 < len(m.InfraFlavors); i0++ {
				if m.InfraFlavors[i0].Name != o.InfraFlavors[i0].Name {
					fields[CloudletFieldInfraFlavorsName] = struct{}{}
					fields[CloudletFieldInfraFlavors] = struct{}{}
				}
				if m.InfraFlavors[i0].Vcpus != o.InfraFlavors[i0].Vcpus {
					fields[CloudletFieldInfraFlavorsVcpus] = struct{}{}
					fields[CloudletFieldInfraFlavors] = struct{}{}
				}
				if m.InfraFlavors[i0].Ram != o.InfraFlavors[i0].Ram {
					fields[CloudletFieldInfraFlavorsRam] = struct{}{}
					fields[CloudletFieldInfraFlavors] = struct{}{}
				}
				if m.InfraFlavors[i0].Disk != o.InfraFlavors[i0].Disk {
					fields[CloudletFieldInfraFlavorsDisk] = struct{}{}
					fields[CloudletFieldInfraFlavors] = struct{}{}
				}
				if m.InfraFlavors[i0].PropMap != nil && o.InfraFlavors[i0].PropMap != nil {
					if len(m.InfraFlavors[i0].PropMap) != len(o.InfraFlavors[i0].PropMap) {
						fields[CloudletFieldInfraFlavorsPropMap] = struct{}{}
						fields[CloudletFieldInfraFlavors] = struct{}{}
					} else {
						for k1, _ := range m.InfraFlavors[i0].PropMap {
							_, vok1 := o.InfraFlavors[i0].PropMap[k1]
							if !vok1 {
								fields[CloudletFieldInfraFlavorsPropMap] = struct{}{}
								fields[CloudletFieldInfraFlavors] = struct{}{}
							} else {
								if m.InfraFlavors[i0].PropMap[k1] != o.InfraFlavors[i0].PropMap[k1] {
									fields[CloudletFieldInfraFlavorsPropMap] = struct{}{}
									fields[CloudletFieldInfraFlavors] = struct{}{}
									break
								}
							}
						}
					}
				} else if (m.InfraFlavors[i0].PropMap != nil && o.InfraFlavors[i0].PropMap == nil) || (m.InfraFlavors[i0].PropMap == nil && o.InfraFlavors[i0].PropMap != nil) {
					fields[CloudletFieldInfraFlavorsPropMap] = struct{}{}
					fields[CloudletFieldInfraFlavors] = struct{}{}
				}
			}
		}
	} else if (m.InfraFlavors != nil && o.InfraFlavors == nil) || (m.InfraFlavors == nil && o.InfraFlavors != nil) {
		fields[CloudletFieldInfraFlavors] = struct{}{}
	}
	if m.EdgeboxOnly != o.EdgeboxOnly {
		fields[CloudletFieldEdgeboxOnly] = struct{}{}
	}
	if m.OnboardingState != o.OnboardingState {
		fields[CloudletFieldOnboardingState] = struct{}{}
	}
}

var UpdateCloudletFieldsMap = map[string]struct{}{
	CloudletFieldLocation:                           struct{}{},
	CloudletFieldLocationLatitude:                   struct{}{},
	CloudletFieldLocationLongitude:                  struct{}{},
	CloudletFieldLocationAltitude:                   struct{}{},
	CloudletFieldIpSupport:                          struct{}{},
	CloudletFieldStaticIps:                          struct{}{},
	CloudletFieldNumDynamicIps:                      struct{}{},
	CloudletFieldTimeLimits:                         struct{}{},
	CloudletFieldTimeLimitsCreateClusterInstTimeout: struct{}{},
	CloudletFieldTimeLimitsUpdateClusterInstTimeout: struct{}{},
	CloudletFieldTimeLimitsDeleteClusterInstTimeout: struct{}{},
	CloudletFieldTimeLimitsCreateAppInstTimeout:     struct{}{},
	CloudletFieldTimeLimitsUpdateAppInstTimeout:     struct{}{},
	CloudletFieldTimeLimitsDeleteAppInstTimeout:     struct{}{},
	CloudletFieldCrmOverride:                        struct{}{},
	CloudletFieldNotifySrvAddr:                      struct{}{},
	CloudletFieldEnvVar:                             struct{}{},
	CloudletFieldEnvVarKey:                          struct{}{},
	CloudletFieldEnvVarValue:                        struct{}{},
	CloudletFieldAccessVars:                         struct{}{},
	CloudletFieldAccessVarsKey:                      struct{}{},
	CloudletFieldAccessVarsValue:                    struct{}{},
	CloudletFieldMaintenanceState:                   struct{}{},
	CloudletFieldTrustPolicy:                        struct{}{},
	CloudletFieldResourceQuotas:                     struct{}{},
	CloudletFieldResourceQuotasName:                 struct{}{},
	CloudletFieldResourceQuotasValue:                struct{}{},
	CloudletFieldResourceQuotasAlertThreshold:       struct{}{},
	CloudletFieldDefaultResourceAlertThreshold:      struct{}{},
	CloudletFieldKafkaCluster:                       struct{}{},
	CloudletFieldKafkaUser:                          struct{}{},
	CloudletFieldKafkaPassword:                      struct{}{},
	CloudletFieldGpuConfig:                          struct{}{},
	CloudletFieldGpuConfigDriver:                    struct{}{},
	CloudletFieldGpuConfigDriverName:                struct{}{},
	CloudletFieldGpuConfigDriverOrganization:        struct{}{},
	CloudletFieldGpuConfigProperties:                struct{}{},
	CloudletFieldGpuConfigPropertiesKey:             struct{}{},
	CloudletFieldGpuConfigPropertiesValue:           struct{}{},
	CloudletFieldGpuConfigLicenseConfig:             struct{}{},
	CloudletFieldEnableDefaultServerlessCluster:     struct{}{},
	CloudletFieldAllianceOrgs:                       struct{}{},
	CloudletFieldSingleKubernetesClusterOwner:       struct{}{},
	CloudletFieldPlatformHighAvailability:           struct{}{},
	CloudletFieldSecondaryNotifySrvAddr:             struct{}{},
	CloudletFieldInfraFlavors:                       struct{}{},
	CloudletFieldInfraFlavorsName:                   struct{}{},
	CloudletFieldInfraFlavorsVcpus:                  struct{}{},
	CloudletFieldInfraFlavorsRam:                    struct{}{},
	CloudletFieldInfraFlavorsDisk:                   struct{}{},
	CloudletFieldInfraFlavorsPropMap:                struct{}{},
	CloudletFieldInfraFlavorsPropMapKey:             struct{}{},
	CloudletFieldInfraFlavorsPropMapValue:           struct{}{},
	CloudletFieldOnboardingState:                    struct{}{},
}

func (m *Cloudlet) ValidateUpdateFields() error {
	if m.Fields == nil {
		return fmt.Errorf("nothing specified to update")
	}
	fmap := MakeFieldMap(m.Fields)
	badFieldStrs := []string{}
	for field, _ := range fmap {
		if m.IsKeyField(field) {
			continue
		}
		if _, ok := UpdateCloudletFieldsMap[field]; !ok {
			if _, ok := CloudletAllFieldsStringMap[field]; !ok {
				continue
			}
			badFieldStrs = append(badFieldStrs, CloudletAllFieldsStringMap[field])
		}
	}
	if len(badFieldStrs) > 0 {
		return fmt.Errorf("specified field(s) %s cannot be modified", strings.Join(badFieldStrs, ","))
	}
	return nil
}

func (m *Cloudlet) Clone() *Cloudlet {
	cp := &Cloudlet{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *Cloudlet) AddErrors(vals ...string) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.Errors {
		cur[v] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v]; found {
			continue // duplicate
		}
		m.Errors = append(m.Errors, v)
		changes++
	}
	return changes
}

func (m *Cloudlet) RemoveErrors(vals ...string) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v] = struct{}{}
	}
	for i := len(m.Errors); i >= 0; i-- {
		if _, found := remove[m.Errors[i]]; found {
			m.Errors = append(m.Errors[:i], m.Errors[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *Cloudlet) AddResourceQuotas(vals ...ResourceQuota) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.ResourceQuotas {
		cur[v.String()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.String()]; found {
			continue // duplicate
		}
		m.ResourceQuotas = append(m.ResourceQuotas, v)
		changes++
	}
	return changes
}

func (m *Cloudlet) RemoveResourceQuotas(vals ...ResourceQuota) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.String()] = struct{}{}
	}
	for i := len(m.ResourceQuotas); i >= 0; i-- {
		if _, found := remove[m.ResourceQuotas[i].String()]; found {
			m.ResourceQuotas = append(m.ResourceQuotas[:i], m.ResourceQuotas[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *Cloudlet) AddAllianceOrgs(vals ...string) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.AllianceOrgs {
		cur[v] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v]; found {
			continue // duplicate
		}
		m.AllianceOrgs = append(m.AllianceOrgs, v)
		changes++
	}
	return changes
}

func (m *Cloudlet) RemoveAllianceOrgs(vals ...string) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v] = struct{}{}
	}
	for i := len(m.AllianceOrgs); i >= 0; i-- {
		if _, found := remove[m.AllianceOrgs[i]]; found {
			m.AllianceOrgs = append(m.AllianceOrgs[:i], m.AllianceOrgs[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *Cloudlet) AddInfraFlavors(vals ...*FlavorInfo) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.InfraFlavors {
		cur[v.String()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.String()]; found {
			continue // duplicate
		}
		m.InfraFlavors = append(m.InfraFlavors, v)
		changes++
	}
	return changes
}

func (m *Cloudlet) RemoveInfraFlavors(vals ...*FlavorInfo) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.String()] = struct{}{}
	}
	for i := len(m.InfraFlavors); i >= 0; i-- {
		if _, found := remove[m.InfraFlavors[i].String()]; found {
			m.InfraFlavors = append(m.InfraFlavors[:i], m.InfraFlavors[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *Cloudlet) CopyInFields(src *Cloudlet) int {
	updateListAction := "replace"
	changed := 0
	fmap := MakeFieldMap(src.Fields)
	if _, set := fmap["2"]; set {
		if _, set := fmap["2.1"]; set {
			if m.Key.Organization != src.Key.Organization {
				m.Key.Organization = src.Key.Organization
				changed++
			}
		}
		if _, set := fmap["2.2"]; set {
			if m.Key.Name != src.Key.Name {
				m.Key.Name = src.Key.Name
				changed++
			}
		}
		if _, set := fmap["2.3"]; set {
			if m.Key.FederatedOrganization != src.Key.FederatedOrganization {
				m.Key.FederatedOrganization = src.Key.FederatedOrganization
				changed++
			}
		}
	}
	if _, set := fmap["5"]; set {
		if _, set := fmap["5.1"]; set {
			if m.Location.Latitude != src.Location.Latitude {
				m.Location.Latitude = src.Location.Latitude
				changed++
			}
		}
		if _, set := fmap["5.2"]; set {
			if m.Location.Longitude != src.Location.Longitude {
				m.Location.Longitude = src.Location.Longitude
				changed++
			}
		}
		if _, set := fmap["5.3"]; set {
			if m.Location.HorizontalAccuracy != src.Location.HorizontalAccuracy {
				m.Location.HorizontalAccuracy = src.Location.HorizontalAccuracy
				changed++
			}
		}
		if _, set := fmap["5.4"]; set {
			if m.Location.VerticalAccuracy != src.Location.VerticalAccuracy {
				m.Location.VerticalAccuracy = src.Location.VerticalAccuracy
				changed++
			}
		}
		if _, set := fmap["5.5"]; set {
			if m.Location.Altitude != src.Location.Altitude {
				m.Location.Altitude = src.Location.Altitude
				changed++
			}
		}
		if _, set := fmap["5.6"]; set {
			if m.Location.Course != src.Location.Course {
				m.Location.Course = src.Location.Course
				changed++
			}
		}
		if _, set := fmap["5.7"]; set {
			if m.Location.Speed != src.Location.Speed {
				m.Location.Speed = src.Location.Speed
				changed++
			}
		}
		if _, set := fmap["5.8"]; set {
			if src.Location.Timestamp != nil {
				if m.Location.Timestamp == nil {
					m.Location.Timestamp = &distributed_match_engine.Timestamp{}
				}
				if _, set := fmap["5.8.1"]; set {
					if m.Location.Timestamp.Seconds != src.Location.Timestamp.Seconds {
						m.Location.Timestamp.Seconds = src.Location.Timestamp.Seconds
						changed++
					}
				}
				if _, set := fmap["5.8.2"]; set {
					if m.Location.Timestamp.Nanos != src.Location.Timestamp.Nanos {
						m.Location.Timestamp.Nanos = src.Location.Timestamp.Nanos
						changed++
					}
				}
			} else if m.Location.Timestamp != nil {
				m.Location.Timestamp = nil
				changed++
			}
		}
	}
	if _, set := fmap["6"]; set {
		if m.IpSupport != src.IpSupport {
			m.IpSupport = src.IpSupport
			changed++
		}
	}
	if _, set := fmap["7"]; set {
		if m.StaticIps != src.StaticIps {
			m.StaticIps = src.StaticIps
			changed++
		}
	}
	if _, set := fmap["8"]; set {
		if m.NumDynamicIps != src.NumDynamicIps {
			m.NumDynamicIps = src.NumDynamicIps
			changed++
		}
	}
	if _, set := fmap["9"]; set {
		if _, set := fmap["9.1"]; set {
			if m.TimeLimits.CreateClusterInstTimeout != src.TimeLimits.CreateClusterInstTimeout {
				m.TimeLimits.CreateClusterInstTimeout = src.TimeLimits.CreateClusterInstTimeout
				changed++
			}
		}
		if _, set := fmap["9.2"]; set {
			if m.TimeLimits.UpdateClusterInstTimeout != src.TimeLimits.UpdateClusterInstTimeout {
				m.TimeLimits.UpdateClusterInstTimeout = src.TimeLimits.UpdateClusterInstTimeout
				changed++
			}
		}
		if _, set := fmap["9.3"]; set {
			if m.TimeLimits.DeleteClusterInstTimeout != src.TimeLimits.DeleteClusterInstTimeout {
				m.TimeLimits.DeleteClusterInstTimeout = src.TimeLimits.DeleteClusterInstTimeout
				changed++
			}
		}
		if _, set := fmap["9.4"]; set {
			if m.TimeLimits.CreateAppInstTimeout != src.TimeLimits.CreateAppInstTimeout {
				m.TimeLimits.CreateAppInstTimeout = src.TimeLimits.CreateAppInstTimeout
				changed++
			}
		}
		if _, set := fmap["9.5"]; set {
			if m.TimeLimits.UpdateAppInstTimeout != src.TimeLimits.UpdateAppInstTimeout {
				m.TimeLimits.UpdateAppInstTimeout = src.TimeLimits.UpdateAppInstTimeout
				changed++
			}
		}
		if _, set := fmap["9.6"]; set {
			if m.TimeLimits.DeleteAppInstTimeout != src.TimeLimits.DeleteAppInstTimeout {
				m.TimeLimits.DeleteAppInstTimeout = src.TimeLimits.DeleteAppInstTimeout
				changed++
			}
		}
	}
	if _, set := fmap["10"]; set {
		if src.Errors != nil {
			if updateListAction == "add" {
				changed += m.AddErrors(src.Errors...)
			} else if updateListAction == "remove" {
				changed += m.RemoveErrors(src.Errors...)
			} else {
				m.Errors = make([]string, 0)
				m.Errors = append(m.Errors, src.Errors...)
				changed++
			}
		} else if m.Errors != nil {
			m.Errors = nil
			changed++
		}
	}
	if _, set := fmap["12"]; set {
		if m.State != src.State {
			m.State = src.State
			changed++
		}
	}
	if _, set := fmap["13"]; set {
		if m.CrmOverride != src.CrmOverride {
			m.CrmOverride = src.CrmOverride
			changed++
		}
	}
	if _, set := fmap["14"]; set {
		if m.DeploymentLocal != src.DeploymentLocal {
			m.DeploymentLocal = src.DeploymentLocal
			changed++
		}
	}
	if _, set := fmap["15"]; set {
		if m.PlatformType != src.PlatformType {
			m.PlatformType = src.PlatformType
			changed++
		}
	}
	if _, set := fmap["16"]; set {
		if m.NotifySrvAddr != src.NotifySrvAddr {
			m.NotifySrvAddr = src.NotifySrvAddr
			changed++
		}
	}
	if _, set := fmap["17"]; set {
		if _, set := fmap["17.1"]; set {
			if m.Flavor.Name != src.Flavor.Name {
				m.Flavor.Name = src.Flavor.Name
				changed++
			}
		}
	}
	if _, set := fmap["18"]; set {
		if m.PhysicalName != src.PhysicalName {
			m.PhysicalName = src.PhysicalName
			changed++
		}
	}
	if _, set := fmap["19"]; set {
		if src.EnvVar != nil {
			if updateListAction == "add" {
				for k0, v := range src.EnvVar {
					m.EnvVar[k0] = v
					changed++
				}
			} else if updateListAction == "remove" {
				for k0, _ := range src.EnvVar {
					if _, ok := m.EnvVar[k0]; ok {
						delete(m.EnvVar, k0)
						changed++
					}
				}
			} else {
				m.EnvVar = make(map[string]string)
				for k0, v := range src.EnvVar {
					m.EnvVar[k0] = v
				}
				changed++
			}
		} else if m.EnvVar != nil {
			m.EnvVar = nil
			changed++
		}
	}
	if _, set := fmap["20"]; set {
		if m.ContainerVersion != src.ContainerVersion {
			m.ContainerVersion = src.ContainerVersion
			changed++
		}
	}
	if _, set := fmap["21"]; set {
		if _, set := fmap["21.1"]; set {
			if m.Config.ContainerRegistryPath != src.Config.ContainerRegistryPath {
				m.Config.ContainerRegistryPath = src.Config.ContainerRegistryPath
				changed++
			}
		}
		if _, set := fmap["21.2"]; set {
			if m.Config.CloudletVmImagePath != src.Config.CloudletVmImagePath {
				m.Config.CloudletVmImagePath = src.Config.CloudletVmImagePath
				changed++
			}
		}
		if _, set := fmap["21.3"]; set {
			if m.Config.NotifyCtrlAddrs != src.Config.NotifyCtrlAddrs {
				m.Config.NotifyCtrlAddrs = src.Config.NotifyCtrlAddrs
				changed++
			}
		}
		if _, set := fmap["21.5"]; set {
			if m.Config.TlsCertFile != src.Config.TlsCertFile {
				m.Config.TlsCertFile = src.Config.TlsCertFile
				changed++
			}
		}
		if _, set := fmap["21.6"]; set {
			if src.Config.EnvVar != nil {
				if updateListAction == "add" {
					for k1, v := range src.Config.EnvVar {
						m.Config.EnvVar[k1] = v
						changed++
					}
				} else if updateListAction == "remove" {
					for k1, _ := range src.Config.EnvVar {
						if _, ok := m.Config.EnvVar[k1]; ok {
							delete(m.Config.EnvVar, k1)
							changed++
						}
					}
				} else {
					m.Config.EnvVar = make(map[string]string)
					for k1, v := range src.Config.EnvVar {
						m.Config.EnvVar[k1] = v
					}
					changed++
				}
			} else if m.Config.EnvVar != nil {
				m.Config.EnvVar = nil
				changed++
			}
		}
		if _, set := fmap["21.8"]; set {
			if m.Config.PlatformTag != src.Config.PlatformTag {
				m.Config.PlatformTag = src.Config.PlatformTag
				changed++
			}
		}
		if _, set := fmap["21.9"]; set {
			if m.Config.TestMode != src.Config.TestMode {
				m.Config.TestMode = src.Config.TestMode
				changed++
			}
		}
		if _, set := fmap["21.10"]; set {
			if m.Config.Span != src.Config.Span {
				m.Config.Span = src.Config.Span
				changed++
			}
		}
		if _, set := fmap["21.11"]; set {
			if m.Config.CleanupMode != src.Config.CleanupMode {
				m.Config.CleanupMode = src.Config.CleanupMode
				changed++
			}
		}
		if _, set := fmap["21.12"]; set {
			if m.Config.Region != src.Config.Region {
				m.Config.Region = src.Config.Region
				changed++
			}
		}
		if _, set := fmap["21.13"]; set {
			if m.Config.CommercialCerts != src.Config.CommercialCerts {
				m.Config.CommercialCerts = src.Config.CommercialCerts
				changed++
			}
		}
		if _, set := fmap["21.14"]; set {
			if m.Config.UseVaultPki != src.Config.UseVaultPki {
				m.Config.UseVaultPki = src.Config.UseVaultPki
				changed++
			}
		}
		if _, set := fmap["21.16"]; set {
			if m.Config.AppDnsRoot != src.Config.AppDnsRoot {
				m.Config.AppDnsRoot = src.Config.AppDnsRoot
				changed++
			}
		}
		if _, set := fmap["21.19"]; set {
			if m.Config.DeploymentTag != src.Config.DeploymentTag {
				m.Config.DeploymentTag = src.Config.DeploymentTag
				changed++
			}
		}
		if _, set := fmap["21.20"]; set {
			if m.Config.TlsKeyFile != src.Config.TlsKeyFile {
				m.Config.TlsKeyFile = src.Config.TlsKeyFile
				changed++
			}
		}
		if _, set := fmap["21.21"]; set {
			if m.Config.TlsCaFile != src.Config.TlsCaFile {
				m.Config.TlsCaFile = src.Config.TlsCaFile
				changed++
			}
		}
		if _, set := fmap["21.22"]; set {
			if m.Config.CrmAccessPrivateKey != src.Config.CrmAccessPrivateKey {
				m.Config.CrmAccessPrivateKey = src.Config.CrmAccessPrivateKey
				changed++
			}
		}
		if _, set := fmap["21.23"]; set {
			if m.Config.AccessApiAddr != src.Config.AccessApiAddr {
				m.Config.AccessApiAddr = src.Config.AccessApiAddr
				changed++
			}
		}
		if _, set := fmap["21.24"]; set {
			if m.Config.CacheDir != src.Config.CacheDir {
				m.Config.CacheDir = src.Config.CacheDir
				changed++
			}
		}
		if _, set := fmap["21.25"]; set {
			if m.Config.SecondaryCrmAccessPrivateKey != src.Config.SecondaryCrmAccessPrivateKey {
				m.Config.SecondaryCrmAccessPrivateKey = src.Config.SecondaryCrmAccessPrivateKey
				changed++
			}
		}
		if _, set := fmap["21.26"]; set {
			if m.Config.ThanosRecvAddr != src.Config.ThanosRecvAddr {
				m.Config.ThanosRecvAddr = src.Config.ThanosRecvAddr
				changed++
			}
		}
		if _, set := fmap["21.27"]; set {
			if m.Config.AnsiblePublicAddr != src.Config.AnsiblePublicAddr {
				m.Config.AnsiblePublicAddr = src.Config.AnsiblePublicAddr
				changed++
			}
		}
		if _, set := fmap["21.29"]; set {
			if m.Config.EnvoyWithCurlImage != src.Config.EnvoyWithCurlImage {
				m.Config.EnvoyWithCurlImage = src.Config.EnvoyWithCurlImage
				changed++
			}
		}
		if _, set := fmap["21.30"]; set {
			if m.Config.NginxWithCurlImage != src.Config.NginxWithCurlImage {
				m.Config.NginxWithCurlImage = src.Config.NginxWithCurlImage
				changed++
			}
		}
	}
	if _, set := fmap["22"]; set {
		if src.ResTagMap != nil {
			if updateListAction == "add" {
				for k0, v := range src.ResTagMap {
					v = v.Clone()
					m.ResTagMap[k0] = v
					changed++
				}
			} else if updateListAction == "remove" {
				for k0, _ := range src.ResTagMap {
					if _, ok := m.ResTagMap[k0]; ok {
						delete(m.ResTagMap, k0)
						changed++
					}
				}
			} else {
				m.ResTagMap = make(map[string]*ResTagTableKey)
				for k0, v := range src.ResTagMap {
					m.ResTagMap[k0] = v.Clone()
				}
				changed++
			}
		} else if m.ResTagMap != nil {
			m.ResTagMap = nil
			changed++
		}
	}
	if _, set := fmap["23"]; set {
		if src.AccessVars != nil {
			if updateListAction == "add" {
				for k0, v := range src.AccessVars {
					m.AccessVars[k0] = v
					changed++
				}
			} else if updateListAction == "remove" {
				for k0, _ := range src.AccessVars {
					if _, ok := m.AccessVars[k0]; ok {
						delete(m.AccessVars, k0)
						changed++
					}
				}
			} else {
				m.AccessVars = make(map[string]string)
				for k0, v := range src.AccessVars {
					m.AccessVars[k0] = v
				}
				changed++
			}
		} else if m.AccessVars != nil {
			m.AccessVars = nil
			changed++
		}
	}
	if _, set := fmap["24"]; set {
		if m.VmImageVersion != src.VmImageVersion {
			m.VmImageVersion = src.VmImageVersion
			changed++
		}
	}
	if _, set := fmap["26"]; set {
		if m.Deployment != src.Deployment {
			m.Deployment = src.Deployment
			changed++
		}
	}
	if _, set := fmap["27"]; set {
		if m.InfraApiAccess != src.InfraApiAccess {
			m.InfraApiAccess = src.InfraApiAccess
			changed++
		}
	}
	if _, set := fmap["28"]; set {
		if _, set := fmap["28.1"]; set {
			if m.InfraConfig.ExternalNetworkName != src.InfraConfig.ExternalNetworkName {
				m.InfraConfig.ExternalNetworkName = src.InfraConfig.ExternalNetworkName
				changed++
			}
		}
		if _, set := fmap["28.2"]; set {
			if m.InfraConfig.FlavorName != src.InfraConfig.FlavorName {
				m.InfraConfig.FlavorName = src.InfraConfig.FlavorName
				changed++
			}
		}
	}
	if _, set := fmap["30"]; set {
		if m.MaintenanceState != src.MaintenanceState {
			m.MaintenanceState = src.MaintenanceState
			changed++
		}
	}
	if _, set := fmap["31"]; set {
		if m.OverridePolicyContainerVersion != src.OverridePolicyContainerVersion {
			m.OverridePolicyContainerVersion = src.OverridePolicyContainerVersion
			changed++
		}
	}
	if _, set := fmap["32"]; set {
		if m.VmPool != src.VmPool {
			m.VmPool = src.VmPool
			changed++
		}
	}
	if _, set := fmap["33"]; set {
		if m.CrmAccessPublicKey != src.CrmAccessPublicKey {
			m.CrmAccessPublicKey = src.CrmAccessPublicKey
			changed++
		}
	}
	if _, set := fmap["34"]; set {
		if m.CrmAccessKeyUpgradeRequired != src.CrmAccessKeyUpgradeRequired {
			m.CrmAccessKeyUpgradeRequired = src.CrmAccessKeyUpgradeRequired
			changed++
		}
	}
	if _, set := fmap["35"]; set {
		if _, set := fmap["35.1"]; set {
			if m.CreatedAt.Seconds != src.CreatedAt.Seconds {
				m.CreatedAt.Seconds = src.CreatedAt.Seconds
				changed++
			}
		}
		if _, set := fmap["35.2"]; set {
			if m.CreatedAt.Nanos != src.CreatedAt.Nanos {
				m.CreatedAt.Nanos = src.CreatedAt.Nanos
				changed++
			}
		}
	}
	if _, set := fmap["36"]; set {
		if _, set := fmap["36.1"]; set {
			if m.UpdatedAt.Seconds != src.UpdatedAt.Seconds {
				m.UpdatedAt.Seconds = src.UpdatedAt.Seconds
				changed++
			}
		}
		if _, set := fmap["36.2"]; set {
			if m.UpdatedAt.Nanos != src.UpdatedAt.Nanos {
				m.UpdatedAt.Nanos = src.UpdatedAt.Nanos
				changed++
			}
		}
	}
	if _, set := fmap["37"]; set {
		if m.TrustPolicy != src.TrustPolicy {
			m.TrustPolicy = src.TrustPolicy
			changed++
		}
	}
	if _, set := fmap["38"]; set {
		if m.TrustPolicyState != src.TrustPolicyState {
			m.TrustPolicyState = src.TrustPolicyState
			changed++
		}
	}
	if _, set := fmap["39"]; set {
		if src.ResourceQuotas != nil {
			if updateListAction == "add" {
				changed += m.AddResourceQuotas(src.ResourceQuotas...)
			} else if updateListAction == "remove" {
				changed += m.RemoveResourceQuotas(src.ResourceQuotas...)
			} else {
				m.ResourceQuotas = make([]ResourceQuota, 0)
				for k0, _ := range src.ResourceQuotas {
					m.ResourceQuotas = append(m.ResourceQuotas, *src.ResourceQuotas[k0].Clone())
				}
				changed++
			}
		} else if m.ResourceQuotas != nil {
			m.ResourceQuotas = nil
			changed++
		}
	}
	if _, set := fmap["40"]; set {
		if m.DefaultResourceAlertThreshold != src.DefaultResourceAlertThreshold {
			m.DefaultResourceAlertThreshold = src.DefaultResourceAlertThreshold
			changed++
		}
	}
	if _, set := fmap["41"]; set {
		if m.HostController != src.HostController {
			m.HostController = src.HostController
			changed++
		}
	}
	if _, set := fmap["42"]; set {
		if m.KafkaCluster != src.KafkaCluster {
			m.KafkaCluster = src.KafkaCluster
			changed++
		}
	}
	if _, set := fmap["43"]; set {
		if m.KafkaUser != src.KafkaUser {
			m.KafkaUser = src.KafkaUser
			changed++
		}
	}
	if _, set := fmap["44"]; set {
		if m.KafkaPassword != src.KafkaPassword {
			m.KafkaPassword = src.KafkaPassword
			changed++
		}
	}
	if _, set := fmap["45"]; set {
		if _, set := fmap["45.1"]; set {
			if _, set := fmap["45.1.1"]; set {
				if m.GpuConfig.Driver.Name != src.GpuConfig.Driver.Name {
					m.GpuConfig.Driver.Name = src.GpuConfig.Driver.Name
					changed++
				}
			}
			if _, set := fmap["45.1.2"]; set {
				if m.GpuConfig.Driver.Organization != src.GpuConfig.Driver.Organization {
					m.GpuConfig.Driver.Organization = src.GpuConfig.Driver.Organization
					changed++
				}
			}
		}
		if _, set := fmap["45.2"]; set {
			if src.GpuConfig.Properties != nil {
				if updateListAction == "add" {
					for k1, v := range src.GpuConfig.Properties {
						m.GpuConfig.Properties[k1] = v
						changed++
					}
				} else if updateListAction == "remove" {
					for k1, _ := range src.GpuConfig.Properties {
						if _, ok := m.GpuConfig.Properties[k1]; ok {
							delete(m.GpuConfig.Properties, k1)
							changed++
						}
					}
				} else {
					m.GpuConfig.Properties = make(map[string]string)
					for k1, v := range src.GpuConfig.Properties {
						m.GpuConfig.Properties[k1] = v
					}
					changed++
				}
			} else if m.GpuConfig.Properties != nil {
				m.GpuConfig.Properties = nil
				changed++
			}
		}
		if _, set := fmap["45.3"]; set {
			if m.GpuConfig.LicenseConfig != src.GpuConfig.LicenseConfig {
				m.GpuConfig.LicenseConfig = src.GpuConfig.LicenseConfig
				changed++
			}
		}
		if _, set := fmap["45.4"]; set {
			if m.GpuConfig.LicenseConfigMd5Sum != src.GpuConfig.LicenseConfigMd5Sum {
				m.GpuConfig.LicenseConfigMd5Sum = src.GpuConfig.LicenseConfigMd5Sum
				changed++
			}
		}
	}
	if _, set := fmap["46"]; set {
		if m.EnableDefaultServerlessCluster != src.EnableDefaultServerlessCluster {
			m.EnableDefaultServerlessCluster = src.EnableDefaultServerlessCluster
			changed++
		}
	}
	if _, set := fmap["47"]; set {
		if src.AllianceOrgs != nil {
			if updateListAction == "add" {
				changed += m.AddAllianceOrgs(src.AllianceOrgs...)
			} else if updateListAction == "remove" {
				changed += m.RemoveAllianceOrgs(src.AllianceOrgs...)
			} else {
				m.AllianceOrgs = make([]string, 0)
				m.AllianceOrgs = append(m.AllianceOrgs, src.AllianceOrgs...)
				changed++
			}
		} else if m.AllianceOrgs != nil {
			m.AllianceOrgs = nil
			changed++
		}
	}
	if _, set := fmap["48"]; set {
		if m.SingleKubernetesClusterOwner != src.SingleKubernetesClusterOwner {
			m.SingleKubernetesClusterOwner = src.SingleKubernetesClusterOwner
			changed++
		}
	}
	if _, set := fmap["49"]; set {
		if m.DeletePrepare != src.DeletePrepare {
			m.DeletePrepare = src.DeletePrepare
			changed++
		}
	}
	if _, set := fmap["50"]; set {
		if m.PlatformHighAvailability != src.PlatformHighAvailability {
			m.PlatformHighAvailability = src.PlatformHighAvailability
			changed++
		}
	}
	if _, set := fmap["51"]; set {
		if m.SecondaryCrmAccessPublicKey != src.SecondaryCrmAccessPublicKey {
			m.SecondaryCrmAccessPublicKey = src.SecondaryCrmAccessPublicKey
			changed++
		}
	}
	if _, set := fmap["52"]; set {
		if m.SecondaryCrmAccessKeyUpgradeRequired != src.SecondaryCrmAccessKeyUpgradeRequired {
			m.SecondaryCrmAccessKeyUpgradeRequired = src.SecondaryCrmAccessKeyUpgradeRequired
			changed++
		}
	}
	if _, set := fmap["53"]; set {
		if m.SecondaryNotifySrvAddr != src.SecondaryNotifySrvAddr {
			m.SecondaryNotifySrvAddr = src.SecondaryNotifySrvAddr
			changed++
		}
	}
	if _, set := fmap["54"]; set {
		if m.DnsLabel != src.DnsLabel {
			m.DnsLabel = src.DnsLabel
			changed++
		}
	}
	if _, set := fmap["55"]; set {
		if m.RootLbFqdn != src.RootLbFqdn {
			m.RootLbFqdn = src.RootLbFqdn
			changed++
		}
	}
	if _, set := fmap["56"]; set {
		if _, set := fmap["56.1"]; set {
			if m.FederationConfig.FederationContextId != src.FederationConfig.FederationContextId {
				m.FederationConfig.FederationContextId = src.FederationConfig.FederationContextId
				changed++
			}
		}
		if _, set := fmap["56.2"]; set {
			if m.FederationConfig.PartnerFederationAddr != src.FederationConfig.PartnerFederationAddr {
				m.FederationConfig.PartnerFederationAddr = src.FederationConfig.PartnerFederationAddr
				changed++
			}
		}
		if _, set := fmap["56.3"]; set {
			if m.FederationConfig.FederationDbId != src.FederationConfig.FederationDbId {
				m.FederationConfig.FederationDbId = src.FederationConfig.FederationDbId
				changed++
			}
		}
		if _, set := fmap["56.4"]; set {
			if m.FederationConfig.FederationName != src.FederationConfig.FederationName {
				m.FederationConfig.FederationName = src.FederationConfig.FederationName
				changed++
			}
		}
	}
	if _, set := fmap["57"]; set {
		if m.LicenseConfigStoragePath != src.LicenseConfigStoragePath {
			m.LicenseConfigStoragePath = src.LicenseConfigStoragePath
			changed++
		}
	}
	if _, set := fmap["58"]; set {
		if src.InfraFlavors != nil {
			if updateListAction == "add" {
				changed += m.AddInfraFlavors(src.InfraFlavors...)
			} else if updateListAction == "remove" {
				changed += m.RemoveInfraFlavors(src.InfraFlavors...)
			} else {
				m.InfraFlavors = make([]*FlavorInfo, 0)
				for k0, _ := range src.InfraFlavors {
					m.InfraFlavors = append(m.InfraFlavors, src.InfraFlavors[k0].Clone())
				}
				changed++
			}
		} else if m.InfraFlavors != nil {
			m.InfraFlavors = nil
			changed++
		}
	}
	if _, set := fmap["59"]; set {
		if m.EdgeboxOnly != src.EdgeboxOnly {
			m.EdgeboxOnly = src.EdgeboxOnly
			changed++
		}
	}
	if _, set := fmap["60"]; set {
		if m.OnboardingState != src.OnboardingState {
			m.OnboardingState = src.OnboardingState
			changed++
		}
	}
	return changed
}

func (m *Cloudlet) DeepCopyIn(src *Cloudlet) {
	m.Key.DeepCopyIn(&src.Key)
	m.Location = src.Location
	m.IpSupport = src.IpSupport
	m.StaticIps = src.StaticIps
	m.NumDynamicIps = src.NumDynamicIps
	m.TimeLimits.DeepCopyIn(&src.TimeLimits)
	if src.Errors != nil {
		m.Errors = make([]string, len(src.Errors), len(src.Errors))
		for ii, s := range src.Errors {
			m.Errors[ii] = s
		}
	} else {
		m.Errors = nil
	}
	m.State = src.State
	m.CrmOverride = src.CrmOverride
	m.DeploymentLocal = src.DeploymentLocal
	m.PlatformType = src.PlatformType
	m.NotifySrvAddr = src.NotifySrvAddr
	m.Flavor.DeepCopyIn(&src.Flavor)
	m.PhysicalName = src.PhysicalName
	if src.EnvVar != nil {
		m.EnvVar = make(map[string]string)
		for k, v := range src.EnvVar {
			m.EnvVar[k] = v
		}
	} else {
		m.EnvVar = nil
	}
	m.ContainerVersion = src.ContainerVersion
	m.Config.DeepCopyIn(&src.Config)
	if src.ResTagMap != nil {
		m.ResTagMap = make(map[string]*ResTagTableKey)
		for k, v := range src.ResTagMap {
			var tmp_v ResTagTableKey
			tmp_v.DeepCopyIn(v)
			m.ResTagMap[k] = &tmp_v
		}
	} else {
		m.ResTagMap = nil
	}
	if src.AccessVars != nil {
		m.AccessVars = make(map[string]string)
		for k, v := range src.AccessVars {
			m.AccessVars[k] = v
		}
	} else {
		m.AccessVars = nil
	}
	m.VmImageVersion = src.VmImageVersion
	m.Deployment = src.Deployment
	m.InfraApiAccess = src.InfraApiAccess
	m.InfraConfig.DeepCopyIn(&src.InfraConfig)
	m.MaintenanceState = src.MaintenanceState
	m.OverridePolicyContainerVersion = src.OverridePolicyContainerVersion
	m.VmPool = src.VmPool
	m.CrmAccessPublicKey = src.CrmAccessPublicKey
	m.CrmAccessKeyUpgradeRequired = src.CrmAccessKeyUpgradeRequired
	m.CreatedAt = src.CreatedAt
	m.UpdatedAt = src.UpdatedAt
	m.TrustPolicy = src.TrustPolicy
	m.TrustPolicyState = src.TrustPolicyState
	if src.ResourceQuotas != nil {
		m.ResourceQuotas = make([]ResourceQuota, len(src.ResourceQuotas), len(src.ResourceQuotas))
		for ii, s := range src.ResourceQuotas {
			m.ResourceQuotas[ii].DeepCopyIn(&s)
		}
	} else {
		m.ResourceQuotas = nil
	}
	m.DefaultResourceAlertThreshold = src.DefaultResourceAlertThreshold
	m.HostController = src.HostController
	m.KafkaCluster = src.KafkaCluster
	m.KafkaUser = src.KafkaUser
	m.KafkaPassword = src.KafkaPassword
	m.GpuConfig.DeepCopyIn(&src.GpuConfig)
	m.EnableDefaultServerlessCluster = src.EnableDefaultServerlessCluster
	if src.AllianceOrgs != nil {
		m.AllianceOrgs = make([]string, len(src.AllianceOrgs), len(src.AllianceOrgs))
		for ii, s := range src.AllianceOrgs {
			m.AllianceOrgs[ii] = s
		}
	} else {
		m.AllianceOrgs = nil
	}
	m.SingleKubernetesClusterOwner = src.SingleKubernetesClusterOwner
	m.DeletePrepare = src.DeletePrepare
	m.PlatformHighAvailability = src.PlatformHighAvailability
	m.SecondaryCrmAccessPublicKey = src.SecondaryCrmAccessPublicKey
	m.SecondaryCrmAccessKeyUpgradeRequired = src.SecondaryCrmAccessKeyUpgradeRequired
	m.SecondaryNotifySrvAddr = src.SecondaryNotifySrvAddr
	m.DnsLabel = src.DnsLabel
	m.RootLbFqdn = src.RootLbFqdn
	m.FederationConfig.DeepCopyIn(&src.FederationConfig)
	m.LicenseConfigStoragePath = src.LicenseConfigStoragePath
	if src.InfraFlavors != nil {
		m.InfraFlavors = make([]*FlavorInfo, len(src.InfraFlavors), len(src.InfraFlavors))
		for ii, s := range src.InfraFlavors {
			var tmp_s FlavorInfo
			tmp_s.DeepCopyIn(s)
			m.InfraFlavors[ii] = &tmp_s
		}
	} else {
		m.InfraFlavors = nil
	}
	m.EdgeboxOnly = src.EdgeboxOnly
	m.OnboardingState = src.OnboardingState
}

func (s *Cloudlet) HasFields() bool {
	return true
}

type CloudletStore interface {
	Create(ctx context.Context, m *Cloudlet, wait func(int64)) (*Result, error)
	Update(ctx context.Context, m *Cloudlet, wait func(int64)) (*Result, error)
	Delete(ctx context.Context, m *Cloudlet, wait func(int64)) (*Result, error)
	Put(ctx context.Context, m *Cloudlet, wait func(int64), ops ...objstore.KVOp) (*Result, error)
	LoadOne(key string) (*Cloudlet, int64, error)
	Get(ctx context.Context, key *CloudletKey, buf *Cloudlet) bool
	STMGet(stm concurrency.STM, key *CloudletKey, buf *Cloudlet) bool
	STMPut(stm concurrency.STM, obj *Cloudlet, ops ...objstore.KVOp)
	STMDel(stm concurrency.STM, key *CloudletKey)
	STMHas(stm concurrency.STM, key *CloudletKey) bool
}

type CloudletStoreImpl struct {
	kvstore objstore.KVStore
}

func NewCloudletStore(kvstore objstore.KVStore) *CloudletStoreImpl {
	return &CloudletStoreImpl{kvstore: kvstore}
}

func (s *CloudletStoreImpl) Create(ctx context.Context, m *Cloudlet, wait func(int64)) (*Result, error) {
	err := m.Validate(CloudletAllFieldsMap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("Cloudlet", m.GetKey())
	val, err := json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Create(ctx, key, string(val))
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *CloudletStoreImpl) Update(ctx context.Context, m *Cloudlet, wait func(int64)) (*Result, error) {
	fmap := MakeFieldMap(m.Fields)
	err := m.Validate(fmap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("Cloudlet", m.GetKey())
	var vers int64 = 0
	curBytes, vers, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, err
	}
	var cur Cloudlet
	err = json.Unmarshal(curBytes, &cur)
	if err != nil {
		return nil, err
	}
	cur.CopyInFields(m)
	// never save fields
	cur.Fields = nil
	val, err := json.Marshal(cur)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Update(ctx, key, string(val), vers)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *CloudletStoreImpl) Put(ctx context.Context, m *Cloudlet, wait func(int64), ops ...objstore.KVOp) (*Result, error) {
	err := m.Validate(CloudletAllFieldsMap)
	m.Fields = nil
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("Cloudlet", m.GetKey())
	var val []byte
	val, err = json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Put(ctx, key, string(val), ops...)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *CloudletStoreImpl) Delete(ctx context.Context, m *Cloudlet, wait func(int64)) (*Result, error) {
	err := m.GetKey().ValidateKey()
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("Cloudlet", m.GetKey())
	rev, err := s.kvstore.Delete(ctx, key)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *CloudletStoreImpl) LoadOne(key string) (*Cloudlet, int64, error) {
	val, rev, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, 0, err
	}
	var obj Cloudlet
	err = json.Unmarshal(val, &obj)
	if err != nil {
		log.DebugLog(log.DebugLevelApi, "Failed to parse Cloudlet data", "val", string(val), "err", err)
		return nil, 0, err
	}
	return &obj, rev, nil
}

func (s *CloudletStoreImpl) Get(ctx context.Context, key *CloudletKey, buf *Cloudlet) bool {
	keystr := objstore.DbKeyString("Cloudlet", key)
	val, _, _, err := s.kvstore.Get(keystr)
	if err != nil {
		return false
	}
	return s.parseGetData(val, buf)
}

func (s *CloudletStoreImpl) STMGet(stm concurrency.STM, key *CloudletKey, buf *Cloudlet) bool {
	keystr := objstore.DbKeyString("Cloudlet", key)
	valstr := stm.Get(keystr)
	return s.parseGetData([]byte(valstr), buf)
}

func (s *CloudletStoreImpl) STMHas(stm concurrency.STM, key *CloudletKey) bool {
	keystr := objstore.DbKeyString("Cloudlet", key)
	return stm.Get(keystr) != ""
}

func (s *CloudletStoreImpl) parseGetData(val []byte, buf *Cloudlet) bool {
	if len(val) == 0 {
		return false
	}
	if buf != nil {
		// clear buf, because empty values in val won't
		// overwrite non-empty values in buf.
		*buf = Cloudlet{}
		err := json.Unmarshal(val, buf)
		if err != nil {
			return false
		}
	}
	return true
}

func (s *CloudletStoreImpl) STMPut(stm concurrency.STM, obj *Cloudlet, ops ...objstore.KVOp) {
	keystr := objstore.DbKeyString("Cloudlet", obj.GetKey())

	val, err := json.Marshal(obj)
	if err != nil {
		log.InfoLog("Cloudlet json marshal failed", "obj", obj, "err", err)
	}
	v3opts := GetSTMOpts(ops...)
	stm.Put(keystr, string(val), v3opts...)
}

func (s *CloudletStoreImpl) STMDel(stm concurrency.STM, key *CloudletKey) {
	keystr := objstore.DbKeyString("Cloudlet", key)
	stm.Del(keystr)
}

type CloudletKeyWatcher struct {
	cb func(ctx context.Context)
}

type CloudletCacheData struct {
	Obj    *Cloudlet
	ModRev int64
}

func (s *CloudletCacheData) Clone() *CloudletCacheData {
	cp := CloudletCacheData{}
	if s.Obj != nil {
		cp.Obj = &Cloudlet{}
		cp.Obj.DeepCopyIn(s.Obj)
	}
	cp.ModRev = s.ModRev
	return &cp
}

// CloudletCache caches Cloudlet objects in memory in a hash table
// and keeps them in sync with the database.
type CloudletCache struct {
	Objs          map[CloudletKey]*CloudletCacheData
	Mux           util.Mutex
	List          map[CloudletKey]struct{}
	FlushAll      bool
	NotifyCbs     []func(ctx context.Context, obj *Cloudlet, modRev int64)
	UpdatedCbs    []func(ctx context.Context, old *Cloudlet, new *Cloudlet)
	DeletedCbs    []func(ctx context.Context, old *Cloudlet)
	KeyWatchers   map[CloudletKey][]*CloudletKeyWatcher
	UpdatedKeyCbs []func(ctx context.Context, key *CloudletKey)
	DeletedKeyCbs []func(ctx context.Context, key *CloudletKey)
}

func NewCloudletCache() *CloudletCache {
	cache := CloudletCache{}
	InitCloudletCache(&cache)
	return &cache
}

func InitCloudletCache(cache *CloudletCache) {
	cache.Objs = make(map[CloudletKey]*CloudletCacheData)
	cache.KeyWatchers = make(map[CloudletKey][]*CloudletKeyWatcher)
	cache.NotifyCbs = nil
	cache.UpdatedCbs = nil
	cache.DeletedCbs = nil
	cache.UpdatedKeyCbs = nil
	cache.DeletedKeyCbs = nil
}

func (c *CloudletCache) GetTypeString() string {
	return "Cloudlet"
}

func (c *CloudletCache) Get(key *CloudletKey, valbuf *Cloudlet) bool {
	var modRev int64
	return c.GetWithRev(key, valbuf, &modRev)
}

func (c *CloudletCache) GetWithRev(key *CloudletKey, valbuf *Cloudlet, modRev *int64) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	inst, found := c.Objs[*key]
	if found {
		valbuf.DeepCopyIn(inst.Obj)
		*modRev = inst.ModRev
	}
	return found
}

func (c *CloudletCache) HasKey(key *CloudletKey) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	_, found := c.Objs[*key]
	return found
}

func (c *CloudletCache) GetAllKeys(ctx context.Context, cb func(key *CloudletKey, modRev int64)) {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for key, data := range c.Objs {
		cb(&key, data.ModRev)
	}
}

func (c *CloudletCache) GetAllLocked(ctx context.Context, cb func(obj *Cloudlet, modRev int64)) {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for _, data := range c.Objs {
		cb(data.Obj, data.ModRev)
	}
}

func (c *CloudletCache) Update(ctx context.Context, in *Cloudlet, modRev int64) {
	c.UpdateModFunc(ctx, in.GetKey(), modRev, func(old *Cloudlet) (*Cloudlet, bool) {
		return in, true
	})
}

func (c *CloudletCache) UpdateModFunc(ctx context.Context, key *CloudletKey, modRev int64, modFunc func(old *Cloudlet) (new *Cloudlet, changed bool)) {
	c.Mux.Lock()
	var old *Cloudlet
	if oldData, found := c.Objs[*key]; found {
		old = oldData.Obj
	}
	new, changed := modFunc(old)
	if !changed {
		c.Mux.Unlock()
		return
	}
	if len(c.UpdatedCbs) > 0 || len(c.NotifyCbs) > 0 {
		newCopy := &Cloudlet{}
		newCopy.DeepCopyIn(new)
		for _, cb := range c.UpdatedCbs {
			defer cb(ctx, old, newCopy)
		}
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				defer cb(ctx, newCopy, modRev)
			}
		}
	}
	for _, cb := range c.UpdatedKeyCbs {
		defer cb(ctx, key)
	}
	store := &Cloudlet{}
	store.DeepCopyIn(new)
	c.Objs[new.GetKeyVal()] = &CloudletCacheData{
		Obj:    store,
		ModRev: modRev,
	}
	log.SpanLog(ctx, log.DebugLevelApi, "cache update", "new", store)
	c.Mux.Unlock()
	c.TriggerKeyWatchers(ctx, new.GetKey())
}

func (c *CloudletCache) Delete(ctx context.Context, in *Cloudlet, modRev int64) {
	c.DeleteCondFunc(ctx, in, modRev, func(old *Cloudlet) bool {
		return true
	})
}

func (c *CloudletCache) DeleteCondFunc(ctx context.Context, in *Cloudlet, modRev int64, condFunc func(old *Cloudlet) bool) {
	c.Mux.Lock()
	var old *Cloudlet
	oldData, found := c.Objs[in.GetKeyVal()]
	if found {
		old = oldData.Obj
		if !condFunc(old) {
			c.Mux.Unlock()
			return
		}
	}
	delete(c.Objs, in.GetKeyVal())
	log.SpanLog(ctx, log.DebugLevelApi, "cache delete", "key", in.GetKeyVal())
	c.Mux.Unlock()
	obj := old
	if obj == nil {
		obj = in
	}
	for _, cb := range c.NotifyCbs {
		if cb != nil {
			cb(ctx, obj, modRev)
		}
	}
	if old != nil {
		for _, cb := range c.DeletedCbs {
			cb(ctx, old)
		}
	}
	for _, cb := range c.DeletedKeyCbs {
		cb(ctx, in.GetKey())
	}
	c.TriggerKeyWatchers(ctx, in.GetKey())
}

func (c *CloudletCache) Prune(ctx context.Context, validKeys map[CloudletKey]struct{}) {
	log.SpanLog(ctx, log.DebugLevelApi, "Prune Cloudlet", "numValidKeys", len(validKeys))
	notify := make(map[CloudletKey]*CloudletCacheData)
	c.Mux.Lock()
	for key, _ := range c.Objs {
		if _, ok := validKeys[key]; !ok {
			if len(c.NotifyCbs) > 0 || len(c.DeletedKeyCbs) > 0 || len(c.DeletedCbs) > 0 {
				notify[key] = c.Objs[key]
			}
			delete(c.Objs, key)
		}
	}
	c.Mux.Unlock()
	for key, old := range notify {
		obj := old.Obj
		if obj == nil {
			obj = &Cloudlet{}
			obj.SetKey(&key)
		}
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, obj, old.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if old.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, old.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (c *CloudletCache) GetCount() int {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	return len(c.Objs)
}

func (c *CloudletCache) Flush(ctx context.Context, notifyId int64) {
}

func (c *CloudletCache) Show(filter *Cloudlet, cb func(ret *Cloudlet) error) error {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for _, data := range c.Objs {
		if !data.Obj.Matches(filter, MatchFilter()) {
			continue
		}
		err := cb(data.Obj)
		if err != nil {
			return err
		}
	}
	return nil
}

func CloudletGenericNotifyCb(fn func(key *CloudletKey, old *Cloudlet)) func(objstore.ObjKey, objstore.Obj) {
	return func(objkey objstore.ObjKey, obj objstore.Obj) {
		fn(objkey.(*CloudletKey), obj.(*Cloudlet))
	}
}

func (c *CloudletCache) SetNotifyCb(fn func(ctx context.Context, obj *Cloudlet, modRev int64)) {
	c.NotifyCbs = []func(ctx context.Context, obj *Cloudlet, modRev int64){fn}
}

func (c *CloudletCache) SetUpdatedCb(fn func(ctx context.Context, old *Cloudlet, new *Cloudlet)) {
	c.UpdatedCbs = []func(ctx context.Context, old *Cloudlet, new *Cloudlet){fn}
}

func (c *CloudletCache) SetDeletedCb(fn func(ctx context.Context, old *Cloudlet)) {
	c.DeletedCbs = []func(ctx context.Context, old *Cloudlet){fn}
}

func (c *CloudletCache) SetUpdatedKeyCb(fn func(ctx context.Context, key *CloudletKey)) {
	c.UpdatedKeyCbs = []func(ctx context.Context, key *CloudletKey){fn}
}

func (c *CloudletCache) SetDeletedKeyCb(fn func(ctx context.Context, key *CloudletKey)) {
	c.DeletedKeyCbs = []func(ctx context.Context, key *CloudletKey){fn}
}

func (c *CloudletCache) AddUpdatedCb(fn func(ctx context.Context, old *Cloudlet, new *Cloudlet)) {
	c.UpdatedCbs = append(c.UpdatedCbs, fn)
}

func (c *CloudletCache) AddDeletedCb(fn func(ctx context.Context, old *Cloudlet)) {
	c.DeletedCbs = append(c.DeletedCbs, fn)
}

func (c *CloudletCache) AddNotifyCb(fn func(ctx context.Context, obj *Cloudlet, modRev int64)) {
	c.NotifyCbs = append(c.NotifyCbs, fn)
}

func (c *CloudletCache) AddUpdatedKeyCb(fn func(ctx context.Context, key *CloudletKey)) {
	c.UpdatedKeyCbs = append(c.UpdatedKeyCbs, fn)
}

func (c *CloudletCache) AddDeletedKeyCb(fn func(ctx context.Context, key *CloudletKey)) {
	c.DeletedKeyCbs = append(c.DeletedKeyCbs, fn)
}

func (c *CloudletCache) SetFlushAll() {
	c.FlushAll = true
}

func (c *CloudletCache) WatchKey(key *CloudletKey, cb func(ctx context.Context)) context.CancelFunc {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	list, ok := c.KeyWatchers[*key]
	if !ok {
		list = make([]*CloudletKeyWatcher, 0)
	}
	watcher := CloudletKeyWatcher{cb: cb}
	c.KeyWatchers[*key] = append(list, &watcher)
	log.DebugLog(log.DebugLevelApi, "Watching Cloudlet", "key", key)
	return func() {
		c.Mux.Lock()
		defer c.Mux.Unlock()
		list, ok := c.KeyWatchers[*key]
		if !ok {
			return
		}
		for ii, _ := range list {
			if list[ii] != &watcher {
				continue
			}
			if len(list) == 1 {
				delete(c.KeyWatchers, *key)
				return
			}
			list[ii] = list[len(list)-1]
			list[len(list)-1] = nil
			c.KeyWatchers[*key] = list[:len(list)-1]
			return
		}
	}
}

func (c *CloudletCache) TriggerKeyWatchers(ctx context.Context, key *CloudletKey) {
	watchers := make([]*CloudletKeyWatcher, 0)
	c.Mux.Lock()
	if list, ok := c.KeyWatchers[*key]; ok {
		watchers = append(watchers, list...)
	}
	c.Mux.Unlock()
	for ii, _ := range watchers {
		watchers[ii].cb(ctx)
	}
}

// Note that we explicitly ignore the global revision number, because of the way
// the notify framework sends updates (by hashing keys and doing lookups, instead
// of sequentially through a history buffer), updates may be done out-of-order
// or multiple updates compressed into one update, so the state of the cache at
// any point in time may not by in sync with a particular database revision number.

func (c *CloudletCache) SyncUpdate(ctx context.Context, key, val []byte, rev, modRev int64) {
	obj := Cloudlet{}
	err := json.Unmarshal(val, &obj)
	if err != nil {
		log.WarnLog("Failed to parse Cloudlet data", "val", string(val), "err", err)
		return
	}
	c.Update(ctx, &obj, modRev)
	c.Mux.Lock()
	if c.List != nil {
		c.List[obj.GetKeyVal()] = struct{}{}
	}
	c.Mux.Unlock()
}

func (c *CloudletCache) SyncDelete(ctx context.Context, key []byte, rev, modRev int64) {
	obj := Cloudlet{}
	keystr := objstore.DbKeyPrefixRemove(string(key))
	CloudletKeyStringParse(keystr, obj.GetKey())
	c.Delete(ctx, &obj, modRev)
}

func (c *CloudletCache) SyncListStart(ctx context.Context) {
	c.List = make(map[CloudletKey]struct{})
}

func (c *CloudletCache) SyncListEnd(ctx context.Context) {
	deleted := make(map[CloudletKey]*CloudletCacheData)
	c.Mux.Lock()
	for key, val := range c.Objs {
		if _, found := c.List[key]; !found {
			deleted[key] = val
			delete(c.Objs, key)
		}
	}
	c.List = nil
	c.Mux.Unlock()
	for key, val := range deleted {
		obj := val.Obj
		if obj == nil {
			obj = &Cloudlet{}
			obj.SetKey(&key)
		}
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, obj, val.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if val.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, val.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (c *CloudletCache) UsesOrg(org string) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for key, _ := range c.Objs {
		if key.Organization == org {
			return true
		}
	}
	return false
}

func (m *Cloudlet) GetObjKey() objstore.ObjKey {
	return m.GetKey()
}

func (m *Cloudlet) GetKey() *CloudletKey {
	return &m.Key
}

func (m *Cloudlet) GetKeyVal() CloudletKey {
	return m.Key
}

func (m *Cloudlet) SetKey(key *CloudletKey) {
	m.Key = *key
}

func CmpSortCloudlet(a Cloudlet, b Cloudlet) bool {
	return a.Key.GetKeyString() < b.Key.GetKeyString()
}
func (m *CloudletKey) StreamKey() string {
	return fmt.Sprintf("CloudletStreamKey: %s", m.String())
}

// Helper method to check that enums have valid values
// NOTE: ValidateEnums checks all Fields even if some are not set
func (m *Cloudlet) ValidateEnums() error {
	if err := m.Key.ValidateEnums(); err != nil {
		return err
	}
	if _, ok := IpSupport_name[int32(m.IpSupport)]; !ok {
		return errors.New("invalid IpSupport")
	}
	if err := m.TimeLimits.ValidateEnums(); err != nil {
		return err
	}
	if _, ok := TrackedState_name[int32(m.State)]; !ok {
		return errors.New("invalid State")
	}
	if _, ok := CRMOverride_name[int32(m.CrmOverride)]; !ok {
		return errors.New("invalid CrmOverride")
	}
	if err := m.Flavor.ValidateEnums(); err != nil {
		return err
	}
	if err := m.Config.ValidateEnums(); err != nil {
		return err
	}
	if _, ok := InfraApiAccess_name[int32(m.InfraApiAccess)]; !ok {
		return errors.New("invalid InfraApiAccess")
	}
	if err := m.InfraConfig.ValidateEnums(); err != nil {
		return err
	}
	if _, ok := distributed_match_engine.MaintenanceState_name[int32(m.MaintenanceState)]; !ok {
		return errors.New("invalid MaintenanceState")
	}
	if _, ok := TrackedState_name[int32(m.TrustPolicyState)]; !ok {
		return errors.New("invalid TrustPolicyState")
	}
	for _, e := range m.ResourceQuotas {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	if err := m.GpuConfig.ValidateEnums(); err != nil {
		return err
	}
	if err := m.FederationConfig.ValidateEnums(); err != nil {
		return err
	}
	for _, e := range m.InfraFlavors {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	if _, ok := TrackedState_name[int32(m.OnboardingState)]; !ok {
		return errors.New("invalid OnboardingState")
	}
	return nil
}

func (s *Cloudlet) ClearTagged(tags map[string]struct{}) {
	s.Key.ClearTagged(tags)
	s.TimeLimits.ClearTagged(tags)
	if _, found := tags["nocmp"]; found {
		s.Errors = nil
	}
	if _, found := tags["nocmp"]; found {
		s.NotifySrvAddr = ""
	}
	s.Flavor.ClearTagged(tags)
	s.Config.ClearTagged(tags)
	s.InfraConfig.ClearTagged(tags)
	if _, found := tags["nocmp"]; found {
		s.CrmAccessPublicKey = ""
	}
	if _, found := tags["timestamp"]; found {
		s.CreatedAt = distributed_match_engine.Timestamp{}
	}
	if _, found := tags["timestamp"]; found {
		s.UpdatedAt = distributed_match_engine.Timestamp{}
	}
	if s.ResourceQuotas != nil {
		for ii := 0; ii < len(s.ResourceQuotas); ii++ {
			s.ResourceQuotas[ii].ClearTagged(tags)
		}
	}
	if _, found := tags["nocmp"]; found {
		s.HostController = ""
	}
	s.GpuConfig.ClearTagged(tags)
	if _, found := tags["nocmp"]; found {
		s.SecondaryCrmAccessPublicKey = ""
	}
	if _, found := tags["nocmp"]; found {
		s.SecondaryNotifySrvAddr = ""
	}
	s.FederationConfig.ClearTagged(tags)
	if s.InfraFlavors != nil {
		for ii := 0; ii < len(s.InfraFlavors); ii++ {
			s.InfraFlavors[ii].ClearTagged(tags)
		}
	}
}

func IgnoreCloudletFields(taglist string) cmp.Option {
	names := []string{}
	tags := make(map[string]struct{})
	for _, tag := range strings.Split(taglist, ",") {
		tags[tag] = struct{}{}
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Errors")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "NotifySrvAddr")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Config.NotifyCtrlAddrs")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Config.PlatformTag")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Config.Span")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Config.CrmAccessPrivateKey")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Config.AccessApiAddr")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Config.SecondaryCrmAccessPrivateKey")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "CrmAccessPublicKey")
	}
	if _, found := tags["timestamp"]; found {
		names = append(names, "CreatedAt")
	}
	if _, found := tags["timestamp"]; found {
		names = append(names, "UpdatedAt")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "HostController")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "SecondaryCrmAccessPublicKey")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "SecondaryNotifySrvAddr")
	}
	return cmpopts.IgnoreFields(Cloudlet{}, names...)
}

func (m *FlavorMatch) Clone() *FlavorMatch {
	cp := &FlavorMatch{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *FlavorMatch) CopyInFields(src *FlavorMatch) int {
	changed := 0
	if m.Key.Organization != src.Key.Organization {
		m.Key.Organization = src.Key.Organization
		changed++
	}
	if m.Key.Name != src.Key.Name {
		m.Key.Name = src.Key.Name
		changed++
	}
	if m.Key.FederatedOrganization != src.Key.FederatedOrganization {
		m.Key.FederatedOrganization = src.Key.FederatedOrganization
		changed++
	}
	if m.FlavorName != src.FlavorName {
		m.FlavorName = src.FlavorName
		changed++
	}
	if m.AvailabilityZone != src.AvailabilityZone {
		m.AvailabilityZone = src.AvailabilityZone
		changed++
	}
	return changed
}

func (m *FlavorMatch) DeepCopyIn(src *FlavorMatch) {
	m.Key.DeepCopyIn(&src.Key)
	m.FlavorName = src.FlavorName
	m.AvailabilityZone = src.AvailabilityZone
}

func (m *FlavorMatch) GetObjKey() objstore.ObjKey {
	return m.GetKey()
}

func (m *FlavorMatch) GetKey() *CloudletKey {
	return &m.Key
}

func (m *FlavorMatch) GetKeyVal() CloudletKey {
	return m.Key
}

func (m *FlavorMatch) SetKey(key *CloudletKey) {
	m.Key = *key
}

func CmpSortFlavorMatch(a FlavorMatch, b FlavorMatch) bool {
	return a.Key.GetKeyString() < b.Key.GetKeyString()
}

// Helper method to check that enums have valid values
func (m *FlavorMatch) ValidateEnums() error {
	if err := m.Key.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func (s *FlavorMatch) ClearTagged(tags map[string]struct{}) {
	s.Key.ClearTagged(tags)
}

func (m *CloudletManifest) Clone() *CloudletManifest {
	cp := &CloudletManifest{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *CloudletManifest) CopyInFields(src *CloudletManifest) int {
	changed := 0
	if m.Manifest != src.Manifest {
		m.Manifest = src.Manifest
		changed++
	}
	return changed
}

func (m *CloudletManifest) DeepCopyIn(src *CloudletManifest) {
	m.Manifest = src.Manifest
}

// Helper method to check that enums have valid values
func (m *CloudletManifest) ValidateEnums() error {
	return nil
}

func (s *CloudletManifest) ClearTagged(tags map[string]struct{}) {
}

func (m *PropertyInfo) Clone() *PropertyInfo {
	cp := &PropertyInfo{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *PropertyInfo) CopyInFields(src *PropertyInfo) int {
	changed := 0
	if m.Name != src.Name {
		m.Name = src.Name
		changed++
	}
	if m.Description != src.Description {
		m.Description = src.Description
		changed++
	}
	if m.Value != src.Value {
		m.Value = src.Value
		changed++
	}
	if m.Secret != src.Secret {
		m.Secret = src.Secret
		changed++
	}
	if m.Mandatory != src.Mandatory {
		m.Mandatory = src.Mandatory
		changed++
	}
	if m.Internal != src.Internal {
		m.Internal = src.Internal
		changed++
	}
	if m.TotpSecret != src.TotpSecret {
		m.TotpSecret = src.TotpSecret
		changed++
	}
	return changed
}

func (m *PropertyInfo) DeepCopyIn(src *PropertyInfo) {
	m.Name = src.Name
	m.Description = src.Description
	m.Value = src.Value
	m.Secret = src.Secret
	m.Mandatory = src.Mandatory
	m.Internal = src.Internal
	m.TotpSecret = src.TotpSecret
}

// Helper method to check that enums have valid values
func (m *PropertyInfo) ValidateEnums() error {
	return nil
}

func (s *PropertyInfo) ClearTagged(tags map[string]struct{}) {
}

func (m *CloudletProps) Clone() *CloudletProps {
	cp := &CloudletProps{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *CloudletProps) CopyInFields(src *CloudletProps) int {
	updateListAction := "replace"
	changed := 0
	if m.PlatformType != src.PlatformType {
		m.PlatformType = src.PlatformType
		changed++
	}
	if src.Properties != nil {
		if updateListAction == "add" {
			for k0, v := range src.Properties {
				v = v.Clone()
				m.Properties[k0] = v
				changed++
			}
		} else if updateListAction == "remove" {
			for k0, _ := range src.Properties {
				if _, ok := m.Properties[k0]; ok {
					delete(m.Properties, k0)
					changed++
				}
			}
		} else {
			m.Properties = make(map[string]*PropertyInfo)
			for k0, v := range src.Properties {
				m.Properties[k0] = v.Clone()
			}
			changed++
		}
	} else if m.Properties != nil {
		m.Properties = nil
		changed++
	}
	if m.Organization != src.Organization {
		m.Organization = src.Organization
		changed++
	}
	return changed
}

func (m *CloudletProps) DeepCopyIn(src *CloudletProps) {
	m.PlatformType = src.PlatformType
	if src.Properties != nil {
		m.Properties = make(map[string]*PropertyInfo)
		for k, v := range src.Properties {
			var tmp_v PropertyInfo
			tmp_v.DeepCopyIn(v)
			m.Properties[k] = &tmp_v
		}
	} else {
		m.Properties = nil
	}
	m.Organization = src.Organization
}

// Helper method to check that enums have valid values
func (m *CloudletProps) ValidateEnums() error {
	return nil
}

func (s *CloudletProps) ClearTagged(tags map[string]struct{}) {
}

func (m *CloudletResourceQuotaProps) Clone() *CloudletResourceQuotaProps {
	cp := &CloudletResourceQuotaProps{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *CloudletResourceQuotaProps) AddProperties(vals ...InfraResource) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.Properties {
		cur[v.String()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.String()]; found {
			continue // duplicate
		}
		m.Properties = append(m.Properties, v)
		changes++
	}
	return changes
}

func (m *CloudletResourceQuotaProps) RemoveProperties(vals ...InfraResource) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.String()] = struct{}{}
	}
	for i := len(m.Properties); i >= 0; i-- {
		if _, found := remove[m.Properties[i].String()]; found {
			m.Properties = append(m.Properties[:i], m.Properties[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *CloudletResourceQuotaProps) CopyInFields(src *CloudletResourceQuotaProps) int {
	updateListAction := "replace"
	changed := 0
	if m.PlatformType != src.PlatformType {
		m.PlatformType = src.PlatformType
		changed++
	}
	if src.Properties != nil {
		if updateListAction == "add" {
			changed += m.AddProperties(src.Properties...)
		} else if updateListAction == "remove" {
			changed += m.RemoveProperties(src.Properties...)
		} else {
			m.Properties = make([]InfraResource, 0)
			for k0, _ := range src.Properties {
				m.Properties = append(m.Properties, *src.Properties[k0].Clone())
			}
			changed++
		}
	} else if m.Properties != nil {
		m.Properties = nil
		changed++
	}
	if m.Organization != src.Organization {
		m.Organization = src.Organization
		changed++
	}
	return changed
}

func (m *CloudletResourceQuotaProps) DeepCopyIn(src *CloudletResourceQuotaProps) {
	m.PlatformType = src.PlatformType
	if src.Properties != nil {
		m.Properties = make([]InfraResource, len(src.Properties), len(src.Properties))
		for ii, s := range src.Properties {
			m.Properties[ii].DeepCopyIn(&s)
		}
	} else {
		m.Properties = nil
	}
	m.Organization = src.Organization
}

// Helper method to check that enums have valid values
func (m *CloudletResourceQuotaProps) ValidateEnums() error {
	for _, e := range m.Properties {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (s *CloudletResourceQuotaProps) ClearTagged(tags map[string]struct{}) {
	if s.Properties != nil {
		for ii := 0; ii < len(s.Properties); ii++ {
			s.Properties[ii].ClearTagged(tags)
		}
	}
}

func (m *CloudletResourceUsage) Clone() *CloudletResourceUsage {
	cp := &CloudletResourceUsage{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *CloudletResourceUsage) AddInfo(vals ...InfraResource) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.Info {
		cur[v.String()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.String()]; found {
			continue // duplicate
		}
		m.Info = append(m.Info, v)
		changes++
	}
	return changes
}

func (m *CloudletResourceUsage) RemoveInfo(vals ...InfraResource) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.String()] = struct{}{}
	}
	for i := len(m.Info); i >= 0; i-- {
		if _, found := remove[m.Info[i].String()]; found {
			m.Info = append(m.Info[:i], m.Info[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *CloudletResourceUsage) CopyInFields(src *CloudletResourceUsage) int {
	updateListAction := "replace"
	changed := 0
	if m.Key.Organization != src.Key.Organization {
		m.Key.Organization = src.Key.Organization
		changed++
	}
	if m.Key.Name != src.Key.Name {
		m.Key.Name = src.Key.Name
		changed++
	}
	if m.Key.FederatedOrganization != src.Key.FederatedOrganization {
		m.Key.FederatedOrganization = src.Key.FederatedOrganization
		changed++
	}
	if m.InfraUsage != src.InfraUsage {
		m.InfraUsage = src.InfraUsage
		changed++
	}
	if src.Info != nil {
		if updateListAction == "add" {
			changed += m.AddInfo(src.Info...)
		} else if updateListAction == "remove" {
			changed += m.RemoveInfo(src.Info...)
		} else {
			m.Info = make([]InfraResource, 0)
			for k0, _ := range src.Info {
				m.Info = append(m.Info, *src.Info[k0].Clone())
			}
			changed++
		}
	} else if m.Info != nil {
		m.Info = nil
		changed++
	}
	return changed
}

func (m *CloudletResourceUsage) DeepCopyIn(src *CloudletResourceUsage) {
	m.Key.DeepCopyIn(&src.Key)
	m.InfraUsage = src.InfraUsage
	if src.Info != nil {
		m.Info = make([]InfraResource, len(src.Info), len(src.Info))
		for ii, s := range src.Info {
			m.Info[ii].DeepCopyIn(&s)
		}
	} else {
		m.Info = nil
	}
}

func (m *CloudletResourceUsage) GetObjKey() objstore.ObjKey {
	return m.GetKey()
}

func (m *CloudletResourceUsage) GetKey() *CloudletKey {
	return &m.Key
}

func (m *CloudletResourceUsage) GetKeyVal() CloudletKey {
	return m.Key
}

func (m *CloudletResourceUsage) SetKey(key *CloudletKey) {
	m.Key = *key
}

func CmpSortCloudletResourceUsage(a CloudletResourceUsage, b CloudletResourceUsage) bool {
	return a.Key.GetKeyString() < b.Key.GetKeyString()
}

// Helper method to check that enums have valid values
func (m *CloudletResourceUsage) ValidateEnums() error {
	if err := m.Key.ValidateEnums(); err != nil {
		return err
	}
	for _, e := range m.Info {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (s *CloudletResourceUsage) ClearTagged(tags map[string]struct{}) {
	s.Key.ClearTagged(tags)
	if s.Info != nil {
		for ii := 0; ii < len(s.Info); ii++ {
			s.Info[ii].ClearTagged(tags)
		}
	}
}

func (m *CloudletAllianceOrg) Clone() *CloudletAllianceOrg {
	cp := &CloudletAllianceOrg{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *CloudletAllianceOrg) CopyInFields(src *CloudletAllianceOrg) int {
	changed := 0
	if m.Key.Organization != src.Key.Organization {
		m.Key.Organization = src.Key.Organization
		changed++
	}
	if m.Key.Name != src.Key.Name {
		m.Key.Name = src.Key.Name
		changed++
	}
	if m.Key.FederatedOrganization != src.Key.FederatedOrganization {
		m.Key.FederatedOrganization = src.Key.FederatedOrganization
		changed++
	}
	if m.Organization != src.Organization {
		m.Organization = src.Organization
		changed++
	}
	return changed
}

func (m *CloudletAllianceOrg) DeepCopyIn(src *CloudletAllianceOrg) {
	m.Key.DeepCopyIn(&src.Key)
	m.Organization = src.Organization
}

func (m *CloudletAllianceOrg) GetObjKey() objstore.ObjKey {
	return m.GetKey()
}

func (m *CloudletAllianceOrg) GetKey() *CloudletKey {
	return &m.Key
}

func (m *CloudletAllianceOrg) GetKeyVal() CloudletKey {
	return m.Key
}

func (m *CloudletAllianceOrg) SetKey(key *CloudletKey) {
	m.Key = *key
}

func CmpSortCloudletAllianceOrg(a CloudletAllianceOrg, b CloudletAllianceOrg) bool {
	return a.Key.GetKeyString() < b.Key.GetKeyString()
}

// Helper method to check that enums have valid values
func (m *CloudletAllianceOrg) ValidateEnums() error {
	if err := m.Key.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func (s *CloudletAllianceOrg) ClearTagged(tags map[string]struct{}) {
	s.Key.ClearTagged(tags)
}

func (m *FlavorInfo) Clone() *FlavorInfo {
	cp := &FlavorInfo{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *FlavorInfo) CopyInFields(src *FlavorInfo) int {
	updateListAction := "replace"
	changed := 0
	if m.Name != src.Name {
		m.Name = src.Name
		changed++
	}
	if m.Vcpus != src.Vcpus {
		m.Vcpus = src.Vcpus
		changed++
	}
	if m.Ram != src.Ram {
		m.Ram = src.Ram
		changed++
	}
	if m.Disk != src.Disk {
		m.Disk = src.Disk
		changed++
	}
	if src.PropMap != nil {
		if updateListAction == "add" {
			for k0, v := range src.PropMap {
				m.PropMap[k0] = v
				changed++
			}
		} else if updateListAction == "remove" {
			for k0, _ := range src.PropMap {
				if _, ok := m.PropMap[k0]; ok {
					delete(m.PropMap, k0)
					changed++
				}
			}
		} else {
			m.PropMap = make(map[string]string)
			for k0, v := range src.PropMap {
				m.PropMap[k0] = v
			}
			changed++
		}
	} else if m.PropMap != nil {
		m.PropMap = nil
		changed++
	}
	return changed
}

func (m *FlavorInfo) DeepCopyIn(src *FlavorInfo) {
	m.Name = src.Name
	m.Vcpus = src.Vcpus
	m.Ram = src.Ram
	m.Disk = src.Disk
	if src.PropMap != nil {
		m.PropMap = make(map[string]string)
		for k, v := range src.PropMap {
			m.PropMap[k] = v
		}
	} else {
		m.PropMap = nil
	}
}

// Helper method to check that enums have valid values
func (m *FlavorInfo) ValidateEnums() error {
	return nil
}

func (s *FlavorInfo) ClearTagged(tags map[string]struct{}) {
}

func (m *OSAZone) Clone() *OSAZone {
	cp := &OSAZone{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *OSAZone) CopyInFields(src *OSAZone) int {
	changed := 0
	if m.Name != src.Name {
		m.Name = src.Name
		changed++
	}
	if m.Status != src.Status {
		m.Status = src.Status
		changed++
	}
	return changed
}

func (m *OSAZone) DeepCopyIn(src *OSAZone) {
	m.Name = src.Name
	m.Status = src.Status
}

// Helper method to check that enums have valid values
func (m *OSAZone) ValidateEnums() error {
	return nil
}

func (s *OSAZone) ClearTagged(tags map[string]struct{}) {
}

func (m *OSImage) Clone() *OSImage {
	cp := &OSImage{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *OSImage) CopyInFields(src *OSImage) int {
	changed := 0
	if m.Name != src.Name {
		m.Name = src.Name
		changed++
	}
	if m.Tags != src.Tags {
		m.Tags = src.Tags
		changed++
	}
	if m.Properties != src.Properties {
		m.Properties = src.Properties
		changed++
	}
	if m.DiskFormat != src.DiskFormat {
		m.DiskFormat = src.DiskFormat
		changed++
	}
	return changed
}

func (m *OSImage) DeepCopyIn(src *OSImage) {
	m.Name = src.Name
	m.Tags = src.Tags
	m.Properties = src.Properties
	m.DiskFormat = src.DiskFormat
}

// Helper method to check that enums have valid values
func (m *OSImage) ValidateEnums() error {
	return nil
}

func (s *OSImage) ClearTagged(tags map[string]struct{}) {
}

func (m *CloudletOnboardingInfo) Clone() *CloudletOnboardingInfo {
	cp := &CloudletOnboardingInfo{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *CloudletOnboardingInfo) AddStatusMsgs(vals ...string) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.Status.Msgs {
		cur[v] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v]; found {
			continue // duplicate
		}
		m.Status.Msgs = append(m.Status.Msgs, v)
		changes++
	}
	return changes
}

func (m *CloudletOnboardingInfo) RemoveStatusMsgs(vals ...string) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v] = struct{}{}
	}
	for i := len(m.Status.Msgs); i >= 0; i-- {
		if _, found := remove[m.Status.Msgs[i]]; found {
			m.Status.Msgs = append(m.Status.Msgs[:i], m.Status.Msgs[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *CloudletOnboardingInfo) AddErrors(vals ...string) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.Errors {
		cur[v] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v]; found {
			continue // duplicate
		}
		m.Errors = append(m.Errors, v)
		changes++
	}
	return changes
}

func (m *CloudletOnboardingInfo) RemoveErrors(vals ...string) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v] = struct{}{}
	}
	for i := len(m.Errors); i >= 0; i-- {
		if _, found := remove[m.Errors[i]]; found {
			m.Errors = append(m.Errors[:i], m.Errors[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *CloudletOnboardingInfo) CopyInFields(src *CloudletOnboardingInfo) int {
	updateListAction := "replace"
	changed := 0
	if m.Key.Organization != src.Key.Organization {
		m.Key.Organization = src.Key.Organization
		changed++
	}
	if m.Key.Name != src.Key.Name {
		m.Key.Name = src.Key.Name
		changed++
	}
	if m.Key.FederatedOrganization != src.Key.FederatedOrganization {
		m.Key.FederatedOrganization = src.Key.FederatedOrganization
		changed++
	}
	if m.OnboardingState != src.OnboardingState {
		m.OnboardingState = src.OnboardingState
		changed++
	}
	if m.Status.TaskNumber != src.Status.TaskNumber {
		m.Status.TaskNumber = src.Status.TaskNumber
		changed++
	}
	if m.Status.MaxTasks != src.Status.MaxTasks {
		m.Status.MaxTasks = src.Status.MaxTasks
		changed++
	}
	if m.Status.TaskName != src.Status.TaskName {
		m.Status.TaskName = src.Status.TaskName
		changed++
	}
	if m.Status.StepName != src.Status.StepName {
		m.Status.StepName = src.Status.StepName
		changed++
	}
	if m.Status.MsgCount != src.Status.MsgCount {
		m.Status.MsgCount = src.Status.MsgCount
		changed++
	}
	if src.Status.Msgs != nil {
		if updateListAction == "add" {
			changed += m.AddStatusMsgs(src.Status.Msgs...)
		} else if updateListAction == "remove" {
			changed += m.RemoveStatusMsgs(src.Status.Msgs...)
		} else {
			m.Status.Msgs = make([]string, 0)
			m.Status.Msgs = append(m.Status.Msgs, src.Status.Msgs...)
			changed++
		}
	} else if m.Status.Msgs != nil {
		m.Status.Msgs = nil
		changed++
	}
	if src.Errors != nil {
		if updateListAction == "add" {
			changed += m.AddErrors(src.Errors...)
		} else if updateListAction == "remove" {
			changed += m.RemoveErrors(src.Errors...)
		} else {
			m.Errors = make([]string, 0)
			m.Errors = append(m.Errors, src.Errors...)
			changed++
		}
	} else if m.Errors != nil {
		m.Errors = nil
		changed++
	}
	return changed
}

func (m *CloudletOnboardingInfo) DeepCopyIn(src *CloudletOnboardingInfo) {
	m.Key.DeepCopyIn(&src.Key)
	m.OnboardingState = src.OnboardingState
	m.Status.DeepCopyIn(&src.Status)
	if src.Errors != nil {
		m.Errors = make([]string, len(src.Errors), len(src.Errors))
		for ii, s := range src.Errors {
			m.Errors[ii] = s
		}
	} else {
		m.Errors = nil
	}
}

func (m *CloudletOnboardingInfo) GetObjKey() objstore.ObjKey {
	return m.GetKey()
}

func (m *CloudletOnboardingInfo) GetKey() *CloudletKey {
	return &m.Key
}

func (m *CloudletOnboardingInfo) GetKeyVal() CloudletKey {
	return m.Key
}

func (m *CloudletOnboardingInfo) SetKey(key *CloudletKey) {
	m.Key = *key
}

func CmpSortCloudletOnboardingInfo(a CloudletOnboardingInfo, b CloudletOnboardingInfo) bool {
	return a.Key.GetKeyString() < b.Key.GetKeyString()
}

// MessageKey can be used as a channel name which includes the
// key value for pubsub, to listen for this specific object type
// plus key value.
func (m *CloudletOnboardingInfo) MessageKey() string {
	return fmt.Sprintf("msg/key/CloudletOnboardingInfo/%s", m.GetKey().GetKeyString())
}

func (m *CloudletOnboardingInfo) MessageTypeKey() string {
	return "msg/type/CloudletOnboardingInfo"
}

// Helper method to check that enums have valid values
func (m *CloudletOnboardingInfo) ValidateEnums() error {
	if err := m.Key.ValidateEnums(); err != nil {
		return err
	}
	if _, ok := TrackedState_name[int32(m.OnboardingState)]; !ok {
		return errors.New("invalid OnboardingState")
	}
	if err := m.Status.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func (s *CloudletOnboardingInfo) ClearTagged(tags map[string]struct{}) {
	s.Key.ClearTagged(tags)
	s.Status.ClearTagged(tags)
}

func (m *CloudletInfo) Matches(o *CloudletInfo, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !m.Key.Matches(&o.Key, fopts...) {
		return false
	}
	if !opts.Filter || o.State != 0 {
		if o.State != m.State {
			return false
		}
	}
	if !opts.Filter || o.NotifyId != 0 {
		if o.NotifyId != m.NotifyId {
			return false
		}
	}
	if !opts.Filter || o.Controller != "" {
		if o.Controller != m.Controller {
			return false
		}
	}
	if !opts.Filter || o.OsMaxRam != 0 {
		if o.OsMaxRam != m.OsMaxRam {
			return false
		}
	}
	if !opts.Filter || o.OsMaxVcores != 0 {
		if o.OsMaxVcores != m.OsMaxVcores {
			return false
		}
	}
	if !opts.Filter || o.OsMaxVolGb != 0 {
		if o.OsMaxVolGb != m.OsMaxVolGb {
			return false
		}
	}
	if !opts.Filter || o.Errors != nil {
		if len(m.Errors) == 0 && len(o.Errors) > 0 || len(m.Errors) > 0 && len(o.Errors) == 0 {
			return false
		} else if m.Errors != nil && o.Errors != nil {
			if !opts.Filter && len(m.Errors) != len(o.Errors) {
				return false
			}
			found := 0
			for oIndex, _ := range o.Errors {
				for mIndex, _ := range m.Errors {
					if o.Errors[oIndex] == m.Errors[mIndex] {
						found++
						break
					}
				}
			}
			if found != len(o.Errors) {
				return false
			}
		}
	}
	if !opts.Filter || o.Flavors != nil {
		if len(m.Flavors) == 0 && len(o.Flavors) > 0 || len(m.Flavors) > 0 && len(o.Flavors) == 0 {
			return false
		} else if m.Flavors != nil && o.Flavors != nil {
			if !opts.Filter && len(m.Flavors) != len(o.Flavors) {
				return false
			}
		}
	}
	if !opts.Filter || o.ContainerVersion != "" {
		if o.ContainerVersion != m.ContainerVersion {
			return false
		}
	}
	if !opts.Filter || o.AvailabilityZones != nil {
		if len(m.AvailabilityZones) == 0 && len(o.AvailabilityZones) > 0 || len(m.AvailabilityZones) > 0 && len(o.AvailabilityZones) == 0 {
			return false
		} else if m.AvailabilityZones != nil && o.AvailabilityZones != nil {
			if !opts.Filter && len(m.AvailabilityZones) != len(o.AvailabilityZones) {
				return false
			}
		}
	}
	if !opts.Filter || o.OsImages != nil {
		if len(m.OsImages) == 0 && len(o.OsImages) > 0 || len(m.OsImages) > 0 && len(o.OsImages) == 0 {
			return false
		} else if m.OsImages != nil && o.OsImages != nil {
			if !opts.Filter && len(m.OsImages) != len(o.OsImages) {
				return false
			}
		}
	}
	if !opts.Filter || o.ControllerCacheReceived != false {
		if o.ControllerCacheReceived != m.ControllerCacheReceived {
			return false
		}
	}
	if !opts.Filter || o.MaintenanceState != 0 {
		if o.MaintenanceState != m.MaintenanceState {
			return false
		}
	}
	if !opts.IgnoreBackend {
	}
	if !opts.Filter || o.TrustPolicyState != 0 {
		if o.TrustPolicyState != m.TrustPolicyState {
			return false
		}
	}
	if !opts.Filter || o.CompatibilityVersion != 0 {
		if o.CompatibilityVersion != m.CompatibilityVersion {
			return false
		}
	}
	if !opts.Filter || o.Properties != nil {
		if len(m.Properties) == 0 && len(o.Properties) > 0 || len(m.Properties) > 0 && len(o.Properties) == 0 {
			return false
		} else if m.Properties != nil && o.Properties != nil {
			if !opts.Filter && len(m.Properties) != len(o.Properties) {
				return false
			}
			for k, _ := range o.Properties {
				_, ok := m.Properties[k]
				if !ok {
					return false
				}
				if o.Properties[k] != m.Properties[k] {
					return false
				}
			}
		}
	}
	if !opts.Filter || o.NodeInfos != nil {
		if len(m.NodeInfos) == 0 && len(o.NodeInfos) > 0 || len(m.NodeInfos) > 0 && len(o.NodeInfos) == 0 {
			return false
		} else if m.NodeInfos != nil && o.NodeInfos != nil {
			if !opts.Filter && len(m.NodeInfos) != len(o.NodeInfos) {
				return false
			}
		}
	}
	if !opts.Filter || o.ActiveCrmInstance != "" {
		if o.ActiveCrmInstance != m.ActiveCrmInstance {
			return false
		}
	}
	if !opts.Filter || o.StandbyCrm != false {
		if o.StandbyCrm != m.StandbyCrm {
			return false
		}
	}
	if !opts.Filter || o.ReleaseVersion != "" {
		if o.ReleaseVersion != m.ReleaseVersion {
			return false
		}
	}
	return true
}

const CloudletInfoFieldKey = "2"
const CloudletInfoFieldKeyOrganization = "2.1"
const CloudletInfoFieldKeyName = "2.2"
const CloudletInfoFieldKeyFederatedOrganization = "2.3"
const CloudletInfoFieldState = "3"
const CloudletInfoFieldNotifyId = "4"
const CloudletInfoFieldController = "5"
const CloudletInfoFieldOsMaxRam = "6"
const CloudletInfoFieldOsMaxVcores = "7"
const CloudletInfoFieldOsMaxVolGb = "8"
const CloudletInfoFieldErrors = "9"
const CloudletInfoFieldFlavors = "10"
const CloudletInfoFieldFlavorsName = "10.1"
const CloudletInfoFieldFlavorsVcpus = "10.2"
const CloudletInfoFieldFlavorsRam = "10.3"
const CloudletInfoFieldFlavorsDisk = "10.4"
const CloudletInfoFieldFlavorsPropMap = "10.5"
const CloudletInfoFieldFlavorsPropMapKey = "10.5.1"
const CloudletInfoFieldFlavorsPropMapValue = "10.5.2"
const CloudletInfoFieldStatus = "11"
const CloudletInfoFieldStatusTaskNumber = "11.1"
const CloudletInfoFieldStatusMaxTasks = "11.2"
const CloudletInfoFieldStatusTaskName = "11.3"
const CloudletInfoFieldStatusStepName = "11.4"
const CloudletInfoFieldStatusMsgCount = "11.5"
const CloudletInfoFieldStatusMsgs = "11.6"
const CloudletInfoFieldContainerVersion = "12"
const CloudletInfoFieldAvailabilityZones = "13"
const CloudletInfoFieldAvailabilityZonesName = "13.1"
const CloudletInfoFieldAvailabilityZonesStatus = "13.2"
const CloudletInfoFieldOsImages = "14"
const CloudletInfoFieldOsImagesName = "14.1"
const CloudletInfoFieldOsImagesTags = "14.2"
const CloudletInfoFieldOsImagesProperties = "14.3"
const CloudletInfoFieldOsImagesDiskFormat = "14.4"
const CloudletInfoFieldControllerCacheReceived = "15"
const CloudletInfoFieldMaintenanceState = "16"
const CloudletInfoFieldResourcesSnapshot = "17"
const CloudletInfoFieldResourcesSnapshotPlatformVms = "17.1"
const CloudletInfoFieldResourcesSnapshotPlatformVmsName = "17.1.1"
const CloudletInfoFieldResourcesSnapshotPlatformVmsType = "17.1.2"
const CloudletInfoFieldResourcesSnapshotPlatformVmsStatus = "17.1.3"
const CloudletInfoFieldResourcesSnapshotPlatformVmsInfraFlavor = "17.1.4"
const CloudletInfoFieldResourcesSnapshotPlatformVmsIpaddresses = "17.1.5"
const CloudletInfoFieldResourcesSnapshotPlatformVmsIpaddressesExternalIp = "17.1.5.1"
const CloudletInfoFieldResourcesSnapshotPlatformVmsIpaddressesInternalIp = "17.1.5.2"
const CloudletInfoFieldResourcesSnapshotPlatformVmsContainers = "17.1.6"
const CloudletInfoFieldResourcesSnapshotPlatformVmsContainersName = "17.1.6.1"
const CloudletInfoFieldResourcesSnapshotPlatformVmsContainersType = "17.1.6.2"
const CloudletInfoFieldResourcesSnapshotPlatformVmsContainersStatus = "17.1.6.3"
const CloudletInfoFieldResourcesSnapshotPlatformVmsContainersClusterip = "17.1.6.4"
const CloudletInfoFieldResourcesSnapshotPlatformVmsContainersRestarts = "17.1.6.5"
const CloudletInfoFieldResourcesSnapshotInfo = "17.2"
const CloudletInfoFieldResourcesSnapshotInfoName = "17.2.1"
const CloudletInfoFieldResourcesSnapshotInfoValue = "17.2.2"
const CloudletInfoFieldResourcesSnapshotInfoInfraMaxValue = "17.2.3"
const CloudletInfoFieldResourcesSnapshotInfoQuotaMaxValue = "17.2.4"
const CloudletInfoFieldResourcesSnapshotInfoDescription = "17.2.5"
const CloudletInfoFieldResourcesSnapshotInfoUnits = "17.2.6"
const CloudletInfoFieldResourcesSnapshotInfoAlertThreshold = "17.2.7"
const CloudletInfoFieldResourcesSnapshotClusterInsts = "17.3"
const CloudletInfoFieldResourcesSnapshotClusterInstsName = "17.3.1"
const CloudletInfoFieldResourcesSnapshotClusterInstsOrganization = "17.3.2"
const CloudletInfoFieldResourcesSnapshotVmAppInsts = "17.4"
const CloudletInfoFieldResourcesSnapshotVmAppInstsName = "17.4.1"
const CloudletInfoFieldResourcesSnapshotVmAppInstsOrganization = "17.4.2"
const CloudletInfoFieldResourcesSnapshotK8SAppInsts = "17.5"
const CloudletInfoFieldResourcesSnapshotK8SAppInstsName = "17.5.1"
const CloudletInfoFieldResourcesSnapshotK8SAppInstsOrganization = "17.5.2"
const CloudletInfoFieldTrustPolicyState = "18"
const CloudletInfoFieldCompatibilityVersion = "19"
const CloudletInfoFieldProperties = "20"
const CloudletInfoFieldPropertiesKey = "20.1"
const CloudletInfoFieldPropertiesValue = "20.2"
const CloudletInfoFieldNodeInfos = "21"
const CloudletInfoFieldNodeInfosName = "21.1"
const CloudletInfoFieldNodeInfosAllocatable = "21.2"
const CloudletInfoFieldNodeInfosAllocatableKey = "21.2.1"
const CloudletInfoFieldNodeInfosAllocatableValue = "21.2.2"
const CloudletInfoFieldNodeInfosAllocatableValueWhole = "21.2.2.1"
const CloudletInfoFieldNodeInfosAllocatableValueNanos = "21.2.2.2"
const CloudletInfoFieldNodeInfosCapacity = "21.3"
const CloudletInfoFieldNodeInfosCapacityKey = "21.3.1"
const CloudletInfoFieldNodeInfosCapacityValue = "21.3.2"
const CloudletInfoFieldNodeInfosCapacityValueWhole = "21.3.2.1"
const CloudletInfoFieldNodeInfosCapacityValueNanos = "21.3.2.2"
const CloudletInfoFieldActiveCrmInstance = "22"
const CloudletInfoFieldStandbyCrm = "23"
const CloudletInfoFieldReleaseVersion = "24"

var CloudletInfoAllFields = []string{
	CloudletInfoFieldKeyOrganization,
	CloudletInfoFieldKeyName,
	CloudletInfoFieldKeyFederatedOrganization,
	CloudletInfoFieldState,
	CloudletInfoFieldNotifyId,
	CloudletInfoFieldController,
	CloudletInfoFieldOsMaxRam,
	CloudletInfoFieldOsMaxVcores,
	CloudletInfoFieldOsMaxVolGb,
	CloudletInfoFieldErrors,
	CloudletInfoFieldFlavorsName,
	CloudletInfoFieldFlavorsVcpus,
	CloudletInfoFieldFlavorsRam,
	CloudletInfoFieldFlavorsDisk,
	CloudletInfoFieldFlavorsPropMapKey,
	CloudletInfoFieldFlavorsPropMapValue,
	CloudletInfoFieldStatusTaskNumber,
	CloudletInfoFieldStatusMaxTasks,
	CloudletInfoFieldStatusTaskName,
	CloudletInfoFieldStatusStepName,
	CloudletInfoFieldStatusMsgCount,
	CloudletInfoFieldStatusMsgs,
	CloudletInfoFieldContainerVersion,
	CloudletInfoFieldAvailabilityZonesName,
	CloudletInfoFieldAvailabilityZonesStatus,
	CloudletInfoFieldOsImagesName,
	CloudletInfoFieldOsImagesTags,
	CloudletInfoFieldOsImagesProperties,
	CloudletInfoFieldOsImagesDiskFormat,
	CloudletInfoFieldControllerCacheReceived,
	CloudletInfoFieldMaintenanceState,
	CloudletInfoFieldResourcesSnapshotPlatformVmsName,
	CloudletInfoFieldResourcesSnapshotPlatformVmsType,
	CloudletInfoFieldResourcesSnapshotPlatformVmsStatus,
	CloudletInfoFieldResourcesSnapshotPlatformVmsInfraFlavor,
	CloudletInfoFieldResourcesSnapshotPlatformVmsIpaddressesExternalIp,
	CloudletInfoFieldResourcesSnapshotPlatformVmsIpaddressesInternalIp,
	CloudletInfoFieldResourcesSnapshotPlatformVmsContainersName,
	CloudletInfoFieldResourcesSnapshotPlatformVmsContainersType,
	CloudletInfoFieldResourcesSnapshotPlatformVmsContainersStatus,
	CloudletInfoFieldResourcesSnapshotPlatformVmsContainersClusterip,
	CloudletInfoFieldResourcesSnapshotPlatformVmsContainersRestarts,
	CloudletInfoFieldResourcesSnapshotInfoName,
	CloudletInfoFieldResourcesSnapshotInfoValue,
	CloudletInfoFieldResourcesSnapshotInfoInfraMaxValue,
	CloudletInfoFieldResourcesSnapshotInfoQuotaMaxValue,
	CloudletInfoFieldResourcesSnapshotInfoDescription,
	CloudletInfoFieldResourcesSnapshotInfoUnits,
	CloudletInfoFieldResourcesSnapshotInfoAlertThreshold,
	CloudletInfoFieldResourcesSnapshotClusterInstsName,
	CloudletInfoFieldResourcesSnapshotClusterInstsOrganization,
	CloudletInfoFieldResourcesSnapshotVmAppInstsName,
	CloudletInfoFieldResourcesSnapshotVmAppInstsOrganization,
	CloudletInfoFieldResourcesSnapshotK8SAppInstsName,
	CloudletInfoFieldResourcesSnapshotK8SAppInstsOrganization,
	CloudletInfoFieldTrustPolicyState,
	CloudletInfoFieldCompatibilityVersion,
	CloudletInfoFieldPropertiesKey,
	CloudletInfoFieldPropertiesValue,
	CloudletInfoFieldNodeInfosName,
	CloudletInfoFieldNodeInfosAllocatableKey,
	CloudletInfoFieldNodeInfosAllocatableValueWhole,
	CloudletInfoFieldNodeInfosAllocatableValueNanos,
	CloudletInfoFieldNodeInfosCapacityKey,
	CloudletInfoFieldNodeInfosCapacityValueWhole,
	CloudletInfoFieldNodeInfosCapacityValueNanos,
	CloudletInfoFieldActiveCrmInstance,
	CloudletInfoFieldStandbyCrm,
	CloudletInfoFieldReleaseVersion,
}

var CloudletInfoAllFieldsMap = map[string]struct{}{
	CloudletInfoFieldKeyOrganization:                                   struct{}{},
	CloudletInfoFieldKeyName:                                           struct{}{},
	CloudletInfoFieldKeyFederatedOrganization:                          struct{}{},
	CloudletInfoFieldState:                                             struct{}{},
	CloudletInfoFieldNotifyId:                                          struct{}{},
	CloudletInfoFieldController:                                        struct{}{},
	CloudletInfoFieldOsMaxRam:                                          struct{}{},
	CloudletInfoFieldOsMaxVcores:                                       struct{}{},
	CloudletInfoFieldOsMaxVolGb:                                        struct{}{},
	CloudletInfoFieldErrors:                                            struct{}{},
	CloudletInfoFieldFlavorsName:                                       struct{}{},
	CloudletInfoFieldFlavorsVcpus:                                      struct{}{},
	CloudletInfoFieldFlavorsRam:                                        struct{}{},
	CloudletInfoFieldFlavorsDisk:                                       struct{}{},
	CloudletInfoFieldFlavorsPropMapKey:                                 struct{}{},
	CloudletInfoFieldFlavorsPropMapValue:                               struct{}{},
	CloudletInfoFieldStatusTaskNumber:                                  struct{}{},
	CloudletInfoFieldStatusMaxTasks:                                    struct{}{},
	CloudletInfoFieldStatusTaskName:                                    struct{}{},
	CloudletInfoFieldStatusStepName:                                    struct{}{},
	CloudletInfoFieldStatusMsgCount:                                    struct{}{},
	CloudletInfoFieldStatusMsgs:                                        struct{}{},
	CloudletInfoFieldContainerVersion:                                  struct{}{},
	CloudletInfoFieldAvailabilityZonesName:                             struct{}{},
	CloudletInfoFieldAvailabilityZonesStatus:                           struct{}{},
	CloudletInfoFieldOsImagesName:                                      struct{}{},
	CloudletInfoFieldOsImagesTags:                                      struct{}{},
	CloudletInfoFieldOsImagesProperties:                                struct{}{},
	CloudletInfoFieldOsImagesDiskFormat:                                struct{}{},
	CloudletInfoFieldControllerCacheReceived:                           struct{}{},
	CloudletInfoFieldMaintenanceState:                                  struct{}{},
	CloudletInfoFieldResourcesSnapshotPlatformVmsName:                  struct{}{},
	CloudletInfoFieldResourcesSnapshotPlatformVmsType:                  struct{}{},
	CloudletInfoFieldResourcesSnapshotPlatformVmsStatus:                struct{}{},
	CloudletInfoFieldResourcesSnapshotPlatformVmsInfraFlavor:           struct{}{},
	CloudletInfoFieldResourcesSnapshotPlatformVmsIpaddressesExternalIp: struct{}{},
	CloudletInfoFieldResourcesSnapshotPlatformVmsIpaddressesInternalIp: struct{}{},
	CloudletInfoFieldResourcesSnapshotPlatformVmsContainersName:        struct{}{},
	CloudletInfoFieldResourcesSnapshotPlatformVmsContainersType:        struct{}{},
	CloudletInfoFieldResourcesSnapshotPlatformVmsContainersStatus:      struct{}{},
	CloudletInfoFieldResourcesSnapshotPlatformVmsContainersClusterip:   struct{}{},
	CloudletInfoFieldResourcesSnapshotPlatformVmsContainersRestarts:    struct{}{},
	CloudletInfoFieldResourcesSnapshotInfoName:                         struct{}{},
	CloudletInfoFieldResourcesSnapshotInfoValue:                        struct{}{},
	CloudletInfoFieldResourcesSnapshotInfoInfraMaxValue:                struct{}{},
	CloudletInfoFieldResourcesSnapshotInfoQuotaMaxValue:                struct{}{},
	CloudletInfoFieldResourcesSnapshotInfoDescription:                  struct{}{},
	CloudletInfoFieldResourcesSnapshotInfoUnits:                        struct{}{},
	CloudletInfoFieldResourcesSnapshotInfoAlertThreshold:               struct{}{},
	CloudletInfoFieldResourcesSnapshotClusterInstsName:                 struct{}{},
	CloudletInfoFieldResourcesSnapshotClusterInstsOrganization:         struct{}{},
	CloudletInfoFieldResourcesSnapshotVmAppInstsName:                   struct{}{},
	CloudletInfoFieldResourcesSnapshotVmAppInstsOrganization:           struct{}{},
	CloudletInfoFieldResourcesSnapshotK8SAppInstsName:                  struct{}{},
	CloudletInfoFieldResourcesSnapshotK8SAppInstsOrganization:          struct{}{},
	CloudletInfoFieldTrustPolicyState:                                  struct{}{},
	CloudletInfoFieldCompatibilityVersion:                              struct{}{},
	CloudletInfoFieldPropertiesKey:                                     struct{}{},
	CloudletInfoFieldPropertiesValue:                                   struct{}{},
	CloudletInfoFieldNodeInfosName:                                     struct{}{},
	CloudletInfoFieldNodeInfosAllocatableKey:                           struct{}{},
	CloudletInfoFieldNodeInfosAllocatableValueWhole:                    struct{}{},
	CloudletInfoFieldNodeInfosAllocatableValueNanos:                    struct{}{},
	CloudletInfoFieldNodeInfosCapacityKey:                              struct{}{},
	CloudletInfoFieldNodeInfosCapacityValueWhole:                       struct{}{},
	CloudletInfoFieldNodeInfosCapacityValueNanos:                       struct{}{},
	CloudletInfoFieldActiveCrmInstance:                                 struct{}{},
	CloudletInfoFieldStandbyCrm:                                        struct{}{},
	CloudletInfoFieldReleaseVersion:                                    struct{}{},
}

var CloudletInfoAllFieldsStringMap = map[string]string{
	CloudletInfoFieldKeyOrganization:                                   "Key Organization",
	CloudletInfoFieldKeyName:                                           "Key Name",
	CloudletInfoFieldKeyFederatedOrganization:                          "Key Federated Organization",
	CloudletInfoFieldState:                                             "State",
	CloudletInfoFieldNotifyId:                                          "Notify Id",
	CloudletInfoFieldController:                                        "Controller",
	CloudletInfoFieldOsMaxRam:                                          "Os Max Ram",
	CloudletInfoFieldOsMaxVcores:                                       "Os Max Vcores",
	CloudletInfoFieldOsMaxVolGb:                                        "Os Max Vol Gb",
	CloudletInfoFieldErrors:                                            "Errors",
	CloudletInfoFieldFlavorsName:                                       "Flavors Name",
	CloudletInfoFieldFlavorsVcpus:                                      "Flavors Vcpus",
	CloudletInfoFieldFlavorsRam:                                        "Flavors Ram",
	CloudletInfoFieldFlavorsDisk:                                       "Flavors Disk",
	CloudletInfoFieldFlavorsPropMapKey:                                 "Flavors Prop Map Key",
	CloudletInfoFieldFlavorsPropMapValue:                               "Flavors Prop Map Value",
	CloudletInfoFieldStatusTaskNumber:                                  "Status Task Number",
	CloudletInfoFieldStatusMaxTasks:                                    "Status Max Tasks",
	CloudletInfoFieldStatusTaskName:                                    "Status Task Name",
	CloudletInfoFieldStatusStepName:                                    "Status Step Name",
	CloudletInfoFieldStatusMsgCount:                                    "Status Msg Count",
	CloudletInfoFieldStatusMsgs:                                        "Status Msgs",
	CloudletInfoFieldContainerVersion:                                  "Container Version",
	CloudletInfoFieldAvailabilityZonesName:                             "Availability Zones Name",
	CloudletInfoFieldAvailabilityZonesStatus:                           "Availability Zones Status",
	CloudletInfoFieldOsImagesName:                                      "Os Images Name",
	CloudletInfoFieldOsImagesTags:                                      "Os Images Tags",
	CloudletInfoFieldOsImagesProperties:                                "Os Images Properties",
	CloudletInfoFieldOsImagesDiskFormat:                                "Os Images Disk Format",
	CloudletInfoFieldControllerCacheReceived:                           "Controller Cache Received",
	CloudletInfoFieldMaintenanceState:                                  "Maintenance State",
	CloudletInfoFieldResourcesSnapshotPlatformVmsName:                  "Resources Snapshot Platform Vms Name",
	CloudletInfoFieldResourcesSnapshotPlatformVmsType:                  "Resources Snapshot Platform Vms Type",
	CloudletInfoFieldResourcesSnapshotPlatformVmsStatus:                "Resources Snapshot Platform Vms Status",
	CloudletInfoFieldResourcesSnapshotPlatformVmsInfraFlavor:           "Resources Snapshot Platform Vms Infra Flavor",
	CloudletInfoFieldResourcesSnapshotPlatformVmsIpaddressesExternalIp: "Resources Snapshot Platform Vms Ipaddresses External Ip",
	CloudletInfoFieldResourcesSnapshotPlatformVmsIpaddressesInternalIp: "Resources Snapshot Platform Vms Ipaddresses Internal Ip",
	CloudletInfoFieldResourcesSnapshotPlatformVmsContainersName:        "Resources Snapshot Platform Vms Containers Name",
	CloudletInfoFieldResourcesSnapshotPlatformVmsContainersType:        "Resources Snapshot Platform Vms Containers Type",
	CloudletInfoFieldResourcesSnapshotPlatformVmsContainersStatus:      "Resources Snapshot Platform Vms Containers Status",
	CloudletInfoFieldResourcesSnapshotPlatformVmsContainersClusterip:   "Resources Snapshot Platform Vms Containers Clusterip",
	CloudletInfoFieldResourcesSnapshotPlatformVmsContainersRestarts:    "Resources Snapshot Platform Vms Containers Restarts",
	CloudletInfoFieldResourcesSnapshotInfoName:                         "Resources Snapshot Info Name",
	CloudletInfoFieldResourcesSnapshotInfoValue:                        "Resources Snapshot Info Value",
	CloudletInfoFieldResourcesSnapshotInfoInfraMaxValue:                "Resources Snapshot Info Infra Max Value",
	CloudletInfoFieldResourcesSnapshotInfoQuotaMaxValue:                "Resources Snapshot Info Quota Max Value",
	CloudletInfoFieldResourcesSnapshotInfoDescription:                  "Resources Snapshot Info Description",
	CloudletInfoFieldResourcesSnapshotInfoUnits:                        "Resources Snapshot Info Units",
	CloudletInfoFieldResourcesSnapshotInfoAlertThreshold:               "Resources Snapshot Info Alert Threshold",
	CloudletInfoFieldResourcesSnapshotClusterInstsName:                 "Resources Snapshot Cluster Insts Name",
	CloudletInfoFieldResourcesSnapshotClusterInstsOrganization:         "Resources Snapshot Cluster Insts Organization",
	CloudletInfoFieldResourcesSnapshotVmAppInstsName:                   "Resources Snapshot Vm App Insts Name",
	CloudletInfoFieldResourcesSnapshotVmAppInstsOrganization:           "Resources Snapshot Vm App Insts Organization",
	CloudletInfoFieldResourcesSnapshotK8SAppInstsName:                  "Resources Snapshot K8 S App Insts Name",
	CloudletInfoFieldResourcesSnapshotK8SAppInstsOrganization:          "Resources Snapshot K8 S App Insts Organization",
	CloudletInfoFieldTrustPolicyState:                                  "Trust Policy State",
	CloudletInfoFieldCompatibilityVersion:                              "Compatibility Version",
	CloudletInfoFieldPropertiesKey:                                     "Properties Key",
	CloudletInfoFieldPropertiesValue:                                   "Properties Value",
	CloudletInfoFieldNodeInfosName:                                     "Node Infos Name",
	CloudletInfoFieldNodeInfosAllocatableKey:                           "Node Infos Allocatable Key",
	CloudletInfoFieldNodeInfosAllocatableValueWhole:                    "Node Infos Allocatable Value Whole",
	CloudletInfoFieldNodeInfosAllocatableValueNanos:                    "Node Infos Allocatable Value Nanos",
	CloudletInfoFieldNodeInfosCapacityKey:                              "Node Infos Capacity Key",
	CloudletInfoFieldNodeInfosCapacityValueWhole:                       "Node Infos Capacity Value Whole",
	CloudletInfoFieldNodeInfosCapacityValueNanos:                       "Node Infos Capacity Value Nanos",
	CloudletInfoFieldActiveCrmInstance:                                 "Active Crm Instance",
	CloudletInfoFieldStandbyCrm:                                        "Standby Crm",
	CloudletInfoFieldReleaseVersion:                                    "Release Version",
}

func (m *CloudletInfo) IsKeyField(s string) bool {
	return strings.HasPrefix(s, CloudletInfoFieldKey+".") || s == CloudletInfoFieldKey
}

func (m *CloudletInfo) DiffFields(o *CloudletInfo, fields map[string]struct{}) {
	if m.Key.Organization != o.Key.Organization {
		fields[CloudletInfoFieldKeyOrganization] = struct{}{}
		fields[CloudletInfoFieldKey] = struct{}{}
	}
	if m.Key.Name != o.Key.Name {
		fields[CloudletInfoFieldKeyName] = struct{}{}
		fields[CloudletInfoFieldKey] = struct{}{}
	}
	if m.Key.FederatedOrganization != o.Key.FederatedOrganization {
		fields[CloudletInfoFieldKeyFederatedOrganization] = struct{}{}
		fields[CloudletInfoFieldKey] = struct{}{}
	}
	if m.State != o.State {
		fields[CloudletInfoFieldState] = struct{}{}
	}
	if m.NotifyId != o.NotifyId {
		fields[CloudletInfoFieldNotifyId] = struct{}{}
	}
	if m.Controller != o.Controller {
		fields[CloudletInfoFieldController] = struct{}{}
	}
	if m.OsMaxRam != o.OsMaxRam {
		fields[CloudletInfoFieldOsMaxRam] = struct{}{}
	}
	if m.OsMaxVcores != o.OsMaxVcores {
		fields[CloudletInfoFieldOsMaxVcores] = struct{}{}
	}
	if m.OsMaxVolGb != o.OsMaxVolGb {
		fields[CloudletInfoFieldOsMaxVolGb] = struct{}{}
	}
	if len(m.Errors) != len(o.Errors) {
		fields[CloudletInfoFieldErrors] = struct{}{}
	} else {
		for i0 := 0; i0 < len(m.Errors); i0++ {
			if m.Errors[i0] != o.Errors[i0] {
				fields[CloudletInfoFieldErrors] = struct{}{}
				break
			}
		}
	}
	if m.Flavors != nil && o.Flavors != nil {
		if len(m.Flavors) != len(o.Flavors) {
			fields[CloudletInfoFieldFlavors] = struct{}{}
		} else {
			for i0 := 0; i0 < len(m.Flavors); i0++ {
				if m.Flavors[i0].Name != o.Flavors[i0].Name {
					fields[CloudletInfoFieldFlavorsName] = struct{}{}
					fields[CloudletInfoFieldFlavors] = struct{}{}
				}
				if m.Flavors[i0].Vcpus != o.Flavors[i0].Vcpus {
					fields[CloudletInfoFieldFlavorsVcpus] = struct{}{}
					fields[CloudletInfoFieldFlavors] = struct{}{}
				}
				if m.Flavors[i0].Ram != o.Flavors[i0].Ram {
					fields[CloudletInfoFieldFlavorsRam] = struct{}{}
					fields[CloudletInfoFieldFlavors] = struct{}{}
				}
				if m.Flavors[i0].Disk != o.Flavors[i0].Disk {
					fields[CloudletInfoFieldFlavorsDisk] = struct{}{}
					fields[CloudletInfoFieldFlavors] = struct{}{}
				}
				if m.Flavors[i0].PropMap != nil && o.Flavors[i0].PropMap != nil {
					if len(m.Flavors[i0].PropMap) != len(o.Flavors[i0].PropMap) {
						fields[CloudletInfoFieldFlavorsPropMap] = struct{}{}
						fields[CloudletInfoFieldFlavors] = struct{}{}
					} else {
						for k1, _ := range m.Flavors[i0].PropMap {
							_, vok1 := o.Flavors[i0].PropMap[k1]
							if !vok1 {
								fields[CloudletInfoFieldFlavorsPropMap] = struct{}{}
								fields[CloudletInfoFieldFlavors] = struct{}{}
							} else {
								if m.Flavors[i0].PropMap[k1] != o.Flavors[i0].PropMap[k1] {
									fields[CloudletInfoFieldFlavorsPropMap] = struct{}{}
									fields[CloudletInfoFieldFlavors] = struct{}{}
									break
								}
							}
						}
					}
				} else if (m.Flavors[i0].PropMap != nil && o.Flavors[i0].PropMap == nil) || (m.Flavors[i0].PropMap == nil && o.Flavors[i0].PropMap != nil) {
					fields[CloudletInfoFieldFlavorsPropMap] = struct{}{}
					fields[CloudletInfoFieldFlavors] = struct{}{}
				}
			}
		}
	} else if (m.Flavors != nil && o.Flavors == nil) || (m.Flavors == nil && o.Flavors != nil) {
		fields[CloudletInfoFieldFlavors] = struct{}{}
	}
	if m.Status.TaskNumber != o.Status.TaskNumber {
		fields[CloudletInfoFieldStatusTaskNumber] = struct{}{}
		fields[CloudletInfoFieldStatus] = struct{}{}
	}
	if m.Status.MaxTasks != o.Status.MaxTasks {
		fields[CloudletInfoFieldStatusMaxTasks] = struct{}{}
		fields[CloudletInfoFieldStatus] = struct{}{}
	}
	if m.Status.TaskName != o.Status.TaskName {
		fields[CloudletInfoFieldStatusTaskName] = struct{}{}
		fields[CloudletInfoFieldStatus] = struct{}{}
	}
	if m.Status.StepName != o.Status.StepName {
		fields[CloudletInfoFieldStatusStepName] = struct{}{}
		fields[CloudletInfoFieldStatus] = struct{}{}
	}
	if m.Status.MsgCount != o.Status.MsgCount {
		fields[CloudletInfoFieldStatusMsgCount] = struct{}{}
		fields[CloudletInfoFieldStatus] = struct{}{}
	}
	if len(m.Status.Msgs) != len(o.Status.Msgs) {
		fields[CloudletInfoFieldStatusMsgs] = struct{}{}
		fields[CloudletInfoFieldStatus] = struct{}{}
	} else {
		for i1 := 0; i1 < len(m.Status.Msgs); i1++ {
			if m.Status.Msgs[i1] != o.Status.Msgs[i1] {
				fields[CloudletInfoFieldStatusMsgs] = struct{}{}
				fields[CloudletInfoFieldStatus] = struct{}{}
				break
			}
		}
	}
	if m.ContainerVersion != o.ContainerVersion {
		fields[CloudletInfoFieldContainerVersion] = struct{}{}
	}
	if m.AvailabilityZones != nil && o.AvailabilityZones != nil {
		if len(m.AvailabilityZones) != len(o.AvailabilityZones) {
			fields[CloudletInfoFieldAvailabilityZones] = struct{}{}
		} else {
			for i0 := 0; i0 < len(m.AvailabilityZones); i0++ {
				if m.AvailabilityZones[i0].Name != o.AvailabilityZones[i0].Name {
					fields[CloudletInfoFieldAvailabilityZonesName] = struct{}{}
					fields[CloudletInfoFieldAvailabilityZones] = struct{}{}
				}
				if m.AvailabilityZones[i0].Status != o.AvailabilityZones[i0].Status {
					fields[CloudletInfoFieldAvailabilityZonesStatus] = struct{}{}
					fields[CloudletInfoFieldAvailabilityZones] = struct{}{}
				}
			}
		}
	} else if (m.AvailabilityZones != nil && o.AvailabilityZones == nil) || (m.AvailabilityZones == nil && o.AvailabilityZones != nil) {
		fields[CloudletInfoFieldAvailabilityZones] = struct{}{}
	}
	if m.OsImages != nil && o.OsImages != nil {
		if len(m.OsImages) != len(o.OsImages) {
			fields[CloudletInfoFieldOsImages] = struct{}{}
		} else {
			for i0 := 0; i0 < len(m.OsImages); i0++ {
				if m.OsImages[i0].Name != o.OsImages[i0].Name {
					fields[CloudletInfoFieldOsImagesName] = struct{}{}
					fields[CloudletInfoFieldOsImages] = struct{}{}
				}
				if m.OsImages[i0].Tags != o.OsImages[i0].Tags {
					fields[CloudletInfoFieldOsImagesTags] = struct{}{}
					fields[CloudletInfoFieldOsImages] = struct{}{}
				}
				if m.OsImages[i0].Properties != o.OsImages[i0].Properties {
					fields[CloudletInfoFieldOsImagesProperties] = struct{}{}
					fields[CloudletInfoFieldOsImages] = struct{}{}
				}
				if m.OsImages[i0].DiskFormat != o.OsImages[i0].DiskFormat {
					fields[CloudletInfoFieldOsImagesDiskFormat] = struct{}{}
					fields[CloudletInfoFieldOsImages] = struct{}{}
				}
			}
		}
	} else if (m.OsImages != nil && o.OsImages == nil) || (m.OsImages == nil && o.OsImages != nil) {
		fields[CloudletInfoFieldOsImages] = struct{}{}
	}
	if m.ControllerCacheReceived != o.ControllerCacheReceived {
		fields[CloudletInfoFieldControllerCacheReceived] = struct{}{}
	}
	if m.MaintenanceState != o.MaintenanceState {
		fields[CloudletInfoFieldMaintenanceState] = struct{}{}
	}
	if len(m.ResourcesSnapshot.PlatformVms) != len(o.ResourcesSnapshot.PlatformVms) {
		fields[CloudletInfoFieldResourcesSnapshotPlatformVms] = struct{}{}
		fields[CloudletInfoFieldResourcesSnapshot] = struct{}{}
	} else {
		for i1 := 0; i1 < len(m.ResourcesSnapshot.PlatformVms); i1++ {
			if m.ResourcesSnapshot.PlatformVms[i1].Name != o.ResourcesSnapshot.PlatformVms[i1].Name {
				fields[CloudletInfoFieldResourcesSnapshotPlatformVmsName] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshotPlatformVms] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshot] = struct{}{}
			}
			if m.ResourcesSnapshot.PlatformVms[i1].Type != o.ResourcesSnapshot.PlatformVms[i1].Type {
				fields[CloudletInfoFieldResourcesSnapshotPlatformVmsType] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshotPlatformVms] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshot] = struct{}{}
			}
			if m.ResourcesSnapshot.PlatformVms[i1].Status != o.ResourcesSnapshot.PlatformVms[i1].Status {
				fields[CloudletInfoFieldResourcesSnapshotPlatformVmsStatus] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshotPlatformVms] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshot] = struct{}{}
			}
			if m.ResourcesSnapshot.PlatformVms[i1].InfraFlavor != o.ResourcesSnapshot.PlatformVms[i1].InfraFlavor {
				fields[CloudletInfoFieldResourcesSnapshotPlatformVmsInfraFlavor] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshotPlatformVms] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshot] = struct{}{}
			}
			if len(m.ResourcesSnapshot.PlatformVms[i1].Ipaddresses) != len(o.ResourcesSnapshot.PlatformVms[i1].Ipaddresses) {
				fields[CloudletInfoFieldResourcesSnapshotPlatformVmsIpaddresses] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshotPlatformVms] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshot] = struct{}{}
			} else {
				for i2 := 0; i2 < len(m.ResourcesSnapshot.PlatformVms[i1].Ipaddresses); i2++ {
					if m.ResourcesSnapshot.PlatformVms[i1].Ipaddresses[i2].ExternalIp != o.ResourcesSnapshot.PlatformVms[i1].Ipaddresses[i2].ExternalIp {
						fields[CloudletInfoFieldResourcesSnapshotPlatformVmsIpaddressesExternalIp] = struct{}{}
						fields[CloudletInfoFieldResourcesSnapshotPlatformVmsIpaddresses] = struct{}{}
						fields[CloudletInfoFieldResourcesSnapshotPlatformVms] = struct{}{}
						fields[CloudletInfoFieldResourcesSnapshot] = struct{}{}
					}
					if m.ResourcesSnapshot.PlatformVms[i1].Ipaddresses[i2].InternalIp != o.ResourcesSnapshot.PlatformVms[i1].Ipaddresses[i2].InternalIp {
						fields[CloudletInfoFieldResourcesSnapshotPlatformVmsIpaddressesInternalIp] = struct{}{}
						fields[CloudletInfoFieldResourcesSnapshotPlatformVmsIpaddresses] = struct{}{}
						fields[CloudletInfoFieldResourcesSnapshotPlatformVms] = struct{}{}
						fields[CloudletInfoFieldResourcesSnapshot] = struct{}{}
					}
				}
			}
			if m.ResourcesSnapshot.PlatformVms[i1].Containers != nil && o.ResourcesSnapshot.PlatformVms[i1].Containers != nil {
				if len(m.ResourcesSnapshot.PlatformVms[i1].Containers) != len(o.ResourcesSnapshot.PlatformVms[i1].Containers) {
					fields[CloudletInfoFieldResourcesSnapshotPlatformVmsContainers] = struct{}{}
					fields[CloudletInfoFieldResourcesSnapshotPlatformVms] = struct{}{}
					fields[CloudletInfoFieldResourcesSnapshot] = struct{}{}
				} else {
					for i2 := 0; i2 < len(m.ResourcesSnapshot.PlatformVms[i1].Containers); i2++ {
						if m.ResourcesSnapshot.PlatformVms[i1].Containers[i2].Name != o.ResourcesSnapshot.PlatformVms[i1].Containers[i2].Name {
							fields[CloudletInfoFieldResourcesSnapshotPlatformVmsContainersName] = struct{}{}
							fields[CloudletInfoFieldResourcesSnapshotPlatformVmsContainers] = struct{}{}
							fields[CloudletInfoFieldResourcesSnapshotPlatformVms] = struct{}{}
							fields[CloudletInfoFieldResourcesSnapshot] = struct{}{}
						}
						if m.ResourcesSnapshot.PlatformVms[i1].Containers[i2].Type != o.ResourcesSnapshot.PlatformVms[i1].Containers[i2].Type {
							fields[CloudletInfoFieldResourcesSnapshotPlatformVmsContainersType] = struct{}{}
							fields[CloudletInfoFieldResourcesSnapshotPlatformVmsContainers] = struct{}{}
							fields[CloudletInfoFieldResourcesSnapshotPlatformVms] = struct{}{}
							fields[CloudletInfoFieldResourcesSnapshot] = struct{}{}
						}
						if m.ResourcesSnapshot.PlatformVms[i1].Containers[i2].Status != o.ResourcesSnapshot.PlatformVms[i1].Containers[i2].Status {
							fields[CloudletInfoFieldResourcesSnapshotPlatformVmsContainersStatus] = struct{}{}
							fields[CloudletInfoFieldResourcesSnapshotPlatformVmsContainers] = struct{}{}
							fields[CloudletInfoFieldResourcesSnapshotPlatformVms] = struct{}{}
							fields[CloudletInfoFieldResourcesSnapshot] = struct{}{}
						}
						if m.ResourcesSnapshot.PlatformVms[i1].Containers[i2].Clusterip != o.ResourcesSnapshot.PlatformVms[i1].Containers[i2].Clusterip {
							fields[CloudletInfoFieldResourcesSnapshotPlatformVmsContainersClusterip] = struct{}{}
							fields[CloudletInfoFieldResourcesSnapshotPlatformVmsContainers] = struct{}{}
							fields[CloudletInfoFieldResourcesSnapshotPlatformVms] = struct{}{}
							fields[CloudletInfoFieldResourcesSnapshot] = struct{}{}
						}
						if m.ResourcesSnapshot.PlatformVms[i1].Containers[i2].Restarts != o.ResourcesSnapshot.PlatformVms[i1].Containers[i2].Restarts {
							fields[CloudletInfoFieldResourcesSnapshotPlatformVmsContainersRestarts] = struct{}{}
							fields[CloudletInfoFieldResourcesSnapshotPlatformVmsContainers] = struct{}{}
							fields[CloudletInfoFieldResourcesSnapshotPlatformVms] = struct{}{}
							fields[CloudletInfoFieldResourcesSnapshot] = struct{}{}
						}
					}
				}
			} else if (m.ResourcesSnapshot.PlatformVms[i1].Containers != nil && o.ResourcesSnapshot.PlatformVms[i1].Containers == nil) || (m.ResourcesSnapshot.PlatformVms[i1].Containers == nil && o.ResourcesSnapshot.PlatformVms[i1].Containers != nil) {
				fields[CloudletInfoFieldResourcesSnapshotPlatformVmsContainers] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshotPlatformVms] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshot] = struct{}{}
			}
		}
	}
	if len(m.ResourcesSnapshot.Info) != len(o.ResourcesSnapshot.Info) {
		fields[CloudletInfoFieldResourcesSnapshotInfo] = struct{}{}
		fields[CloudletInfoFieldResourcesSnapshot] = struct{}{}
	} else {
		for i1 := 0; i1 < len(m.ResourcesSnapshot.Info); i1++ {
			if m.ResourcesSnapshot.Info[i1].Name != o.ResourcesSnapshot.Info[i1].Name {
				fields[CloudletInfoFieldResourcesSnapshotInfoName] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshotInfo] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshot] = struct{}{}
			}
			if m.ResourcesSnapshot.Info[i1].Value != o.ResourcesSnapshot.Info[i1].Value {
				fields[CloudletInfoFieldResourcesSnapshotInfoValue] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshotInfo] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshot] = struct{}{}
			}
			if m.ResourcesSnapshot.Info[i1].InfraMaxValue != o.ResourcesSnapshot.Info[i1].InfraMaxValue {
				fields[CloudletInfoFieldResourcesSnapshotInfoInfraMaxValue] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshotInfo] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshot] = struct{}{}
			}
			if m.ResourcesSnapshot.Info[i1].QuotaMaxValue != o.ResourcesSnapshot.Info[i1].QuotaMaxValue {
				fields[CloudletInfoFieldResourcesSnapshotInfoQuotaMaxValue] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshotInfo] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshot] = struct{}{}
			}
			if m.ResourcesSnapshot.Info[i1].Description != o.ResourcesSnapshot.Info[i1].Description {
				fields[CloudletInfoFieldResourcesSnapshotInfoDescription] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshotInfo] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshot] = struct{}{}
			}
			if m.ResourcesSnapshot.Info[i1].Units != o.ResourcesSnapshot.Info[i1].Units {
				fields[CloudletInfoFieldResourcesSnapshotInfoUnits] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshotInfo] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshot] = struct{}{}
			}
			if m.ResourcesSnapshot.Info[i1].AlertThreshold != o.ResourcesSnapshot.Info[i1].AlertThreshold {
				fields[CloudletInfoFieldResourcesSnapshotInfoAlertThreshold] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshotInfo] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshot] = struct{}{}
			}
		}
	}
	if len(m.ResourcesSnapshot.ClusterInsts) != len(o.ResourcesSnapshot.ClusterInsts) {
		fields[CloudletInfoFieldResourcesSnapshotClusterInsts] = struct{}{}
		fields[CloudletInfoFieldResourcesSnapshot] = struct{}{}
	} else {
		for i1 := 0; i1 < len(m.ResourcesSnapshot.ClusterInsts); i1++ {
			if m.ResourcesSnapshot.ClusterInsts[i1].Name != o.ResourcesSnapshot.ClusterInsts[i1].Name {
				fields[CloudletInfoFieldResourcesSnapshotClusterInstsName] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshotClusterInsts] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshot] = struct{}{}
			}
			if m.ResourcesSnapshot.ClusterInsts[i1].Organization != o.ResourcesSnapshot.ClusterInsts[i1].Organization {
				fields[CloudletInfoFieldResourcesSnapshotClusterInstsOrganization] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshotClusterInsts] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshot] = struct{}{}
			}
		}
	}
	if len(m.ResourcesSnapshot.VmAppInsts) != len(o.ResourcesSnapshot.VmAppInsts) {
		fields[CloudletInfoFieldResourcesSnapshotVmAppInsts] = struct{}{}
		fields[CloudletInfoFieldResourcesSnapshot] = struct{}{}
	} else {
		for i1 := 0; i1 < len(m.ResourcesSnapshot.VmAppInsts); i1++ {
			if m.ResourcesSnapshot.VmAppInsts[i1].Name != o.ResourcesSnapshot.VmAppInsts[i1].Name {
				fields[CloudletInfoFieldResourcesSnapshotVmAppInstsName] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshotVmAppInsts] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshot] = struct{}{}
			}
			if m.ResourcesSnapshot.VmAppInsts[i1].Organization != o.ResourcesSnapshot.VmAppInsts[i1].Organization {
				fields[CloudletInfoFieldResourcesSnapshotVmAppInstsOrganization] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshotVmAppInsts] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshot] = struct{}{}
			}
		}
	}
	if len(m.ResourcesSnapshot.K8SAppInsts) != len(o.ResourcesSnapshot.K8SAppInsts) {
		fields[CloudletInfoFieldResourcesSnapshotK8SAppInsts] = struct{}{}
		fields[CloudletInfoFieldResourcesSnapshot] = struct{}{}
	} else {
		for i1 := 0; i1 < len(m.ResourcesSnapshot.K8SAppInsts); i1++ {
			if m.ResourcesSnapshot.K8SAppInsts[i1].Name != o.ResourcesSnapshot.K8SAppInsts[i1].Name {
				fields[CloudletInfoFieldResourcesSnapshotK8SAppInstsName] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshotK8SAppInsts] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshot] = struct{}{}
			}
			if m.ResourcesSnapshot.K8SAppInsts[i1].Organization != o.ResourcesSnapshot.K8SAppInsts[i1].Organization {
				fields[CloudletInfoFieldResourcesSnapshotK8SAppInstsOrganization] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshotK8SAppInsts] = struct{}{}
				fields[CloudletInfoFieldResourcesSnapshot] = struct{}{}
			}
		}
	}
	if m.TrustPolicyState != o.TrustPolicyState {
		fields[CloudletInfoFieldTrustPolicyState] = struct{}{}
	}
	if m.CompatibilityVersion != o.CompatibilityVersion {
		fields[CloudletInfoFieldCompatibilityVersion] = struct{}{}
	}
	if m.Properties != nil && o.Properties != nil {
		if len(m.Properties) != len(o.Properties) {
			fields[CloudletInfoFieldProperties] = struct{}{}
		} else {
			for k0, _ := range m.Properties {
				_, vok0 := o.Properties[k0]
				if !vok0 {
					fields[CloudletInfoFieldProperties] = struct{}{}
				} else {
					if m.Properties[k0] != o.Properties[k0] {
						fields[CloudletInfoFieldProperties] = struct{}{}
						break
					}
				}
			}
		}
	} else if (m.Properties != nil && o.Properties == nil) || (m.Properties == nil && o.Properties != nil) {
		fields[CloudletInfoFieldProperties] = struct{}{}
	}
	if m.NodeInfos != nil && o.NodeInfos != nil {
		if len(m.NodeInfos) != len(o.NodeInfos) {
			fields[CloudletInfoFieldNodeInfos] = struct{}{}
		} else {
			for i0 := 0; i0 < len(m.NodeInfos); i0++ {
				if m.NodeInfos[i0].Name != o.NodeInfos[i0].Name {
					fields[CloudletInfoFieldNodeInfosName] = struct{}{}
					fields[CloudletInfoFieldNodeInfos] = struct{}{}
				}
				if m.NodeInfos[i0].Allocatable != nil && o.NodeInfos[i0].Allocatable != nil {
					if len(m.NodeInfos[i0].Allocatable) != len(o.NodeInfos[i0].Allocatable) {
						fields[CloudletInfoFieldNodeInfosAllocatable] = struct{}{}
						fields[CloudletInfoFieldNodeInfos] = struct{}{}
					} else {
						for k1, _ := range m.NodeInfos[i0].Allocatable {
							_, vok1 := o.NodeInfos[i0].Allocatable[k1]
							if !vok1 {
								fields[CloudletInfoFieldNodeInfosAllocatable] = struct{}{}
								fields[CloudletInfoFieldNodeInfos] = struct{}{}
							} else {
								if m.NodeInfos[i0].Allocatable[k1].Whole != o.NodeInfos[i0].Allocatable[k1].Whole {
									fields[CloudletInfoFieldNodeInfosAllocatableValueWhole] = struct{}{}
									fields[CloudletInfoFieldNodeInfosAllocatableValue] = struct{}{}
									fields[CloudletInfoFieldNodeInfosAllocatable] = struct{}{}
									fields[CloudletInfoFieldNodeInfos] = struct{}{}
								}
								if m.NodeInfos[i0].Allocatable[k1].Nanos != o.NodeInfos[i0].Allocatable[k1].Nanos {
									fields[CloudletInfoFieldNodeInfosAllocatableValueNanos] = struct{}{}
									fields[CloudletInfoFieldNodeInfosAllocatableValue] = struct{}{}
									fields[CloudletInfoFieldNodeInfosAllocatable] = struct{}{}
									fields[CloudletInfoFieldNodeInfos] = struct{}{}
								}
							}
						}
					}
				} else if (m.NodeInfos[i0].Allocatable != nil && o.NodeInfos[i0].Allocatable == nil) || (m.NodeInfos[i0].Allocatable == nil && o.NodeInfos[i0].Allocatable != nil) {
					fields[CloudletInfoFieldNodeInfosAllocatable] = struct{}{}
					fields[CloudletInfoFieldNodeInfos] = struct{}{}
				}
				if m.NodeInfos[i0].Capacity != nil && o.NodeInfos[i0].Capacity != nil {
					if len(m.NodeInfos[i0].Capacity) != len(o.NodeInfos[i0].Capacity) {
						fields[CloudletInfoFieldNodeInfosCapacity] = struct{}{}
						fields[CloudletInfoFieldNodeInfos] = struct{}{}
					} else {
						for k1, _ := range m.NodeInfos[i0].Capacity {
							_, vok1 := o.NodeInfos[i0].Capacity[k1]
							if !vok1 {
								fields[CloudletInfoFieldNodeInfosCapacity] = struct{}{}
								fields[CloudletInfoFieldNodeInfos] = struct{}{}
							} else {
								if m.NodeInfos[i0].Capacity[k1].Whole != o.NodeInfos[i0].Capacity[k1].Whole {
									fields[CloudletInfoFieldNodeInfosCapacityValueWhole] = struct{}{}
									fields[CloudletInfoFieldNodeInfosCapacityValue] = struct{}{}
									fields[CloudletInfoFieldNodeInfosCapacity] = struct{}{}
									fields[CloudletInfoFieldNodeInfos] = struct{}{}
								}
								if m.NodeInfos[i0].Capacity[k1].Nanos != o.NodeInfos[i0].Capacity[k1].Nanos {
									fields[CloudletInfoFieldNodeInfosCapacityValueNanos] = struct{}{}
									fields[CloudletInfoFieldNodeInfosCapacityValue] = struct{}{}
									fields[CloudletInfoFieldNodeInfosCapacity] = struct{}{}
									fields[CloudletInfoFieldNodeInfos] = struct{}{}
								}
							}
						}
					}
				} else if (m.NodeInfos[i0].Capacity != nil && o.NodeInfos[i0].Capacity == nil) || (m.NodeInfos[i0].Capacity == nil && o.NodeInfos[i0].Capacity != nil) {
					fields[CloudletInfoFieldNodeInfosCapacity] = struct{}{}
					fields[CloudletInfoFieldNodeInfos] = struct{}{}
				}
			}
		}
	} else if (m.NodeInfos != nil && o.NodeInfos == nil) || (m.NodeInfos == nil && o.NodeInfos != nil) {
		fields[CloudletInfoFieldNodeInfos] = struct{}{}
	}
	if m.ActiveCrmInstance != o.ActiveCrmInstance {
		fields[CloudletInfoFieldActiveCrmInstance] = struct{}{}
	}
	if m.StandbyCrm != o.StandbyCrm {
		fields[CloudletInfoFieldStandbyCrm] = struct{}{}
	}
	if m.ReleaseVersion != o.ReleaseVersion {
		fields[CloudletInfoFieldReleaseVersion] = struct{}{}
	}
}

func (m *CloudletInfo) Clone() *CloudletInfo {
	cp := &CloudletInfo{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *CloudletInfo) AddErrors(vals ...string) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.Errors {
		cur[v] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v]; found {
			continue // duplicate
		}
		m.Errors = append(m.Errors, v)
		changes++
	}
	return changes
}

func (m *CloudletInfo) RemoveErrors(vals ...string) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v] = struct{}{}
	}
	for i := len(m.Errors); i >= 0; i-- {
		if _, found := remove[m.Errors[i]]; found {
			m.Errors = append(m.Errors[:i], m.Errors[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *CloudletInfo) AddFlavors(vals ...*FlavorInfo) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.Flavors {
		cur[v.String()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.String()]; found {
			continue // duplicate
		}
		m.Flavors = append(m.Flavors, v)
		changes++
	}
	return changes
}

func (m *CloudletInfo) RemoveFlavors(vals ...*FlavorInfo) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.String()] = struct{}{}
	}
	for i := len(m.Flavors); i >= 0; i-- {
		if _, found := remove[m.Flavors[i].String()]; found {
			m.Flavors = append(m.Flavors[:i], m.Flavors[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *CloudletInfo) AddStatusMsgs(vals ...string) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.Status.Msgs {
		cur[v] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v]; found {
			continue // duplicate
		}
		m.Status.Msgs = append(m.Status.Msgs, v)
		changes++
	}
	return changes
}

func (m *CloudletInfo) RemoveStatusMsgs(vals ...string) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v] = struct{}{}
	}
	for i := len(m.Status.Msgs); i >= 0; i-- {
		if _, found := remove[m.Status.Msgs[i]]; found {
			m.Status.Msgs = append(m.Status.Msgs[:i], m.Status.Msgs[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *CloudletInfo) AddAvailabilityZones(vals ...*OSAZone) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.AvailabilityZones {
		cur[v.String()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.String()]; found {
			continue // duplicate
		}
		m.AvailabilityZones = append(m.AvailabilityZones, v)
		changes++
	}
	return changes
}

func (m *CloudletInfo) RemoveAvailabilityZones(vals ...*OSAZone) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.String()] = struct{}{}
	}
	for i := len(m.AvailabilityZones); i >= 0; i-- {
		if _, found := remove[m.AvailabilityZones[i].String()]; found {
			m.AvailabilityZones = append(m.AvailabilityZones[:i], m.AvailabilityZones[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *CloudletInfo) AddOsImages(vals ...*OSImage) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.OsImages {
		cur[v.String()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.String()]; found {
			continue // duplicate
		}
		m.OsImages = append(m.OsImages, v)
		changes++
	}
	return changes
}

func (m *CloudletInfo) RemoveOsImages(vals ...*OSImage) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.String()] = struct{}{}
	}
	for i := len(m.OsImages); i >= 0; i-- {
		if _, found := remove[m.OsImages[i].String()]; found {
			m.OsImages = append(m.OsImages[:i], m.OsImages[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *CloudletInfo) AddResourcesSnapshotPlatformVms(vals ...VmInfo) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.ResourcesSnapshot.PlatformVms {
		cur[v.String()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.String()]; found {
			continue // duplicate
		}
		m.ResourcesSnapshot.PlatformVms = append(m.ResourcesSnapshot.PlatformVms, v)
		changes++
	}
	return changes
}

func (m *CloudletInfo) RemoveResourcesSnapshotPlatformVms(vals ...VmInfo) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.String()] = struct{}{}
	}
	for i := len(m.ResourcesSnapshot.PlatformVms); i >= 0; i-- {
		if _, found := remove[m.ResourcesSnapshot.PlatformVms[i].String()]; found {
			m.ResourcesSnapshot.PlatformVms = append(m.ResourcesSnapshot.PlatformVms[:i], m.ResourcesSnapshot.PlatformVms[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *CloudletInfo) AddResourcesSnapshotInfo(vals ...InfraResource) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.ResourcesSnapshot.Info {
		cur[v.String()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.String()]; found {
			continue // duplicate
		}
		m.ResourcesSnapshot.Info = append(m.ResourcesSnapshot.Info, v)
		changes++
	}
	return changes
}

func (m *CloudletInfo) RemoveResourcesSnapshotInfo(vals ...InfraResource) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.String()] = struct{}{}
	}
	for i := len(m.ResourcesSnapshot.Info); i >= 0; i-- {
		if _, found := remove[m.ResourcesSnapshot.Info[i].String()]; found {
			m.ResourcesSnapshot.Info = append(m.ResourcesSnapshot.Info[:i], m.ResourcesSnapshot.Info[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *CloudletInfo) AddResourcesSnapshotClusterInsts(vals ...ClusterKey) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.ResourcesSnapshot.ClusterInsts {
		cur[v.GetKeyString()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.GetKeyString()]; found {
			continue // duplicate
		}
		m.ResourcesSnapshot.ClusterInsts = append(m.ResourcesSnapshot.ClusterInsts, v)
		changes++
	}
	return changes
}

func (m *CloudletInfo) RemoveResourcesSnapshotClusterInsts(vals ...ClusterKey) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.GetKeyString()] = struct{}{}
	}
	for i := len(m.ResourcesSnapshot.ClusterInsts); i >= 0; i-- {
		if _, found := remove[m.ResourcesSnapshot.ClusterInsts[i].GetKeyString()]; found {
			m.ResourcesSnapshot.ClusterInsts = append(m.ResourcesSnapshot.ClusterInsts[:i], m.ResourcesSnapshot.ClusterInsts[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *CloudletInfo) AddResourcesSnapshotVmAppInsts(vals ...AppInstRefKey) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.ResourcesSnapshot.VmAppInsts {
		cur[v.GetKeyString()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.GetKeyString()]; found {
			continue // duplicate
		}
		m.ResourcesSnapshot.VmAppInsts = append(m.ResourcesSnapshot.VmAppInsts, v)
		changes++
	}
	return changes
}

func (m *CloudletInfo) RemoveResourcesSnapshotVmAppInsts(vals ...AppInstRefKey) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.GetKeyString()] = struct{}{}
	}
	for i := len(m.ResourcesSnapshot.VmAppInsts); i >= 0; i-- {
		if _, found := remove[m.ResourcesSnapshot.VmAppInsts[i].GetKeyString()]; found {
			m.ResourcesSnapshot.VmAppInsts = append(m.ResourcesSnapshot.VmAppInsts[:i], m.ResourcesSnapshot.VmAppInsts[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *CloudletInfo) AddResourcesSnapshotK8SAppInsts(vals ...AppInstRefKey) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.ResourcesSnapshot.K8SAppInsts {
		cur[v.GetKeyString()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.GetKeyString()]; found {
			continue // duplicate
		}
		m.ResourcesSnapshot.K8SAppInsts = append(m.ResourcesSnapshot.K8SAppInsts, v)
		changes++
	}
	return changes
}

func (m *CloudletInfo) RemoveResourcesSnapshotK8SAppInsts(vals ...AppInstRefKey) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.GetKeyString()] = struct{}{}
	}
	for i := len(m.ResourcesSnapshot.K8SAppInsts); i >= 0; i-- {
		if _, found := remove[m.ResourcesSnapshot.K8SAppInsts[i].GetKeyString()]; found {
			m.ResourcesSnapshot.K8SAppInsts = append(m.ResourcesSnapshot.K8SAppInsts[:i], m.ResourcesSnapshot.K8SAppInsts[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *CloudletInfo) AddNodeInfos(vals ...*NodeInfo) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.NodeInfos {
		cur[v.String()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.String()]; found {
			continue // duplicate
		}
		m.NodeInfos = append(m.NodeInfos, v)
		changes++
	}
	return changes
}

func (m *CloudletInfo) RemoveNodeInfos(vals ...*NodeInfo) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.String()] = struct{}{}
	}
	for i := len(m.NodeInfos); i >= 0; i-- {
		if _, found := remove[m.NodeInfos[i].String()]; found {
			m.NodeInfos = append(m.NodeInfos[:i], m.NodeInfos[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *CloudletInfo) CopyInFields(src *CloudletInfo) int {
	updateListAction := "replace"
	changed := 0
	fmap := MakeFieldMap(src.Fields)
	if _, set := fmap["2"]; set {
		if _, set := fmap["2.1"]; set {
			if m.Key.Organization != src.Key.Organization {
				m.Key.Organization = src.Key.Organization
				changed++
			}
		}
		if _, set := fmap["2.2"]; set {
			if m.Key.Name != src.Key.Name {
				m.Key.Name = src.Key.Name
				changed++
			}
		}
		if _, set := fmap["2.3"]; set {
			if m.Key.FederatedOrganization != src.Key.FederatedOrganization {
				m.Key.FederatedOrganization = src.Key.FederatedOrganization
				changed++
			}
		}
	}
	if _, set := fmap["3"]; set {
		if m.State != src.State {
			m.State = src.State
			changed++
		}
	}
	if _, set := fmap["4"]; set {
		if m.NotifyId != src.NotifyId {
			m.NotifyId = src.NotifyId
			changed++
		}
	}
	if _, set := fmap["5"]; set {
		if m.Controller != src.Controller {
			m.Controller = src.Controller
			changed++
		}
	}
	if _, set := fmap["6"]; set {
		if m.OsMaxRam != src.OsMaxRam {
			m.OsMaxRam = src.OsMaxRam
			changed++
		}
	}
	if _, set := fmap["7"]; set {
		if m.OsMaxVcores != src.OsMaxVcores {
			m.OsMaxVcores = src.OsMaxVcores
			changed++
		}
	}
	if _, set := fmap["8"]; set {
		if m.OsMaxVolGb != src.OsMaxVolGb {
			m.OsMaxVolGb = src.OsMaxVolGb
			changed++
		}
	}
	if _, set := fmap["9"]; set {
		if src.Errors != nil {
			if updateListAction == "add" {
				changed += m.AddErrors(src.Errors...)
			} else if updateListAction == "remove" {
				changed += m.RemoveErrors(src.Errors...)
			} else {
				m.Errors = make([]string, 0)
				m.Errors = append(m.Errors, src.Errors...)
				changed++
			}
		} else if m.Errors != nil {
			m.Errors = nil
			changed++
		}
	}
	if _, set := fmap["10"]; set {
		if src.Flavors != nil {
			if updateListAction == "add" {
				changed += m.AddFlavors(src.Flavors...)
			} else if updateListAction == "remove" {
				changed += m.RemoveFlavors(src.Flavors...)
			} else {
				m.Flavors = make([]*FlavorInfo, 0)
				for k0, _ := range src.Flavors {
					m.Flavors = append(m.Flavors, src.Flavors[k0].Clone())
				}
				changed++
			}
		} else if m.Flavors != nil {
			m.Flavors = nil
			changed++
		}
	}
	if _, set := fmap["11"]; set {
		if _, set := fmap["11.1"]; set {
			if m.Status.TaskNumber != src.Status.TaskNumber {
				m.Status.TaskNumber = src.Status.TaskNumber
				changed++
			}
		}
		if _, set := fmap["11.2"]; set {
			if m.Status.MaxTasks != src.Status.MaxTasks {
				m.Status.MaxTasks = src.Status.MaxTasks
				changed++
			}
		}
		if _, set := fmap["11.3"]; set {
			if m.Status.TaskName != src.Status.TaskName {
				m.Status.TaskName = src.Status.TaskName
				changed++
			}
		}
		if _, set := fmap["11.4"]; set {
			if m.Status.StepName != src.Status.StepName {
				m.Status.StepName = src.Status.StepName
				changed++
			}
		}
		if _, set := fmap["11.5"]; set {
			if m.Status.MsgCount != src.Status.MsgCount {
				m.Status.MsgCount = src.Status.MsgCount
				changed++
			}
		}
		if _, set := fmap["11.6"]; set {
			if src.Status.Msgs != nil {
				if updateListAction == "add" {
					changed += m.AddStatusMsgs(src.Status.Msgs...)
				} else if updateListAction == "remove" {
					changed += m.RemoveStatusMsgs(src.Status.Msgs...)
				} else {
					m.Status.Msgs = make([]string, 0)
					m.Status.Msgs = append(m.Status.Msgs, src.Status.Msgs...)
					changed++
				}
			} else if m.Status.Msgs != nil {
				m.Status.Msgs = nil
				changed++
			}
		}
	}
	if _, set := fmap["12"]; set {
		if m.ContainerVersion != src.ContainerVersion {
			m.ContainerVersion = src.ContainerVersion
			changed++
		}
	}
	if _, set := fmap["13"]; set {
		if src.AvailabilityZones != nil {
			if updateListAction == "add" {
				changed += m.AddAvailabilityZones(src.AvailabilityZones...)
			} else if updateListAction == "remove" {
				changed += m.RemoveAvailabilityZones(src.AvailabilityZones...)
			} else {
				m.AvailabilityZones = make([]*OSAZone, 0)
				for k0, _ := range src.AvailabilityZones {
					m.AvailabilityZones = append(m.AvailabilityZones, src.AvailabilityZones[k0].Clone())
				}
				changed++
			}
		} else if m.AvailabilityZones != nil {
			m.AvailabilityZones = nil
			changed++
		}
	}
	if _, set := fmap["14"]; set {
		if src.OsImages != nil {
			if updateListAction == "add" {
				changed += m.AddOsImages(src.OsImages...)
			} else if updateListAction == "remove" {
				changed += m.RemoveOsImages(src.OsImages...)
			} else {
				m.OsImages = make([]*OSImage, 0)
				for k0, _ := range src.OsImages {
					m.OsImages = append(m.OsImages, src.OsImages[k0].Clone())
				}
				changed++
			}
		} else if m.OsImages != nil {
			m.OsImages = nil
			changed++
		}
	}
	if _, set := fmap["15"]; set {
		if m.ControllerCacheReceived != src.ControllerCacheReceived {
			m.ControllerCacheReceived = src.ControllerCacheReceived
			changed++
		}
	}
	if _, set := fmap["16"]; set {
		if m.MaintenanceState != src.MaintenanceState {
			m.MaintenanceState = src.MaintenanceState
			changed++
		}
	}
	if _, set := fmap["17"]; set {
		if _, set := fmap["17.1"]; set {
			if src.ResourcesSnapshot.PlatformVms != nil {
				if updateListAction == "add" {
					changed += m.AddResourcesSnapshotPlatformVms(src.ResourcesSnapshot.PlatformVms...)
				} else if updateListAction == "remove" {
					changed += m.RemoveResourcesSnapshotPlatformVms(src.ResourcesSnapshot.PlatformVms...)
				} else {
					m.ResourcesSnapshot.PlatformVms = make([]VmInfo, 0)
					for k1, _ := range src.ResourcesSnapshot.PlatformVms {
						m.ResourcesSnapshot.PlatformVms = append(m.ResourcesSnapshot.PlatformVms, *src.ResourcesSnapshot.PlatformVms[k1].Clone())
					}
					changed++
				}
			} else if m.ResourcesSnapshot.PlatformVms != nil {
				m.ResourcesSnapshot.PlatformVms = nil
				changed++
			}
		}
		if _, set := fmap["17.2"]; set {
			if src.ResourcesSnapshot.Info != nil {
				if updateListAction == "add" {
					changed += m.AddResourcesSnapshotInfo(src.ResourcesSnapshot.Info...)
				} else if updateListAction == "remove" {
					changed += m.RemoveResourcesSnapshotInfo(src.ResourcesSnapshot.Info...)
				} else {
					m.ResourcesSnapshot.Info = make([]InfraResource, 0)
					for k1, _ := range src.ResourcesSnapshot.Info {
						m.ResourcesSnapshot.Info = append(m.ResourcesSnapshot.Info, *src.ResourcesSnapshot.Info[k1].Clone())
					}
					changed++
				}
			} else if m.ResourcesSnapshot.Info != nil {
				m.ResourcesSnapshot.Info = nil
				changed++
			}
		}
		if _, set := fmap["17.3"]; set {
			if src.ResourcesSnapshot.ClusterInsts != nil {
				if updateListAction == "add" {
					changed += m.AddResourcesSnapshotClusterInsts(src.ResourcesSnapshot.ClusterInsts...)
				} else if updateListAction == "remove" {
					changed += m.RemoveResourcesSnapshotClusterInsts(src.ResourcesSnapshot.ClusterInsts...)
				} else {
					m.ResourcesSnapshot.ClusterInsts = make([]ClusterKey, 0)
					for k1, _ := range src.ResourcesSnapshot.ClusterInsts {
						m.ResourcesSnapshot.ClusterInsts = append(m.ResourcesSnapshot.ClusterInsts, *src.ResourcesSnapshot.ClusterInsts[k1].Clone())
					}
					changed++
				}
			} else if m.ResourcesSnapshot.ClusterInsts != nil {
				m.ResourcesSnapshot.ClusterInsts = nil
				changed++
			}
		}
		if _, set := fmap["17.4"]; set {
			if src.ResourcesSnapshot.VmAppInsts != nil {
				if updateListAction == "add" {
					changed += m.AddResourcesSnapshotVmAppInsts(src.ResourcesSnapshot.VmAppInsts...)
				} else if updateListAction == "remove" {
					changed += m.RemoveResourcesSnapshotVmAppInsts(src.ResourcesSnapshot.VmAppInsts...)
				} else {
					m.ResourcesSnapshot.VmAppInsts = make([]AppInstRefKey, 0)
					for k1, _ := range src.ResourcesSnapshot.VmAppInsts {
						m.ResourcesSnapshot.VmAppInsts = append(m.ResourcesSnapshot.VmAppInsts, *src.ResourcesSnapshot.VmAppInsts[k1].Clone())
					}
					changed++
				}
			} else if m.ResourcesSnapshot.VmAppInsts != nil {
				m.ResourcesSnapshot.VmAppInsts = nil
				changed++
			}
		}
		if _, set := fmap["17.5"]; set {
			if src.ResourcesSnapshot.K8SAppInsts != nil {
				if updateListAction == "add" {
					changed += m.AddResourcesSnapshotK8SAppInsts(src.ResourcesSnapshot.K8SAppInsts...)
				} else if updateListAction == "remove" {
					changed += m.RemoveResourcesSnapshotK8SAppInsts(src.ResourcesSnapshot.K8SAppInsts...)
				} else {
					m.ResourcesSnapshot.K8SAppInsts = make([]AppInstRefKey, 0)
					for k1, _ := range src.ResourcesSnapshot.K8SAppInsts {
						m.ResourcesSnapshot.K8SAppInsts = append(m.ResourcesSnapshot.K8SAppInsts, *src.ResourcesSnapshot.K8SAppInsts[k1].Clone())
					}
					changed++
				}
			} else if m.ResourcesSnapshot.K8SAppInsts != nil {
				m.ResourcesSnapshot.K8SAppInsts = nil
				changed++
			}
		}
	}
	if _, set := fmap["18"]; set {
		if m.TrustPolicyState != src.TrustPolicyState {
			m.TrustPolicyState = src.TrustPolicyState
			changed++
		}
	}
	if _, set := fmap["19"]; set {
		if m.CompatibilityVersion != src.CompatibilityVersion {
			m.CompatibilityVersion = src.CompatibilityVersion
			changed++
		}
	}
	if _, set := fmap["20"]; set {
		if src.Properties != nil {
			if updateListAction == "add" {
				for k0, v := range src.Properties {
					m.Properties[k0] = v
					changed++
				}
			} else if updateListAction == "remove" {
				for k0, _ := range src.Properties {
					if _, ok := m.Properties[k0]; ok {
						delete(m.Properties, k0)
						changed++
					}
				}
			} else {
				m.Properties = make(map[string]string)
				for k0, v := range src.Properties {
					m.Properties[k0] = v
				}
				changed++
			}
		} else if m.Properties != nil {
			m.Properties = nil
			changed++
		}
	}
	if _, set := fmap["21"]; set {
		if src.NodeInfos != nil {
			if updateListAction == "add" {
				changed += m.AddNodeInfos(src.NodeInfos...)
			} else if updateListAction == "remove" {
				changed += m.RemoveNodeInfos(src.NodeInfos...)
			} else {
				m.NodeInfos = make([]*NodeInfo, 0)
				for k0, _ := range src.NodeInfos {
					m.NodeInfos = append(m.NodeInfos, src.NodeInfos[k0].Clone())
				}
				changed++
			}
		} else if m.NodeInfos != nil {
			m.NodeInfos = nil
			changed++
		}
	}
	if _, set := fmap["22"]; set {
		if m.ActiveCrmInstance != src.ActiveCrmInstance {
			m.ActiveCrmInstance = src.ActiveCrmInstance
			changed++
		}
	}
	if _, set := fmap["23"]; set {
		if m.StandbyCrm != src.StandbyCrm {
			m.StandbyCrm = src.StandbyCrm
			changed++
		}
	}
	if _, set := fmap["24"]; set {
		if m.ReleaseVersion != src.ReleaseVersion {
			m.ReleaseVersion = src.ReleaseVersion
			changed++
		}
	}
	return changed
}

func (m *CloudletInfo) DeepCopyIn(src *CloudletInfo) {
	m.Key.DeepCopyIn(&src.Key)
	m.State = src.State
	m.NotifyId = src.NotifyId
	m.Controller = src.Controller
	m.OsMaxRam = src.OsMaxRam
	m.OsMaxVcores = src.OsMaxVcores
	m.OsMaxVolGb = src.OsMaxVolGb
	if src.Errors != nil {
		m.Errors = make([]string, len(src.Errors), len(src.Errors))
		for ii, s := range src.Errors {
			m.Errors[ii] = s
		}
	} else {
		m.Errors = nil
	}
	if src.Flavors != nil {
		m.Flavors = make([]*FlavorInfo, len(src.Flavors), len(src.Flavors))
		for ii, s := range src.Flavors {
			var tmp_s FlavorInfo
			tmp_s.DeepCopyIn(s)
			m.Flavors[ii] = &tmp_s
		}
	} else {
		m.Flavors = nil
	}
	m.Status.DeepCopyIn(&src.Status)
	m.ContainerVersion = src.ContainerVersion
	if src.AvailabilityZones != nil {
		m.AvailabilityZones = make([]*OSAZone, len(src.AvailabilityZones), len(src.AvailabilityZones))
		for ii, s := range src.AvailabilityZones {
			var tmp_s OSAZone
			tmp_s.DeepCopyIn(s)
			m.AvailabilityZones[ii] = &tmp_s
		}
	} else {
		m.AvailabilityZones = nil
	}
	if src.OsImages != nil {
		m.OsImages = make([]*OSImage, len(src.OsImages), len(src.OsImages))
		for ii, s := range src.OsImages {
			var tmp_s OSImage
			tmp_s.DeepCopyIn(s)
			m.OsImages[ii] = &tmp_s
		}
	} else {
		m.OsImages = nil
	}
	m.ControllerCacheReceived = src.ControllerCacheReceived
	m.MaintenanceState = src.MaintenanceState
	m.ResourcesSnapshot.DeepCopyIn(&src.ResourcesSnapshot)
	m.TrustPolicyState = src.TrustPolicyState
	m.CompatibilityVersion = src.CompatibilityVersion
	if src.Properties != nil {
		m.Properties = make(map[string]string)
		for k, v := range src.Properties {
			m.Properties[k] = v
		}
	} else {
		m.Properties = nil
	}
	if src.NodeInfos != nil {
		m.NodeInfos = make([]*NodeInfo, len(src.NodeInfos), len(src.NodeInfos))
		for ii, s := range src.NodeInfos {
			var tmp_s NodeInfo
			tmp_s.DeepCopyIn(s)
			m.NodeInfos[ii] = &tmp_s
		}
	} else {
		m.NodeInfos = nil
	}
	m.ActiveCrmInstance = src.ActiveCrmInstance
	m.StandbyCrm = src.StandbyCrm
	m.ReleaseVersion = src.ReleaseVersion
}

func (s *CloudletInfo) HasFields() bool {
	return true
}

type CloudletInfoStore interface {
	Create(ctx context.Context, m *CloudletInfo, wait func(int64)) (*Result, error)
	Update(ctx context.Context, m *CloudletInfo, wait func(int64)) (*Result, error)
	Delete(ctx context.Context, m *CloudletInfo, wait func(int64)) (*Result, error)
	Put(ctx context.Context, m *CloudletInfo, wait func(int64), ops ...objstore.KVOp) (*Result, error)
	LoadOne(key string) (*CloudletInfo, int64, error)
	Get(ctx context.Context, key *CloudletKey, buf *CloudletInfo) bool
	STMGet(stm concurrency.STM, key *CloudletKey, buf *CloudletInfo) bool
	STMPut(stm concurrency.STM, obj *CloudletInfo, ops ...objstore.KVOp)
	STMDel(stm concurrency.STM, key *CloudletKey)
	STMHas(stm concurrency.STM, key *CloudletKey) bool
}

type CloudletInfoStoreImpl struct {
	kvstore objstore.KVStore
}

func NewCloudletInfoStore(kvstore objstore.KVStore) *CloudletInfoStoreImpl {
	return &CloudletInfoStoreImpl{kvstore: kvstore}
}

func (s *CloudletInfoStoreImpl) Create(ctx context.Context, m *CloudletInfo, wait func(int64)) (*Result, error) {
	err := m.Validate(CloudletInfoAllFieldsMap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("CloudletInfo", m.GetKey())
	val, err := json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Create(ctx, key, string(val))
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *CloudletInfoStoreImpl) Update(ctx context.Context, m *CloudletInfo, wait func(int64)) (*Result, error) {
	fmap := MakeFieldMap(m.Fields)
	err := m.Validate(fmap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("CloudletInfo", m.GetKey())
	var vers int64 = 0
	curBytes, vers, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, err
	}
	var cur CloudletInfo
	err = json.Unmarshal(curBytes, &cur)
	if err != nil {
		return nil, err
	}
	cur.CopyInFields(m)
	// never save fields
	cur.Fields = nil
	val, err := json.Marshal(cur)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Update(ctx, key, string(val), vers)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *CloudletInfoStoreImpl) Put(ctx context.Context, m *CloudletInfo, wait func(int64), ops ...objstore.KVOp) (*Result, error) {
	err := m.Validate(CloudletInfoAllFieldsMap)
	m.Fields = nil
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("CloudletInfo", m.GetKey())
	var val []byte
	val, err = json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Put(ctx, key, string(val), ops...)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *CloudletInfoStoreImpl) Delete(ctx context.Context, m *CloudletInfo, wait func(int64)) (*Result, error) {
	err := m.GetKey().ValidateKey()
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("CloudletInfo", m.GetKey())
	rev, err := s.kvstore.Delete(ctx, key)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *CloudletInfoStoreImpl) LoadOne(key string) (*CloudletInfo, int64, error) {
	val, rev, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, 0, err
	}
	var obj CloudletInfo
	err = json.Unmarshal(val, &obj)
	if err != nil {
		log.DebugLog(log.DebugLevelApi, "Failed to parse CloudletInfo data", "val", string(val), "err", err)
		return nil, 0, err
	}
	return &obj, rev, nil
}

func (s *CloudletInfoStoreImpl) Get(ctx context.Context, key *CloudletKey, buf *CloudletInfo) bool {
	keystr := objstore.DbKeyString("CloudletInfo", key)
	val, _, _, err := s.kvstore.Get(keystr)
	if err != nil {
		return false
	}
	return s.parseGetData(val, buf)
}

func (s *CloudletInfoStoreImpl) STMGet(stm concurrency.STM, key *CloudletKey, buf *CloudletInfo) bool {
	keystr := objstore.DbKeyString("CloudletInfo", key)
	valstr := stm.Get(keystr)
	return s.parseGetData([]byte(valstr), buf)
}

func (s *CloudletInfoStoreImpl) STMHas(stm concurrency.STM, key *CloudletKey) bool {
	keystr := objstore.DbKeyString("CloudletInfo", key)
	return stm.Get(keystr) != ""
}

func (s *CloudletInfoStoreImpl) parseGetData(val []byte, buf *CloudletInfo) bool {
	if len(val) == 0 {
		return false
	}
	if buf != nil {
		// clear buf, because empty values in val won't
		// overwrite non-empty values in buf.
		*buf = CloudletInfo{}
		err := json.Unmarshal(val, buf)
		if err != nil {
			return false
		}
	}
	return true
}

func (s *CloudletInfoStoreImpl) STMPut(stm concurrency.STM, obj *CloudletInfo, ops ...objstore.KVOp) {
	keystr := objstore.DbKeyString("CloudletInfo", obj.GetKey())

	val, err := json.Marshal(obj)
	if err != nil {
		log.InfoLog("CloudletInfo json marshal failed", "obj", obj, "err", err)
	}
	v3opts := GetSTMOpts(ops...)
	stm.Put(keystr, string(val), v3opts...)
}

func (s *CloudletInfoStoreImpl) STMDel(stm concurrency.STM, key *CloudletKey) {
	keystr := objstore.DbKeyString("CloudletInfo", key)
	stm.Del(keystr)
}

type CloudletInfoKeyWatcher struct {
	cb func(ctx context.Context)
}

type CloudletInfoCacheData struct {
	Obj    *CloudletInfo
	ModRev int64
}

func (s *CloudletInfoCacheData) Clone() *CloudletInfoCacheData {
	cp := CloudletInfoCacheData{}
	if s.Obj != nil {
		cp.Obj = &CloudletInfo{}
		cp.Obj.DeepCopyIn(s.Obj)
	}
	cp.ModRev = s.ModRev
	return &cp
}

// CloudletInfoCache caches CloudletInfo objects in memory in a hash table
// and keeps them in sync with the database.
type CloudletInfoCache struct {
	Objs          map[CloudletKey]*CloudletInfoCacheData
	Mux           util.Mutex
	List          map[CloudletKey]struct{}
	FlushAll      bool
	NotifyCbs     []func(ctx context.Context, obj *CloudletInfo, modRev int64)
	UpdatedCbs    []func(ctx context.Context, old *CloudletInfo, new *CloudletInfo)
	DeletedCbs    []func(ctx context.Context, old *CloudletInfo)
	KeyWatchers   map[CloudletKey][]*CloudletInfoKeyWatcher
	UpdatedKeyCbs []func(ctx context.Context, key *CloudletKey)
	DeletedKeyCbs []func(ctx context.Context, key *CloudletKey)
}

func NewCloudletInfoCache() *CloudletInfoCache {
	cache := CloudletInfoCache{}
	InitCloudletInfoCache(&cache)
	return &cache
}

func InitCloudletInfoCache(cache *CloudletInfoCache) {
	cache.Objs = make(map[CloudletKey]*CloudletInfoCacheData)
	cache.KeyWatchers = make(map[CloudletKey][]*CloudletInfoKeyWatcher)
	cache.NotifyCbs = nil
	cache.UpdatedCbs = nil
	cache.DeletedCbs = nil
	cache.UpdatedKeyCbs = nil
	cache.DeletedKeyCbs = nil
}

func (c *CloudletInfoCache) GetTypeString() string {
	return "CloudletInfo"
}

func (c *CloudletInfoCache) Get(key *CloudletKey, valbuf *CloudletInfo) bool {
	var modRev int64
	return c.GetWithRev(key, valbuf, &modRev)
}

func (c *CloudletInfoCache) GetWithRev(key *CloudletKey, valbuf *CloudletInfo, modRev *int64) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	inst, found := c.Objs[*key]
	if found {
		valbuf.DeepCopyIn(inst.Obj)
		*modRev = inst.ModRev
	}
	return found
}

func (c *CloudletInfoCache) HasKey(key *CloudletKey) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	_, found := c.Objs[*key]
	return found
}

func (c *CloudletInfoCache) GetAllKeys(ctx context.Context, cb func(key *CloudletKey, modRev int64)) {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for key, data := range c.Objs {
		cb(&key, data.ModRev)
	}
}

func (c *CloudletInfoCache) GetAllLocked(ctx context.Context, cb func(obj *CloudletInfo, modRev int64)) {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for _, data := range c.Objs {
		cb(data.Obj, data.ModRev)
	}
}

func (c *CloudletInfoCache) Update(ctx context.Context, in *CloudletInfo, modRev int64) {
	c.UpdateModFunc(ctx, in.GetKey(), modRev, func(old *CloudletInfo) (*CloudletInfo, bool) {
		return in, true
	})
}

func (c *CloudletInfoCache) UpdateModFunc(ctx context.Context, key *CloudletKey, modRev int64, modFunc func(old *CloudletInfo) (new *CloudletInfo, changed bool)) {
	c.Mux.Lock()
	var old *CloudletInfo
	if oldData, found := c.Objs[*key]; found {
		old = oldData.Obj
	}
	new, changed := modFunc(old)
	if !changed {
		c.Mux.Unlock()
		return
	}
	if len(c.UpdatedCbs) > 0 || len(c.NotifyCbs) > 0 {
		newCopy := &CloudletInfo{}
		newCopy.DeepCopyIn(new)
		for _, cb := range c.UpdatedCbs {
			defer cb(ctx, old, newCopy)
		}
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				defer cb(ctx, newCopy, modRev)
			}
		}
	}
	for _, cb := range c.UpdatedKeyCbs {
		defer cb(ctx, key)
	}
	store := &CloudletInfo{}
	store.DeepCopyIn(new)
	c.Objs[new.GetKeyVal()] = &CloudletInfoCacheData{
		Obj:    store,
		ModRev: modRev,
	}
	log.SpanLog(ctx, log.DebugLevelApi, "cache update", "new", store)
	c.Mux.Unlock()
	c.TriggerKeyWatchers(ctx, new.GetKey())
}

func (c *CloudletInfoCache) Delete(ctx context.Context, in *CloudletInfo, modRev int64) {
	c.DeleteCondFunc(ctx, in, modRev, func(old *CloudletInfo) bool {
		return true
	})
}

func (c *CloudletInfoCache) DeleteCondFunc(ctx context.Context, in *CloudletInfo, modRev int64, condFunc func(old *CloudletInfo) bool) {
	c.Mux.Lock()
	var old *CloudletInfo
	oldData, found := c.Objs[in.GetKeyVal()]
	if found {
		old = oldData.Obj
		if !condFunc(old) {
			c.Mux.Unlock()
			return
		}
	}
	delete(c.Objs, in.GetKeyVal())
	log.SpanLog(ctx, log.DebugLevelApi, "cache delete", "key", in.GetKeyVal())
	c.Mux.Unlock()
	obj := old
	if obj == nil {
		obj = in
	}
	for _, cb := range c.NotifyCbs {
		if cb != nil {
			cb(ctx, obj, modRev)
		}
	}
	if old != nil {
		for _, cb := range c.DeletedCbs {
			cb(ctx, old)
		}
	}
	for _, cb := range c.DeletedKeyCbs {
		cb(ctx, in.GetKey())
	}
	c.TriggerKeyWatchers(ctx, in.GetKey())
}

func (c *CloudletInfoCache) Prune(ctx context.Context, validKeys map[CloudletKey]struct{}) {
	log.SpanLog(ctx, log.DebugLevelApi, "Prune CloudletInfo", "numValidKeys", len(validKeys))
	notify := make(map[CloudletKey]*CloudletInfoCacheData)
	c.Mux.Lock()
	for key, _ := range c.Objs {
		if _, ok := validKeys[key]; !ok {
			if len(c.NotifyCbs) > 0 || len(c.DeletedKeyCbs) > 0 || len(c.DeletedCbs) > 0 {
				notify[key] = c.Objs[key]
			}
			delete(c.Objs, key)
		}
	}
	c.Mux.Unlock()
	for key, old := range notify {
		obj := old.Obj
		if obj == nil {
			obj = &CloudletInfo{}
			obj.SetKey(&key)
		}
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, obj, old.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if old.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, old.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (c *CloudletInfoCache) GetCount() int {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	return len(c.Objs)
}

func (c *CloudletInfoCache) Flush(ctx context.Context, notifyId int64) {
	log.SpanLog(ctx, log.DebugLevelApi, "CacheFlush CloudletInfo", "notifyId", notifyId, "FlushAll", c.FlushAll)
	flushed := make(map[CloudletKey]*CloudletInfoCacheData)
	c.Mux.Lock()
	for key, val := range c.Objs {
		if !c.FlushAll && val.Obj.NotifyId != notifyId {
			continue
		}
		flushed[key] = c.Objs[key]
		log.SpanLog(ctx, log.DebugLevelApi, "CacheFlush CloudletInfo delete", "key", key)
		delete(c.Objs, key)
	}
	c.Mux.Unlock()
	if len(flushed) > 0 {
		for key, old := range flushed {
			obj := old.Obj
			if obj == nil {
				obj = &CloudletInfo{}
				obj.SetKey(&key)
			}
			for _, cb := range c.NotifyCbs {
				if cb != nil {
					cb(ctx, obj, old.ModRev)
				}
			}
			for _, cb := range c.DeletedKeyCbs {
				cb(ctx, &key)
			}
			if old.Obj != nil {
				for _, cb := range c.DeletedCbs {
					cb(ctx, old.Obj)
				}
			}
			c.TriggerKeyWatchers(ctx, &key)
		}
	}
}

func (c *CloudletInfoCache) Show(filter *CloudletInfo, cb func(ret *CloudletInfo) error) error {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for _, data := range c.Objs {
		if !data.Obj.Matches(filter, MatchFilter()) {
			continue
		}
		err := cb(data.Obj)
		if err != nil {
			return err
		}
	}
	return nil
}

func CloudletInfoGenericNotifyCb(fn func(key *CloudletKey, old *CloudletInfo)) func(objstore.ObjKey, objstore.Obj) {
	return func(objkey objstore.ObjKey, obj objstore.Obj) {
		fn(objkey.(*CloudletKey), obj.(*CloudletInfo))
	}
}

func (c *CloudletInfoCache) SetNotifyCb(fn func(ctx context.Context, obj *CloudletInfo, modRev int64)) {
	c.NotifyCbs = []func(ctx context.Context, obj *CloudletInfo, modRev int64){fn}
}

func (c *CloudletInfoCache) SetUpdatedCb(fn func(ctx context.Context, old *CloudletInfo, new *CloudletInfo)) {
	c.UpdatedCbs = []func(ctx context.Context, old *CloudletInfo, new *CloudletInfo){fn}
}

func (c *CloudletInfoCache) SetDeletedCb(fn func(ctx context.Context, old *CloudletInfo)) {
	c.DeletedCbs = []func(ctx context.Context, old *CloudletInfo){fn}
}

func (c *CloudletInfoCache) SetUpdatedKeyCb(fn func(ctx context.Context, key *CloudletKey)) {
	c.UpdatedKeyCbs = []func(ctx context.Context, key *CloudletKey){fn}
}

func (c *CloudletInfoCache) SetDeletedKeyCb(fn func(ctx context.Context, key *CloudletKey)) {
	c.DeletedKeyCbs = []func(ctx context.Context, key *CloudletKey){fn}
}

func (c *CloudletInfoCache) AddUpdatedCb(fn func(ctx context.Context, old *CloudletInfo, new *CloudletInfo)) {
	c.UpdatedCbs = append(c.UpdatedCbs, fn)
}

func (c *CloudletInfoCache) AddDeletedCb(fn func(ctx context.Context, old *CloudletInfo)) {
	c.DeletedCbs = append(c.DeletedCbs, fn)
}

func (c *CloudletInfoCache) AddNotifyCb(fn func(ctx context.Context, obj *CloudletInfo, modRev int64)) {
	c.NotifyCbs = append(c.NotifyCbs, fn)
}

func (c *CloudletInfoCache) AddUpdatedKeyCb(fn func(ctx context.Context, key *CloudletKey)) {
	c.UpdatedKeyCbs = append(c.UpdatedKeyCbs, fn)
}

func (c *CloudletInfoCache) AddDeletedKeyCb(fn func(ctx context.Context, key *CloudletKey)) {
	c.DeletedKeyCbs = append(c.DeletedKeyCbs, fn)
}

func (c *CloudletInfoCache) SetFlushAll() {
	c.FlushAll = true
}

func (c *CloudletInfoCache) WatchKey(key *CloudletKey, cb func(ctx context.Context)) context.CancelFunc {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	list, ok := c.KeyWatchers[*key]
	if !ok {
		list = make([]*CloudletInfoKeyWatcher, 0)
	}
	watcher := CloudletInfoKeyWatcher{cb: cb}
	c.KeyWatchers[*key] = append(list, &watcher)
	log.DebugLog(log.DebugLevelApi, "Watching CloudletInfo", "key", key)
	return func() {
		c.Mux.Lock()
		defer c.Mux.Unlock()
		list, ok := c.KeyWatchers[*key]
		if !ok {
			return
		}
		for ii, _ := range list {
			if list[ii] != &watcher {
				continue
			}
			if len(list) == 1 {
				delete(c.KeyWatchers, *key)
				return
			}
			list[ii] = list[len(list)-1]
			list[len(list)-1] = nil
			c.KeyWatchers[*key] = list[:len(list)-1]
			return
		}
	}
}

func (c *CloudletInfoCache) TriggerKeyWatchers(ctx context.Context, key *CloudletKey) {
	watchers := make([]*CloudletInfoKeyWatcher, 0)
	c.Mux.Lock()
	if list, ok := c.KeyWatchers[*key]; ok {
		watchers = append(watchers, list...)
	}
	c.Mux.Unlock()
	for ii, _ := range watchers {
		watchers[ii].cb(ctx)
	}
}

// Note that we explicitly ignore the global revision number, because of the way
// the notify framework sends updates (by hashing keys and doing lookups, instead
// of sequentially through a history buffer), updates may be done out-of-order
// or multiple updates compressed into one update, so the state of the cache at
// any point in time may not by in sync with a particular database revision number.

func (c *CloudletInfoCache) SyncUpdate(ctx context.Context, key, val []byte, rev, modRev int64) {
	obj := CloudletInfo{}
	err := json.Unmarshal(val, &obj)
	if err != nil {
		log.WarnLog("Failed to parse CloudletInfo data", "val", string(val), "err", err)
		return
	}
	c.Update(ctx, &obj, modRev)
	c.Mux.Lock()
	if c.List != nil {
		c.List[obj.GetKeyVal()] = struct{}{}
	}
	c.Mux.Unlock()
}

func (c *CloudletInfoCache) SyncDelete(ctx context.Context, key []byte, rev, modRev int64) {
	obj := CloudletInfo{}
	keystr := objstore.DbKeyPrefixRemove(string(key))
	CloudletKeyStringParse(keystr, obj.GetKey())
	c.Delete(ctx, &obj, modRev)
}

func (c *CloudletInfoCache) SyncListStart(ctx context.Context) {
	c.List = make(map[CloudletKey]struct{})
}

func (c *CloudletInfoCache) SyncListEnd(ctx context.Context) {
	deleted := make(map[CloudletKey]*CloudletInfoCacheData)
	c.Mux.Lock()
	for key, val := range c.Objs {
		if _, found := c.List[key]; !found {
			deleted[key] = val
			delete(c.Objs, key)
		}
	}
	c.List = nil
	c.Mux.Unlock()
	for key, val := range deleted {
		obj := val.Obj
		if obj == nil {
			obj = &CloudletInfo{}
			obj.SetKey(&key)
		}
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, obj, val.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if val.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, val.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func WaitForCloudletInfo(ctx context.Context, key *CloudletKey, store CloudletInfoStore, targetState distributed_match_engine.CloudletState, transitionStates map[distributed_match_engine.CloudletState]struct{}, errorState distributed_match_engine.CloudletState, successMsg string, send func(*Result) error, opts ...WaitStateOps) error {
	var lastMsgCnt int
	var err error

	handleTargetState := func() {
		if successMsg != "" && send != nil {
			send(&Result{Message: successMsg})
		}
	}

	// State updates come via Redis, since they are bundled with status updates.
	// However, the Redis channel is set up after the Etcd transaction to commit
	// the state change (i.e. CREATE_REQUESTED) in order to treat Etcd as the
	// source of truth for concurrent changes, so there is a small timing window
	// where the state may be updated by the info (from CRM) before the Redis
	// subscription is set up. So here our initial state needs to come from Etcd
	// in case both it and Redis were updated before the crmMsgCh was set up.
	curState := distributed_match_engine.CloudletState_CLOUDLET_STATE_NOT_PRESENT
	buf := CloudletInfo{}
	if store.Get(ctx, key, &buf) {
		curState = buf.State
	}
	if curState == targetState {
		handleTargetState()
		return nil
	}

	var wSpec WaitStateSpec
	for _, op := range opts {
		if err := op(&wSpec); err != nil {
			return err
		}
	}

	if wSpec.CrmMsgCh == nil {
		return nil
	}

	for {
		select {
		case chObj := <-wSpec.CrmMsgCh:
			if chObj == nil {
				// Since msg chan is a receive-only chan, it will return nil if
				// connection to redis server is disrupted. But the object might
				// still be in progress. Hence, just show a message about the failure,
				// so that user can manually look at object's progress
				if send != nil {
					msg := fmt.Sprintf("Failed to get progress messages. Please use ShowCloudlet to check current status")
					send(&Result{Message: msg})
				}
				return nil
			}
			info := CloudletInfo{}
			err = json.Unmarshal([]byte(chObj.Payload), &info)
			if err != nil {
				return err
			}
			curState = info.State
			log.SpanLog(ctx, log.DebugLevelApi, "Received crm update for CloudletInfo", "key", key, "obj", info)
			if send != nil {
				for ii := lastMsgCnt; ii < len(info.Status.Msgs); ii++ {
					send(&Result{Message: info.Status.Msgs[ii]})
				}
				lastMsgCnt = len(info.Status.Msgs)
			}

			switch info.State {
			case errorState:
				errs := strings.Join(info.Errors, ", ")
				err = fmt.Errorf("Encountered failures: %s", errs)
				return err
			case targetState:
				handleTargetState()
				return nil
			}
		case <-ctx.Done():
			if _, found := transitionStates[curState]; found {
				// no success response, but state is a valid transition
				// state. That means work is still in progress.
				// Notify user that this is not an error.
				// Do not undo since CRM is still busy.
				if send != nil {
					msg := fmt.Sprintf("Timed out while work still in progress state %s. Please use ShowCloudlet to check current status", distributed_match_engine.CloudletState_CamelName[int32(curState)])
					send(&Result{Message: msg})
				}
				err = nil
			} else {
				err = fmt.Errorf("Timed out; expected state %s but is %s",
					distributed_match_engine.CloudletState_CamelName[int32(targetState)],
					distributed_match_engine.CloudletState_CamelName[int32(curState)])
			}
			return err
		}
	}
}

func (c *CloudletInfoCache) UsesOrg(org string) bool {
	return false
}

func (m *CloudletInfo) GetObjKey() objstore.ObjKey {
	return m.GetKey()
}

func (m *CloudletInfo) GetKey() *CloudletKey {
	return &m.Key
}

func (m *CloudletInfo) GetKeyVal() CloudletKey {
	return m.Key
}

func (m *CloudletInfo) SetKey(key *CloudletKey) {
	m.Key = *key
}

func CmpSortCloudletInfo(a CloudletInfo, b CloudletInfo) bool {
	return a.Key.GetKeyString() < b.Key.GetKeyString()
}

// Helper method to check that enums have valid values
// NOTE: ValidateEnums checks all Fields even if some are not set
func (m *CloudletInfo) ValidateEnums() error {
	if err := m.Key.ValidateEnums(); err != nil {
		return err
	}
	if _, ok := distributed_match_engine.CloudletState_name[int32(m.State)]; !ok {
		return errors.New("invalid State")
	}
	for _, e := range m.Flavors {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	if err := m.Status.ValidateEnums(); err != nil {
		return err
	}
	for _, e := range m.AvailabilityZones {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	for _, e := range m.OsImages {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	if _, ok := distributed_match_engine.MaintenanceState_name[int32(m.MaintenanceState)]; !ok {
		return errors.New("invalid MaintenanceState")
	}
	if err := m.ResourcesSnapshot.ValidateEnums(); err != nil {
		return err
	}
	if _, ok := TrackedState_name[int32(m.TrustPolicyState)]; !ok {
		return errors.New("invalid TrustPolicyState")
	}
	for _, e := range m.NodeInfos {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (s *CloudletInfo) ClearTagged(tags map[string]struct{}) {
	s.Key.ClearTagged(tags)
	if _, found := tags["nocmp"]; found {
		s.NotifyId = 0
	}
	if _, found := tags["nocmp"]; found {
		s.Controller = ""
	}
	if s.Flavors != nil {
		for ii := 0; ii < len(s.Flavors); ii++ {
			s.Flavors[ii].ClearTagged(tags)
		}
	}
	if _, found := tags["nocmp"]; found {
		s.Status = StatusInfo{}
	}
	if s.AvailabilityZones != nil {
		for ii := 0; ii < len(s.AvailabilityZones); ii++ {
			s.AvailabilityZones[ii].ClearTagged(tags)
		}
	}
	if s.OsImages != nil {
		for ii := 0; ii < len(s.OsImages); ii++ {
			s.OsImages[ii].ClearTagged(tags)
		}
	}
	s.ResourcesSnapshot.ClearTagged(tags)
	if _, found := tags["nocmp"]; found {
		s.CompatibilityVersion = 0
	}
	if s.NodeInfos != nil {
		for ii := 0; ii < len(s.NodeInfos); ii++ {
			s.NodeInfos[ii].ClearTagged(tags)
		}
	}
}

func (s *CloudletInfo) ClearRedisOnlyFields() {
	// Clear fields so that they are not stored in DB, as they are cached in Redis
	s.Status = StatusInfo{}
}

func IgnoreCloudletInfoFields(taglist string) cmp.Option {
	names := []string{}
	tags := make(map[string]struct{})
	for _, tag := range strings.Split(taglist, ",") {
		tags[tag] = struct{}{}
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "NotifyId")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Controller")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Status")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "CompatibilityVersion")
	}
	return cmpopts.IgnoreFields(CloudletInfo{}, names...)
}

func (m *CloudletMetrics) Clone() *CloudletMetrics {
	cp := &CloudletMetrics{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *CloudletMetrics) CopyInFields(src *CloudletMetrics) int {
	changed := 0
	if m.Foo != src.Foo {
		m.Foo = src.Foo
		changed++
	}
	return changed
}

func (m *CloudletMetrics) DeepCopyIn(src *CloudletMetrics) {
	m.Foo = src.Foo
}

// Helper method to check that enums have valid values
func (m *CloudletMetrics) ValidateEnums() error {
	return nil
}

func (s *CloudletMetrics) ClearTagged(tags map[string]struct{}) {
}

var InfraApiAccessStrings = []string{
	"DIRECT_ACCESS",
	"RESTRICTED_ACCESS",
}

const (
	InfraApiAccessDIRECT_ACCESS     uint64 = 1 << 0
	InfraApiAccessRESTRICTED_ACCESS uint64 = 1 << 1
)

var InfraApiAccess_CamelName = map[int32]string{
	// DIRECT_ACCESS -> DirectAccess
	0: "DirectAccess",
	// RESTRICTED_ACCESS -> RestrictedAccess
	1: "RestrictedAccess",
}
var InfraApiAccess_CamelValue = map[string]int32{
	"DirectAccess":     0,
	"RestrictedAccess": 1,
}

func ParseInfraApiAccess(data interface{}) (InfraApiAccess, error) {
	if val, ok := data.(InfraApiAccess); ok {
		return val, nil
	} else if str, ok := data.(string); ok {
		val, ok := InfraApiAccess_CamelValue[util.CamelCase(str)]
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = InfraApiAccess_CamelName[val]
			}
		}
		if !ok {
			return InfraApiAccess(0), fmt.Errorf("Invalid InfraApiAccess value %q", str)
		}
		return InfraApiAccess(val), nil
	} else if ival, ok := data.(int32); ok {
		if _, ok := InfraApiAccess_CamelName[ival]; ok {
			return InfraApiAccess(ival), nil
		} else {
			return InfraApiAccess(0), fmt.Errorf("Invalid InfraApiAccess value %d", ival)
		}
	}
	return InfraApiAccess(0), fmt.Errorf("Invalid InfraApiAccess value %v", data)
}

func (e *InfraApiAccess) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, err := ParseInfraApiAccess(str)
	if err != nil {
		return err
	}
	*e = val
	return nil
}

func (e InfraApiAccess) MarshalYAML() (interface{}, error) {
	str := proto.EnumName(InfraApiAccess_CamelName, int32(e))
	return str, nil
}

// custom JSON encoding/decoding
func (e *InfraApiAccess) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, err := ParseInfraApiAccess(str)
		if err != nil {
			return &json.UnmarshalTypeError{
				Value: "string " + str,
				Type:  reflect.TypeOf(InfraApiAccess(0)),
			}
		}
		*e = InfraApiAccess(val)
		return nil
	}
	var ival int32
	err = json.Unmarshal(b, &ival)
	if err == nil {
		val, err := ParseInfraApiAccess(ival)
		if err == nil {
			*e = val
			return nil
		}
	}
	return &json.UnmarshalTypeError{
		Value: "value " + string(b),
		Type:  reflect.TypeOf(InfraApiAccess(0)),
	}
}

func (e InfraApiAccess) MarshalJSON() ([]byte, error) {
	str := proto.EnumName(InfraApiAccess_CamelName, int32(e))
	return json.Marshal(str)
}

var OSTypeStrings = []string{
	"LINUX",
	"WINDOWS",
	"OTHERS",
}

const (
	OSTypeLINUX   uint64 = 1 << 0
	OSTypeWINDOWS uint64 = 1 << 1
	OSTypeOTHERS  uint64 = 1 << 2
)

var OSType_CamelName = map[int32]string{
	// LINUX -> Linux
	0: "Linux",
	// WINDOWS -> Windows
	1: "Windows",
	// OTHERS -> Others
	20: "Others",
}
var OSType_CamelValue = map[string]int32{
	"Linux":   0,
	"Windows": 1,
	"Others":  20,
}

func ParseOSType(data interface{}) (OSType, error) {
	if val, ok := data.(OSType); ok {
		return val, nil
	} else if str, ok := data.(string); ok {
		val, ok := OSType_CamelValue[util.CamelCase(str)]
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = OSType_CamelName[val]
			}
		}
		if !ok {
			return OSType(0), fmt.Errorf("Invalid OSType value %q", str)
		}
		return OSType(val), nil
	} else if ival, ok := data.(int32); ok {
		if _, ok := OSType_CamelName[ival]; ok {
			return OSType(ival), nil
		} else {
			return OSType(0), fmt.Errorf("Invalid OSType value %d", ival)
		}
	}
	return OSType(0), fmt.Errorf("Invalid OSType value %v", data)
}

func (e *OSType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, err := ParseOSType(str)
	if err != nil {
		return err
	}
	*e = val
	return nil
}

func (e OSType) MarshalYAML() (interface{}, error) {
	str := proto.EnumName(OSType_CamelName, int32(e))
	return str, nil
}

// custom JSON encoding/decoding
func (e *OSType) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, err := ParseOSType(str)
		if err != nil {
			return &json.UnmarshalTypeError{
				Value: "string " + str,
				Type:  reflect.TypeOf(OSType(0)),
			}
		}
		*e = OSType(val)
		return nil
	}
	var ival int32
	err = json.Unmarshal(b, &ival)
	if err == nil {
		val, err := ParseOSType(ival)
		if err == nil {
			*e = val
			return nil
		}
	}
	return &json.UnmarshalTypeError{
		Value: "value " + string(b),
		Type:  reflect.TypeOf(OSType(0)),
	}
}

func (e OSType) MarshalJSON() ([]byte, error) {
	str := proto.EnumName(OSType_CamelName, int32(e))
	return json.Marshal(str)
}

var ReportScheduleStrings = []string{
	"EveryWeek",
	"Every15Days",
	"EveryMonth",
}

const (
	ReportScheduleEveryWeek   uint64 = 1 << 0
	ReportScheduleEvery15Days uint64 = 1 << 1
	ReportScheduleEveryMonth  uint64 = 1 << 2
)

var ReportSchedule_CamelName = map[int32]string{
	// EveryWeek -> EveryWeek
	0: "EveryWeek",
	// Every15Days -> Every15Days
	1: "Every15Days",
	// EveryMonth -> EveryMonth
	3: "EveryMonth",
}
var ReportSchedule_CamelValue = map[string]int32{
	"EveryWeek":   0,
	"Every15Days": 1,
	"EveryMonth":  3,
}

func ParseReportSchedule(data interface{}) (ReportSchedule, error) {
	if val, ok := data.(ReportSchedule); ok {
		return val, nil
	} else if str, ok := data.(string); ok {
		val, ok := ReportSchedule_CamelValue[util.CamelCase(str)]
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = ReportSchedule_CamelName[val]
			}
		}
		if !ok {
			return ReportSchedule(0), fmt.Errorf("Invalid ReportSchedule value %q", str)
		}
		return ReportSchedule(val), nil
	} else if ival, ok := data.(int32); ok {
		if _, ok := ReportSchedule_CamelName[ival]; ok {
			return ReportSchedule(ival), nil
		} else {
			return ReportSchedule(0), fmt.Errorf("Invalid ReportSchedule value %d", ival)
		}
	}
	return ReportSchedule(0), fmt.Errorf("Invalid ReportSchedule value %v", data)
}

func (e *ReportSchedule) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, err := ParseReportSchedule(str)
	if err != nil {
		return err
	}
	*e = val
	return nil
}

func (e ReportSchedule) MarshalYAML() (interface{}, error) {
	str := proto.EnumName(ReportSchedule_CamelName, int32(e))
	return str, nil
}

// custom JSON encoding/decoding
func (e *ReportSchedule) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, err := ParseReportSchedule(str)
		if err != nil {
			return &json.UnmarshalTypeError{
				Value: "string " + str,
				Type:  reflect.TypeOf(ReportSchedule(0)),
			}
		}
		*e = ReportSchedule(val)
		return nil
	}
	var ival int32
	err = json.Unmarshal(b, &ival)
	if err == nil {
		val, err := ParseReportSchedule(ival)
		if err == nil {
			*e = val
			return nil
		}
	}
	return &json.UnmarshalTypeError{
		Value: "value " + string(b),
		Type:  reflect.TypeOf(ReportSchedule(0)),
	}
}

func (e ReportSchedule) MarshalJSON() ([]byte, error) {
	str := proto.EnumName(ReportSchedule_CamelName, int32(e))
	return json.Marshal(str)
}
func (m *PlatformFeatures) IsValidArgsForDeletePlatformFeatures() error {
	return nil
}

func (m *GPUDriver) IsValidArgsForCreateGPUDriver() error {
	if m.LicenseConfigMd5Sum != "" {
		return fmt.Errorf("Invalid field specified: LicenseConfigMd5Sum, this field is only for internal use")
	}
	if m.State != "" {
		return fmt.Errorf("Invalid field specified: State, this field is only for internal use")
	}
	if m.DeletePrepare != false {
		return fmt.Errorf("Invalid field specified: DeletePrepare, this field is only for internal use")
	}
	if m.StorageBucketName != "" {
		return fmt.Errorf("Invalid field specified: StorageBucketName, this field is only for internal use")
	}
	if m.LicenseConfigStoragePath != "" {
		return fmt.Errorf("Invalid field specified: LicenseConfigStoragePath, this field is only for internal use")
	}
	return nil
}

func (m *GPUDriver) IsValidArgsForDeleteGPUDriver() error {
	if m.LicenseConfigMd5Sum != "" {
		return fmt.Errorf("Invalid field specified: LicenseConfigMd5Sum, this field is only for internal use")
	}
	if m.State != "" {
		return fmt.Errorf("Invalid field specified: State, this field is only for internal use")
	}
	if m.DeletePrepare != false {
		return fmt.Errorf("Invalid field specified: DeletePrepare, this field is only for internal use")
	}
	if m.StorageBucketName != "" {
		return fmt.Errorf("Invalid field specified: StorageBucketName, this field is only for internal use")
	}
	if m.LicenseConfigStoragePath != "" {
		return fmt.Errorf("Invalid field specified: LicenseConfigStoragePath, this field is only for internal use")
	}
	return nil
}

func (m *GPUDriver) IsValidArgsForUpdateGPUDriver() error {
	if m.Builds != nil {
		return fmt.Errorf("Invalid field specified: Builds, this field is only for internal use")
	}
	if m.LicenseConfigMd5Sum != "" {
		return fmt.Errorf("Invalid field specified: LicenseConfigMd5Sum, this field is only for internal use")
	}
	if m.State != "" {
		return fmt.Errorf("Invalid field specified: State, this field is only for internal use")
	}
	if m.IgnoreState != false {
		return fmt.Errorf("Invalid field specified: IgnoreState, this field is only for internal use")
	}
	if m.DeletePrepare != false {
		return fmt.Errorf("Invalid field specified: DeletePrepare, this field is only for internal use")
	}
	if m.StorageBucketName != "" {
		return fmt.Errorf("Invalid field specified: StorageBucketName, this field is only for internal use")
	}
	if m.LicenseConfigStoragePath != "" {
		return fmt.Errorf("Invalid field specified: LicenseConfigStoragePath, this field is only for internal use")
	}
	return nil
}

func (m *GPUDriverBuildMember) IsValidArgsForAddGPUDriverBuild() error {
	return nil
}

func (m *GPUDriverBuildMember) IsValidArgsForRemoveGPUDriverBuild() error {
	if m.Build.DriverPath != "" {
		return fmt.Errorf("Invalid field specified: Build.DriverPath, this field is only for internal use")
	}
	if m.Build.OperatingSystem != 0 {
		return fmt.Errorf("Invalid field specified: Build.OperatingSystem, this field is only for internal use")
	}
	if m.Build.KernelVersion != "" {
		return fmt.Errorf("Invalid field specified: Build.KernelVersion, this field is only for internal use")
	}
	if m.Build.HypervisorInfo != "" {
		return fmt.Errorf("Invalid field specified: Build.HypervisorInfo, this field is only for internal use")
	}
	return nil
}

func (m *GPUDriverBuildMember) IsValidArgsForGetGPUDriverBuildURL() error {
	if m.Build.DriverPath != "" {
		return fmt.Errorf("Invalid field specified: Build.DriverPath, this field is only for internal use")
	}
	if m.Build.DriverPathCreds != "" {
		return fmt.Errorf("Invalid field specified: Build.DriverPathCreds, this field is only for internal use")
	}
	if m.Build.OperatingSystem != 0 {
		return fmt.Errorf("Invalid field specified: Build.OperatingSystem, this field is only for internal use")
	}
	if m.Build.KernelVersion != "" {
		return fmt.Errorf("Invalid field specified: Build.KernelVersion, this field is only for internal use")
	}
	if m.Build.HypervisorInfo != "" {
		return fmt.Errorf("Invalid field specified: Build.HypervisorInfo, this field is only for internal use")
	}
	if m.Build.Md5Sum != "" {
		return fmt.Errorf("Invalid field specified: Build.Md5Sum, this field is only for internal use")
	}
	return nil
}

func (m *GPUDriverKey) IsValidArgsForGetGPUDriverLicenseConfig() error {
	return nil
}

func (m *Cloudlet) IsValidArgsForCreateCloudlet() error {
	if m.Errors != nil {
		return fmt.Errorf("Invalid field specified: Errors, this field is only for internal use")
	}
	if m.State != 0 {
		return fmt.Errorf("Invalid field specified: State, this field is only for internal use")
	}
	if m.Config.ContainerRegistryPath != "" {
		return fmt.Errorf("Invalid field specified: Config.ContainerRegistryPath, this field is only for internal use")
	}
	if m.Config.CloudletVmImagePath != "" {
		return fmt.Errorf("Invalid field specified: Config.CloudletVmImagePath, this field is only for internal use")
	}
	if m.Config.NotifyCtrlAddrs != "" {
		return fmt.Errorf("Invalid field specified: Config.NotifyCtrlAddrs, this field is only for internal use")
	}
	if m.Config.TlsCertFile != "" {
		return fmt.Errorf("Invalid field specified: Config.TlsCertFile, this field is only for internal use")
	}
	if m.Config.EnvVar != nil {
		return fmt.Errorf("Invalid field specified: Config.EnvVar, this field is only for internal use")
	}
	if m.Config.PlatformTag != "" {
		return fmt.Errorf("Invalid field specified: Config.PlatformTag, this field is only for internal use")
	}
	if m.Config.TestMode != false {
		return fmt.Errorf("Invalid field specified: Config.TestMode, this field is only for internal use")
	}
	if m.Config.Span != "" {
		return fmt.Errorf("Invalid field specified: Config.Span, this field is only for internal use")
	}
	if m.Config.CleanupMode != false {
		return fmt.Errorf("Invalid field specified: Config.CleanupMode, this field is only for internal use")
	}
	if m.Config.Region != "" {
		return fmt.Errorf("Invalid field specified: Config.Region, this field is only for internal use")
	}
	if m.Config.CommercialCerts != false {
		return fmt.Errorf("Invalid field specified: Config.CommercialCerts, this field is only for internal use")
	}
	if m.Config.UseVaultPki != false {
		return fmt.Errorf("Invalid field specified: Config.UseVaultPki, this field is only for internal use")
	}
	if m.Config.AppDnsRoot != "" {
		return fmt.Errorf("Invalid field specified: Config.AppDnsRoot, this field is only for internal use")
	}
	if m.Config.DeploymentTag != "" {
		return fmt.Errorf("Invalid field specified: Config.DeploymentTag, this field is only for internal use")
	}
	if m.Config.TlsKeyFile != "" {
		return fmt.Errorf("Invalid field specified: Config.TlsKeyFile, this field is only for internal use")
	}
	if m.Config.TlsCaFile != "" {
		return fmt.Errorf("Invalid field specified: Config.TlsCaFile, this field is only for internal use")
	}
	if m.Config.CrmAccessPrivateKey != "" {
		return fmt.Errorf("Invalid field specified: Config.CrmAccessPrivateKey, this field is only for internal use")
	}
	if m.Config.AccessApiAddr != "" {
		return fmt.Errorf("Invalid field specified: Config.AccessApiAddr, this field is only for internal use")
	}
	if m.Config.CacheDir != "" {
		return fmt.Errorf("Invalid field specified: Config.CacheDir, this field is only for internal use")
	}
	if m.Config.SecondaryCrmAccessPrivateKey != "" {
		return fmt.Errorf("Invalid field specified: Config.SecondaryCrmAccessPrivateKey, this field is only for internal use")
	}
	if m.Config.ThanosRecvAddr != "" {
		return fmt.Errorf("Invalid field specified: Config.ThanosRecvAddr, this field is only for internal use")
	}
	if m.Config.AnsiblePublicAddr != "" {
		return fmt.Errorf("Invalid field specified: Config.AnsiblePublicAddr, this field is only for internal use")
	}
	if m.Config.EnvoyWithCurlImage != "" {
		return fmt.Errorf("Invalid field specified: Config.EnvoyWithCurlImage, this field is only for internal use")
	}
	if m.Config.NginxWithCurlImage != "" {
		return fmt.Errorf("Invalid field specified: Config.NginxWithCurlImage, this field is only for internal use")
	}
	if m.ResTagMap != nil {
		return fmt.Errorf("Invalid field specified: ResTagMap, this field is only for internal use")
	}
	if m.CrmAccessPublicKey != "" {
		return fmt.Errorf("Invalid field specified: CrmAccessPublicKey, this field is only for internal use")
	}
	if m.CrmAccessKeyUpgradeRequired != false {
		return fmt.Errorf("Invalid field specified: CrmAccessKeyUpgradeRequired, this field is only for internal use")
	}
	if m.CreatedAt.Seconds != 0 {
		return fmt.Errorf("Invalid field specified: CreatedAt.Seconds, this field is only for internal use")
	}
	if m.CreatedAt.Nanos != 0 {
		return fmt.Errorf("Invalid field specified: CreatedAt.Nanos, this field is only for internal use")
	}
	if m.UpdatedAt.Seconds != 0 {
		return fmt.Errorf("Invalid field specified: UpdatedAt.Seconds, this field is only for internal use")
	}
	if m.UpdatedAt.Nanos != 0 {
		return fmt.Errorf("Invalid field specified: UpdatedAt.Nanos, this field is only for internal use")
	}
	if m.TrustPolicyState != 0 {
		return fmt.Errorf("Invalid field specified: TrustPolicyState, this field is only for internal use")
	}
	if m.HostController != "" {
		return fmt.Errorf("Invalid field specified: HostController, this field is only for internal use")
	}
	if m.DeletePrepare != false {
		return fmt.Errorf("Invalid field specified: DeletePrepare, this field is only for internal use")
	}
	if m.SecondaryCrmAccessPublicKey != "" {
		return fmt.Errorf("Invalid field specified: SecondaryCrmAccessPublicKey, this field is only for internal use")
	}
	if m.SecondaryCrmAccessKeyUpgradeRequired != false {
		return fmt.Errorf("Invalid field specified: SecondaryCrmAccessKeyUpgradeRequired, this field is only for internal use")
	}
	if m.DnsLabel != "" {
		return fmt.Errorf("Invalid field specified: DnsLabel, this field is only for internal use")
	}
	if m.RootLbFqdn != "" {
		return fmt.Errorf("Invalid field specified: RootLbFqdn, this field is only for internal use")
	}
	if m.FederationConfig.FederationContextId != "" {
		return fmt.Errorf("Invalid field specified: FederationConfig.FederationContextId, this field is only for internal use")
	}
	if m.FederationConfig.PartnerFederationAddr != "" {
		return fmt.Errorf("Invalid field specified: FederationConfig.PartnerFederationAddr, this field is only for internal use")
	}
	if m.FederationConfig.FederationDbId != 0 {
		return fmt.Errorf("Invalid field specified: FederationConfig.FederationDbId, this field is only for internal use")
	}
	if m.FederationConfig.FederationName != "" {
		return fmt.Errorf("Invalid field specified: FederationConfig.FederationName, this field is only for internal use")
	}
	if m.LicenseConfigStoragePath != "" {
		return fmt.Errorf("Invalid field specified: LicenseConfigStoragePath, this field is only for internal use")
	}
	return nil
}

func (m *Cloudlet) IsValidArgsForDeleteCloudlet() error {
	if m.Errors != nil {
		return fmt.Errorf("Invalid field specified: Errors, this field is only for internal use")
	}
	if m.State != 0 {
		return fmt.Errorf("Invalid field specified: State, this field is only for internal use")
	}
	if m.Config.ContainerRegistryPath != "" {
		return fmt.Errorf("Invalid field specified: Config.ContainerRegistryPath, this field is only for internal use")
	}
	if m.Config.CloudletVmImagePath != "" {
		return fmt.Errorf("Invalid field specified: Config.CloudletVmImagePath, this field is only for internal use")
	}
	if m.Config.NotifyCtrlAddrs != "" {
		return fmt.Errorf("Invalid field specified: Config.NotifyCtrlAddrs, this field is only for internal use")
	}
	if m.Config.TlsCertFile != "" {
		return fmt.Errorf("Invalid field specified: Config.TlsCertFile, this field is only for internal use")
	}
	if m.Config.EnvVar != nil {
		return fmt.Errorf("Invalid field specified: Config.EnvVar, this field is only for internal use")
	}
	if m.Config.PlatformTag != "" {
		return fmt.Errorf("Invalid field specified: Config.PlatformTag, this field is only for internal use")
	}
	if m.Config.TestMode != false {
		return fmt.Errorf("Invalid field specified: Config.TestMode, this field is only for internal use")
	}
	if m.Config.Span != "" {
		return fmt.Errorf("Invalid field specified: Config.Span, this field is only for internal use")
	}
	if m.Config.CleanupMode != false {
		return fmt.Errorf("Invalid field specified: Config.CleanupMode, this field is only for internal use")
	}
	if m.Config.Region != "" {
		return fmt.Errorf("Invalid field specified: Config.Region, this field is only for internal use")
	}
	if m.Config.CommercialCerts != false {
		return fmt.Errorf("Invalid field specified: Config.CommercialCerts, this field is only for internal use")
	}
	if m.Config.UseVaultPki != false {
		return fmt.Errorf("Invalid field specified: Config.UseVaultPki, this field is only for internal use")
	}
	if m.Config.AppDnsRoot != "" {
		return fmt.Errorf("Invalid field specified: Config.AppDnsRoot, this field is only for internal use")
	}
	if m.Config.DeploymentTag != "" {
		return fmt.Errorf("Invalid field specified: Config.DeploymentTag, this field is only for internal use")
	}
	if m.Config.TlsKeyFile != "" {
		return fmt.Errorf("Invalid field specified: Config.TlsKeyFile, this field is only for internal use")
	}
	if m.Config.TlsCaFile != "" {
		return fmt.Errorf("Invalid field specified: Config.TlsCaFile, this field is only for internal use")
	}
	if m.Config.CrmAccessPrivateKey != "" {
		return fmt.Errorf("Invalid field specified: Config.CrmAccessPrivateKey, this field is only for internal use")
	}
	if m.Config.AccessApiAddr != "" {
		return fmt.Errorf("Invalid field specified: Config.AccessApiAddr, this field is only for internal use")
	}
	if m.Config.CacheDir != "" {
		return fmt.Errorf("Invalid field specified: Config.CacheDir, this field is only for internal use")
	}
	if m.Config.SecondaryCrmAccessPrivateKey != "" {
		return fmt.Errorf("Invalid field specified: Config.SecondaryCrmAccessPrivateKey, this field is only for internal use")
	}
	if m.Config.ThanosRecvAddr != "" {
		return fmt.Errorf("Invalid field specified: Config.ThanosRecvAddr, this field is only for internal use")
	}
	if m.Config.AnsiblePublicAddr != "" {
		return fmt.Errorf("Invalid field specified: Config.AnsiblePublicAddr, this field is only for internal use")
	}
	if m.Config.EnvoyWithCurlImage != "" {
		return fmt.Errorf("Invalid field specified: Config.EnvoyWithCurlImage, this field is only for internal use")
	}
	if m.Config.NginxWithCurlImage != "" {
		return fmt.Errorf("Invalid field specified: Config.NginxWithCurlImage, this field is only for internal use")
	}
	if m.ResTagMap != nil {
		return fmt.Errorf("Invalid field specified: ResTagMap, this field is only for internal use")
	}
	if m.CrmAccessPublicKey != "" {
		return fmt.Errorf("Invalid field specified: CrmAccessPublicKey, this field is only for internal use")
	}
	if m.CrmAccessKeyUpgradeRequired != false {
		return fmt.Errorf("Invalid field specified: CrmAccessKeyUpgradeRequired, this field is only for internal use")
	}
	if m.CreatedAt.Seconds != 0 {
		return fmt.Errorf("Invalid field specified: CreatedAt.Seconds, this field is only for internal use")
	}
	if m.CreatedAt.Nanos != 0 {
		return fmt.Errorf("Invalid field specified: CreatedAt.Nanos, this field is only for internal use")
	}
	if m.UpdatedAt.Seconds != 0 {
		return fmt.Errorf("Invalid field specified: UpdatedAt.Seconds, this field is only for internal use")
	}
	if m.UpdatedAt.Nanos != 0 {
		return fmt.Errorf("Invalid field specified: UpdatedAt.Nanos, this field is only for internal use")
	}
	if m.TrustPolicyState != 0 {
		return fmt.Errorf("Invalid field specified: TrustPolicyState, this field is only for internal use")
	}
	if m.HostController != "" {
		return fmt.Errorf("Invalid field specified: HostController, this field is only for internal use")
	}
	if m.DeletePrepare != false {
		return fmt.Errorf("Invalid field specified: DeletePrepare, this field is only for internal use")
	}
	if m.SecondaryCrmAccessPublicKey != "" {
		return fmt.Errorf("Invalid field specified: SecondaryCrmAccessPublicKey, this field is only for internal use")
	}
	if m.SecondaryCrmAccessKeyUpgradeRequired != false {
		return fmt.Errorf("Invalid field specified: SecondaryCrmAccessKeyUpgradeRequired, this field is only for internal use")
	}
	if m.DnsLabel != "" {
		return fmt.Errorf("Invalid field specified: DnsLabel, this field is only for internal use")
	}
	if m.RootLbFqdn != "" {
		return fmt.Errorf("Invalid field specified: RootLbFqdn, this field is only for internal use")
	}
	if m.FederationConfig.FederationContextId != "" {
		return fmt.Errorf("Invalid field specified: FederationConfig.FederationContextId, this field is only for internal use")
	}
	if m.FederationConfig.PartnerFederationAddr != "" {
		return fmt.Errorf("Invalid field specified: FederationConfig.PartnerFederationAddr, this field is only for internal use")
	}
	if m.FederationConfig.FederationDbId != 0 {
		return fmt.Errorf("Invalid field specified: FederationConfig.FederationDbId, this field is only for internal use")
	}
	if m.FederationConfig.FederationName != "" {
		return fmt.Errorf("Invalid field specified: FederationConfig.FederationName, this field is only for internal use")
	}
	if m.LicenseConfigStoragePath != "" {
		return fmt.Errorf("Invalid field specified: LicenseConfigStoragePath, this field is only for internal use")
	}
	return nil
}

func (m *Cloudlet) IsValidArgsForUpdateCloudlet() error {
	if m.Errors != nil {
		return fmt.Errorf("Invalid field specified: Errors, this field is only for internal use")
	}
	if m.State != 0 {
		return fmt.Errorf("Invalid field specified: State, this field is only for internal use")
	}
	if m.DeploymentLocal != false {
		return fmt.Errorf("Invalid field specified: DeploymentLocal, this field is only for internal use")
	}
	if m.PlatformType != "" {
		return fmt.Errorf("Invalid field specified: PlatformType, this field is only for internal use")
	}
	if m.Flavor.Name != "" {
		return fmt.Errorf("Invalid field specified: Flavor.Name, this field is only for internal use")
	}
	if m.PhysicalName != "" {
		return fmt.Errorf("Invalid field specified: PhysicalName, this field is only for internal use")
	}
	if m.ContainerVersion != "" {
		return fmt.Errorf("Invalid field specified: ContainerVersion, this field is only for internal use")
	}
	if m.Config.ContainerRegistryPath != "" {
		return fmt.Errorf("Invalid field specified: Config.ContainerRegistryPath, this field is only for internal use")
	}
	if m.Config.CloudletVmImagePath != "" {
		return fmt.Errorf("Invalid field specified: Config.CloudletVmImagePath, this field is only for internal use")
	}
	if m.Config.NotifyCtrlAddrs != "" {
		return fmt.Errorf("Invalid field specified: Config.NotifyCtrlAddrs, this field is only for internal use")
	}
	if m.Config.TlsCertFile != "" {
		return fmt.Errorf("Invalid field specified: Config.TlsCertFile, this field is only for internal use")
	}
	if m.Config.EnvVar != nil {
		return fmt.Errorf("Invalid field specified: Config.EnvVar, this field is only for internal use")
	}
	if m.Config.PlatformTag != "" {
		return fmt.Errorf("Invalid field specified: Config.PlatformTag, this field is only for internal use")
	}
	if m.Config.TestMode != false {
		return fmt.Errorf("Invalid field specified: Config.TestMode, this field is only for internal use")
	}
	if m.Config.Span != "" {
		return fmt.Errorf("Invalid field specified: Config.Span, this field is only for internal use")
	}
	if m.Config.CleanupMode != false {
		return fmt.Errorf("Invalid field specified: Config.CleanupMode, this field is only for internal use")
	}
	if m.Config.Region != "" {
		return fmt.Errorf("Invalid field specified: Config.Region, this field is only for internal use")
	}
	if m.Config.CommercialCerts != false {
		return fmt.Errorf("Invalid field specified: Config.CommercialCerts, this field is only for internal use")
	}
	if m.Config.UseVaultPki != false {
		return fmt.Errorf("Invalid field specified: Config.UseVaultPki, this field is only for internal use")
	}
	if m.Config.AppDnsRoot != "" {
		return fmt.Errorf("Invalid field specified: Config.AppDnsRoot, this field is only for internal use")
	}
	if m.Config.DeploymentTag != "" {
		return fmt.Errorf("Invalid field specified: Config.DeploymentTag, this field is only for internal use")
	}
	if m.Config.TlsKeyFile != "" {
		return fmt.Errorf("Invalid field specified: Config.TlsKeyFile, this field is only for internal use")
	}
	if m.Config.TlsCaFile != "" {
		return fmt.Errorf("Invalid field specified: Config.TlsCaFile, this field is only for internal use")
	}
	if m.Config.CrmAccessPrivateKey != "" {
		return fmt.Errorf("Invalid field specified: Config.CrmAccessPrivateKey, this field is only for internal use")
	}
	if m.Config.AccessApiAddr != "" {
		return fmt.Errorf("Invalid field specified: Config.AccessApiAddr, this field is only for internal use")
	}
	if m.Config.CacheDir != "" {
		return fmt.Errorf("Invalid field specified: Config.CacheDir, this field is only for internal use")
	}
	if m.Config.SecondaryCrmAccessPrivateKey != "" {
		return fmt.Errorf("Invalid field specified: Config.SecondaryCrmAccessPrivateKey, this field is only for internal use")
	}
	if m.Config.ThanosRecvAddr != "" {
		return fmt.Errorf("Invalid field specified: Config.ThanosRecvAddr, this field is only for internal use")
	}
	if m.Config.AnsiblePublicAddr != "" {
		return fmt.Errorf("Invalid field specified: Config.AnsiblePublicAddr, this field is only for internal use")
	}
	if m.Config.EnvoyWithCurlImage != "" {
		return fmt.Errorf("Invalid field specified: Config.EnvoyWithCurlImage, this field is only for internal use")
	}
	if m.Config.NginxWithCurlImage != "" {
		return fmt.Errorf("Invalid field specified: Config.NginxWithCurlImage, this field is only for internal use")
	}
	if m.ResTagMap != nil {
		return fmt.Errorf("Invalid field specified: ResTagMap, this field is only for internal use")
	}
	if m.VmImageVersion != "" {
		return fmt.Errorf("Invalid field specified: VmImageVersion, this field is only for internal use")
	}
	if m.Deployment != "" {
		return fmt.Errorf("Invalid field specified: Deployment, this field is only for internal use")
	}
	if m.InfraApiAccess != 0 {
		return fmt.Errorf("Invalid field specified: InfraApiAccess, this field is only for internal use")
	}
	if m.InfraConfig.ExternalNetworkName != "" {
		return fmt.Errorf("Invalid field specified: InfraConfig.ExternalNetworkName, this field is only for internal use")
	}
	if m.InfraConfig.FlavorName != "" {
		return fmt.Errorf("Invalid field specified: InfraConfig.FlavorName, this field is only for internal use")
	}
	if m.OverridePolicyContainerVersion != false {
		return fmt.Errorf("Invalid field specified: OverridePolicyContainerVersion, this field is only for internal use")
	}
	if m.VmPool != "" {
		return fmt.Errorf("Invalid field specified: VmPool, this field is only for internal use")
	}
	if m.CrmAccessPublicKey != "" {
		return fmt.Errorf("Invalid field specified: CrmAccessPublicKey, this field is only for internal use")
	}
	if m.CrmAccessKeyUpgradeRequired != false {
		return fmt.Errorf("Invalid field specified: CrmAccessKeyUpgradeRequired, this field is only for internal use")
	}
	if m.CreatedAt.Seconds != 0 {
		return fmt.Errorf("Invalid field specified: CreatedAt.Seconds, this field is only for internal use")
	}
	if m.CreatedAt.Nanos != 0 {
		return fmt.Errorf("Invalid field specified: CreatedAt.Nanos, this field is only for internal use")
	}
	if m.UpdatedAt.Seconds != 0 {
		return fmt.Errorf("Invalid field specified: UpdatedAt.Seconds, this field is only for internal use")
	}
	if m.UpdatedAt.Nanos != 0 {
		return fmt.Errorf("Invalid field specified: UpdatedAt.Nanos, this field is only for internal use")
	}
	if m.TrustPolicyState != 0 {
		return fmt.Errorf("Invalid field specified: TrustPolicyState, this field is only for internal use")
	}
	if m.HostController != "" {
		return fmt.Errorf("Invalid field specified: HostController, this field is only for internal use")
	}
	if m.DeletePrepare != false {
		return fmt.Errorf("Invalid field specified: DeletePrepare, this field is only for internal use")
	}
	if m.SecondaryCrmAccessPublicKey != "" {
		return fmt.Errorf("Invalid field specified: SecondaryCrmAccessPublicKey, this field is only for internal use")
	}
	if m.SecondaryCrmAccessKeyUpgradeRequired != false {
		return fmt.Errorf("Invalid field specified: SecondaryCrmAccessKeyUpgradeRequired, this field is only for internal use")
	}
	if m.DnsLabel != "" {
		return fmt.Errorf("Invalid field specified: DnsLabel, this field is only for internal use")
	}
	if m.RootLbFqdn != "" {
		return fmt.Errorf("Invalid field specified: RootLbFqdn, this field is only for internal use")
	}
	if m.FederationConfig.FederationContextId != "" {
		return fmt.Errorf("Invalid field specified: FederationConfig.FederationContextId, this field is only for internal use")
	}
	if m.FederationConfig.PartnerFederationAddr != "" {
		return fmt.Errorf("Invalid field specified: FederationConfig.PartnerFederationAddr, this field is only for internal use")
	}
	if m.FederationConfig.FederationDbId != 0 {
		return fmt.Errorf("Invalid field specified: FederationConfig.FederationDbId, this field is only for internal use")
	}
	if m.FederationConfig.FederationName != "" {
		return fmt.Errorf("Invalid field specified: FederationConfig.FederationName, this field is only for internal use")
	}
	if m.LicenseConfigStoragePath != "" {
		return fmt.Errorf("Invalid field specified: LicenseConfigStoragePath, this field is only for internal use")
	}
	if m.EdgeboxOnly != false {
		return fmt.Errorf("Invalid field specified: EdgeboxOnly, this field is only for internal use")
	}
	return nil
}

func (m *CloudletKey) IsValidArgsForGetCloudletManifest() error {
	return nil
}

func (m *CloudletProps) IsValidArgsForGetCloudletProps() error {
	if m.Properties != nil {
		return fmt.Errorf("Invalid field specified: Properties, this field is only for internal use")
	}
	return nil
}

func (m *CloudletResourceQuotaProps) IsValidArgsForGetCloudletResourceQuotaProps() error {
	if m.Properties != nil {
		return fmt.Errorf("Invalid field specified: Properties, this field is only for internal use")
	}
	return nil
}

func (m *CloudletResourceUsage) IsValidArgsForGetCloudletResourceUsage() error {
	if m.Info != nil {
		return fmt.Errorf("Invalid field specified: Info, this field is only for internal use")
	}
	return nil
}

func (m *CloudletResMap) IsValidArgsForAddCloudletResMapping() error {
	return nil
}

func (m *CloudletResMap) IsValidArgsForRemoveCloudletResMapping() error {
	return nil
}

func (m *CloudletAllianceOrg) IsValidArgsForAddCloudletAllianceOrg() error {
	return nil
}

func (m *CloudletAllianceOrg) IsValidArgsForRemoveCloudletAllianceOrg() error {
	return nil
}

func (m *FlavorMatch) IsValidArgsForFindFlavorMatch() error {
	return nil
}

func (m *CloudletKey) IsValidArgsForShowFlavorsForCloudlet() error {
	return nil
}

func (m *CloudletKey) IsValidArgsForGetOrganizationsOnCloudlet() error {
	return nil
}

func (m *CloudletKey) IsValidArgsForRevokeAccessKey() error {
	return nil
}

func (m *CloudletKey) IsValidArgsForGenerateAccessKey() error {
	return nil
}

func (m *CloudletKey) IsValidArgsForGetCloudletGPUDriverLicenseConfig() error {
	return nil
}

func (m *CloudletInfo) IsValidArgsForInjectCloudletInfo() error {
	if m.Status.TaskNumber != 0 {
		return fmt.Errorf("Invalid field specified: Status.TaskNumber, this field is only for internal use")
	}
	if m.Status.MaxTasks != 0 {
		return fmt.Errorf("Invalid field specified: Status.MaxTasks, this field is only for internal use")
	}
	if m.Status.TaskName != "" {
		return fmt.Errorf("Invalid field specified: Status.TaskName, this field is only for internal use")
	}
	if m.Status.StepName != "" {
		return fmt.Errorf("Invalid field specified: Status.StepName, this field is only for internal use")
	}
	if m.Status.MsgCount != 0 {
		return fmt.Errorf("Invalid field specified: Status.MsgCount, this field is only for internal use")
	}
	if m.Status.Msgs != nil {
		return fmt.Errorf("Invalid field specified: Status.Msgs, this field is only for internal use")
	}
	return nil
}

func (m *CloudletInfo) IsValidArgsForEvictCloudletInfo() error {
	if m.Status.TaskNumber != 0 {
		return fmt.Errorf("Invalid field specified: Status.TaskNumber, this field is only for internal use")
	}
	if m.Status.MaxTasks != 0 {
		return fmt.Errorf("Invalid field specified: Status.MaxTasks, this field is only for internal use")
	}
	if m.Status.TaskName != "" {
		return fmt.Errorf("Invalid field specified: Status.TaskName, this field is only for internal use")
	}
	if m.Status.StepName != "" {
		return fmt.Errorf("Invalid field specified: Status.StepName, this field is only for internal use")
	}
	if m.Status.MsgCount != 0 {
		return fmt.Errorf("Invalid field specified: Status.MsgCount, this field is only for internal use")
	}
	if m.Status.Msgs != nil {
		return fmt.Errorf("Invalid field specified: Status.Msgs, this field is only for internal use")
	}
	return nil
}

func (m *OperationTimeLimits) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreateClusterInstTimeout != 0 {
		n += 1 + sovCloudlet(uint64(m.CreateClusterInstTimeout))
	}
	if m.UpdateClusterInstTimeout != 0 {
		n += 1 + sovCloudlet(uint64(m.UpdateClusterInstTimeout))
	}
	if m.DeleteClusterInstTimeout != 0 {
		n += 1 + sovCloudlet(uint64(m.DeleteClusterInstTimeout))
	}
	if m.CreateAppInstTimeout != 0 {
		n += 1 + sovCloudlet(uint64(m.CreateAppInstTimeout))
	}
	if m.UpdateAppInstTimeout != 0 {
		n += 1 + sovCloudlet(uint64(m.UpdateAppInstTimeout))
	}
	if m.DeleteAppInstTimeout != 0 {
		n += 1 + sovCloudlet(uint64(m.DeleteAppInstTimeout))
	}
	return n
}

func (m *CloudletInternal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovCloudlet(uint64(l))
		}
	}
	l = m.Key.Size()
	n += 1 + l + sovCloudlet(uint64(l))
	if len(m.Props) > 0 {
		for k, v := range m.Props {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovCloudlet(uint64(len(k))) + 1 + len(v) + sovCloudlet(uint64(len(v)))
			n += mapEntrySize + 1 + sovCloudlet(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *PlatformConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContainerRegistryPath)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	l = len(m.CloudletVmImagePath)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	l = len(m.NotifyCtrlAddrs)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	l = len(m.TlsCertFile)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	if len(m.EnvVar) > 0 {
		for k, v := range m.EnvVar {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovCloudlet(uint64(len(k))) + 1 + len(v) + sovCloudlet(uint64(len(v)))
			n += mapEntrySize + 1 + sovCloudlet(uint64(mapEntrySize))
		}
	}
	l = len(m.PlatformTag)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	if m.TestMode {
		n += 2
	}
	l = len(m.Span)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	if m.CleanupMode {
		n += 2
	}
	l = len(m.Region)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	if m.CommercialCerts {
		n += 2
	}
	if m.UseVaultPki {
		n += 2
	}
	l = len(m.AppDnsRoot)
	if l > 0 {
		n += 2 + l + sovCloudlet(uint64(l))
	}
	l = len(m.DeploymentTag)
	if l > 0 {
		n += 2 + l + sovCloudlet(uint64(l))
	}
	l = len(m.TlsKeyFile)
	if l > 0 {
		n += 2 + l + sovCloudlet(uint64(l))
	}
	l = len(m.TlsCaFile)
	if l > 0 {
		n += 2 + l + sovCloudlet(uint64(l))
	}
	l = len(m.CrmAccessPrivateKey)
	if l > 0 {
		n += 2 + l + sovCloudlet(uint64(l))
	}
	l = len(m.AccessApiAddr)
	if l > 0 {
		n += 2 + l + sovCloudlet(uint64(l))
	}
	l = len(m.CacheDir)
	if l > 0 {
		n += 2 + l + sovCloudlet(uint64(l))
	}
	l = len(m.SecondaryCrmAccessPrivateKey)
	if l > 0 {
		n += 2 + l + sovCloudlet(uint64(l))
	}
	l = len(m.ThanosRecvAddr)
	if l > 0 {
		n += 2 + l + sovCloudlet(uint64(l))
	}
	l = len(m.AnsiblePublicAddr)
	if l > 0 {
		n += 2 + l + sovCloudlet(uint64(l))
	}
	l = len(m.EnvoyWithCurlImage)
	if l > 0 {
		n += 2 + l + sovCloudlet(uint64(l))
	}
	l = len(m.NginxWithCurlImage)
	if l > 0 {
		n += 2 + l + sovCloudlet(uint64(l))
	}
	return n
}

func (m *FederationConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FederationContextId)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	l = len(m.PartnerFederationAddr)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	if m.FederationDbId != 0 {
		n += 1 + sovCloudlet(uint64(m.FederationDbId))
	}
	l = len(m.FederationName)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	return n
}

func (m *PlatformFeatures) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PlatformType)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	if m.SupportsMultiTenantCluster {
		n += 2
	}
	if m.SupportsSharedVolume {
		n += 2
	}
	if m.SupportsTrustPolicy {
		n += 2
	}
	if m.SupportsKubernetesOnly {
		n += 2
	}
	if m.KubernetesRequiresWorkerNodes {
		n += 2
	}
	if m.CloudletServicesLocal {
		n += 2
	}
	if m.IpAllocatedPerService {
		n += 2
	}
	if m.SupportsImageTypeOvf {
		n += 2
	}
	if m.IsVmPool {
		n += 2
	}
	if m.IsFake {
		n += 2
	}
	if m.SupportsAdditionalNetworks {
		n += 2
	}
	if m.IsSingleKubernetesCluster {
		n += 2
	}
	if m.SupportsAppInstDedicatedIp {
		n += 2
	}
	if m.SupportsPlatformHighAvailabilityOnK8S {
		n += 2
	}
	if m.SupportsPlatformHighAvailabilityOnDocker {
		n += 3
	}
	if m.NoKubernetesClusterAutoScale {
		n += 3
	}
	if m.IsPrebuiltKubernetesCluster {
		n += 3
	}
	if m.SupportsImageTypeOva {
		n += 3
	}
	if m.NoClusterSupport {
		n += 3
	}
	if m.IsEdgebox {
		n += 3
	}
	if len(m.AccessVars) > 0 {
		for k, v := range m.AccessVars {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCloudlet(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovCloudlet(uint64(len(k))) + l
			n += mapEntrySize + 2 + sovCloudlet(uint64(mapEntrySize))
		}
	}
	if len(m.Properties) > 0 {
		for k, v := range m.Properties {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCloudlet(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovCloudlet(uint64(len(k))) + l
			n += mapEntrySize + 2 + sovCloudlet(uint64(mapEntrySize))
		}
	}
	if len(m.ResourceQuotaProperties) > 0 {
		for _, e := range m.ResourceQuotaProperties {
			l = e.Size()
			n += 2 + l + sovCloudlet(uint64(l))
		}
	}
	l = len(m.NodeType)
	if l > 0 {
		n += 2 + l + sovCloudlet(uint64(l))
	}
	if m.IsMock {
		n += 3
	}
	if m.SupportsIpv6 {
		n += 3
	}
	if m.DeletePrepare {
		n += 3
	}
	return n
}

func (m *CloudletResMap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Key.Size()
	n += 1 + l + sovCloudlet(uint64(l))
	if len(m.Mapping) > 0 {
		for k, v := range m.Mapping {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovCloudlet(uint64(len(k))) + 1 + len(v) + sovCloudlet(uint64(len(v)))
			n += mapEntrySize + 1 + sovCloudlet(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *InfraConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ExternalNetworkName)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	l = len(m.FlavorName)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	return n
}

func (m *ResourceQuota) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	if m.Value != 0 {
		n += 1 + sovCloudlet(uint64(m.Value))
	}
	if m.AlertThreshold != 0 {
		n += 1 + sovCloudlet(uint64(m.AlertThreshold))
	}
	return n
}

func (m *GPUDriverKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	l = len(m.Organization)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	return n
}

func (m *GPUDriverBuild) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	l = len(m.DriverPath)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	l = len(m.DriverPathCreds)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	if m.OperatingSystem != 0 {
		n += 1 + sovCloudlet(uint64(m.OperatingSystem))
	}
	l = len(m.KernelVersion)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	l = len(m.HypervisorInfo)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	l = len(m.Md5Sum)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	l = len(m.StoragePath)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	return n
}

func (m *GPUDriverBuildMember) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Key.Size()
	n += 1 + l + sovCloudlet(uint64(l))
	l = m.Build.Size()
	n += 1 + l + sovCloudlet(uint64(l))
	if m.IgnoreState {
		n += 2
	}
	return n
}

func (m *GPUDriverBuildURL) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BuildUrlPath)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	if m.Validity != 0 {
		n += 1 + sovCloudlet(uint64(m.Validity))
	}
	return n
}

func (m *GPUDriver) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovCloudlet(uint64(l))
		}
	}
	l = m.Key.Size()
	n += 1 + l + sovCloudlet(uint64(l))
	if len(m.Builds) > 0 {
		for _, e := range m.Builds {
			l = e.Size()
			n += 1 + l + sovCloudlet(uint64(l))
		}
	}
	l = len(m.LicenseConfig)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	l = len(m.LicenseConfigMd5Sum)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	if len(m.Properties) > 0 {
		for k, v := range m.Properties {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovCloudlet(uint64(len(k))) + 1 + len(v) + sovCloudlet(uint64(len(v)))
			n += mapEntrySize + 1 + sovCloudlet(uint64(mapEntrySize))
		}
	}
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	if m.IgnoreState {
		n += 2
	}
	if m.DeletePrepare {
		n += 2
	}
	l = len(m.StorageBucketName)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	l = len(m.LicenseConfigStoragePath)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	return n
}

func (m *GPUConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Driver.Size()
	n += 1 + l + sovCloudlet(uint64(l))
	if len(m.Properties) > 0 {
		for k, v := range m.Properties {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovCloudlet(uint64(len(k))) + 1 + len(v) + sovCloudlet(uint64(len(v)))
			n += mapEntrySize + 1 + sovCloudlet(uint64(mapEntrySize))
		}
	}
	l = len(m.LicenseConfig)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	l = len(m.LicenseConfigMd5Sum)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	return n
}

func (m *Cloudlet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovCloudlet(uint64(l))
		}
	}
	l = m.Key.Size()
	n += 1 + l + sovCloudlet(uint64(l))
	l = m.Location.Size()
	n += 1 + l + sovCloudlet(uint64(l))
	if m.IpSupport != 0 {
		n += 1 + sovCloudlet(uint64(m.IpSupport))
	}
	l = len(m.StaticIps)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	if m.NumDynamicIps != 0 {
		n += 1 + sovCloudlet(uint64(m.NumDynamicIps))
	}
	l = m.TimeLimits.Size()
	n += 1 + l + sovCloudlet(uint64(l))
	if len(m.Errors) > 0 {
		for _, s := range m.Errors {
			l = len(s)
			n += 1 + l + sovCloudlet(uint64(l))
		}
	}
	if m.State != 0 {
		n += 1 + sovCloudlet(uint64(m.State))
	}
	if m.CrmOverride != 0 {
		n += 1 + sovCloudlet(uint64(m.CrmOverride))
	}
	if m.DeploymentLocal {
		n += 2
	}
	l = len(m.PlatformType)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	l = len(m.NotifySrvAddr)
	if l > 0 {
		n += 2 + l + sovCloudlet(uint64(l))
	}
	l = m.Flavor.Size()
	n += 2 + l + sovCloudlet(uint64(l))
	l = len(m.PhysicalName)
	if l > 0 {
		n += 2 + l + sovCloudlet(uint64(l))
	}
	if len(m.EnvVar) > 0 {
		for k, v := range m.EnvVar {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovCloudlet(uint64(len(k))) + 1 + len(v) + sovCloudlet(uint64(len(v)))
			n += mapEntrySize + 2 + sovCloudlet(uint64(mapEntrySize))
		}
	}
	l = len(m.ContainerVersion)
	if l > 0 {
		n += 2 + l + sovCloudlet(uint64(l))
	}
	l = m.Config.Size()
	n += 2 + l + sovCloudlet(uint64(l))
	if len(m.ResTagMap) > 0 {
		for k, v := range m.ResTagMap {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCloudlet(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovCloudlet(uint64(len(k))) + l
			n += mapEntrySize + 2 + sovCloudlet(uint64(mapEntrySize))
		}
	}
	if len(m.AccessVars) > 0 {
		for k, v := range m.AccessVars {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovCloudlet(uint64(len(k))) + 1 + len(v) + sovCloudlet(uint64(len(v)))
			n += mapEntrySize + 2 + sovCloudlet(uint64(mapEntrySize))
		}
	}
	l = len(m.VmImageVersion)
	if l > 0 {
		n += 2 + l + sovCloudlet(uint64(l))
	}
	l = len(m.Deployment)
	if l > 0 {
		n += 2 + l + sovCloudlet(uint64(l))
	}
	if m.InfraApiAccess != 0 {
		n += 2 + sovCloudlet(uint64(m.InfraApiAccess))
	}
	l = m.InfraConfig.Size()
	n += 2 + l + sovCloudlet(uint64(l))
	if m.MaintenanceState != 0 {
		n += 2 + sovCloudlet(uint64(m.MaintenanceState))
	}
	if m.OverridePolicyContainerVersion {
		n += 3
	}
	l = len(m.VmPool)
	if l > 0 {
		n += 2 + l + sovCloudlet(uint64(l))
	}
	l = len(m.CrmAccessPublicKey)
	if l > 0 {
		n += 2 + l + sovCloudlet(uint64(l))
	}
	if m.CrmAccessKeyUpgradeRequired {
		n += 3
	}
	l = m.CreatedAt.Size()
	n += 2 + l + sovCloudlet(uint64(l))
	l = m.UpdatedAt.Size()
	n += 2 + l + sovCloudlet(uint64(l))
	l = len(m.TrustPolicy)
	if l > 0 {
		n += 2 + l + sovCloudlet(uint64(l))
	}
	if m.TrustPolicyState != 0 {
		n += 2 + sovCloudlet(uint64(m.TrustPolicyState))
	}
	if len(m.ResourceQuotas) > 0 {
		for _, e := range m.ResourceQuotas {
			l = e.Size()
			n += 2 + l + sovCloudlet(uint64(l))
		}
	}
	if m.DefaultResourceAlertThreshold != 0 {
		n += 2 + sovCloudlet(uint64(m.DefaultResourceAlertThreshold))
	}
	l = len(m.HostController)
	if l > 0 {
		n += 2 + l + sovCloudlet(uint64(l))
	}
	l = len(m.KafkaCluster)
	if l > 0 {
		n += 2 + l + sovCloudlet(uint64(l))
	}
	l = len(m.KafkaUser)
	if l > 0 {
		n += 2 + l + sovCloudlet(uint64(l))
	}
	l = len(m.KafkaPassword)
	if l > 0 {
		n += 2 + l + sovCloudlet(uint64(l))
	}
	l = m.GpuConfig.Size()
	n += 2 + l + sovCloudlet(uint64(l))
	if m.EnableDefaultServerlessCluster {
		n += 3
	}
	if len(m.AllianceOrgs) > 0 {
		for _, s := range m.AllianceOrgs {
			l = len(s)
			n += 2 + l + sovCloudlet(uint64(l))
		}
	}
	l = len(m.SingleKubernetesClusterOwner)
	if l > 0 {
		n += 2 + l + sovCloudlet(uint64(l))
	}
	if m.DeletePrepare {
		n += 3
	}
	if m.PlatformHighAvailability {
		n += 3
	}
	l = len(m.SecondaryCrmAccessPublicKey)
	if l > 0 {
		n += 2 + l + sovCloudlet(uint64(l))
	}
	if m.SecondaryCrmAccessKeyUpgradeRequired {
		n += 3
	}
	l = len(m.SecondaryNotifySrvAddr)
	if l > 0 {
		n += 2 + l + sovCloudlet(uint64(l))
	}
	l = len(m.DnsLabel)
	if l > 0 {
		n += 2 + l + sovCloudlet(uint64(l))
	}
	l = len(m.RootLbFqdn)
	if l > 0 {
		n += 2 + l + sovCloudlet(uint64(l))
	}
	l = m.FederationConfig.Size()
	n += 2 + l + sovCloudlet(uint64(l))
	l = len(m.LicenseConfigStoragePath)
	if l > 0 {
		n += 2 + l + sovCloudlet(uint64(l))
	}
	if len(m.InfraFlavors) > 0 {
		for _, e := range m.InfraFlavors {
			l = e.Size()
			n += 2 + l + sovCloudlet(uint64(l))
		}
	}
	if m.EdgeboxOnly {
		n += 3
	}
	if m.OnboardingState != 0 {
		n += 2 + sovCloudlet(uint64(m.OnboardingState))
	}
	return n
}

func (m *FlavorMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Key.Size()
	n += 1 + l + sovCloudlet(uint64(l))
	l = len(m.FlavorName)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	l = len(m.AvailabilityZone)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	return n
}

func (m *CloudletManifest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Manifest)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	return n
}

func (m *PropertyInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	if m.Secret {
		n += 2
	}
	if m.Mandatory {
		n += 2
	}
	if m.Internal {
		n += 2
	}
	if m.TotpSecret {
		n += 2
	}
	return n
}

func (m *CloudletProps) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PlatformType)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	if len(m.Properties) > 0 {
		for k, v := range m.Properties {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCloudlet(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovCloudlet(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovCloudlet(uint64(mapEntrySize))
		}
	}
	l = len(m.Organization)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	return n
}

func (m *CloudletResourceQuotaProps) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PlatformType)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	if len(m.Properties) > 0 {
		for _, e := range m.Properties {
			l = e.Size()
			n += 1 + l + sovCloudlet(uint64(l))
		}
	}
	l = len(m.Organization)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	return n
}

func (m *CloudletResourceUsage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Key.Size()
	n += 1 + l + sovCloudlet(uint64(l))
	if m.InfraUsage {
		n += 2
	}
	if len(m.Info) > 0 {
		for _, e := range m.Info {
			l = e.Size()
			n += 1 + l + sovCloudlet(uint64(l))
		}
	}
	return n
}

func (m *CloudletAllianceOrg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Key.Size()
	n += 1 + l + sovCloudlet(uint64(l))
	l = len(m.Organization)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	return n
}

func (m *FlavorInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	if m.Vcpus != 0 {
		n += 1 + sovCloudlet(uint64(m.Vcpus))
	}
	if m.Ram != 0 {
		n += 1 + sovCloudlet(uint64(m.Ram))
	}
	if m.Disk != 0 {
		n += 1 + sovCloudlet(uint64(m.Disk))
	}
	if len(m.PropMap) > 0 {
		for k, v := range m.PropMap {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovCloudlet(uint64(len(k))) + 1 + len(v) + sovCloudlet(uint64(len(v)))
			n += mapEntrySize + 1 + sovCloudlet(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *OSAZone) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	return n
}

func (m *OSImage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	l = len(m.Tags)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	l = len(m.Properties)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	l = len(m.DiskFormat)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	return n
}

func (m *CloudletOnboardingInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Key.Size()
	n += 1 + l + sovCloudlet(uint64(l))
	if m.OnboardingState != 0 {
		n += 1 + sovCloudlet(uint64(m.OnboardingState))
	}
	l = m.Status.Size()
	n += 1 + l + sovCloudlet(uint64(l))
	if len(m.Errors) > 0 {
		for _, s := range m.Errors {
			l = len(s)
			n += 1 + l + sovCloudlet(uint64(l))
		}
	}
	return n
}

func (m *CloudletInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovCloudlet(uint64(l))
		}
	}
	l = m.Key.Size()
	n += 1 + l + sovCloudlet(uint64(l))
	if m.State != 0 {
		n += 1 + sovCloudlet(uint64(m.State))
	}
	if m.NotifyId != 0 {
		n += 1 + sovCloudlet(uint64(m.NotifyId))
	}
	l = len(m.Controller)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	if m.OsMaxRam != 0 {
		n += 1 + sovCloudlet(uint64(m.OsMaxRam))
	}
	if m.OsMaxVcores != 0 {
		n += 1 + sovCloudlet(uint64(m.OsMaxVcores))
	}
	if m.OsMaxVolGb != 0 {
		n += 1 + sovCloudlet(uint64(m.OsMaxVolGb))
	}
	if len(m.Errors) > 0 {
		for _, s := range m.Errors {
			l = len(s)
			n += 1 + l + sovCloudlet(uint64(l))
		}
	}
	if len(m.Flavors) > 0 {
		for _, e := range m.Flavors {
			l = e.Size()
			n += 1 + l + sovCloudlet(uint64(l))
		}
	}
	l = m.Status.Size()
	n += 1 + l + sovCloudlet(uint64(l))
	l = len(m.ContainerVersion)
	if l > 0 {
		n += 1 + l + sovCloudlet(uint64(l))
	}
	if len(m.AvailabilityZones) > 0 {
		for _, e := range m.AvailabilityZones {
			l = e.Size()
			n += 1 + l + sovCloudlet(uint64(l))
		}
	}
	if len(m.OsImages) > 0 {
		for _, e := range m.OsImages {
			l = e.Size()
			n += 1 + l + sovCloudlet(uint64(l))
		}
	}
	if m.ControllerCacheReceived {
		n += 2
	}
	if m.MaintenanceState != 0 {
		n += 2 + sovCloudlet(uint64(m.MaintenanceState))
	}
	l = m.ResourcesSnapshot.Size()
	n += 2 + l + sovCloudlet(uint64(l))
	if m.TrustPolicyState != 0 {
		n += 2 + sovCloudlet(uint64(m.TrustPolicyState))
	}
	if m.CompatibilityVersion != 0 {
		n += 2 + sovCloudlet(uint64(m.CompatibilityVersion))
	}
	if len(m.Properties) > 0 {
		for k, v := range m.Properties {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovCloudlet(uint64(len(k))) + 1 + len(v) + sovCloudlet(uint64(len(v)))
			n += mapEntrySize + 2 + sovCloudlet(uint64(mapEntrySize))
		}
	}
	if len(m.NodeInfos) > 0 {
		for _, e := range m.NodeInfos {
			l = e.Size()
			n += 2 + l + sovCloudlet(uint64(l))
		}
	}
	l = len(m.ActiveCrmInstance)
	if l > 0 {
		n += 2 + l + sovCloudlet(uint64(l))
	}
	if m.StandbyCrm {
		n += 3
	}
	l = len(m.ReleaseVersion)
	if l > 0 {
		n += 2 + l + sovCloudlet(uint64(l))
	}
	return n
}

func (m *CloudletMetrics) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Foo != 0 {
		n += 1 + sovCloudlet(uint64(m.Foo))
	}
	return n
}

func sovCloudlet(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCloudlet(x uint64) (n int) {
	return sovCloudlet(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *OperationTimeLimits) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OperationTimeLimits: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OperationTimeLimits: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateClusterInstTimeout", wireType)
			}
			m.CreateClusterInstTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateClusterInstTimeout |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateClusterInstTimeout", wireType)
			}
			m.UpdateClusterInstTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateClusterInstTimeout |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteClusterInstTimeout", wireType)
			}
			m.DeleteClusterInstTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeleteClusterInstTimeout |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateAppInstTimeout", wireType)
			}
			m.CreateAppInstTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateAppInstTimeout |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateAppInstTimeout", wireType)
			}
			m.UpdateAppInstTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateAppInstTimeout |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteAppInstTimeout", wireType)
			}
			m.DeleteAppInstTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeleteAppInstTimeout |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCloudlet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloudletInternal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloudletInternal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloudletInternal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Props", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Props == nil {
				m.Props = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCloudlet
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudlet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCloudlet
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCloudlet
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudlet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthCloudlet
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthCloudlet
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCloudlet(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthCloudlet
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Props[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudlet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlatformConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlatformConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlatformConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerRegistryPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerRegistryPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudletVmImagePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CloudletVmImagePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotifyCtrlAddrs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NotifyCtrlAddrs = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsCertFile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TlsCertFile = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnvVar", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EnvVar == nil {
				m.EnvVar = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCloudlet
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudlet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCloudlet
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCloudlet
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudlet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthCloudlet
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthCloudlet
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCloudlet(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthCloudlet
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.EnvVar[mapkey] = mapvalue
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlatformTag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlatformTag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestMode", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TestMode = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Span", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Span = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CleanupMode", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CleanupMode = bool(v != 0)
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommercialCerts", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CommercialCerts = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseVaultPki", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseVaultPki = bool(v != 0)
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppDnsRoot", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppDnsRoot = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentTag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeploymentTag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsKeyFile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TlsKeyFile = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsCaFile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TlsCaFile = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrmAccessPrivateKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CrmAccessPrivateKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessApiAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessApiAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheDir", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CacheDir = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecondaryCrmAccessPrivateKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecondaryCrmAccessPrivateKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThanosRecvAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ThanosRecvAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnsiblePublicAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AnsiblePublicAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnvoyWithCurlImage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EnvoyWithCurlImage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NginxWithCurlImage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NginxWithCurlImage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudlet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FederationConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FederationConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FederationConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FederationContextId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FederationContextId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartnerFederationAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartnerFederationAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FederationDbId", wireType)
			}
			m.FederationDbId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FederationDbId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FederationName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FederationName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudlet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlatformFeatures) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlatformFeatures: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlatformFeatures: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlatformType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlatformType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportsMultiTenantCluster", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SupportsMultiTenantCluster = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportsSharedVolume", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SupportsSharedVolume = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportsTrustPolicy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SupportsTrustPolicy = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportsKubernetesOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SupportsKubernetesOnly = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KubernetesRequiresWorkerNodes", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.KubernetesRequiresWorkerNodes = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudletServicesLocal", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CloudletServicesLocal = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAllocatedPerService", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IpAllocatedPerService = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportsImageTypeOvf", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SupportsImageTypeOvf = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsVmPool", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsVmPool = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFake", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsFake = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportsAdditionalNetworks", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SupportsAdditionalNetworks = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSingleKubernetesCluster", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSingleKubernetesCluster = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportsAppInstDedicatedIp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SupportsAppInstDedicatedIp = bool(v != 0)
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportsPlatformHighAvailabilityOnK8S", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SupportsPlatformHighAvailabilityOnK8S = bool(v != 0)
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportsPlatformHighAvailabilityOnDocker", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SupportsPlatformHighAvailabilityOnDocker = bool(v != 0)
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoKubernetesClusterAutoScale", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoKubernetesClusterAutoScale = bool(v != 0)
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPrebuiltKubernetesCluster", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPrebuiltKubernetesCluster = bool(v != 0)
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportsImageTypeOva", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SupportsImageTypeOva = bool(v != 0)
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoClusterSupport", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoClusterSupport = bool(v != 0)
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsEdgebox", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsEdgebox = bool(v != 0)
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessVars", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AccessVars == nil {
				m.AccessVars = make(map[string]*PropertyInfo)
			}
			var mapkey string
			var mapvalue *PropertyInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCloudlet
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudlet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCloudlet
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCloudlet
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudlet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCloudlet
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthCloudlet
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &PropertyInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCloudlet(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthCloudlet
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.AccessVars[mapkey] = mapvalue
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Properties == nil {
				m.Properties = make(map[string]*PropertyInfo)
			}
			var mapkey string
			var mapvalue *PropertyInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCloudlet
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudlet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCloudlet
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCloudlet
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudlet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCloudlet
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthCloudlet
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &PropertyInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCloudlet(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthCloudlet
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Properties[mapkey] = mapvalue
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceQuotaProperties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceQuotaProperties = append(m.ResourceQuotaProperties, InfraResource{})
			if err := m.ResourceQuotaProperties[len(m.ResourceQuotaProperties)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsMock", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsMock = bool(v != 0)
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportsIpv6", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SupportsIpv6 = bool(v != 0)
		case 99:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletePrepare", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DeletePrepare = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCloudlet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloudletResMap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloudletResMap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloudletResMap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mapping", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mapping == nil {
				m.Mapping = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCloudlet
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudlet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCloudlet
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCloudlet
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudlet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthCloudlet
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthCloudlet
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCloudlet(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthCloudlet
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Mapping[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudlet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InfraConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InfraConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InfraConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalNetworkName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalNetworkName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlavorName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FlavorName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudlet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceQuota) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceQuota: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceQuota: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlertThreshold", wireType)
			}
			m.AlertThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AlertThreshold |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCloudlet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GPUDriverKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GPUDriverKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GPUDriverKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Organization", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Organization = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudlet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GPUDriverBuild) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GPUDriverBuild: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GPUDriverBuild: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DriverPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DriverPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DriverPathCreds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DriverPathCreds = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatingSystem", wireType)
			}
			m.OperatingSystem = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperatingSystem |= OSType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KernelVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KernelVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HypervisorInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HypervisorInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Md5Sum", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Md5Sum = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoragePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StoragePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudlet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GPUDriverBuildMember) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GPUDriverBuildMember: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GPUDriverBuildMember: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Build", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Build.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoreState", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IgnoreState = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCloudlet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GPUDriverBuildURL) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GPUDriverBuildURL: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GPUDriverBuildURL: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildUrlPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BuildUrlPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validity", wireType)
			}
			m.Validity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Validity |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCloudlet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GPUDriver) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GPUDriver: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GPUDriver: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Builds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Builds = append(m.Builds, GPUDriverBuild{})
			if err := m.Builds[len(m.Builds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LicenseConfig", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LicenseConfig = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LicenseConfigMd5Sum", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LicenseConfigMd5Sum = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Properties == nil {
				m.Properties = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCloudlet
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudlet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCloudlet
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCloudlet
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudlet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthCloudlet
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthCloudlet
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCloudlet(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthCloudlet
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Properties[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoreState", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IgnoreState = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletePrepare", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DeletePrepare = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageBucketName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StorageBucketName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LicenseConfigStoragePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LicenseConfigStoragePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudlet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GPUConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GPUConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GPUConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Driver", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Driver.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Properties == nil {
				m.Properties = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCloudlet
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudlet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCloudlet
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCloudlet
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudlet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthCloudlet
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthCloudlet
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCloudlet(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthCloudlet
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Properties[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LicenseConfig", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LicenseConfig = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LicenseConfigMd5Sum", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LicenseConfigMd5Sum = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudlet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cloudlet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cloudlet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cloudlet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpSupport", wireType)
			}
			m.IpSupport = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpSupport |= IpSupport(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StaticIps", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StaticIps = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumDynamicIps", wireType)
			}
			m.NumDynamicIps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumDynamicIps |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeLimits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TimeLimits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errors", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Errors = append(m.Errors, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= TrackedState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrmOverride", wireType)
			}
			m.CrmOverride = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CrmOverride |= CRMOverride(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentLocal", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DeploymentLocal = bool(v != 0)
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlatformType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlatformType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotifySrvAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NotifySrvAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flavor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Flavor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhysicalName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhysicalName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnvVar", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EnvVar == nil {
				m.EnvVar = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCloudlet
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudlet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCloudlet
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCloudlet
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudlet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthCloudlet
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthCloudlet
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCloudlet(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthCloudlet
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.EnvVar[mapkey] = mapvalue
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResTagMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResTagMap == nil {
				m.ResTagMap = make(map[string]*ResTagTableKey)
			}
			var mapkey string
			var mapvalue *ResTagTableKey
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCloudlet
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudlet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCloudlet
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCloudlet
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudlet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCloudlet
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthCloudlet
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ResTagTableKey{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCloudlet(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthCloudlet
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ResTagMap[mapkey] = mapvalue
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessVars", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AccessVars == nil {
				m.AccessVars = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCloudlet
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudlet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCloudlet
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCloudlet
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudlet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthCloudlet
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthCloudlet
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCloudlet(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthCloudlet
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.AccessVars[mapkey] = mapvalue
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VmImageVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VmImageVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deployment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Deployment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InfraApiAccess", wireType)
			}
			m.InfraApiAccess = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InfraApiAccess |= InfraApiAccess(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InfraConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.InfraConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaintenanceState", wireType)
			}
			m.MaintenanceState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaintenanceState |= distributed_match_engine.MaintenanceState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverridePolicyContainerVersion", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OverridePolicyContainerVersion = bool(v != 0)
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VmPool", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VmPool = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrmAccessPublicKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CrmAccessPublicKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrmAccessKeyUpgradeRequired", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CrmAccessKeyUpgradeRequired = bool(v != 0)
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CreatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.UpdatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustPolicy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrustPolicy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 38:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustPolicyState", wireType)
			}
			m.TrustPolicyState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TrustPolicyState |= TrackedState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 39:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceQuotas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceQuotas = append(m.ResourceQuotas, ResourceQuota{})
			if err := m.ResourceQuotas[len(m.ResourceQuotas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultResourceAlertThreshold", wireType)
			}
			m.DefaultResourceAlertThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefaultResourceAlertThreshold |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostController", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostController = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KafkaCluster", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KafkaCluster = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 43:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KafkaUser", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KafkaUser = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 44:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KafkaPassword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KafkaPassword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpuConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GpuConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 46:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableDefaultServerlessCluster", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableDefaultServerlessCluster = bool(v != 0)
		case 47:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllianceOrgs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllianceOrgs = append(m.AllianceOrgs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 48:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SingleKubernetesClusterOwner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SingleKubernetesClusterOwner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 49:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletePrepare", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DeletePrepare = bool(v != 0)
		case 50:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlatformHighAvailability", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlatformHighAvailability = bool(v != 0)
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecondaryCrmAccessPublicKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecondaryCrmAccessPublicKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 52:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecondaryCrmAccessKeyUpgradeRequired", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SecondaryCrmAccessKeyUpgradeRequired = bool(v != 0)
		case 53:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecondaryNotifySrvAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecondaryNotifySrvAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 54:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsLabel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DnsLabel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 55:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RootLbFqdn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RootLbFqdn = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 56:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FederationConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FederationConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 57:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LicenseConfigStoragePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LicenseConfigStoragePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 58:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InfraFlavors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InfraFlavors = append(m.InfraFlavors, &FlavorInfo{})
			if err := m.InfraFlavors[len(m.InfraFlavors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 59:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EdgeboxOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EdgeboxOnly = bool(v != 0)
		case 60:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnboardingState", wireType)
			}
			m.OnboardingState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OnboardingState |= TrackedState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCloudlet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlavorMatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlavorMatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlavorMatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlavorName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FlavorName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailabilityZone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AvailabilityZone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudlet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloudletManifest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloudletManifest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloudletManifest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Manifest", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Manifest = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudlet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PropertyInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PropertyInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PropertyInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secret", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Secret = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mandatory", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Mandatory = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Internal", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Internal = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotpSecret", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TotpSecret = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCloudlet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloudletProps) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloudletProps: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloudletProps: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlatformType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlatformType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Properties == nil {
				m.Properties = make(map[string]*PropertyInfo)
			}
			var mapkey string
			var mapvalue *PropertyInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCloudlet
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudlet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCloudlet
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCloudlet
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudlet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCloudlet
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthCloudlet
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &PropertyInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCloudlet(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthCloudlet
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Properties[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Organization", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Organization = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudlet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloudletResourceQuotaProps) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloudletResourceQuotaProps: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloudletResourceQuotaProps: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlatformType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlatformType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Properties = append(m.Properties, InfraResource{})
			if err := m.Properties[len(m.Properties)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Organization", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Organization = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudlet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloudletResourceUsage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloudletResourceUsage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloudletResourceUsage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InfraUsage", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InfraUsage = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Info = append(m.Info, InfraResource{})
			if err := m.Info[len(m.Info)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudlet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloudletAllianceOrg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloudletAllianceOrg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloudletAllianceOrg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Organization", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Organization = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudlet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlavorInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlavorInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlavorInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vcpus", wireType)
			}
			m.Vcpus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Vcpus |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ram", wireType)
			}
			m.Ram = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ram |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disk", wireType)
			}
			m.Disk = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Disk |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PropMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PropMap == nil {
				m.PropMap = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCloudlet
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudlet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCloudlet
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCloudlet
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudlet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthCloudlet
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthCloudlet
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCloudlet(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthCloudlet
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.PropMap[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudlet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OSAZone) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OSAZone: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OSAZone: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudlet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OSImage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OSImage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OSImage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Properties = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskFormat", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DiskFormat = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudlet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloudletOnboardingInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloudletOnboardingInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloudletOnboardingInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnboardingState", wireType)
			}
			m.OnboardingState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OnboardingState |= TrackedState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errors", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Errors = append(m.Errors, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudlet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloudletInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloudletInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloudletInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= distributed_match_engine.CloudletState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotifyId", wireType)
			}
			m.NotifyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NotifyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Controller", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Controller = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OsMaxRam", wireType)
			}
			m.OsMaxRam = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OsMaxRam |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OsMaxVcores", wireType)
			}
			m.OsMaxVcores = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OsMaxVcores |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OsMaxVolGb", wireType)
			}
			m.OsMaxVolGb = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OsMaxVolGb |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errors", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Errors = append(m.Errors, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flavors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Flavors = append(m.Flavors, &FlavorInfo{})
			if err := m.Flavors[len(m.Flavors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailabilityZones", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AvailabilityZones = append(m.AvailabilityZones, &OSAZone{})
			if err := m.AvailabilityZones[len(m.AvailabilityZones)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OsImages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OsImages = append(m.OsImages, &OSImage{})
			if err := m.OsImages[len(m.OsImages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ControllerCacheReceived", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ControllerCacheReceived = bool(v != 0)
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaintenanceState", wireType)
			}
			m.MaintenanceState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaintenanceState |= distributed_match_engine.MaintenanceState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourcesSnapshot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResourcesSnapshot.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustPolicyState", wireType)
			}
			m.TrustPolicyState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TrustPolicyState |= TrackedState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompatibilityVersion", wireType)
			}
			m.CompatibilityVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompatibilityVersion |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Properties == nil {
				m.Properties = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCloudlet
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudlet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCloudlet
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCloudlet
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCloudlet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthCloudlet
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthCloudlet
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCloudlet(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthCloudlet
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Properties[mapkey] = mapvalue
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeInfos = append(m.NodeInfos, &NodeInfo{})
			if err := m.NodeInfos[len(m.NodeInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveCrmInstance", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActiveCrmInstance = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StandbyCrm", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StandbyCrm = bool(v != 0)
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReleaseVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCloudlet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCloudlet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReleaseVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCloudlet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloudletMetrics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloudletMetrics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloudletMetrics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Foo", wireType)
			}
			m.Foo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Foo |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCloudlet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCloudlet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCloudlet(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCloudlet
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCloudlet
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCloudlet
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCloudlet
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCloudlet
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCloudlet        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCloudlet          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCloudlet = fmt.Errorf("proto: unexpected end of group")
)
