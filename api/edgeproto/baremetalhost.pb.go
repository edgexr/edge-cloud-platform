// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: baremetalhost.proto

package edgeproto

import (
	context "context"
	"encoding/json"
	fmt "fmt"
	"github.com/edgexr/edge-cloud-platform/pkg/log"
	"github.com/edgexr/edge-cloud-platform/pkg/objstore"
	_ "github.com/edgexr/edge-cloud-platform/tools/protogen"
	_ "github.com/gogo/googleapis/google/api"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	"go.etcd.io/etcd/client/v3/concurrency"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type BareMetalHostKey struct {
	// Name of the bare metal host
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Name of the organization that this cluster belongs to
	Organization string `protobuf:"bytes,2,opt,name=organization,proto3" json:"organization,omitempty"`
	// Cloudlet name to which this machine is associated
	Cloudlet string `protobuf:"bytes,3,opt,name=cloudlet,proto3" json:"cloudlet,omitempty"`
}

func (m *BareMetalHostKey) Reset()         { *m = BareMetalHostKey{} }
func (m *BareMetalHostKey) String() string { return proto.CompactTextString(m) }
func (*BareMetalHostKey) ProtoMessage()    {}
func (*BareMetalHostKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_71193c536d3eaa79, []int{0}
}
func (m *BareMetalHostKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BareMetalHostKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BareMetalHostKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BareMetalHostKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BareMetalHostKey.Merge(m, src)
}
func (m *BareMetalHostKey) XXX_Size() int {
	return m.Size()
}
func (m *BareMetalHostKey) XXX_DiscardUnknown() {
	xxx_messageInfo_BareMetalHostKey.DiscardUnknown(m)
}

var xxx_messageInfo_BareMetalHostKey proto.InternalMessageInfo

type BareMetalHost struct {
	// Fields are used for the Update API to specify which fields to apply
	Fields []string `protobuf:"bytes,1,rep,name=fields,proto3" json:"fields,omitempty"`
	// Unique key
	// required: true
	Key BareMetalHostKey `protobuf:"bytes,2,opt,name=key,proto3" json:"key"`
	// machine status
	Status string `protobuf:"bytes,3,opt,name=status,proto3" json:"status,omitempty"`
	// boot mac address
	BootMacAddress string `protobuf:"bytes,4,opt,name=boot_mac_address,json=bootMacAddress,proto3" json:"boot_mac_address,omitempty"`
	// boot mode
	BootMode string `protobuf:"bytes,5,opt,name=boot_mode,json=bootMode,proto3" json:"boot_mode,omitempty"`
	// BMC address
	BmcAddress string `protobuf:"bytes,6,opt,name=bmc_address,json=bmcAddress,proto3" json:"bmc_address,omitempty"`
	// BMC username
	BmcUsername string `protobuf:"bytes,7,opt,name=bmc_username,json=bmcUsername,proto3" json:"bmc_username,omitempty"`
	// BMC password
	BmcPassword string `protobuf:"bytes,8,opt,name=bmc_password,json=bmcPassword,proto3" json:"bmc_password,omitempty"`
	// BMC disable certificate verification
	BmcDisableCertVerification bool `protobuf:"varint,9,opt,name=bmc_disable_cert_verification,json=bmcDisableCertVerification,proto3" json:"bmc_disable_cert_verification,omitempty"`
	// hardware profile
	HardwareProfile string `protobuf:"bytes,10,opt,name=hardware_profile,json=hardwareProfile,proto3" json:"hardware_profile,omitempty"`
	// labels
	Labels map[string]string `protobuf:"bytes,11,rep,name=labels,proto3" json:"labels" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// resources
	Resources *FlavorInfo `protobuf:"bytes,12,opt,name=resources,proto3" json:"resources,omitempty"`
	// nics
	Nics []*BareMetalHostNic `protobuf:"bytes,13,rep,name=nics,proto3" json:"nics,omitempty"`
}

func (m *BareMetalHost) Reset()         { *m = BareMetalHost{} }
func (m *BareMetalHost) String() string { return proto.CompactTextString(m) }
func (*BareMetalHost) ProtoMessage()    {}
func (*BareMetalHost) Descriptor() ([]byte, []int) {
	return fileDescriptor_71193c536d3eaa79, []int{1}
}
func (m *BareMetalHost) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BareMetalHost) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BareMetalHost.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BareMetalHost) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BareMetalHost.Merge(m, src)
}
func (m *BareMetalHost) XXX_Size() int {
	return m.Size()
}
func (m *BareMetalHost) XXX_DiscardUnknown() {
	xxx_messageInfo_BareMetalHost.DiscardUnknown(m)
}

var xxx_messageInfo_BareMetalHost proto.InternalMessageInfo

type BareMetalHostNic struct {
	// Name of the network interface
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// MAC address of the network interface
	MacAddress string `protobuf:"bytes,2,opt,name=mac_address,json=macAddress,proto3" json:"mac_address,omitempty"`
	// IP address of the network interface
	Ip string `protobuf:"bytes,3,opt,name=ip,proto3" json:"ip,omitempty"`
	// The vendor and product IDs of the NIC
	Model string `protobuf:"bytes,4,opt,name=model,proto3" json:"model,omitempty"`
}

func (m *BareMetalHostNic) Reset()         { *m = BareMetalHostNic{} }
func (m *BareMetalHostNic) String() string { return proto.CompactTextString(m) }
func (*BareMetalHostNic) ProtoMessage()    {}
func (*BareMetalHostNic) Descriptor() ([]byte, []int) {
	return fileDescriptor_71193c536d3eaa79, []int{2}
}
func (m *BareMetalHostNic) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BareMetalHostNic) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BareMetalHostNic.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BareMetalHostNic) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BareMetalHostNic.Merge(m, src)
}
func (m *BareMetalHostNic) XXX_Size() int {
	return m.Size()
}
func (m *BareMetalHostNic) XXX_DiscardUnknown() {
	xxx_messageInfo_BareMetalHostNic.DiscardUnknown(m)
}

var xxx_messageInfo_BareMetalHostNic proto.InternalMessageInfo

func init() {
	proto.RegisterType((*BareMetalHostKey)(nil), "edgeproto.BareMetalHostKey")
	proto.RegisterType((*BareMetalHost)(nil), "edgeproto.BareMetalHost")
	proto.RegisterMapType((map[string]string)(nil), "edgeproto.BareMetalHost.LabelsEntry")
	proto.RegisterType((*BareMetalHostNic)(nil), "edgeproto.BareMetalHostNic")
}

func init() { proto.RegisterFile("baremetalhost.proto", fileDescriptor_71193c536d3eaa79) }

var fileDescriptor_71193c536d3eaa79 = []byte{
	// 766 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x94, 0x41, 0x4f, 0xe3, 0x46,
	0x14, 0xc7, 0x33, 0x49, 0x08, 0xc9, 0x38, 0x40, 0x3a, 0x40, 0x35, 0x0a, 0x90, 0xa4, 0x51, 0x0f,
	0x69, 0x9b, 0x26, 0x15, 0x5c, 0x68, 0xa4, 0x1e, 0x12, 0xda, 0xaa, 0x15, 0x25, 0x20, 0xa3, 0x72,
	0xab, 0xa2, 0xb1, 0x3d, 0x71, 0x46, 0xb5, 0x3d, 0xd1, 0x8c, 0x43, 0x44, 0x8f, 0xfd, 0x04, 0x55,
	0x7b, 0xe3, 0x50, 0xf5, 0x1b, 0xb4, 0x67, 0x3e, 0x01, 0x47, 0xa4, 0xf6, 0xd0, 0xd3, 0x6a, 0x17,
	0xf6, 0xb0, 0xda, 0xd3, 0x4a, 0x2c, 0x68, 0x8f, 0x2b, 0x8f, 0xed, 0x90, 0x44, 0xca, 0x6d, 0xde,
	0x7b, 0xbf, 0x19, 0xff, 0xe7, 0xcd, 0xff, 0x19, 0xae, 0x1b, 0x44, 0x50, 0x97, 0xfa, 0xc4, 0x19,
	0x70, 0xe9, 0x37, 0x86, 0x82, 0xfb, 0x1c, 0xe5, 0xa8, 0x65, 0x53, 0xb5, 0x2c, 0x6e, 0xdb, 0x9c,
	0xdb, 0x0e, 0x6d, 0x92, 0x21, 0x6b, 0x12, 0xcf, 0xe3, 0x3e, 0xf1, 0x19, 0xf7, 0x64, 0x08, 0x16,
	0x77, 0x7c, 0xce, 0x1d, 0xd9, 0x54, 0x81, 0x4d, 0xbd, 0xc9, 0x22, 0x2a, 0xaf, 0x9a, 0x0e, 0x1f,
	0x59, 0x0e, 0x8d, 0xce, 0x2d, 0x6e, 0xd8, 0xdc, 0xe6, 0x6a, 0xd9, 0x0c, 0x56, 0x61, 0xb6, 0xfa,
	0x27, 0x80, 0x85, 0x0e, 0x11, 0xf4, 0x28, 0x50, 0xf1, 0x1d, 0x97, 0xfe, 0x21, 0xbd, 0x40, 0x65,
	0x98, 0xf6, 0x88, 0x4b, 0x31, 0xa8, 0x80, 0x5a, 0xae, 0xa3, 0x5d, 0x3d, 0xe2, 0x65, 0xc3, 0x1d,
	0x04, 0x29, 0x5d, 0x15, 0x50, 0x03, 0xe6, 0xb9, 0xb0, 0x89, 0xc7, 0x7e, 0x51, 0x8a, 0x70, 0x52,
	0x81, 0xf0, 0xea, 0x11, 0x67, 0x0c, 0x77, 0xc0, 0x85, 0xad, 0xcf, 0xd4, 0xd1, 0x67, 0x30, 0x1b,
	0xab, 0xc1, 0x29, 0xc5, 0xae, 0x5d, 0x3d, 0x62, 0xcd, 0x70, 0x07, 0x71, 0x5a, 0x9f, 0x00, 0xad,
	0xfc, 0xab, 0x7b, 0x0c, 0xde, 0xdd, 0x63, 0xf0, 0xcf, 0x5f, 0x65, 0x50, 0xfd, 0x6f, 0x09, 0xae,
	0xcc, 0x08, 0x44, 0x1f, 0xc2, 0x4c, 0x9f, 0x51, 0xc7, 0x92, 0x18, 0x54, 0x52, 0xb5, 0x9c, 0x1e,
	0x45, 0x68, 0x0f, 0xa6, 0x7e, 0xa6, 0x17, 0x4a, 0x8b, 0xb6, 0xbb, 0xd5, 0x98, 0xb4, 0xb1, 0x31,
	0x7f, 0xbf, 0x4e, 0xfa, 0xfa, 0x59, 0x39, 0xa1, 0x07, 0x74, 0x70, 0x98, 0xf4, 0x89, 0x3f, 0x92,
	0xa1, 0x2e, 0x3d, 0x8a, 0x50, 0x0d, 0x16, 0x0c, 0xce, 0xfd, 0x9e, 0x4b, 0xcc, 0x1e, 0xb1, 0x2c,
	0x41, 0xa5, 0xc4, 0x69, 0x45, 0xac, 0x06, 0xf9, 0x23, 0x62, 0xb6, 0xc3, 0x2c, 0xda, 0x82, 0xb9,
	0x90, 0xe4, 0x16, 0xc5, 0x4b, 0x0a, 0xc9, 0x2a, 0x84, 0x5b, 0x14, 0x95, 0xa1, 0x66, 0xb8, 0x4f,
	0x27, 0x64, 0x54, 0x19, 0x1a, 0xee, 0x64, 0xf7, 0x47, 0x30, 0x1f, 0x00, 0x23, 0x49, 0x85, 0x6a,
	0xf9, 0xb2, 0x22, 0x82, 0x4d, 0x3f, 0x46, 0xa9, 0x18, 0x19, 0x12, 0x29, 0xc7, 0x5c, 0x58, 0x38,
	0x3b, 0x41, 0x4e, 0xa2, 0x14, 0x6a, 0xc3, 0x9d, 0x00, 0xb1, 0x98, 0x24, 0x86, 0x43, 0x7b, 0x26,
	0x15, 0x7e, 0xef, 0x9c, 0x0a, 0xd6, 0x67, 0x66, 0xf8, 0x40, 0xb9, 0x0a, 0xa8, 0x65, 0xf5, 0xa2,
	0xe1, 0x9a, 0x5f, 0x87, 0xcc, 0x01, 0x15, 0xfe, 0xd9, 0x14, 0x81, 0x3e, 0x81, 0x85, 0x01, 0x11,
	0xd6, 0x98, 0x08, 0xda, 0x1b, 0x0a, 0xde, 0x67, 0x0e, 0xc5, 0x50, 0x7d, 0x69, 0x2d, 0xce, 0x9f,
	0x84, 0x69, 0xd4, 0x81, 0x19, 0x87, 0x18, 0xd4, 0x91, 0x58, 0xab, 0xa4, 0x6a, 0xda, 0xee, 0xc7,
	0x8b, 0x7a, 0xdd, 0xf8, 0x41, 0x61, 0xdf, 0x78, 0xbe, 0x88, 0x9b, 0x1e, 0xed, 0x44, 0x7b, 0x30,
	0x27, 0xa8, 0xe4, 0x23, 0x61, 0x52, 0x89, 0xf3, 0xea, 0xc9, 0x36, 0xa7, 0x8e, 0xf9, 0xd6, 0x21,
	0xe7, 0x5c, 0x7c, 0xef, 0xf5, 0xb9, 0xfe, 0xc4, 0xa1, 0x26, 0x4c, 0x7b, 0xcc, 0x94, 0x78, 0x45,
	0x7d, 0x76, 0xe1, 0x13, 0x77, 0x99, 0xa9, 0x2b, 0xb0, 0xf8, 0x25, 0xd4, 0xa6, 0x24, 0xa0, 0x42,
	0xe8, 0x10, 0x65, 0xeb, 0xf0, 0xf9, 0x37, 0xe0, 0xd2, 0x39, 0x71, 0x46, 0x34, 0x74, 0xb0, 0x1e,
	0x06, 0xad, 0xe4, 0x3e, 0x68, 0xfd, 0x14, 0xb8, 0xf0, 0xcd, 0x3d, 0x06, 0xbf, 0x3f, 0xe0, 0xcd,
	0x53, 0x65, 0x8a, 0xba, 0x1e, 0x2b, 0xa9, 0x77, 0x99, 0x29, 0x2f, 0x1f, 0xf0, 0x7e, 0xf0, 0x40,
	0x5f, 0x1d, 0xd2, 0x8b, 0x46, 0x97, 0xb8, 0xb4, 0xce, 0x85, 0xad, 0x82, 0xe3, 0x29, 0xef, 0xd7,
	0x63, 0x5f, 0xab, 0xca, 0x41, 0x14, 0x54, 0xdd, 0xb9, 0xb1, 0xeb, 0x32, 0x13, 0xa1, 0xe9, 0xb1,
	0x8b, 0x26, 0xad, 0x0c, 0xb5, 0x69, 0x0b, 0x86, 0x32, 0xa1, 0xfb, 0x64, 0xbf, 0x55, 0x98, 0x64,
	0xc3, 0xc8, 0xbc, 0x49, 0x36, 0x0c, 0x6e, 0x14, 0x38, 0xd1, 0x89, 0xdc, 0x1a, 0x06, 0xbb, 0x7f,
	0xcf, 0x8f, 0x79, 0x7b, 0xc8, 0xd0, 0x25, 0x80, 0x1f, 0x9c, 0x0e, 0xf8, 0x78, 0x76, 0xbc, 0xf0,
	0xa2, 0xb6, 0x16, 0x17, 0x56, 0xaa, 0xc7, 0xaf, 0xdf, 0xe2, 0xcf, 0xe3, 0xee, 0xc4, 0x77, 0x94,
	0xf5, 0xb6, 0x19, 0x74, 0xe0, 0x8c, 0xd1, 0x71, 0x7d, 0xbe, 0x2d, 0xbf, 0xfe, 0xfb, 0xf2, 0x8f,
	0x24, 0xae, 0xae, 0x37, 0xe5, 0x80, 0x8f, 0x9b, 0x33, 0xff, 0xc1, 0x16, 0xf8, 0xf4, 0x0b, 0xd0,
	0xd9, 0xbe, 0x7e, 0x51, 0x4a, 0x5c, 0xdf, 0x96, 0xc0, 0xcd, 0x6d, 0x09, 0x3c, 0xbf, 0x2d, 0x81,
	0xdf, 0xee, 0x4a, 0x89, 0x9b, 0xbb, 0x52, 0xe2, 0xff, 0xbb, 0x52, 0xc2, 0xc8, 0x28, 0x15, 0x7b,
	0xef, 0x03, 0x00, 0x00, 0xff, 0xff, 0x6d, 0x33, 0x39, 0x89, 0x42, 0x05, 0x00, 0x00,
}

func (this *BareMetalHostKey) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&edgeproto.BareMetalHostKey{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Organization: "+fmt.Sprintf("%#v", this.Organization)+",\n")
	s = append(s, "Cloudlet: "+fmt.Sprintf("%#v", this.Cloudlet)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringBaremetalhost(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// BareMetalHostApiClient is the client API for BareMetalHostApi service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type BareMetalHostApiClient interface {
	// Show BareMetalHosts
	ShowBareMetalHost(ctx context.Context, in *BareMetalHost, opts ...grpc.CallOption) (BareMetalHostApi_ShowBareMetalHostClient, error)
}

type bareMetalHostApiClient struct {
	cc *grpc.ClientConn
}

func NewBareMetalHostApiClient(cc *grpc.ClientConn) BareMetalHostApiClient {
	return &bareMetalHostApiClient{cc}
}

func (c *bareMetalHostApiClient) ShowBareMetalHost(ctx context.Context, in *BareMetalHost, opts ...grpc.CallOption) (BareMetalHostApi_ShowBareMetalHostClient, error) {
	stream, err := c.cc.NewStream(ctx, &_BareMetalHostApi_serviceDesc.Streams[0], "/edgeproto.BareMetalHostApi/ShowBareMetalHost", opts...)
	if err != nil {
		return nil, err
	}
	x := &bareMetalHostApiShowBareMetalHostClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type BareMetalHostApi_ShowBareMetalHostClient interface {
	Recv() (*BareMetalHost, error)
	grpc.ClientStream
}

type bareMetalHostApiShowBareMetalHostClient struct {
	grpc.ClientStream
}

func (x *bareMetalHostApiShowBareMetalHostClient) Recv() (*BareMetalHost, error) {
	m := new(BareMetalHost)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// BareMetalHostApiServer is the server API for BareMetalHostApi service.
type BareMetalHostApiServer interface {
	// Show BareMetalHosts
	ShowBareMetalHost(*BareMetalHost, BareMetalHostApi_ShowBareMetalHostServer) error
}

// UnimplementedBareMetalHostApiServer can be embedded to have forward compatible implementations.
type UnimplementedBareMetalHostApiServer struct {
}

func (*UnimplementedBareMetalHostApiServer) ShowBareMetalHost(req *BareMetalHost, srv BareMetalHostApi_ShowBareMetalHostServer) error {
	return status.Errorf(codes.Unimplemented, "method ShowBareMetalHost not implemented")
}

func RegisterBareMetalHostApiServer(s *grpc.Server, srv BareMetalHostApiServer) {
	s.RegisterService(&_BareMetalHostApi_serviceDesc, srv)
}

func _BareMetalHostApi_ShowBareMetalHost_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BareMetalHost)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BareMetalHostApiServer).ShowBareMetalHost(m, &bareMetalHostApiShowBareMetalHostServer{stream})
}

type BareMetalHostApi_ShowBareMetalHostServer interface {
	Send(*BareMetalHost) error
	grpc.ServerStream
}

type bareMetalHostApiShowBareMetalHostServer struct {
	grpc.ServerStream
}

func (x *bareMetalHostApiShowBareMetalHostServer) Send(m *BareMetalHost) error {
	return x.ServerStream.SendMsg(m)
}

var _BareMetalHostApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "edgeproto.BareMetalHostApi",
	HandlerType: (*BareMetalHostApiServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ShowBareMetalHost",
			Handler:       _BareMetalHostApi_ShowBareMetalHost_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "baremetalhost.proto",
}

func (m *BareMetalHostKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BareMetalHostKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BareMetalHostKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Cloudlet) > 0 {
		i -= len(m.Cloudlet)
		copy(dAtA[i:], m.Cloudlet)
		i = encodeVarintBaremetalhost(dAtA, i, uint64(len(m.Cloudlet)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Organization) > 0 {
		i -= len(m.Organization)
		copy(dAtA[i:], m.Organization)
		i = encodeVarintBaremetalhost(dAtA, i, uint64(len(m.Organization)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintBaremetalhost(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BareMetalHost) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BareMetalHost) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BareMetalHost) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Nics) > 0 {
		for iNdEx := len(m.Nics) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Nics[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBaremetalhost(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6a
		}
	}
	if m.Resources != nil {
		{
			size, err := m.Resources.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBaremetalhost(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if len(m.Labels) > 0 {
		for k := range m.Labels {
			v := m.Labels[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintBaremetalhost(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintBaremetalhost(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintBaremetalhost(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.HardwareProfile) > 0 {
		i -= len(m.HardwareProfile)
		copy(dAtA[i:], m.HardwareProfile)
		i = encodeVarintBaremetalhost(dAtA, i, uint64(len(m.HardwareProfile)))
		i--
		dAtA[i] = 0x52
	}
	if m.BmcDisableCertVerification {
		i--
		if m.BmcDisableCertVerification {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if len(m.BmcPassword) > 0 {
		i -= len(m.BmcPassword)
		copy(dAtA[i:], m.BmcPassword)
		i = encodeVarintBaremetalhost(dAtA, i, uint64(len(m.BmcPassword)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.BmcUsername) > 0 {
		i -= len(m.BmcUsername)
		copy(dAtA[i:], m.BmcUsername)
		i = encodeVarintBaremetalhost(dAtA, i, uint64(len(m.BmcUsername)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.BmcAddress) > 0 {
		i -= len(m.BmcAddress)
		copy(dAtA[i:], m.BmcAddress)
		i = encodeVarintBaremetalhost(dAtA, i, uint64(len(m.BmcAddress)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.BootMode) > 0 {
		i -= len(m.BootMode)
		copy(dAtA[i:], m.BootMode)
		i = encodeVarintBaremetalhost(dAtA, i, uint64(len(m.BootMode)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.BootMacAddress) > 0 {
		i -= len(m.BootMacAddress)
		copy(dAtA[i:], m.BootMacAddress)
		i = encodeVarintBaremetalhost(dAtA, i, uint64(len(m.BootMacAddress)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintBaremetalhost(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintBaremetalhost(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Fields) > 0 {
		for iNdEx := len(m.Fields) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Fields[iNdEx])
			copy(dAtA[i:], m.Fields[iNdEx])
			i = encodeVarintBaremetalhost(dAtA, i, uint64(len(m.Fields[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *BareMetalHostNic) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BareMetalHostNic) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BareMetalHostNic) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Model) > 0 {
		i -= len(m.Model)
		copy(dAtA[i:], m.Model)
		i = encodeVarintBaremetalhost(dAtA, i, uint64(len(m.Model)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Ip) > 0 {
		i -= len(m.Ip)
		copy(dAtA[i:], m.Ip)
		i = encodeVarintBaremetalhost(dAtA, i, uint64(len(m.Ip)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MacAddress) > 0 {
		i -= len(m.MacAddress)
		copy(dAtA[i:], m.MacAddress)
		i = encodeVarintBaremetalhost(dAtA, i, uint64(len(m.MacAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintBaremetalhost(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintBaremetalhost(dAtA []byte, offset int, v uint64) int {
	offset -= sovBaremetalhost(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *BareMetalHostKey) Matches(o *BareMetalHostKey, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !opts.Filter || o.Name != "" {
		if o.Name != m.Name {
			return false
		}
	}
	if !opts.Filter || o.Organization != "" {
		if o.Organization != m.Organization {
			return false
		}
	}
	if !opts.Filter || o.Cloudlet != "" {
		if o.Cloudlet != m.Cloudlet {
			return false
		}
	}
	return true
}

func (m *BareMetalHostKey) Clone() *BareMetalHostKey {
	cp := &BareMetalHostKey{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *BareMetalHostKey) CopyInFields(src *BareMetalHostKey) int {
	changed := 0
	if m.Name != src.Name {
		m.Name = src.Name
		changed++
	}
	if m.Organization != src.Organization {
		m.Organization = src.Organization
		changed++
	}
	if m.Cloudlet != src.Cloudlet {
		m.Cloudlet = src.Cloudlet
		changed++
	}
	return changed
}

func (m *BareMetalHostKey) DeepCopyIn(src *BareMetalHostKey) {
	m.Name = src.Name
	m.Organization = src.Organization
	m.Cloudlet = src.Cloudlet
}

func (m *BareMetalHostKey) GetKeyString() string {
	key, err := json.Marshal(m)
	if err != nil {
		log.FatalLog("Failed to marshal BareMetalHostKey key string", "obj", m)
	}
	return string(key)
}

func BareMetalHostKeyStringParse(str string, key *BareMetalHostKey) {
	err := json.Unmarshal([]byte(str), key)
	if err != nil {
		log.FatalLog("Failed to unmarshal BareMetalHostKey key string", "str", str)
	}
}

func (m *BareMetalHostKey) NotFoundError() error {
	return fmt.Errorf("BareMetalHost key %s not found", m.GetKeyString())
}

func (m *BareMetalHostKey) ExistsError() error {
	return fmt.Errorf("BareMetalHost key %s already exists", m.GetKeyString())
}

func (m *BareMetalHostKey) BeingDeletedError() error {
	return fmt.Errorf("BareMetalHost %s is being deleted", m.GetKeyString())
}

var BareMetalHostKeyTagName = "bmhname"
var BareMetalHostKeyTagOrganization = "bmhorg"
var BareMetalHostKeyTagCloudlet = "bmhcloudlet"

func (m *BareMetalHostKey) GetTags() map[string]string {
	tags := make(map[string]string)
	m.AddTags(tags)
	return tags
}

func (m *BareMetalHostKey) AddTagsByFunc(addTag AddTagFunc) {
	addTag("bmhname", m.Name)
	addTag("bmhorg", m.Organization)
	addTag("bmhcloudlet", m.Cloudlet)
}

func (m *BareMetalHostKey) AddTags(tags map[string]string) {
	tagMap := TagMap(tags)
	m.AddTagsByFunc(tagMap.AddTag)
}

// Helper method to check that enums have valid values
func (m *BareMetalHostKey) ValidateEnums() error {
	return nil
}

func (s *BareMetalHostKey) ClearTagged(tags map[string]struct{}) {
}

func (m *BareMetalHost) Matches(o *BareMetalHost, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !m.Key.Matches(&o.Key, fopts...) {
		return false
	}
	if !opts.Filter || o.Status != "" {
		if o.Status != m.Status {
			return false
		}
	}
	if !opts.Filter || o.BootMacAddress != "" {
		if o.BootMacAddress != m.BootMacAddress {
			return false
		}
	}
	if !opts.Filter || o.BootMode != "" {
		if o.BootMode != m.BootMode {
			return false
		}
	}
	if !opts.Filter || o.BmcAddress != "" {
		if o.BmcAddress != m.BmcAddress {
			return false
		}
	}
	if !opts.Filter || o.BmcUsername != "" {
		if o.BmcUsername != m.BmcUsername {
			return false
		}
	}
	if !opts.Filter || o.BmcPassword != "" {
		if o.BmcPassword != m.BmcPassword {
			return false
		}
	}
	if !opts.Filter || o.BmcDisableCertVerification != false {
		if o.BmcDisableCertVerification != m.BmcDisableCertVerification {
			return false
		}
	}
	if !opts.Filter || o.HardwareProfile != "" {
		if o.HardwareProfile != m.HardwareProfile {
			return false
		}
	}
	if !opts.Filter || o.Labels != nil {
		if len(m.Labels) == 0 && len(o.Labels) > 0 || len(m.Labels) > 0 && len(o.Labels) == 0 {
			return false
		} else if m.Labels != nil && o.Labels != nil {
			if !opts.Filter && len(m.Labels) != len(o.Labels) {
				return false
			}
			for k, _ := range o.Labels {
				_, ok := m.Labels[k]
				if !ok {
					return false
				}
				if o.Labels[k] != m.Labels[k] {
					return false
				}
			}
		}
	}
	if !opts.Filter || o.Resources != nil {
		if m.Resources == nil && o.Resources != nil || m.Resources != nil && o.Resources == nil {
			return false
		} else if m.Resources != nil && o.Resources != nil {
		}
	}
	if !opts.Filter || o.Nics != nil {
		if len(m.Nics) == 0 && len(o.Nics) > 0 || len(m.Nics) > 0 && len(o.Nics) == 0 {
			return false
		} else if m.Nics != nil && o.Nics != nil {
			if !opts.Filter && len(m.Nics) != len(o.Nics) {
				return false
			}
		}
	}
	return true
}

const BareMetalHostFieldKey = "2"
const BareMetalHostFieldKeyName = "2.1"
const BareMetalHostFieldKeyOrganization = "2.2"
const BareMetalHostFieldKeyCloudlet = "2.3"
const BareMetalHostFieldStatus = "3"
const BareMetalHostFieldBootMacAddress = "4"
const BareMetalHostFieldBootMode = "5"
const BareMetalHostFieldBmcAddress = "6"
const BareMetalHostFieldBmcUsername = "7"
const BareMetalHostFieldBmcPassword = "8"
const BareMetalHostFieldBmcDisableCertVerification = "9"
const BareMetalHostFieldHardwareProfile = "10"
const BareMetalHostFieldLabels = "11"
const BareMetalHostFieldLabelsKey = "11.1"
const BareMetalHostFieldLabelsValue = "11.2"
const BareMetalHostFieldResources = "12"
const BareMetalHostFieldResourcesName = "12.1"
const BareMetalHostFieldResourcesVcpus = "12.2"
const BareMetalHostFieldResourcesRam = "12.3"
const BareMetalHostFieldResourcesDisk = "12.4"
const BareMetalHostFieldResourcesPropMap = "12.5"
const BareMetalHostFieldResourcesPropMapKey = "12.5.1"
const BareMetalHostFieldResourcesPropMapValue = "12.5.2"
const BareMetalHostFieldResourcesGpus = "12.6"
const BareMetalHostFieldResourcesGpusModelId = "12.6.1"
const BareMetalHostFieldResourcesGpusCount = "12.6.2"
const BareMetalHostFieldResourcesGpusVendor = "12.6.3"
const BareMetalHostFieldResourcesGpusMemory = "12.6.4"
const BareMetalHostFieldResourcesGpusInUse = "12.6.5"
const BareMetalHostFieldNics = "13"
const BareMetalHostFieldNicsName = "13.1"
const BareMetalHostFieldNicsMacAddress = "13.2"
const BareMetalHostFieldNicsIp = "13.3"
const BareMetalHostFieldNicsModel = "13.4"

var BareMetalHostAllFields = []string{
	BareMetalHostFieldKeyName,
	BareMetalHostFieldKeyOrganization,
	BareMetalHostFieldKeyCloudlet,
	BareMetalHostFieldKey,
	BareMetalHostFieldStatus,
	BareMetalHostFieldBootMacAddress,
	BareMetalHostFieldBootMode,
	BareMetalHostFieldBmcAddress,
	BareMetalHostFieldBmcUsername,
	BareMetalHostFieldBmcPassword,
	BareMetalHostFieldBmcDisableCertVerification,
	BareMetalHostFieldHardwareProfile,
	BareMetalHostFieldLabelsKey,
	BareMetalHostFieldLabelsValue,
	BareMetalHostFieldLabels,
	BareMetalHostFieldResourcesName,
	BareMetalHostFieldResourcesVcpus,
	BareMetalHostFieldResourcesRam,
	BareMetalHostFieldResourcesDisk,
	BareMetalHostFieldResourcesPropMapKey,
	BareMetalHostFieldResourcesPropMapValue,
	BareMetalHostFieldResourcesPropMap,
	BareMetalHostFieldResourcesGpusModelId,
	BareMetalHostFieldResourcesGpusCount,
	BareMetalHostFieldResourcesGpusVendor,
	BareMetalHostFieldResourcesGpusMemory,
	BareMetalHostFieldResourcesGpusInUse,
	BareMetalHostFieldResourcesGpus,
	BareMetalHostFieldResources,
	BareMetalHostFieldNicsName,
	BareMetalHostFieldNicsMacAddress,
	BareMetalHostFieldNicsIp,
	BareMetalHostFieldNicsModel,
	BareMetalHostFieldNics,
}

var BareMetalHostAllFieldsMap = NewFieldMap(map[string]struct{}{
	BareMetalHostFieldKeyName:                    struct{}{},
	BareMetalHostFieldKeyOrganization:            struct{}{},
	BareMetalHostFieldKeyCloudlet:                struct{}{},
	BareMetalHostFieldKey:                        struct{}{},
	BareMetalHostFieldStatus:                     struct{}{},
	BareMetalHostFieldBootMacAddress:             struct{}{},
	BareMetalHostFieldBootMode:                   struct{}{},
	BareMetalHostFieldBmcAddress:                 struct{}{},
	BareMetalHostFieldBmcUsername:                struct{}{},
	BareMetalHostFieldBmcPassword:                struct{}{},
	BareMetalHostFieldBmcDisableCertVerification: struct{}{},
	BareMetalHostFieldHardwareProfile:            struct{}{},
	BareMetalHostFieldLabelsKey:                  struct{}{},
	BareMetalHostFieldLabelsValue:                struct{}{},
	BareMetalHostFieldLabels:                     struct{}{},
	BareMetalHostFieldResourcesName:              struct{}{},
	BareMetalHostFieldResourcesVcpus:             struct{}{},
	BareMetalHostFieldResourcesRam:               struct{}{},
	BareMetalHostFieldResourcesDisk:              struct{}{},
	BareMetalHostFieldResourcesPropMapKey:        struct{}{},
	BareMetalHostFieldResourcesPropMapValue:      struct{}{},
	BareMetalHostFieldResourcesPropMap:           struct{}{},
	BareMetalHostFieldResourcesGpusModelId:       struct{}{},
	BareMetalHostFieldResourcesGpusCount:         struct{}{},
	BareMetalHostFieldResourcesGpusVendor:        struct{}{},
	BareMetalHostFieldResourcesGpusMemory:        struct{}{},
	BareMetalHostFieldResourcesGpusInUse:         struct{}{},
	BareMetalHostFieldResourcesGpus:              struct{}{},
	BareMetalHostFieldResources:                  struct{}{},
	BareMetalHostFieldNicsName:                   struct{}{},
	BareMetalHostFieldNicsMacAddress:             struct{}{},
	BareMetalHostFieldNicsIp:                     struct{}{},
	BareMetalHostFieldNicsModel:                  struct{}{},
	BareMetalHostFieldNics:                       struct{}{},
})

var BareMetalHostAllFieldsStringMap = map[string]string{
	BareMetalHostFieldKeyName:                    "Key Name",
	BareMetalHostFieldKeyOrganization:            "Key Organization",
	BareMetalHostFieldKeyCloudlet:                "Key Cloudlet",
	BareMetalHostFieldKey:                        "Key",
	BareMetalHostFieldStatus:                     "Status",
	BareMetalHostFieldBootMacAddress:             "Boot Mac Address",
	BareMetalHostFieldBootMode:                   "Boot Mode",
	BareMetalHostFieldBmcAddress:                 "Bmc Address",
	BareMetalHostFieldBmcUsername:                "Bmc Username",
	BareMetalHostFieldBmcPassword:                "Bmc Password",
	BareMetalHostFieldBmcDisableCertVerification: "Bmc Disable Cert Verification",
	BareMetalHostFieldHardwareProfile:            "Hardware Profile",
	BareMetalHostFieldLabelsKey:                  "Labels Key",
	BareMetalHostFieldLabelsValue:                "Labels Value",
	BareMetalHostFieldLabels:                     "Labels",
	BareMetalHostFieldResourcesName:              "Resources Name",
	BareMetalHostFieldResourcesVcpus:             "Resources Vcpus",
	BareMetalHostFieldResourcesRam:               "Resources Ram",
	BareMetalHostFieldResourcesDisk:              "Resources Disk",
	BareMetalHostFieldResourcesPropMapKey:        "Resources Prop Map Key",
	BareMetalHostFieldResourcesPropMapValue:      "Resources Prop Map Value",
	BareMetalHostFieldResourcesPropMap:           "Resources Prop Map",
	BareMetalHostFieldResourcesGpusModelId:       "Resources Gpus Model Id",
	BareMetalHostFieldResourcesGpusCount:         "Resources Gpus Count",
	BareMetalHostFieldResourcesGpusVendor:        "Resources Gpus Vendor",
	BareMetalHostFieldResourcesGpusMemory:        "Resources Gpus Memory",
	BareMetalHostFieldResourcesGpusInUse:         "Resources Gpus In Use",
	BareMetalHostFieldResourcesGpus:              "Resources Gpus",
	BareMetalHostFieldResources:                  "Resources",
	BareMetalHostFieldNicsName:                   "Nics Name",
	BareMetalHostFieldNicsMacAddress:             "Nics Mac Address",
	BareMetalHostFieldNicsIp:                     "Nics Ip",
	BareMetalHostFieldNicsModel:                  "Nics Model",
	BareMetalHostFieldNics:                       "Nics",
}

func (m *BareMetalHost) IsKeyField(s string) bool {
	return strings.HasPrefix(s, BareMetalHostFieldKey+".") || s == BareMetalHostFieldKey
}

var BareMetalHostBackendFieldsMap = map[string]struct{}{
	BareMetalHostFieldResourcesPropMapKey:   struct{}{},
	BareMetalHostFieldResourcesPropMapValue: struct{}{},
	BareMetalHostFieldResourcesPropMap:      struct{}{},
}

var BareMetalHostNoConfigFieldsMap = map[string]struct{}{
	BareMetalHostFieldStatus:                struct{}{},
	BareMetalHostFieldResourcesName:         struct{}{},
	BareMetalHostFieldResourcesVcpus:        struct{}{},
	BareMetalHostFieldResourcesRam:          struct{}{},
	BareMetalHostFieldResourcesDisk:         struct{}{},
	BareMetalHostFieldResourcesPropMapKey:   struct{}{},
	BareMetalHostFieldResourcesPropMapValue: struct{}{},
	BareMetalHostFieldResourcesPropMap:      struct{}{},
	BareMetalHostFieldResourcesGpusModelId:  struct{}{},
	BareMetalHostFieldResourcesGpusCount:    struct{}{},
	BareMetalHostFieldResourcesGpusVendor:   struct{}{},
	BareMetalHostFieldResourcesGpusMemory:   struct{}{},
	BareMetalHostFieldResourcesGpusInUse:    struct{}{},
	BareMetalHostFieldResourcesGpus:         struct{}{},
	BareMetalHostFieldResources:             struct{}{},
	BareMetalHostFieldNicsName:              struct{}{},
	BareMetalHostFieldNicsMacAddress:        struct{}{},
	BareMetalHostFieldNicsIp:                struct{}{},
	BareMetalHostFieldNicsModel:             struct{}{},
	BareMetalHostFieldNics:                  struct{}{},
}

func (m *BareMetalHost) DiffFields(o *BareMetalHost, fields *FieldMap) {
	if m.Key.Name != o.Key.Name {
		fields.Set(BareMetalHostFieldKeyName)
		fields.Set(BareMetalHostFieldKey)
	}
	if m.Key.Organization != o.Key.Organization {
		fields.Set(BareMetalHostFieldKeyOrganization)
		fields.Set(BareMetalHostFieldKey)
	}
	if m.Key.Cloudlet != o.Key.Cloudlet {
		fields.Set(BareMetalHostFieldKeyCloudlet)
		fields.Set(BareMetalHostFieldKey)
	}
	if m.Status != o.Status {
		fields.Set(BareMetalHostFieldStatus)
	}
	if m.BootMacAddress != o.BootMacAddress {
		fields.Set(BareMetalHostFieldBootMacAddress)
	}
	if m.BootMode != o.BootMode {
		fields.Set(BareMetalHostFieldBootMode)
	}
	if m.BmcAddress != o.BmcAddress {
		fields.Set(BareMetalHostFieldBmcAddress)
	}
	if m.BmcUsername != o.BmcUsername {
		fields.Set(BareMetalHostFieldBmcUsername)
	}
	if m.BmcPassword != o.BmcPassword {
		fields.Set(BareMetalHostFieldBmcPassword)
	}
	if m.BmcDisableCertVerification != o.BmcDisableCertVerification {
		fields.Set(BareMetalHostFieldBmcDisableCertVerification)
	}
	if m.HardwareProfile != o.HardwareProfile {
		fields.Set(BareMetalHostFieldHardwareProfile)
	}
	if len(m.Labels) != len(o.Labels) {
		fields.Set(BareMetalHostFieldLabels)
	} else {
		for k0, _ := range m.Labels {
			_, vok0 := o.Labels[k0]
			if !vok0 {
				fields.Set(BareMetalHostFieldLabels)
			} else {
				if m.Labels[k0] != o.Labels[k0] {
					fields.Set(BareMetalHostFieldLabels)
					break
				}
			}
		}
	}
	if m.Resources != nil && o.Resources != nil {
		if m.Resources.Name != o.Resources.Name {
			fields.Set(BareMetalHostFieldResourcesName)
			fields.Set(BareMetalHostFieldResources)
		}
		if m.Resources.Vcpus != o.Resources.Vcpus {
			fields.Set(BareMetalHostFieldResourcesVcpus)
			fields.Set(BareMetalHostFieldResources)
		}
		if m.Resources.Ram != o.Resources.Ram {
			fields.Set(BareMetalHostFieldResourcesRam)
			fields.Set(BareMetalHostFieldResources)
		}
		if m.Resources.Disk != o.Resources.Disk {
			fields.Set(BareMetalHostFieldResourcesDisk)
			fields.Set(BareMetalHostFieldResources)
		}
		if m.Resources.PropMap != nil && o.Resources.PropMap != nil {
			if len(m.Resources.PropMap) != len(o.Resources.PropMap) {
				fields.Set(BareMetalHostFieldResourcesPropMap)
				fields.Set(BareMetalHostFieldResources)
			} else {
				for k1, _ := range m.Resources.PropMap {
					_, vok1 := o.Resources.PropMap[k1]
					if !vok1 {
						fields.Set(BareMetalHostFieldResourcesPropMap)
						fields.Set(BareMetalHostFieldResources)
					} else {
						if m.Resources.PropMap[k1] != o.Resources.PropMap[k1] {
							fields.Set(BareMetalHostFieldResourcesPropMap)
							fields.Set(BareMetalHostFieldResources)
							break
						}
					}
				}
			}
		} else if (m.Resources.PropMap != nil && o.Resources.PropMap == nil) || (m.Resources.PropMap == nil && o.Resources.PropMap != nil) {
			fields.Set(BareMetalHostFieldResourcesPropMap)
			fields.Set(BareMetalHostFieldResources)
		}
		if m.Resources.Gpus != nil && o.Resources.Gpus != nil {
			if len(m.Resources.Gpus) != len(o.Resources.Gpus) {
				fields.Set(BareMetalHostFieldResourcesGpus)
				fields.Set(BareMetalHostFieldResources)
			} else {
				for i1 := 0; i1 < len(m.Resources.Gpus); i1++ {
					if m.Resources.Gpus[i1].ModelId != o.Resources.Gpus[i1].ModelId {
						fields.Set(BareMetalHostFieldResourcesGpusModelId)
						fields.Set(BareMetalHostFieldResourcesGpus)
						fields.Set(BareMetalHostFieldResources)
					}
					if m.Resources.Gpus[i1].Count != o.Resources.Gpus[i1].Count {
						fields.Set(BareMetalHostFieldResourcesGpusCount)
						fields.Set(BareMetalHostFieldResourcesGpus)
						fields.Set(BareMetalHostFieldResources)
					}
					if m.Resources.Gpus[i1].Vendor != o.Resources.Gpus[i1].Vendor {
						fields.Set(BareMetalHostFieldResourcesGpusVendor)
						fields.Set(BareMetalHostFieldResourcesGpus)
						fields.Set(BareMetalHostFieldResources)
					}
					if m.Resources.Gpus[i1].Memory != o.Resources.Gpus[i1].Memory {
						fields.Set(BareMetalHostFieldResourcesGpusMemory)
						fields.Set(BareMetalHostFieldResourcesGpus)
						fields.Set(BareMetalHostFieldResources)
					}
					if m.Resources.Gpus[i1].InUse != o.Resources.Gpus[i1].InUse {
						fields.Set(BareMetalHostFieldResourcesGpusInUse)
						fields.Set(BareMetalHostFieldResourcesGpus)
						fields.Set(BareMetalHostFieldResources)
					}
				}
			}
		} else if (m.Resources.Gpus != nil && o.Resources.Gpus == nil) || (m.Resources.Gpus == nil && o.Resources.Gpus != nil) {
			fields.Set(BareMetalHostFieldResourcesGpus)
			fields.Set(BareMetalHostFieldResources)
		}
	} else if (m.Resources != nil && o.Resources == nil) || (m.Resources == nil && o.Resources != nil) {
		fields.Set(BareMetalHostFieldResources)
	}
	if m.Nics != nil && o.Nics != nil {
		if len(m.Nics) != len(o.Nics) {
			fields.Set(BareMetalHostFieldNics)
		} else {
			for i0 := 0; i0 < len(m.Nics); i0++ {
				if m.Nics[i0].Name != o.Nics[i0].Name {
					fields.Set(BareMetalHostFieldNicsName)
					fields.Set(BareMetalHostFieldNics)
				}
				if m.Nics[i0].MacAddress != o.Nics[i0].MacAddress {
					fields.Set(BareMetalHostFieldNicsMacAddress)
					fields.Set(BareMetalHostFieldNics)
				}
				if m.Nics[i0].Ip != o.Nics[i0].Ip {
					fields.Set(BareMetalHostFieldNicsIp)
					fields.Set(BareMetalHostFieldNics)
				}
				if m.Nics[i0].Model != o.Nics[i0].Model {
					fields.Set(BareMetalHostFieldNicsModel)
					fields.Set(BareMetalHostFieldNics)
				}
			}
		}
	} else if (m.Nics != nil && o.Nics == nil) || (m.Nics == nil && o.Nics != nil) {
		fields.Set(BareMetalHostFieldNics)
	}
}

func (m *BareMetalHost) GetDiffFields(o *BareMetalHost) *FieldMap {
	diffFields := NewFieldMap(nil)
	m.DiffFields(o, diffFields)
	return diffFields
}

func (m *BareMetalHost) Clone() *BareMetalHost {
	cp := &BareMetalHost{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *BareMetalHost) AddResourcesGpus(vals ...*GPUResource) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.Resources.Gpus {
		cur[v.GetKey().GetKeyString()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.GetKey().GetKeyString()]; found {
			continue // duplicate
		}
		m.Resources.Gpus = append(m.Resources.Gpus, v)
		changes++
	}
	return changes
}

func (m *BareMetalHost) RemoveResourcesGpus(vals ...*GPUResource) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.GetKey().GetKeyString()] = struct{}{}
	}
	for i := len(m.Resources.Gpus); i >= 0; i-- {
		if _, found := remove[m.Resources.Gpus[i].GetKey().GetKeyString()]; found {
			m.Resources.Gpus = append(m.Resources.Gpus[:i], m.Resources.Gpus[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *BareMetalHost) AddNics(vals ...*BareMetalHostNic) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.Nics {
		cur[v.String()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.String()]; found {
			continue // duplicate
		}
		m.Nics = append(m.Nics, v)
		changes++
	}
	return changes
}

func (m *BareMetalHost) RemoveNics(vals ...*BareMetalHostNic) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.String()] = struct{}{}
	}
	for i := len(m.Nics); i >= 0; i-- {
		if _, found := remove[m.Nics[i].String()]; found {
			m.Nics = append(m.Nics[:i], m.Nics[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *BareMetalHost) CopyInFields(src *BareMetalHost) int {
	updateListAction := "replace"
	changed := 0
	fmap := MakeFieldMap(src.Fields)
	if fmap.HasOrHasChild("2") {
		if fmap.Has("2.1") {
			if m.Key.Name != src.Key.Name {
				m.Key.Name = src.Key.Name
				changed++
			}
		}
		if fmap.Has("2.2") {
			if m.Key.Organization != src.Key.Organization {
				m.Key.Organization = src.Key.Organization
				changed++
			}
		}
		if fmap.Has("2.3") {
			if m.Key.Cloudlet != src.Key.Cloudlet {
				m.Key.Cloudlet = src.Key.Cloudlet
				changed++
			}
		}
	}
	if fmap.Has("3") {
		if m.Status != src.Status {
			m.Status = src.Status
			changed++
		}
	}
	if fmap.Has("4") {
		if m.BootMacAddress != src.BootMacAddress {
			m.BootMacAddress = src.BootMacAddress
			changed++
		}
	}
	if fmap.Has("5") {
		if m.BootMode != src.BootMode {
			m.BootMode = src.BootMode
			changed++
		}
	}
	if fmap.Has("6") {
		if m.BmcAddress != src.BmcAddress {
			m.BmcAddress = src.BmcAddress
			changed++
		}
	}
	if fmap.Has("7") {
		if m.BmcUsername != src.BmcUsername {
			m.BmcUsername = src.BmcUsername
			changed++
		}
	}
	if fmap.Has("8") {
		if m.BmcPassword != src.BmcPassword {
			m.BmcPassword = src.BmcPassword
			changed++
		}
	}
	if fmap.Has("9") {
		if m.BmcDisableCertVerification != src.BmcDisableCertVerification {
			m.BmcDisableCertVerification = src.BmcDisableCertVerification
			changed++
		}
	}
	if fmap.Has("10") {
		if m.HardwareProfile != src.HardwareProfile {
			m.HardwareProfile = src.HardwareProfile
			changed++
		}
	}
	if fmap.HasOrHasChild("11") {
		if src.Labels != nil {
			if updateListAction == "add" {
				for k0, v := range src.Labels {
					m.Labels[k0] = v
					changed++
				}
			} else if updateListAction == "remove" {
				for k0, _ := range src.Labels {
					if _, ok := m.Labels[k0]; ok {
						delete(m.Labels, k0)
						changed++
					}
				}
			} else {
				m.Labels = make(map[string]string)
				for k0, v := range src.Labels {
					m.Labels[k0] = v
				}
				changed++
			}
		} else if m.Labels != nil {
			m.Labels = nil
			changed++
		}
	}
	if fmap.HasOrHasChild("12") {
		if src.Resources != nil {
			if m.Resources == nil {
				m.Resources = &FlavorInfo{}
			}
			if fmap.Has("12.1") {
				if m.Resources.Name != src.Resources.Name {
					m.Resources.Name = src.Resources.Name
					changed++
				}
			}
			if fmap.Has("12.2") {
				if m.Resources.Vcpus != src.Resources.Vcpus {
					m.Resources.Vcpus = src.Resources.Vcpus
					changed++
				}
			}
			if fmap.Has("12.3") {
				if m.Resources.Ram != src.Resources.Ram {
					m.Resources.Ram = src.Resources.Ram
					changed++
				}
			}
			if fmap.Has("12.4") {
				if m.Resources.Disk != src.Resources.Disk {
					m.Resources.Disk = src.Resources.Disk
					changed++
				}
			}
			if fmap.HasOrHasChild("12.5") {
				if src.Resources.PropMap != nil {
					if updateListAction == "add" {
						for k1, v := range src.Resources.PropMap {
							m.Resources.PropMap[k1] = v
							changed++
						}
					} else if updateListAction == "remove" {
						for k1, _ := range src.Resources.PropMap {
							if _, ok := m.Resources.PropMap[k1]; ok {
								delete(m.Resources.PropMap, k1)
								changed++
							}
						}
					} else {
						m.Resources.PropMap = make(map[string]string)
						for k1, v := range src.Resources.PropMap {
							m.Resources.PropMap[k1] = v
						}
						changed++
					}
				} else if m.Resources.PropMap != nil {
					m.Resources.PropMap = nil
					changed++
				}
			}
			if fmap.HasOrHasChild("12.6") {
				if src.Resources.Gpus != nil {
					if updateListAction == "add" {
						changed += m.AddResourcesGpus(src.Resources.Gpus...)
					} else if updateListAction == "remove" {
						changed += m.RemoveResourcesGpus(src.Resources.Gpus...)
					} else {
						m.Resources.Gpus = make([]*GPUResource, 0)
						for k1, _ := range src.Resources.Gpus {
							m.Resources.Gpus = append(m.Resources.Gpus, src.Resources.Gpus[k1].Clone())
						}
						changed++
					}
				} else if m.Resources.Gpus != nil {
					m.Resources.Gpus = nil
					changed++
				}
			}
		} else if m.Resources != nil {
			m.Resources = nil
			changed++
		}
	}
	if fmap.HasOrHasChild("13") {
		if src.Nics != nil {
			if updateListAction == "add" {
				changed += m.AddNics(src.Nics...)
			} else if updateListAction == "remove" {
				changed += m.RemoveNics(src.Nics...)
			} else {
				m.Nics = make([]*BareMetalHostNic, 0)
				for k0, _ := range src.Nics {
					m.Nics = append(m.Nics, src.Nics[k0].Clone())
				}
				changed++
			}
		} else if m.Nics != nil {
			m.Nics = nil
			changed++
		}
	}
	return changed
}

func (m *BareMetalHost) DeepCopyIn(src *BareMetalHost) {
	m.Key.DeepCopyIn(&src.Key)
	m.Status = src.Status
	m.BootMacAddress = src.BootMacAddress
	m.BootMode = src.BootMode
	m.BmcAddress = src.BmcAddress
	m.BmcUsername = src.BmcUsername
	m.BmcPassword = src.BmcPassword
	m.BmcDisableCertVerification = src.BmcDisableCertVerification
	m.HardwareProfile = src.HardwareProfile
	if src.Labels != nil {
		m.Labels = make(map[string]string)
		for k, v := range src.Labels {
			m.Labels[k] = v
		}
	} else {
		m.Labels = nil
	}
	if src.Resources != nil {
		var tmp_Resources FlavorInfo
		tmp_Resources.DeepCopyIn(src.Resources)
		m.Resources = &tmp_Resources
	} else {
		m.Resources = nil
	}
	if src.Nics != nil {
		m.Nics = make([]*BareMetalHostNic, len(src.Nics), len(src.Nics))
		for ii, s := range src.Nics {
			var tmp_s BareMetalHostNic
			tmp_s.DeepCopyIn(s)
			m.Nics[ii] = &tmp_s
		}
	} else {
		m.Nics = nil
	}
}

func (s *BareMetalHost) HasFields() bool {
	return true
}

type BareMetalHostStore interface {
	Create(ctx context.Context, m *BareMetalHost, wait func(int64)) (*Result, error)
	Update(ctx context.Context, m *BareMetalHost, wait func(int64)) (*Result, error)
	Delete(ctx context.Context, m *BareMetalHost, wait func(int64)) (*Result, error)
	Put(ctx context.Context, m *BareMetalHost, wait func(int64), ops ...objstore.KVOp) (*Result, error)
	LoadOne(key string) (*BareMetalHost, int64, error)
	Get(ctx context.Context, key *BareMetalHostKey, buf *BareMetalHost) bool
	List(ctx context.Context, cb func(ctx context.Context, obj *BareMetalHost, modRev int64) error) error
	STMGet(stm concurrency.STM, key *BareMetalHostKey, buf *BareMetalHost) bool
	STMPut(stm concurrency.STM, obj *BareMetalHost, ops ...objstore.KVOp)
	STMDel(stm concurrency.STM, key *BareMetalHostKey)
	STMHas(stm concurrency.STM, key *BareMetalHostKey) bool
}

type BareMetalHostStoreImpl struct {
	kvstore objstore.KVStore
}

func NewBareMetalHostStore(kvstore objstore.KVStore) *BareMetalHostStoreImpl {
	return &BareMetalHostStoreImpl{kvstore: kvstore}
}

func (s *BareMetalHostStoreImpl) Create(ctx context.Context, m *BareMetalHost, wait func(int64)) (*Result, error) {
	err := m.Validate(BareMetalHostAllFieldsMap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("BareMetalHost", m.GetKey())
	val, err := json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Create(ctx, key, string(val))
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *BareMetalHostStoreImpl) Update(ctx context.Context, m *BareMetalHost, wait func(int64)) (*Result, error) {
	fmap := MakeFieldMap(m.Fields)
	err := m.Validate(fmap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("BareMetalHost", m.GetKey())
	var vers int64 = 0
	curBytes, vers, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, err
	}
	var cur BareMetalHost
	err = json.Unmarshal(curBytes, &cur)
	if err != nil {
		return nil, err
	}
	cur.CopyInFields(m)
	// never save fields
	cur.Fields = nil
	val, err := json.Marshal(cur)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Update(ctx, key, string(val), vers)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *BareMetalHostStoreImpl) Put(ctx context.Context, m *BareMetalHost, wait func(int64), ops ...objstore.KVOp) (*Result, error) {
	err := m.Validate(BareMetalHostAllFieldsMap)
	m.Fields = nil
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("BareMetalHost", m.GetKey())
	var val []byte
	val, err = json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Put(ctx, key, string(val), ops...)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *BareMetalHostStoreImpl) Delete(ctx context.Context, m *BareMetalHost, wait func(int64)) (*Result, error) {
	err := m.GetKey().ValidateKey()
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("BareMetalHost", m.GetKey())
	rev, err := s.kvstore.Delete(ctx, key)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *BareMetalHostStoreImpl) LoadOne(key string) (*BareMetalHost, int64, error) {
	val, rev, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, 0, err
	}
	var obj BareMetalHost
	err = json.Unmarshal(val, &obj)
	if err != nil {
		log.DebugLog(log.DebugLevelApi, "Failed to parse BareMetalHost data", "val", string(val), "err", err)
		return nil, 0, err
	}
	return &obj, rev, nil
}

func (s *BareMetalHostStoreImpl) Get(ctx context.Context, key *BareMetalHostKey, buf *BareMetalHost) bool {
	keystr := objstore.DbKeyString("BareMetalHost", key)
	val, _, _, err := s.kvstore.Get(keystr)
	if err != nil {
		return false
	}
	return s.parseGetData(val, buf)
}

func (s *BareMetalHostStoreImpl) List(ctx context.Context, cb func(ctx context.Context, obj *BareMetalHost, modRev int64) error) error {
	prefix := "BareMetalHost/"
	return s.kvstore.List(prefix, func(key, val []byte, rev, modRev int64) error {
		obj := &BareMetalHost{}
		if s.parseGetData(val, obj) {
			return cb(ctx, obj, modRev)
		}
		return nil
	})
}

func (s *BareMetalHostStoreImpl) STMGet(stm concurrency.STM, key *BareMetalHostKey, buf *BareMetalHost) bool {
	keystr := objstore.DbKeyString("BareMetalHost", key)
	valstr := stm.Get(keystr)
	return s.parseGetData([]byte(valstr), buf)
}

func (s *BareMetalHostStoreImpl) STMHas(stm concurrency.STM, key *BareMetalHostKey) bool {
	keystr := objstore.DbKeyString("BareMetalHost", key)
	return stm.Get(keystr) != ""
}

func (s *BareMetalHostStoreImpl) parseGetData(val []byte, buf *BareMetalHost) bool {
	if len(val) == 0 {
		return false
	}
	if buf != nil {
		// clear buf, because empty values in val won't
		// overwrite non-empty values in buf.
		*buf = BareMetalHost{}
		err := json.Unmarshal(val, buf)
		if err != nil {
			return false
		}
	}
	return true
}

func (s *BareMetalHostStoreImpl) STMPut(stm concurrency.STM, obj *BareMetalHost, ops ...objstore.KVOp) {
	keystr := objstore.DbKeyString("BareMetalHost", obj.GetKey())

	val, err := json.Marshal(obj)
	if err != nil {
		log.InfoLog("BareMetalHost json marshal failed", "obj", obj, "err", err)
	}
	v3opts := GetSTMOpts(ops...)
	stm.Put(keystr, string(val), v3opts...)
}

func (s *BareMetalHostStoreImpl) STMDel(stm concurrency.STM, key *BareMetalHostKey) {
	keystr := objstore.DbKeyString("BareMetalHost", key)
	stm.Del(keystr)
}

func StoreListBareMetalHost(ctx context.Context, kvstore objstore.KVStore) ([]BareMetalHost, error) {
	keyPrefix := objstore.DbKeyPrefixString("BareMetalHost") + "/"
	objs := []BareMetalHost{}
	err := kvstore.List(keyPrefix, func(key, val []byte, rev, modRev int64) error {
		obj := BareMetalHost{}
		err := json.Unmarshal(val, &obj)
		if err != nil {
			return fmt.Errorf("failed to unmarshal BareMetalHost json %s, %s", string(val), err)
		}
		objs = append(objs, obj)
		return nil
	})
	return objs, err
}

func (m *BareMetalHost) GetObjKey() objstore.ObjKey {
	return m.GetKey()
}

func (m *BareMetalHost) GetKey() *BareMetalHostKey {
	return &m.Key
}

func (m *BareMetalHost) GetKeyVal() BareMetalHostKey {
	return m.Key
}

func (m *BareMetalHost) SetKey(key *BareMetalHostKey) {
	m.Key = *key
}

func CmpSortBareMetalHost(a BareMetalHost, b BareMetalHost) bool {
	return a.Key.GetKeyString() < b.Key.GetKeyString()
}

// Helper method to check that enums have valid values
// NOTE: ValidateEnums checks all Fields even if some are not set
func (m *BareMetalHost) ValidateEnums() error {
	if err := m.Key.ValidateEnums(); err != nil {
		return err
	}
	if m.Resources != nil {
		if err := m.Resources.ValidateEnums(); err != nil {
			return err
		}
	}
	for _, e := range m.Nics {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (s *BareMetalHost) ClearTagged(tags map[string]struct{}) {
	s.Key.ClearTagged(tags)
	if s.Resources != nil {
		s.Resources.ClearTagged(tags)
	}
	if s.Nics != nil {
		for ii := 0; ii < len(s.Nics); ii++ {
			s.Nics[ii].ClearTagged(tags)
		}
	}
}

func (m *BareMetalHostNic) Clone() *BareMetalHostNic {
	cp := &BareMetalHostNic{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *BareMetalHostNic) CopyInFields(src *BareMetalHostNic) int {
	changed := 0
	if m.Name != src.Name {
		m.Name = src.Name
		changed++
	}
	if m.MacAddress != src.MacAddress {
		m.MacAddress = src.MacAddress
		changed++
	}
	if m.Ip != src.Ip {
		m.Ip = src.Ip
		changed++
	}
	if m.Model != src.Model {
		m.Model = src.Model
		changed++
	}
	return changed
}

func (m *BareMetalHostNic) DeepCopyIn(src *BareMetalHostNic) {
	m.Name = src.Name
	m.MacAddress = src.MacAddress
	m.Ip = src.Ip
	m.Model = src.Model
}

// Helper method to check that enums have valid values
func (m *BareMetalHostNic) ValidateEnums() error {
	return nil
}

func (s *BareMetalHostNic) ClearTagged(tags map[string]struct{}) {
}

func (m *BareMetalHostKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovBaremetalhost(uint64(l))
	}
	l = len(m.Organization)
	if l > 0 {
		n += 1 + l + sovBaremetalhost(uint64(l))
	}
	l = len(m.Cloudlet)
	if l > 0 {
		n += 1 + l + sovBaremetalhost(uint64(l))
	}
	return n
}

func (m *BareMetalHost) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovBaremetalhost(uint64(l))
		}
	}
	l = m.Key.Size()
	n += 1 + l + sovBaremetalhost(uint64(l))
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovBaremetalhost(uint64(l))
	}
	l = len(m.BootMacAddress)
	if l > 0 {
		n += 1 + l + sovBaremetalhost(uint64(l))
	}
	l = len(m.BootMode)
	if l > 0 {
		n += 1 + l + sovBaremetalhost(uint64(l))
	}
	l = len(m.BmcAddress)
	if l > 0 {
		n += 1 + l + sovBaremetalhost(uint64(l))
	}
	l = len(m.BmcUsername)
	if l > 0 {
		n += 1 + l + sovBaremetalhost(uint64(l))
	}
	l = len(m.BmcPassword)
	if l > 0 {
		n += 1 + l + sovBaremetalhost(uint64(l))
	}
	if m.BmcDisableCertVerification {
		n += 2
	}
	l = len(m.HardwareProfile)
	if l > 0 {
		n += 1 + l + sovBaremetalhost(uint64(l))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovBaremetalhost(uint64(len(k))) + 1 + len(v) + sovBaremetalhost(uint64(len(v)))
			n += mapEntrySize + 1 + sovBaremetalhost(uint64(mapEntrySize))
		}
	}
	if m.Resources != nil {
		l = m.Resources.Size()
		n += 1 + l + sovBaremetalhost(uint64(l))
	}
	if len(m.Nics) > 0 {
		for _, e := range m.Nics {
			l = e.Size()
			n += 1 + l + sovBaremetalhost(uint64(l))
		}
	}
	return n
}

func (m *BareMetalHostNic) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovBaremetalhost(uint64(l))
	}
	l = len(m.MacAddress)
	if l > 0 {
		n += 1 + l + sovBaremetalhost(uint64(l))
	}
	l = len(m.Ip)
	if l > 0 {
		n += 1 + l + sovBaremetalhost(uint64(l))
	}
	l = len(m.Model)
	if l > 0 {
		n += 1 + l + sovBaremetalhost(uint64(l))
	}
	return n
}

func sovBaremetalhost(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozBaremetalhost(x uint64) (n int) {
	return sovBaremetalhost(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *BareMetalHostKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaremetalhost
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BareMetalHostKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BareMetalHostKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaremetalhost
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBaremetalhost
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBaremetalhost
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Organization", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaremetalhost
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBaremetalhost
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBaremetalhost
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Organization = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cloudlet", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaremetalhost
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBaremetalhost
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBaremetalhost
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cloudlet = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBaremetalhost(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBaremetalhost
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BareMetalHost) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaremetalhost
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BareMetalHost: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BareMetalHost: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaremetalhost
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBaremetalhost
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBaremetalhost
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaremetalhost
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBaremetalhost
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBaremetalhost
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaremetalhost
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBaremetalhost
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBaremetalhost
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BootMacAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaremetalhost
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBaremetalhost
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBaremetalhost
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BootMacAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BootMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaremetalhost
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBaremetalhost
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBaremetalhost
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BootMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BmcAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaremetalhost
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBaremetalhost
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBaremetalhost
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BmcAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BmcUsername", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaremetalhost
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBaremetalhost
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBaremetalhost
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BmcUsername = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BmcPassword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaremetalhost
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBaremetalhost
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBaremetalhost
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BmcPassword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BmcDisableCertVerification", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaremetalhost
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BmcDisableCertVerification = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HardwareProfile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaremetalhost
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBaremetalhost
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBaremetalhost
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HardwareProfile = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaremetalhost
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBaremetalhost
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBaremetalhost
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBaremetalhost
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBaremetalhost
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthBaremetalhost
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthBaremetalhost
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBaremetalhost
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthBaremetalhost
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthBaremetalhost
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipBaremetalhost(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthBaremetalhost
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaremetalhost
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBaremetalhost
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBaremetalhost
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resources == nil {
				m.Resources = &FlavorInfo{}
			}
			if err := m.Resources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaremetalhost
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBaremetalhost
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBaremetalhost
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nics = append(m.Nics, &BareMetalHostNic{})
			if err := m.Nics[len(m.Nics)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBaremetalhost(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBaremetalhost
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BareMetalHostNic) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaremetalhost
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BareMetalHostNic: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BareMetalHostNic: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaremetalhost
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBaremetalhost
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBaremetalhost
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaremetalhost
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBaremetalhost
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBaremetalhost
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MacAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaremetalhost
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBaremetalhost
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBaremetalhost
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaremetalhost
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBaremetalhost
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBaremetalhost
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Model = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBaremetalhost(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBaremetalhost
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBaremetalhost(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBaremetalhost
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBaremetalhost
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBaremetalhost
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthBaremetalhost
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupBaremetalhost
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthBaremetalhost
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthBaremetalhost        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBaremetalhost          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupBaremetalhost = fmt.Errorf("proto: unexpected end of group")
)
