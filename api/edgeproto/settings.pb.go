// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: settings.proto

package edgeproto

import (
	context "context"
	encoding_binary "encoding/binary"
	"encoding/json"
	fmt "fmt"
	"github.com/edgexr/edge-cloud-platform/pkg/log"
	"github.com/edgexr/edge-cloud-platform/pkg/objstore"
	"github.com/edgexr/edge-cloud-platform/pkg/util"
	_ "github.com/edgexr/edge-cloud-platform/tools/protogen"
	_ "github.com/gogo/googleapis/google/api"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	"go.etcd.io/etcd/client/v3/concurrency"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Global settings
type Settings struct {
	// Fields are used for the Update API to specify which fields to apply
	Fields []string `protobuf:"bytes,1,rep,name=fields,proto3" json:"fields,omitempty"`
	// Shepherd metrics collection interval for k8s and docker appInstances (duration)
	ShepherdMetricsCollectionInterval Duration `protobuf:"varint,2,opt,name=shepherd_metrics_collection_interval,json=shepherdMetricsCollectionInterval,proto3,casttype=Duration" json:"shepherd_metrics_collection_interval,omitempty"`
	// Shepherd alert evaluation interval for k8s and docker appInstances (duration)
	ShepherdAlertEvaluationInterval Duration `protobuf:"varint,20,opt,name=shepherd_alert_evaluation_interval,json=shepherdAlertEvaluationInterval,proto3,casttype=Duration" json:"shepherd_alert_evaluation_interval,omitempty"`
	// Shepherd metrics scraping interval (how often metrics are pulled by prometheus, vs pushed to Controller by Shepherd collection)
	ShepherdMetricsScrapeInterval Duration `protobuf:"varint,40,opt,name=shepherd_metrics_scrape_interval,json=shepherdMetricsScrapeInterval,proto3,casttype=Duration" json:"shepherd_metrics_scrape_interval,omitempty"`
	// Number of times Shepherd Health Check fails before we mark appInst down
	ShepherdHealthCheckRetries int32 `protobuf:"varint,3,opt,name=shepherd_health_check_retries,json=shepherdHealthCheckRetries,proto3" json:"shepherd_health_check_retries,omitempty"`
	// Health Checking probing frequency (duration)
	ShepherdHealthCheckInterval Duration `protobuf:"varint,4,opt,name=shepherd_health_check_interval,json=shepherdHealthCheckInterval,proto3,casttype=Duration" json:"shepherd_health_check_interval,omitempty"`
	// Auto Provisioning Stats push and analysis interval (seconds)
	AutoDeployIntervalSec float64 `protobuf:"fixed64,5,opt,name=auto_deploy_interval_sec,json=autoDeployIntervalSec,proto3" json:"auto_deploy_interval_sec,omitempty"`
	// Auto Provisioning analysis offset from interval (seconds)
	AutoDeployOffsetSec float64 `protobuf:"fixed64,6,opt,name=auto_deploy_offset_sec,json=autoDeployOffsetSec,proto3" json:"auto_deploy_offset_sec,omitempty"`
	// Auto Provisioning Policy max allowed intervals
	AutoDeployMaxIntervals uint32 `protobuf:"varint,7,opt,name=auto_deploy_max_intervals,json=autoDeployMaxIntervals,proto3" json:"auto_deploy_max_intervals,omitempty"`
	// Create AppInst timeout (duration)
	CreateAppInstTimeout Duration `protobuf:"varint,8,opt,name=create_app_inst_timeout,json=createAppInstTimeout,proto3,casttype=Duration" json:"create_app_inst_timeout,omitempty"`
	// Update AppInst timeout (duration)
	UpdateAppInstTimeout Duration `protobuf:"varint,9,opt,name=update_app_inst_timeout,json=updateAppInstTimeout,proto3,casttype=Duration" json:"update_app_inst_timeout,omitempty"`
	// Delete AppInst timeout (duration)
	DeleteAppInstTimeout Duration `protobuf:"varint,10,opt,name=delete_app_inst_timeout,json=deleteAppInstTimeout,proto3,casttype=Duration" json:"delete_app_inst_timeout,omitempty"`
	// Create ClusterInst timeout (duration)
	CreateClusterInstTimeout Duration `protobuf:"varint,11,opt,name=create_cluster_inst_timeout,json=createClusterInstTimeout,proto3,casttype=Duration" json:"create_cluster_inst_timeout,omitempty"`
	// Update ClusterInst timeout (duration)
	UpdateClusterInstTimeout Duration `protobuf:"varint,12,opt,name=update_cluster_inst_timeout,json=updateClusterInstTimeout,proto3,casttype=Duration" json:"update_cluster_inst_timeout,omitempty"`
	// Delete ClusterInst timeout (duration)
	DeleteClusterInstTimeout Duration `protobuf:"varint,13,opt,name=delete_cluster_inst_timeout,json=deleteClusterInstTimeout,proto3,casttype=Duration" json:"delete_cluster_inst_timeout,omitempty"`
	// Default flavor for k8s master VM and > 0  workers
	MasterNodeFlavor string `protobuf:"bytes,14,opt,name=master_node_flavor,json=masterNodeFlavor,proto3" json:"master_node_flavor,omitempty"`
	// Max DME clients to be tracked at the same time.
	MaxTrackedDmeClients int32 `protobuf:"varint,16,opt,name=max_tracked_dme_clients,json=maxTrackedDmeClients,proto3" json:"max_tracked_dme_clients,omitempty"`
	// Default chef client interval (duration)
	ChefClientInterval Duration `protobuf:"varint,17,opt,name=chef_client_interval,json=chefClientInterval,proto3,casttype=Duration" json:"chef_client_interval,omitempty"`
	// Default influxDB metrics retention policy (duration)
	InfluxDbMetricsRetention Duration `protobuf:"varint,18,opt,name=influx_db_metrics_retention,json=influxDbMetricsRetention,proto3,casttype=Duration" json:"influx_db_metrics_retention,omitempty"`
	// Default Cloudlet Maintenance timeout (used twice for AutoProv and Cloudlet)
	CloudletMaintenanceTimeout Duration `protobuf:"varint,19,opt,name=cloudlet_maintenance_timeout,json=cloudletMaintenanceTimeout,proto3,casttype=Duration" json:"cloudlet_maintenance_timeout,omitempty"`
	// Update VM pool timeout (duration)
	UpdateVmPoolTimeout Duration `protobuf:"varint,21,opt,name=update_vm_pool_timeout,json=updateVmPoolTimeout,proto3,casttype=Duration" json:"update_vm_pool_timeout,omitempty"`
	// Update Trust Policy timeout (duration)
	UpdateTrustPolicyTimeout Duration `protobuf:"varint,22,opt,name=update_trust_policy_timeout,json=updateTrustPolicyTimeout,proto3,casttype=Duration" json:"update_trust_policy_timeout,omitempty"`
	// Metrics collection interval for DME API counts (duration)
	DmeApiMetricsCollectionInterval Duration `protobuf:"varint,23,opt,name=dme_api_metrics_collection_interval,json=dmeApiMetricsCollectionInterval,proto3,casttype=Duration" json:"dme_api_metrics_collection_interval,omitempty"`
	// Collection interval for edgeevents metrics (latency, device, and custom)
	EdgeEventsMetricsCollectionInterval Duration `protobuf:"varint,24,opt,name=edge_events_metrics_collection_interval,json=edgeEventsMetricsCollectionInterval,proto3,casttype=Duration" json:"edge_events_metrics_collection_interval,omitempty"`
	// Idle reservable ClusterInst clean up time
	CleanupReservableAutoClusterIdletime Duration `protobuf:"varint,25,opt,name=cleanup_reservable_auto_cluster_idletime,json=cleanupReservableAutoClusterIdletime,proto3,casttype=Duration" json:"cleanup_reservable_auto_cluster_idletime,omitempty"`
	// Default influxDB cloudlet usage metrics retention policy (duration)
	InfluxDbCloudletUsageMetricsRetention Duration `protobuf:"varint,26,opt,name=influx_db_cloudlet_usage_metrics_retention,json=influxDbCloudletUsageMetricsRetention,proto3,casttype=Duration" json:"influx_db_cloudlet_usage_metrics_retention,omitempty"`
	// Create Cloudlet timeout (duration)
	CreateCloudletTimeout Duration `protobuf:"varint,27,opt,name=create_cloudlet_timeout,json=createCloudletTimeout,proto3,casttype=Duration" json:"create_cloudlet_timeout,omitempty"`
	// Update Cloudlet timeout (duration)
	UpdateCloudletTimeout Duration `protobuf:"varint,28,opt,name=update_cloudlet_timeout,json=updateCloudletTimeout,proto3,casttype=Duration" json:"update_cloudlet_timeout,omitempty"`
	// Length of location tiles side for latency metrics (km)
	LocationTileSideLengthKm int64 `protobuf:"varint,29,opt,name=location_tile_side_length_km,json=locationTileSideLengthKm,proto3" json:"location_tile_side_length_km,omitempty"`
	// List of collection intervals for Continuous Queries for EdgeEvents metrics
	EdgeEventsMetricsContinuousQueriesCollectionIntervals []*CollectionInterval `protobuf:"bytes,30,rep,name=edge_events_metrics_continuous_queries_collection_intervals,json=edgeEventsMetricsContinuousQueriesCollectionIntervals,proto3" json:"edge_events_metrics_continuous_queries_collection_intervals,omitempty"`
	// Default retention policy for downsampled influx db (duration)
	InfluxDbDownsampledMetricsRetention Duration `protobuf:"varint,31,opt,name=influx_db_downsampled_metrics_retention,json=influxDbDownsampledMetricsRetention,proto3,casttype=Duration" json:"influx_db_downsampled_metrics_retention,omitempty"`
	// Default retention policy for edgeevents metrics influx db (duration)
	InfluxDbEdgeEventsMetricsRetention Duration `protobuf:"varint,32,opt,name=influx_db_edge_events_metrics_retention,json=influxDbEdgeEventsMetricsRetention,proto3,casttype=Duration" json:"influx_db_edge_events_metrics_retention,omitempty"`
	// AppInstClient cleanup thread run interval
	AppinstClientCleanupInterval Duration `protobuf:"varint,33,opt,name=appinst_client_cleanup_interval,json=appinstClientCleanupInterval,proto3,casttype=Duration" json:"appinst_client_cleanup_interval,omitempty"`
	// Cluster auto scale averaging duration for stats to avoid spikes (seconds), avoid setting below 30s or it will not capture any measurements to average
	ClusterAutoScaleAveragingDurationSec int64 `protobuf:"varint,34,opt,name=cluster_auto_scale_averaging_duration_sec,json=clusterAutoScaleAveragingDurationSec,proto3" json:"cluster_auto_scale_averaging_duration_sec,omitempty"`
	// Cluster auto scale retry delay if scaling failed
	ClusterAutoScaleRetryDelay Duration `protobuf:"varint,35,opt,name=cluster_auto_scale_retry_delay,json=clusterAutoScaleRetryDelay,proto3,casttype=Duration" json:"cluster_auto_scale_retry_delay,omitempty"`
	// Minimmum trigger time for alert policies
	AlertPolicyMinTriggerTime Duration `protobuf:"varint,36,opt,name=alert_policy_min_trigger_time,json=alertPolicyMinTriggerTime,proto3,casttype=Duration" json:"alert_policy_min_trigger_time,omitempty"`
	// Disable rate limiting for APIs (default is false)
	DisableRateLimit bool `protobuf:"varint,37,opt,name=disable_rate_limit,json=disableRateLimit,proto3" json:"disable_rate_limit,omitempty"`
	// Maximum number of IPs to track for rate limiting
	RateLimitMaxTrackedIps int64 `protobuf:"varint,39,opt,name=rate_limit_max_tracked_ips,json=rateLimitMaxTrackedIps,proto3" json:"rate_limit_max_tracked_ips,omitempty"`
	// ResourceSnapshot Refresh thread run interval
	ResourceSnapshotThreadInterval Duration `protobuf:"varint,41,opt,name=resource_snapshot_thread_interval,json=resourceSnapshotThreadInterval,proto3,casttype=Duration" json:"resource_snapshot_thread_interval,omitempty"`
	// Platform HA instance poll interval
	PlatformHaInstancePollInterval Duration `protobuf:"varint,42,opt,name=platform_ha_instance_poll_interval,json=platformHaInstancePollInterval,proto3,casttype=Duration" json:"platform_ha_instance_poll_interval,omitempty"`
	// Platform HA instance active time
	PlatformHaInstanceActiveExpireTime Duration `protobuf:"varint,43,opt,name=platform_ha_instance_active_expire_time,json=platformHaInstanceActiveExpireTime,proto3,casttype=Duration" json:"platform_ha_instance_active_expire_time,omitempty"`
	// Timeout for controller platform-specific API calls to CCRM
	CcrmRedisapiTimeout Duration `protobuf:"varint,44,opt,name=ccrm_redisapi_timeout,json=ccrmRedisapiTimeout,proto3,casttype=Duration" json:"ccrm_redisapi_timeout,omitempty"`
}

func (m *Settings) Reset()         { *m = Settings{} }
func (m *Settings) String() string { return proto.CompactTextString(m) }
func (*Settings) ProtoMessage()    {}
func (*Settings) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c7cab62fa432213, []int{0}
}
func (m *Settings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Settings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Settings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Settings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Settings.Merge(m, src)
}
func (m *Settings) XXX_Size() int {
	return m.Size()
}
func (m *Settings) XXX_DiscardUnknown() {
	xxx_messageInfo_Settings.DiscardUnknown(m)
}

var xxx_messageInfo_Settings proto.InternalMessageInfo

// Collection interval for Influxdb (Specifically used for cq intervals, because cannot gogoproto.casttype to Duration for repeated fields otherwise)
type CollectionInterval struct {
	// Collection interval for Influxdb (Specifically used for continuous query intervals) (Data from old continuous queries will be inaccessible if intervals are updated)
	Interval Duration `protobuf:"varint,1,opt,name=interval,proto3,casttype=Duration" json:"interval,omitempty"`
	// Retention duration for Influxdb interval (0 uses default retention policy)
	Retention Duration `protobuf:"varint,2,opt,name=retention,proto3,casttype=Duration" json:"retention,omitempty"`
}

func (m *CollectionInterval) Reset()         { *m = CollectionInterval{} }
func (m *CollectionInterval) String() string { return proto.CompactTextString(m) }
func (*CollectionInterval) ProtoMessage()    {}
func (*CollectionInterval) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c7cab62fa432213, []int{1}
}
func (m *CollectionInterval) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollectionInterval) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CollectionInterval.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CollectionInterval) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollectionInterval.Merge(m, src)
}
func (m *CollectionInterval) XXX_Size() int {
	return m.Size()
}
func (m *CollectionInterval) XXX_DiscardUnknown() {
	xxx_messageInfo_CollectionInterval.DiscardUnknown(m)
}

var xxx_messageInfo_CollectionInterval proto.InternalMessageInfo

func init() {
	proto.RegisterType((*Settings)(nil), "edgeproto.Settings")
	proto.RegisterType((*CollectionInterval)(nil), "edgeproto.CollectionInterval")
}

func init() { proto.RegisterFile("settings.proto", fileDescriptor_6c7cab62fa432213) }

var fileDescriptor_6c7cab62fa432213 = []byte{
	// 1533 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x57, 0x4d, 0x6f, 0x1b, 0xc7,
	0x19, 0xd6, 0x5a, 0x8e, 0x2b, 0x8d, 0x65, 0x45, 0x59, 0x7d, 0x78, 0x4d, 0x51, 0x14, 0x4d, 0x2b,
	0x30, 0xa3, 0x08, 0x26, 0x90, 0x20, 0x08, 0xaa, 0x00, 0x41, 0x19, 0x52, 0x45, 0x54, 0x45, 0xae,
	0xb2, 0x94, 0x93, 0xb6, 0x40, 0x31, 0x18, 0xed, 0xbe, 0x5c, 0x4e, 0x3d, 0xbb, 0xb3, 0xd9, 0x99,
	0xd5, 0xc7, 0xad, 0xe8, 0x2f, 0x30, 0xd0, 0x53, 0xd1, 0x7f, 0xd1, 0x5f, 0xe1, 0xa3, 0x81, 0x5e,
	0x7a, 0x2a, 0x5a, 0xbb, 0x87, 0xc2, 0xe8, 0xa1, 0xa8, 0xe5, 0xa2, 0xe8, 0xa9, 0x98, 0xd9, 0xdd,
	0xa1, 0x24, 0x8e, 0x8d, 0xe6, 0x46, 0xce, 0x3c, 0xcf, 0xf3, 0xbe, 0x33, 0xef, 0xd7, 0x2c, 0x9a,
	0x17, 0x20, 0x25, 0x4d, 0x22, 0xf1, 0x20, 0xcd, 0xb8, 0xe4, 0xee, 0x2c, 0x84, 0x11, 0xe8, 0x9f,
	0xb5, 0xb9, 0x0c, 0x44, 0xce, 0x64, 0xb1, 0x51, 0xab, 0x47, 0x9c, 0x47, 0x0c, 0x3a, 0x24, 0xa5,
	0x1d, 0x92, 0x24, 0x5c, 0x12, 0x49, 0x79, 0x52, 0xd2, 0x6a, 0x6b, 0x92, 0x73, 0x26, 0x3a, 0xfa,
	0x4f, 0x04, 0x89, 0xf9, 0x51, 0x6e, 0x2f, 0x45, 0x3c, 0xe2, 0xfa, 0x67, 0x47, 0xfd, 0x2a, 0x56,
	0x5b, 0xbf, 0xaf, 0xa1, 0x99, 0x41, 0x69, 0xde, 0x5d, 0x41, 0x37, 0x86, 0x14, 0x58, 0x28, 0x3c,
	0xa7, 0x39, 0xdd, 0x9e, 0xf5, 0xcb, 0x7f, 0xee, 0x2f, 0xd1, 0x86, 0x18, 0x41, 0x3a, 0x82, 0x2c,
	0xc4, 0x31, 0xc8, 0x8c, 0x06, 0x02, 0x07, 0x9c, 0x31, 0x08, 0x94, 0x7d, 0x4c, 0x13, 0x09, 0xd9,
	0x31, 0x61, 0xde, 0xb5, 0xa6, 0xd3, 0x9e, 0xfe, 0x62, 0xee, 0xbf, 0x7f, 0x5e, 0x9f, 0xe9, 0xe7,
	0x99, 0x76, 0xce, 0xbf, 0x5b, 0x31, 0xf7, 0x0b, 0x62, 0xcf, 0xf0, 0x76, 0x4b, 0x9a, 0xfb, 0x73,
	0xd4, 0x32, 0xf2, 0x84, 0x41, 0x26, 0x31, 0x1c, 0x13, 0x96, 0x93, 0xcb, 0xe2, 0x4b, 0x16, 0xf1,
	0xf5, 0x8a, 0xd7, 0x55, 0xb4, 0x1d, 0xc3, 0x32, 0xd2, 0x8f, 0x50, 0x73, 0xc2, 0x73, 0x11, 0x64,
	0x24, 0x85, 0xb1, 0x70, 0xdb, 0x22, 0xbc, 0x76, 0xc5, 0xeb, 0x81, 0xe6, 0x18, 0xd9, 0x2e, 0x32,
	0x00, 0x3c, 0x02, 0xc2, 0xe4, 0x08, 0x07, 0x23, 0x08, 0x1e, 0xe3, 0x4c, 0xc1, 0x41, 0x78, 0xd3,
	0x4d, 0xa7, 0xfd, 0x8e, 0x5f, 0xab, 0x40, 0x5f, 0x6a, 0x4c, 0x4f, 0x41, 0xfc, 0x02, 0xe1, 0x7e,
	0x8d, 0x1a, 0x76, 0x09, 0xe3, 0xd7, 0x75, 0x8b, 0x5f, 0xab, 0x16, 0x45, 0xe3, 0xd5, 0xa7, 0xc8,
	0x23, 0xb9, 0xe4, 0x38, 0x84, 0x94, 0xf1, 0x33, 0x23, 0x84, 0x05, 0x04, 0xde, 0x3b, 0x4d, 0xa7,
	0xed, 0xf8, 0xcb, 0x6a, 0xbf, 0xaf, 0xb7, 0x2b, 0xd6, 0x00, 0x02, 0xf7, 0x63, 0xb4, 0x72, 0x91,
	0xc8, 0x87, 0x43, 0x01, 0x52, 0xd3, 0x6e, 0x68, 0xda, 0xe2, 0x98, 0xf6, 0x53, 0xbd, 0xa7, 0x48,
	0x3f, 0x44, 0x77, 0x2e, 0x92, 0x62, 0x72, 0x6a, 0x2c, 0x0a, 0xef, 0x07, 0x4d, 0xa7, 0x7d, 0xcb,
	0x5f, 0x19, 0xf3, 0xf6, 0xc9, 0x69, 0x65, 0x51, 0xb8, 0x3d, 0x74, 0x3b, 0xc8, 0x80, 0x48, 0xc0,
	0x24, 0x4d, 0x31, 0x4d, 0x84, 0xc4, 0x92, 0xc6, 0xc0, 0x73, 0xe9, 0xcd, 0x58, 0x0e, 0xbd, 0x54,
	0x80, 0xbb, 0x69, 0xba, 0x9b, 0x08, 0x79, 0x58, 0x20, 0x95, 0x48, 0x9e, 0x86, 0x56, 0x91, 0x59,
	0x9b, 0x48, 0x01, 0x9e, 0x14, 0x09, 0x81, 0x81, 0x4d, 0x04, 0xd9, 0x44, 0x0a, 0xf0, 0x15, 0x91,
	0x3d, 0xb4, 0x5a, 0x1e, 0x27, 0x60, 0xb9, 0x90, 0x90, 0x5d, 0x16, 0xba, 0x69, 0x11, 0xf2, 0x0a,
	0x42, 0xaf, 0xc0, 0x5f, 0x11, 0x2b, 0x8f, 0x65, 0x15, 0x9b, 0xb3, 0x89, 0x15, 0x04, 0xbb, 0x58,
	0x79, 0x3c, 0xab, 0xd8, 0x2d, 0x9b, 0x58, 0x41, 0xb0, 0x88, 0x6d, 0x21, 0x37, 0x26, 0x5a, 0x24,
	0xe1, 0x21, 0xe0, 0x21, 0x23, 0xc7, 0x3c, 0xf3, 0xe6, 0x9b, 0x4e, 0x7b, 0xd6, 0x5f, 0x28, 0x76,
	0x1e, 0xf2, 0x10, 0x7e, 0xac, 0xd7, 0xdd, 0x4f, 0xd0, 0x6d, 0x95, 0x12, 0x32, 0x23, 0xc1, 0x63,
	0x08, 0x71, 0x18, 0x2b, 0x1f, 0x28, 0x24, 0x52, 0x78, 0x0b, 0xba, 0x38, 0x96, 0x62, 0x72, 0x7a,
	0x58, 0xec, 0xf6, 0x63, 0xe8, 0x15, 0x7b, 0xee, 0xe7, 0x68, 0x29, 0x18, 0xc1, 0xb0, 0xc4, 0x8e,
	0x8b, 0xe1, 0x3d, 0xc5, 0xb9, 0xe2, 0xaa, 0xab, 0x90, 0x05, 0xd1, 0xd4, 0xc0, 0x1e, 0x5a, 0xa5,
	0xc9, 0x90, 0xe5, 0xa7, 0x38, 0x3c, 0x32, 0x15, 0x9f, 0x81, 0x84, 0x44, 0x51, 0x3c, 0xd7, 0x76,
	0xe2, 0x82, 0xd0, 0x3f, 0x2a, 0x6b, 0xdd, 0xaf, 0xd0, 0xee, 0x43, 0x54, 0x0f, 0x18, 0xcf, 0x43,
	0x06, 0x12, 0xc7, 0x44, 0xf9, 0x92, 0x90, 0x24, 0x00, 0x73, 0x7f, 0x8b, 0x16, 0xa7, 0x6a, 0x15,
	0x63, 0x7f, 0x4c, 0xa8, 0x6e, 0xb0, 0x8b, 0x56, 0xca, 0xd8, 0x1e, 0xc7, 0x38, 0xe5, 0x9c, 0x19,
	0xa5, 0x65, 0x8b, 0x5f, 0x8b, 0x05, 0xf6, 0x9b, 0xf8, 0x80, 0x73, 0x36, 0x99, 0x1e, 0x32, 0xcb,
	0x85, 0xc4, 0x29, 0x67, 0x34, 0x38, 0x33, 0x3a, 0x2b, 0x6f, 0x4e, 0x8f, 0x43, 0x85, 0x3f, 0xd0,
	0xf0, 0x4a, 0xec, 0x17, 0xe8, 0x9e, 0x8a, 0x0b, 0x49, 0xe9, 0x5b, 0xdb, 0xfa, 0x6d, 0x5b, 0xe7,
	0x0d, 0x63, 0xe8, 0xa6, 0xf4, 0xcd, 0x4d, 0xfd, 0x08, 0xdd, 0x57, 0x63, 0x0c, 0xc3, 0xb1, 0x8a,
	0xeb, 0x5b, 0xf5, 0x3d, 0x8b, 0xfe, 0x3d, 0x45, 0xde, 0xd1, 0xdc, 0x37, 0xdb, 0x08, 0x51, 0x3b,
	0x60, 0x40, 0x92, 0x3c, 0xc5, 0x19, 0x08, 0xb5, 0x76, 0xc4, 0x00, 0xeb, 0xae, 0x64, 0xf2, 0x5d,
	0x85, 0x82, 0xc6, 0xe0, 0xdd, 0xb1, 0x18, 0xd9, 0x28, 0xd9, 0xbe, 0x21, 0x77, 0x73, 0xc9, 0xab,
	0xd4, 0x2f, 0x99, 0x6e, 0x84, 0x36, 0xc7, 0x29, 0x65, 0xf2, 0x21, 0x17, 0x24, 0x02, 0x4b, 0x86,
	0xd5, 0x2c, 0x76, 0xde, 0xaf, 0x32, 0xac, 0x57, 0xb2, 0x1f, 0x29, 0xf2, 0x44, 0xba, 0xf5, 0x4d,
	0x5b, 0x34, 0x56, 0xaa, 0xb8, 0xae, 0x5a, 0x54, 0x97, 0xab, 0x1e, 0x52, 0x60, 0xab, 0xa0, 0xf6,
	0x4d, 0x5f, 0x9c, 0x50, 0xa9, 0xdb, 0x54, 0xaa, 0xe6, 0x71, 0x59, 0xe5, 0x73, 0x54, 0x67, 0x3c,
	0x28, 0x46, 0xb0, 0xa4, 0x0c, 0xb0, 0xa0, 0x21, 0x60, 0x06, 0x49, 0x24, 0x47, 0xf8, 0x71, 0xec,
	0xad, 0x29, 0x29, 0xdf, 0xab, 0x30, 0x87, 0x94, 0xc1, 0x80, 0x86, 0xf0, 0x95, 0x06, 0xec, 0xc5,
	0xee, 0xef, 0x1c, 0xf4, 0x99, 0x3d, 0xfe, 0x89, 0xa4, 0x49, 0xce, 0x73, 0x81, 0xbf, 0xcb, 0x41,
	0x4d, 0x42, 0x5b, 0x4a, 0x08, 0xaf, 0xd1, 0x9c, 0x6e, 0xdf, 0xfc, 0x68, 0xed, 0x81, 0x79, 0x0a,
	0x3d, 0x98, 0x8c, 0xbf, 0xff, 0x89, 0x25, 0x49, 0x2a, 0xf9, 0xaf, 0x0b, 0xf5, 0x49, 0x96, 0x50,
	0xa9, 0x39, 0x0e, 0x68, 0xc8, 0x4f, 0x12, 0x41, 0xe2, 0x94, 0x41, 0x68, 0x89, 0xe6, 0xba, 0x2d,
	0x35, 0xab, 0x68, 0xf6, 0xc7, 0xd4, 0x89, 0x58, 0x92, 0x8b, 0x36, 0x6c, 0x17, 0x31, 0xb6, 0xd1,
	0xb4, 0xd8, 0x68, 0x55, 0x36, 0x76, 0xae, 0x9e, 0x70, 0x6c, 0x62, 0x80, 0xd6, 0x49, 0x9a, 0xea,
	0x86, 0x5e, 0x76, 0xcb, 0xaa, 0x18, 0x4c, 0x65, 0xdd, 0xb5, 0x48, 0xd7, 0x4b, 0x52, 0xd1, 0x38,
	0x7b, 0x05, 0xc5, 0x94, 0xd4, 0xb7, 0xe8, 0x83, 0xaa, 0x74, 0x74, 0x1d, 0x89, 0x80, 0xa8, 0x92,
	0x3a, 0x86, 0x8c, 0x44, 0x34, 0x89, 0x70, 0x58, 0xca, 0xe8, 0xd7, 0x41, 0x4b, 0x27, 0xc1, 0x46,
	0x49, 0x50, 0xb5, 0x33, 0x50, 0xf0, 0x6e, 0x85, 0xae, 0x6c, 0xaa, 0xe7, 0xc2, 0x01, 0x6a, 0x58,
	0x84, 0xd5, 0x7b, 0xe9, 0x0c, 0x87, 0xc0, 0xc8, 0x99, 0x77, 0xcf, 0xe2, 0x6c, 0xed, 0xaa, 0xb6,
	0x7a, 0x3e, 0x9d, 0xf5, 0x15, 0xde, 0x7d, 0x88, 0xd6, 0x8a, 0xd7, 0x62, 0xd9, 0x03, 0x63, 0x9a,
	0x60, 0x99, 0xd1, 0x28, 0x82, 0x4c, 0x67, 0xbc, 0xb7, 0x61, 0x11, 0xbc, 0xa3, 0x29, 0x45, 0x1b,
	0xdc, 0xa7, 0xc9, 0x61, 0x81, 0x57, 0x59, 0xaf, 0xe6, 0x5b, 0x48, 0x85, 0x6e, 0x21, 0x99, 0x2a,
	0x1f, 0x46, 0x63, 0x2a, 0xbd, 0xf7, 0x9b, 0x4e, 0x7b, 0xc6, 0x5f, 0x28, 0x77, 0x7c, 0x22, 0xe1,
	0x2b, 0xb5, 0xee, 0x6e, 0xa3, 0xda, 0x18, 0x85, 0x2f, 0x8e, 0x3a, 0x9a, 0x0a, 0xef, 0xbe, 0xbe,
	0x99, 0x95, 0xac, 0x82, 0xef, 0x9b, 0x59, 0xb7, 0x9b, 0x0a, 0xf7, 0x5b, 0x74, 0x37, 0x03, 0xc1,
	0xf3, 0x2c, 0x00, 0x2c, 0x12, 0x92, 0x8a, 0x11, 0x97, 0x58, 0x8e, 0x32, 0x20, 0xe1, 0x38, 0x76,
	0x1f, 0x58, 0xbc, 0x6f, 0x54, 0xb4, 0x41, 0xc9, 0x3a, 0xd4, 0x24, 0x13, 0xbd, 0x9f, 0xa1, 0x56,
	0xca, 0x88, 0x1c, 0xf2, 0x2c, 0xc6, 0x23, 0xa2, 0x87, 0xbd, 0x1e, 0x58, 0x29, 0x67, 0x6c, 0xac,
	0xbc, 0x69, 0x53, 0xae, 0x78, 0x5f, 0x92, 0xdd, 0x92, 0x75, 0xc0, 0x19, 0x33, 0xca, 0x04, 0xdd,
	0xb7, 0x2a, 0x93, 0x40, 0xd2, 0x63, 0xc0, 0x70, 0x9a, 0xd2, 0xac, 0x18, 0x8c, 0xde, 0x87, 0xb6,
	0x7c, 0x9e, 0x94, 0xef, 0x6a, 0xe6, 0x8e, 0x26, 0xea, 0xfb, 0xff, 0x11, 0x5a, 0x0e, 0x82, 0x2c,
	0xc6, 0x19, 0xa8, 0xcb, 0x4e, 0xa9, 0x69, 0x5b, 0x5b, 0xb6, 0xe1, 0xa8, 0xa0, 0x7e, 0x89, 0x2c,
	0x9b, 0xd6, 0xf6, 0x87, 0x7f, 0x7f, 0xe5, 0x39, 0xff, 0x7c, 0xe5, 0x39, 0xbf, 0x3e, 0xf7, 0x9c,
	0x27, 0xe7, 0x9e, 0xf3, 0xaf, 0xd7, 0xde, 0xcd, 0xea, 0xeb, 0x66, 0x0f, 0xce, 0xfe, 0xf3, 0xda,
	0x73, 0xfe, 0xf0, 0x6f, 0xef, 0x7a, 0xc2, 0x13, 0xf8, 0xc9, 0xf5, 0x99, 0x77, 0x17, 0x16, 0xfc,
	0x3a, 0xe3, 0x24, 0xc4, 0x47, 0x84, 0x29, 0x97, 0x32, 0x1d, 0xc7, 0x94, 0x67, 0x12, 0x67, 0x24,
	0x89, 0xa0, 0xf5, 0x2b, 0xe4, 0x5a, 0xc6, 0x4e, 0x1b, 0xcd, 0x98, 0xbb, 0x74, 0x2c, 0xbe, 0x99,
	0x5d, 0x77, 0x13, 0xcd, 0x8e, 0xeb, 0xdc, 0xf6, 0x75, 0x34, 0xde, 0xfe, 0xe8, 0x1f, 0xd7, 0x90,
	0xf1, 0xb5, 0x9b, 0x52, 0x37, 0x47, 0xf3, 0x8f, 0x74, 0x6b, 0x36, 0x9f, 0x67, 0x8b, 0x17, 0xba,
	0x61, 0xb5, 0x58, 0x7b, 0xef, 0xc2, 0xa2, 0xaf, 0x3f, 0x16, 0x5b, 0x9f, 0xbd, 0x3c, 0xf7, 0xea,
	0x7e, 0x99, 0x29, 0x3d, 0x9e, 0x0c, 0x69, 0xb4, 0xd5, 0xd5, 0x47, 0xd8, 0x27, 0x09, 0x89, 0x60,
	0xeb, 0x37, 0x7f, 0xfc, 0xdb, 0x6f, 0xaf, 0x2d, 0xb7, 0x16, 0x3a, 0x45, 0xef, 0xef, 0x54, 0xdf,
	0x9f, 0xdb, 0xce, 0xa6, 0x2b, 0xd0, 0x2d, 0x35, 0x0e, 0xe5, 0xf7, 0xb6, 0xba, 0xfd, 0x7f, 0x59,
	0x5d, 0x6a, 0xbd, 0xdb, 0x51, 0xb3, 0x5a, 0x5e, 0x32, 0xfa, 0x1d, 0x9a, 0x1b, 0x8c, 0xf8, 0xc9,
	0xdb, 0x6d, 0xda, 0x16, 0x5b, 0x9f, 0xbe, 0x3c, 0xf7, 0x6a, 0x56, 0xab, 0xdf, 0x50, 0x38, 0x29,
	0x6c, 0x2e, 0xb6, 0xe6, 0x3b, 0x62, 0xc4, 0x4f, 0x2e, 0x9a, 0xfc, 0xa2, 0xfe, 0xf4, 0xaf, 0x8d,
	0xa9, 0xa7, 0xcf, 0x1b, 0xce, 0xb3, 0xe7, 0x0d, 0xe7, 0x2f, 0xcf, 0x1b, 0xce, 0x93, 0x17, 0x8d,
	0xa9, 0x67, 0x2f, 0x1a, 0x53, 0x7f, 0x7a, 0xd1, 0x98, 0x3a, 0xba, 0xa1, 0xcd, 0x7c, 0xfc, 0xbf,
	0x00, 0x00, 0x00, 0xff, 0xff, 0x72, 0xea, 0x39, 0xdf, 0x9b, 0x0f, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// SettingsApiClient is the client API for SettingsApi service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type SettingsApiClient interface {
	// Update settings
	UpdateSettings(ctx context.Context, in *Settings, opts ...grpc.CallOption) (*Result, error)
	// Reset all settings to their defaults
	ResetSettings(ctx context.Context, in *Settings, opts ...grpc.CallOption) (*Result, error)
	// Show settings
	ShowSettings(ctx context.Context, in *Settings, opts ...grpc.CallOption) (*Settings, error)
}

type settingsApiClient struct {
	cc *grpc.ClientConn
}

func NewSettingsApiClient(cc *grpc.ClientConn) SettingsApiClient {
	return &settingsApiClient{cc}
}

func (c *settingsApiClient) UpdateSettings(ctx context.Context, in *Settings, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/edgeproto.SettingsApi/UpdateSettings", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *settingsApiClient) ResetSettings(ctx context.Context, in *Settings, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/edgeproto.SettingsApi/ResetSettings", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *settingsApiClient) ShowSettings(ctx context.Context, in *Settings, opts ...grpc.CallOption) (*Settings, error) {
	out := new(Settings)
	err := c.cc.Invoke(ctx, "/edgeproto.SettingsApi/ShowSettings", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SettingsApiServer is the server API for SettingsApi service.
type SettingsApiServer interface {
	// Update settings
	UpdateSettings(context.Context, *Settings) (*Result, error)
	// Reset all settings to their defaults
	ResetSettings(context.Context, *Settings) (*Result, error)
	// Show settings
	ShowSettings(context.Context, *Settings) (*Settings, error)
}

// UnimplementedSettingsApiServer can be embedded to have forward compatible implementations.
type UnimplementedSettingsApiServer struct {
}

func (*UnimplementedSettingsApiServer) UpdateSettings(ctx context.Context, req *Settings) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSettings not implemented")
}
func (*UnimplementedSettingsApiServer) ResetSettings(ctx context.Context, req *Settings) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetSettings not implemented")
}
func (*UnimplementedSettingsApiServer) ShowSettings(ctx context.Context, req *Settings) (*Settings, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ShowSettings not implemented")
}

func RegisterSettingsApiServer(s *grpc.Server, srv SettingsApiServer) {
	s.RegisterService(&_SettingsApi_serviceDesc, srv)
}

func _SettingsApi_UpdateSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Settings)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SettingsApiServer).UpdateSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.SettingsApi/UpdateSettings",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SettingsApiServer).UpdateSettings(ctx, req.(*Settings))
	}
	return interceptor(ctx, in, info, handler)
}

func _SettingsApi_ResetSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Settings)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SettingsApiServer).ResetSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.SettingsApi/ResetSettings",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SettingsApiServer).ResetSettings(ctx, req.(*Settings))
	}
	return interceptor(ctx, in, info, handler)
}

func _SettingsApi_ShowSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Settings)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SettingsApiServer).ShowSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.SettingsApi/ShowSettings",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SettingsApiServer).ShowSettings(ctx, req.(*Settings))
	}
	return interceptor(ctx, in, info, handler)
}

var _SettingsApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "edgeproto.SettingsApi",
	HandlerType: (*SettingsApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UpdateSettings",
			Handler:    _SettingsApi_UpdateSettings_Handler,
		},
		{
			MethodName: "ResetSettings",
			Handler:    _SettingsApi_ResetSettings_Handler,
		},
		{
			MethodName: "ShowSettings",
			Handler:    _SettingsApi_ShowSettings_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "settings.proto",
}

func (m *Settings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Settings) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Settings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CcrmRedisapiTimeout != 0 {
		i = encodeVarintSettings(dAtA, i, uint64(m.CcrmRedisapiTimeout))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe0
	}
	if m.PlatformHaInstanceActiveExpireTime != 0 {
		i = encodeVarintSettings(dAtA, i, uint64(m.PlatformHaInstanceActiveExpireTime))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd8
	}
	if m.PlatformHaInstancePollInterval != 0 {
		i = encodeVarintSettings(dAtA, i, uint64(m.PlatformHaInstancePollInterval))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd0
	}
	if m.ResourceSnapshotThreadInterval != 0 {
		i = encodeVarintSettings(dAtA, i, uint64(m.ResourceSnapshotThreadInterval))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc8
	}
	if m.ShepherdMetricsScrapeInterval != 0 {
		i = encodeVarintSettings(dAtA, i, uint64(m.ShepherdMetricsScrapeInterval))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc0
	}
	if m.RateLimitMaxTrackedIps != 0 {
		i = encodeVarintSettings(dAtA, i, uint64(m.RateLimitMaxTrackedIps))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb8
	}
	if m.DisableRateLimit {
		i--
		if m.DisableRateLimit {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa8
	}
	if m.AlertPolicyMinTriggerTime != 0 {
		i = encodeVarintSettings(dAtA, i, uint64(m.AlertPolicyMinTriggerTime))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa0
	}
	if m.ClusterAutoScaleRetryDelay != 0 {
		i = encodeVarintSettings(dAtA, i, uint64(m.ClusterAutoScaleRetryDelay))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x98
	}
	if m.ClusterAutoScaleAveragingDurationSec != 0 {
		i = encodeVarintSettings(dAtA, i, uint64(m.ClusterAutoScaleAveragingDurationSec))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x90
	}
	if m.AppinstClientCleanupInterval != 0 {
		i = encodeVarintSettings(dAtA, i, uint64(m.AppinstClientCleanupInterval))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x88
	}
	if m.InfluxDbEdgeEventsMetricsRetention != 0 {
		i = encodeVarintSettings(dAtA, i, uint64(m.InfluxDbEdgeEventsMetricsRetention))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x80
	}
	if m.InfluxDbDownsampledMetricsRetention != 0 {
		i = encodeVarintSettings(dAtA, i, uint64(m.InfluxDbDownsampledMetricsRetention))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if len(m.EdgeEventsMetricsContinuousQueriesCollectionIntervals) > 0 {
		for iNdEx := len(m.EdgeEventsMetricsContinuousQueriesCollectionIntervals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.EdgeEventsMetricsContinuousQueriesCollectionIntervals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSettings(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xf2
		}
	}
	if m.LocationTileSideLengthKm != 0 {
		i = encodeVarintSettings(dAtA, i, uint64(m.LocationTileSideLengthKm))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe8
	}
	if m.UpdateCloudletTimeout != 0 {
		i = encodeVarintSettings(dAtA, i, uint64(m.UpdateCloudletTimeout))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe0
	}
	if m.CreateCloudletTimeout != 0 {
		i = encodeVarintSettings(dAtA, i, uint64(m.CreateCloudletTimeout))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if m.InfluxDbCloudletUsageMetricsRetention != 0 {
		i = encodeVarintSettings(dAtA, i, uint64(m.InfluxDbCloudletUsageMetricsRetention))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if m.CleanupReservableAutoClusterIdletime != 0 {
		i = encodeVarintSettings(dAtA, i, uint64(m.CleanupReservableAutoClusterIdletime))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if m.EdgeEventsMetricsCollectionInterval != 0 {
		i = encodeVarintSettings(dAtA, i, uint64(m.EdgeEventsMetricsCollectionInterval))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if m.DmeApiMetricsCollectionInterval != 0 {
		i = encodeVarintSettings(dAtA, i, uint64(m.DmeApiMetricsCollectionInterval))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.UpdateTrustPolicyTimeout != 0 {
		i = encodeVarintSettings(dAtA, i, uint64(m.UpdateTrustPolicyTimeout))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.UpdateVmPoolTimeout != 0 {
		i = encodeVarintSettings(dAtA, i, uint64(m.UpdateVmPoolTimeout))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.ShepherdAlertEvaluationInterval != 0 {
		i = encodeVarintSettings(dAtA, i, uint64(m.ShepherdAlertEvaluationInterval))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.CloudletMaintenanceTimeout != 0 {
		i = encodeVarintSettings(dAtA, i, uint64(m.CloudletMaintenanceTimeout))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.InfluxDbMetricsRetention != 0 {
		i = encodeVarintSettings(dAtA, i, uint64(m.InfluxDbMetricsRetention))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.ChefClientInterval != 0 {
		i = encodeVarintSettings(dAtA, i, uint64(m.ChefClientInterval))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.MaxTrackedDmeClients != 0 {
		i = encodeVarintSettings(dAtA, i, uint64(m.MaxTrackedDmeClients))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if len(m.MasterNodeFlavor) > 0 {
		i -= len(m.MasterNodeFlavor)
		copy(dAtA[i:], m.MasterNodeFlavor)
		i = encodeVarintSettings(dAtA, i, uint64(len(m.MasterNodeFlavor)))
		i--
		dAtA[i] = 0x72
	}
	if m.DeleteClusterInstTimeout != 0 {
		i = encodeVarintSettings(dAtA, i, uint64(m.DeleteClusterInstTimeout))
		i--
		dAtA[i] = 0x68
	}
	if m.UpdateClusterInstTimeout != 0 {
		i = encodeVarintSettings(dAtA, i, uint64(m.UpdateClusterInstTimeout))
		i--
		dAtA[i] = 0x60
	}
	if m.CreateClusterInstTimeout != 0 {
		i = encodeVarintSettings(dAtA, i, uint64(m.CreateClusterInstTimeout))
		i--
		dAtA[i] = 0x58
	}
	if m.DeleteAppInstTimeout != 0 {
		i = encodeVarintSettings(dAtA, i, uint64(m.DeleteAppInstTimeout))
		i--
		dAtA[i] = 0x50
	}
	if m.UpdateAppInstTimeout != 0 {
		i = encodeVarintSettings(dAtA, i, uint64(m.UpdateAppInstTimeout))
		i--
		dAtA[i] = 0x48
	}
	if m.CreateAppInstTimeout != 0 {
		i = encodeVarintSettings(dAtA, i, uint64(m.CreateAppInstTimeout))
		i--
		dAtA[i] = 0x40
	}
	if m.AutoDeployMaxIntervals != 0 {
		i = encodeVarintSettings(dAtA, i, uint64(m.AutoDeployMaxIntervals))
		i--
		dAtA[i] = 0x38
	}
	if m.AutoDeployOffsetSec != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.AutoDeployOffsetSec))))
		i--
		dAtA[i] = 0x31
	}
	if m.AutoDeployIntervalSec != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.AutoDeployIntervalSec))))
		i--
		dAtA[i] = 0x29
	}
	if m.ShepherdHealthCheckInterval != 0 {
		i = encodeVarintSettings(dAtA, i, uint64(m.ShepherdHealthCheckInterval))
		i--
		dAtA[i] = 0x20
	}
	if m.ShepherdHealthCheckRetries != 0 {
		i = encodeVarintSettings(dAtA, i, uint64(m.ShepherdHealthCheckRetries))
		i--
		dAtA[i] = 0x18
	}
	if m.ShepherdMetricsCollectionInterval != 0 {
		i = encodeVarintSettings(dAtA, i, uint64(m.ShepherdMetricsCollectionInterval))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Fields) > 0 {
		for iNdEx := len(m.Fields) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Fields[iNdEx])
			copy(dAtA[i:], m.Fields[iNdEx])
			i = encodeVarintSettings(dAtA, i, uint64(len(m.Fields[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CollectionInterval) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectionInterval) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectionInterval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Retention != 0 {
		i = encodeVarintSettings(dAtA, i, uint64(m.Retention))
		i--
		dAtA[i] = 0x10
	}
	if m.Interval != 0 {
		i = encodeVarintSettings(dAtA, i, uint64(m.Interval))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintSettings(dAtA []byte, offset int, v uint64) int {
	offset -= sovSettings(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Settings) Matches(o *Settings, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !opts.Filter || o.ShepherdMetricsCollectionInterval != 0 {
		if o.ShepherdMetricsCollectionInterval != m.ShepherdMetricsCollectionInterval {
			return false
		}
	}
	if !opts.Filter || o.ShepherdHealthCheckRetries != 0 {
		if o.ShepherdHealthCheckRetries != m.ShepherdHealthCheckRetries {
			return false
		}
	}
	if !opts.Filter || o.ShepherdHealthCheckInterval != 0 {
		if o.ShepherdHealthCheckInterval != m.ShepherdHealthCheckInterval {
			return false
		}
	}
	if !opts.Filter || o.AutoDeployIntervalSec != 0 {
		if o.AutoDeployIntervalSec != m.AutoDeployIntervalSec {
			return false
		}
	}
	if !opts.Filter || o.AutoDeployOffsetSec != 0 {
		if o.AutoDeployOffsetSec != m.AutoDeployOffsetSec {
			return false
		}
	}
	if !opts.Filter || o.AutoDeployMaxIntervals != 0 {
		if o.AutoDeployMaxIntervals != m.AutoDeployMaxIntervals {
			return false
		}
	}
	if !opts.Filter || o.CreateAppInstTimeout != 0 {
		if o.CreateAppInstTimeout != m.CreateAppInstTimeout {
			return false
		}
	}
	if !opts.Filter || o.UpdateAppInstTimeout != 0 {
		if o.UpdateAppInstTimeout != m.UpdateAppInstTimeout {
			return false
		}
	}
	if !opts.Filter || o.DeleteAppInstTimeout != 0 {
		if o.DeleteAppInstTimeout != m.DeleteAppInstTimeout {
			return false
		}
	}
	if !opts.Filter || o.CreateClusterInstTimeout != 0 {
		if o.CreateClusterInstTimeout != m.CreateClusterInstTimeout {
			return false
		}
	}
	if !opts.Filter || o.UpdateClusterInstTimeout != 0 {
		if o.UpdateClusterInstTimeout != m.UpdateClusterInstTimeout {
			return false
		}
	}
	if !opts.Filter || o.DeleteClusterInstTimeout != 0 {
		if o.DeleteClusterInstTimeout != m.DeleteClusterInstTimeout {
			return false
		}
	}
	if !opts.Filter || o.MasterNodeFlavor != "" {
		if o.MasterNodeFlavor != m.MasterNodeFlavor {
			return false
		}
	}
	if !opts.Filter || o.MaxTrackedDmeClients != 0 {
		if o.MaxTrackedDmeClients != m.MaxTrackedDmeClients {
			return false
		}
	}
	if !opts.Filter || o.ChefClientInterval != 0 {
		if o.ChefClientInterval != m.ChefClientInterval {
			return false
		}
	}
	if !opts.Filter || o.InfluxDbMetricsRetention != 0 {
		if o.InfluxDbMetricsRetention != m.InfluxDbMetricsRetention {
			return false
		}
	}
	if !opts.Filter || o.CloudletMaintenanceTimeout != 0 {
		if o.CloudletMaintenanceTimeout != m.CloudletMaintenanceTimeout {
			return false
		}
	}
	if !opts.Filter || o.ShepherdAlertEvaluationInterval != 0 {
		if o.ShepherdAlertEvaluationInterval != m.ShepherdAlertEvaluationInterval {
			return false
		}
	}
	if !opts.Filter || o.UpdateVmPoolTimeout != 0 {
		if o.UpdateVmPoolTimeout != m.UpdateVmPoolTimeout {
			return false
		}
	}
	if !opts.Filter || o.UpdateTrustPolicyTimeout != 0 {
		if o.UpdateTrustPolicyTimeout != m.UpdateTrustPolicyTimeout {
			return false
		}
	}
	if !opts.Filter || o.DmeApiMetricsCollectionInterval != 0 {
		if o.DmeApiMetricsCollectionInterval != m.DmeApiMetricsCollectionInterval {
			return false
		}
	}
	if !opts.Filter || o.EdgeEventsMetricsCollectionInterval != 0 {
		if o.EdgeEventsMetricsCollectionInterval != m.EdgeEventsMetricsCollectionInterval {
			return false
		}
	}
	if !opts.Filter || o.CleanupReservableAutoClusterIdletime != 0 {
		if o.CleanupReservableAutoClusterIdletime != m.CleanupReservableAutoClusterIdletime {
			return false
		}
	}
	if !opts.Filter || o.InfluxDbCloudletUsageMetricsRetention != 0 {
		if o.InfluxDbCloudletUsageMetricsRetention != m.InfluxDbCloudletUsageMetricsRetention {
			return false
		}
	}
	if !opts.Filter || o.CreateCloudletTimeout != 0 {
		if o.CreateCloudletTimeout != m.CreateCloudletTimeout {
			return false
		}
	}
	if !opts.Filter || o.UpdateCloudletTimeout != 0 {
		if o.UpdateCloudletTimeout != m.UpdateCloudletTimeout {
			return false
		}
	}
	if !opts.Filter || o.LocationTileSideLengthKm != 0 {
		if o.LocationTileSideLengthKm != m.LocationTileSideLengthKm {
			return false
		}
	}
	if !opts.Filter || o.EdgeEventsMetricsContinuousQueriesCollectionIntervals != nil {
		if len(m.EdgeEventsMetricsContinuousQueriesCollectionIntervals) == 0 && len(o.EdgeEventsMetricsContinuousQueriesCollectionIntervals) > 0 || len(m.EdgeEventsMetricsContinuousQueriesCollectionIntervals) > 0 && len(o.EdgeEventsMetricsContinuousQueriesCollectionIntervals) == 0 {
			return false
		} else if m.EdgeEventsMetricsContinuousQueriesCollectionIntervals != nil && o.EdgeEventsMetricsContinuousQueriesCollectionIntervals != nil {
			if !opts.Filter && len(m.EdgeEventsMetricsContinuousQueriesCollectionIntervals) != len(o.EdgeEventsMetricsContinuousQueriesCollectionIntervals) {
				return false
			}
		}
	}
	if !opts.Filter || o.InfluxDbDownsampledMetricsRetention != 0 {
		if o.InfluxDbDownsampledMetricsRetention != m.InfluxDbDownsampledMetricsRetention {
			return false
		}
	}
	if !opts.Filter || o.InfluxDbEdgeEventsMetricsRetention != 0 {
		if o.InfluxDbEdgeEventsMetricsRetention != m.InfluxDbEdgeEventsMetricsRetention {
			return false
		}
	}
	if !opts.Filter || o.AppinstClientCleanupInterval != 0 {
		if o.AppinstClientCleanupInterval != m.AppinstClientCleanupInterval {
			return false
		}
	}
	if !opts.Filter || o.ClusterAutoScaleAveragingDurationSec != 0 {
		if o.ClusterAutoScaleAveragingDurationSec != m.ClusterAutoScaleAveragingDurationSec {
			return false
		}
	}
	if !opts.Filter || o.ClusterAutoScaleRetryDelay != 0 {
		if o.ClusterAutoScaleRetryDelay != m.ClusterAutoScaleRetryDelay {
			return false
		}
	}
	if !opts.Filter || o.AlertPolicyMinTriggerTime != 0 {
		if o.AlertPolicyMinTriggerTime != m.AlertPolicyMinTriggerTime {
			return false
		}
	}
	if !opts.Filter || o.DisableRateLimit != false {
		if o.DisableRateLimit != m.DisableRateLimit {
			return false
		}
	}
	if !opts.Filter || o.RateLimitMaxTrackedIps != 0 {
		if o.RateLimitMaxTrackedIps != m.RateLimitMaxTrackedIps {
			return false
		}
	}
	if !opts.Filter || o.ShepherdMetricsScrapeInterval != 0 {
		if o.ShepherdMetricsScrapeInterval != m.ShepherdMetricsScrapeInterval {
			return false
		}
	}
	if !opts.Filter || o.ResourceSnapshotThreadInterval != 0 {
		if o.ResourceSnapshotThreadInterval != m.ResourceSnapshotThreadInterval {
			return false
		}
	}
	if !opts.Filter || o.PlatformHaInstancePollInterval != 0 {
		if o.PlatformHaInstancePollInterval != m.PlatformHaInstancePollInterval {
			return false
		}
	}
	if !opts.Filter || o.PlatformHaInstanceActiveExpireTime != 0 {
		if o.PlatformHaInstanceActiveExpireTime != m.PlatformHaInstanceActiveExpireTime {
			return false
		}
	}
	if !opts.Filter || o.CcrmRedisapiTimeout != 0 {
		if o.CcrmRedisapiTimeout != m.CcrmRedisapiTimeout {
			return false
		}
	}
	return true
}

const SettingsFieldShepherdMetricsCollectionInterval = "2"
const SettingsFieldShepherdHealthCheckRetries = "3"
const SettingsFieldShepherdHealthCheckInterval = "4"
const SettingsFieldAutoDeployIntervalSec = "5"
const SettingsFieldAutoDeployOffsetSec = "6"
const SettingsFieldAutoDeployMaxIntervals = "7"
const SettingsFieldCreateAppInstTimeout = "8"
const SettingsFieldUpdateAppInstTimeout = "9"
const SettingsFieldDeleteAppInstTimeout = "10"
const SettingsFieldCreateClusterInstTimeout = "11"
const SettingsFieldUpdateClusterInstTimeout = "12"
const SettingsFieldDeleteClusterInstTimeout = "13"
const SettingsFieldMasterNodeFlavor = "14"
const SettingsFieldMaxTrackedDmeClients = "16"
const SettingsFieldChefClientInterval = "17"
const SettingsFieldInfluxDbMetricsRetention = "18"
const SettingsFieldCloudletMaintenanceTimeout = "19"
const SettingsFieldShepherdAlertEvaluationInterval = "20"
const SettingsFieldUpdateVmPoolTimeout = "21"
const SettingsFieldUpdateTrustPolicyTimeout = "22"
const SettingsFieldDmeApiMetricsCollectionInterval = "23"
const SettingsFieldEdgeEventsMetricsCollectionInterval = "24"
const SettingsFieldCleanupReservableAutoClusterIdletime = "25"
const SettingsFieldInfluxDbCloudletUsageMetricsRetention = "26"
const SettingsFieldCreateCloudletTimeout = "27"
const SettingsFieldUpdateCloudletTimeout = "28"
const SettingsFieldLocationTileSideLengthKm = "29"
const SettingsFieldEdgeEventsMetricsContinuousQueriesCollectionIntervals = "30"
const SettingsFieldEdgeEventsMetricsContinuousQueriesCollectionIntervalsInterval = "30.1"
const SettingsFieldEdgeEventsMetricsContinuousQueriesCollectionIntervalsRetention = "30.2"
const SettingsFieldInfluxDbDownsampledMetricsRetention = "31"
const SettingsFieldInfluxDbEdgeEventsMetricsRetention = "32"
const SettingsFieldAppinstClientCleanupInterval = "33"
const SettingsFieldClusterAutoScaleAveragingDurationSec = "34"
const SettingsFieldClusterAutoScaleRetryDelay = "35"
const SettingsFieldAlertPolicyMinTriggerTime = "36"
const SettingsFieldDisableRateLimit = "37"
const SettingsFieldRateLimitMaxTrackedIps = "39"
const SettingsFieldShepherdMetricsScrapeInterval = "40"
const SettingsFieldResourceSnapshotThreadInterval = "41"
const SettingsFieldPlatformHaInstancePollInterval = "42"
const SettingsFieldPlatformHaInstanceActiveExpireTime = "43"
const SettingsFieldCcrmRedisapiTimeout = "44"

var SettingsAllFields = []string{
	SettingsFieldShepherdMetricsCollectionInterval,
	SettingsFieldShepherdHealthCheckRetries,
	SettingsFieldShepherdHealthCheckInterval,
	SettingsFieldAutoDeployIntervalSec,
	SettingsFieldAutoDeployOffsetSec,
	SettingsFieldAutoDeployMaxIntervals,
	SettingsFieldCreateAppInstTimeout,
	SettingsFieldUpdateAppInstTimeout,
	SettingsFieldDeleteAppInstTimeout,
	SettingsFieldCreateClusterInstTimeout,
	SettingsFieldUpdateClusterInstTimeout,
	SettingsFieldDeleteClusterInstTimeout,
	SettingsFieldMasterNodeFlavor,
	SettingsFieldMaxTrackedDmeClients,
	SettingsFieldChefClientInterval,
	SettingsFieldInfluxDbMetricsRetention,
	SettingsFieldCloudletMaintenanceTimeout,
	SettingsFieldShepherdAlertEvaluationInterval,
	SettingsFieldUpdateVmPoolTimeout,
	SettingsFieldUpdateTrustPolicyTimeout,
	SettingsFieldDmeApiMetricsCollectionInterval,
	SettingsFieldEdgeEventsMetricsCollectionInterval,
	SettingsFieldCleanupReservableAutoClusterIdletime,
	SettingsFieldInfluxDbCloudletUsageMetricsRetention,
	SettingsFieldCreateCloudletTimeout,
	SettingsFieldUpdateCloudletTimeout,
	SettingsFieldLocationTileSideLengthKm,
	SettingsFieldEdgeEventsMetricsContinuousQueriesCollectionIntervalsInterval,
	SettingsFieldEdgeEventsMetricsContinuousQueriesCollectionIntervalsRetention,
	SettingsFieldInfluxDbDownsampledMetricsRetention,
	SettingsFieldInfluxDbEdgeEventsMetricsRetention,
	SettingsFieldAppinstClientCleanupInterval,
	SettingsFieldClusterAutoScaleAveragingDurationSec,
	SettingsFieldClusterAutoScaleRetryDelay,
	SettingsFieldAlertPolicyMinTriggerTime,
	SettingsFieldDisableRateLimit,
	SettingsFieldRateLimitMaxTrackedIps,
	SettingsFieldShepherdMetricsScrapeInterval,
	SettingsFieldResourceSnapshotThreadInterval,
	SettingsFieldPlatformHaInstancePollInterval,
	SettingsFieldPlatformHaInstanceActiveExpireTime,
	SettingsFieldCcrmRedisapiTimeout,
}

var SettingsAllFieldsMap = map[string]struct{}{
	SettingsFieldShepherdMetricsCollectionInterval:                              struct{}{},
	SettingsFieldShepherdHealthCheckRetries:                                     struct{}{},
	SettingsFieldShepherdHealthCheckInterval:                                    struct{}{},
	SettingsFieldAutoDeployIntervalSec:                                          struct{}{},
	SettingsFieldAutoDeployOffsetSec:                                            struct{}{},
	SettingsFieldAutoDeployMaxIntervals:                                         struct{}{},
	SettingsFieldCreateAppInstTimeout:                                           struct{}{},
	SettingsFieldUpdateAppInstTimeout:                                           struct{}{},
	SettingsFieldDeleteAppInstTimeout:                                           struct{}{},
	SettingsFieldCreateClusterInstTimeout:                                       struct{}{},
	SettingsFieldUpdateClusterInstTimeout:                                       struct{}{},
	SettingsFieldDeleteClusterInstTimeout:                                       struct{}{},
	SettingsFieldMasterNodeFlavor:                                               struct{}{},
	SettingsFieldMaxTrackedDmeClients:                                           struct{}{},
	SettingsFieldChefClientInterval:                                             struct{}{},
	SettingsFieldInfluxDbMetricsRetention:                                       struct{}{},
	SettingsFieldCloudletMaintenanceTimeout:                                     struct{}{},
	SettingsFieldShepherdAlertEvaluationInterval:                                struct{}{},
	SettingsFieldUpdateVmPoolTimeout:                                            struct{}{},
	SettingsFieldUpdateTrustPolicyTimeout:                                       struct{}{},
	SettingsFieldDmeApiMetricsCollectionInterval:                                struct{}{},
	SettingsFieldEdgeEventsMetricsCollectionInterval:                            struct{}{},
	SettingsFieldCleanupReservableAutoClusterIdletime:                           struct{}{},
	SettingsFieldInfluxDbCloudletUsageMetricsRetention:                          struct{}{},
	SettingsFieldCreateCloudletTimeout:                                          struct{}{},
	SettingsFieldUpdateCloudletTimeout:                                          struct{}{},
	SettingsFieldLocationTileSideLengthKm:                                       struct{}{},
	SettingsFieldEdgeEventsMetricsContinuousQueriesCollectionIntervalsInterval:  struct{}{},
	SettingsFieldEdgeEventsMetricsContinuousQueriesCollectionIntervalsRetention: struct{}{},
	SettingsFieldInfluxDbDownsampledMetricsRetention:                            struct{}{},
	SettingsFieldInfluxDbEdgeEventsMetricsRetention:                             struct{}{},
	SettingsFieldAppinstClientCleanupInterval:                                   struct{}{},
	SettingsFieldClusterAutoScaleAveragingDurationSec:                           struct{}{},
	SettingsFieldClusterAutoScaleRetryDelay:                                     struct{}{},
	SettingsFieldAlertPolicyMinTriggerTime:                                      struct{}{},
	SettingsFieldDisableRateLimit:                                               struct{}{},
	SettingsFieldRateLimitMaxTrackedIps:                                         struct{}{},
	SettingsFieldShepherdMetricsScrapeInterval:                                  struct{}{},
	SettingsFieldResourceSnapshotThreadInterval:                                 struct{}{},
	SettingsFieldPlatformHaInstancePollInterval:                                 struct{}{},
	SettingsFieldPlatformHaInstanceActiveExpireTime:                             struct{}{},
	SettingsFieldCcrmRedisapiTimeout:                                            struct{}{},
}

var SettingsAllFieldsStringMap = map[string]string{
	SettingsFieldShepherdMetricsCollectionInterval:                              "Shepherd Metrics Collection Interval",
	SettingsFieldShepherdHealthCheckRetries:                                     "Shepherd Health Check Retries",
	SettingsFieldShepherdHealthCheckInterval:                                    "Shepherd Health Check Interval",
	SettingsFieldAutoDeployIntervalSec:                                          "Auto Deploy Interval Sec",
	SettingsFieldAutoDeployOffsetSec:                                            "Auto Deploy Offset Sec",
	SettingsFieldAutoDeployMaxIntervals:                                         "Auto Deploy Max Intervals",
	SettingsFieldCreateAppInstTimeout:                                           "Create App Inst Timeout",
	SettingsFieldUpdateAppInstTimeout:                                           "Update App Inst Timeout",
	SettingsFieldDeleteAppInstTimeout:                                           "Delete App Inst Timeout",
	SettingsFieldCreateClusterInstTimeout:                                       "Create Cluster Inst Timeout",
	SettingsFieldUpdateClusterInstTimeout:                                       "Update Cluster Inst Timeout",
	SettingsFieldDeleteClusterInstTimeout:                                       "Delete Cluster Inst Timeout",
	SettingsFieldMasterNodeFlavor:                                               "Master Node Flavor",
	SettingsFieldMaxTrackedDmeClients:                                           "Max Tracked Dme Clients",
	SettingsFieldChefClientInterval:                                             "Chef Client Interval",
	SettingsFieldInfluxDbMetricsRetention:                                       "Influx Db Metrics Retention",
	SettingsFieldCloudletMaintenanceTimeout:                                     "Cloudlet Maintenance Timeout",
	SettingsFieldShepherdAlertEvaluationInterval:                                "Shepherd Alert Evaluation Interval",
	SettingsFieldUpdateVmPoolTimeout:                                            "Update Vm Pool Timeout",
	SettingsFieldUpdateTrustPolicyTimeout:                                       "Update Trust Policy Timeout",
	SettingsFieldDmeApiMetricsCollectionInterval:                                "Dme Api Metrics Collection Interval",
	SettingsFieldEdgeEventsMetricsCollectionInterval:                            "Edge Events Metrics Collection Interval",
	SettingsFieldCleanupReservableAutoClusterIdletime:                           "Cleanup Reservable Auto Cluster Idletime",
	SettingsFieldInfluxDbCloudletUsageMetricsRetention:                          "Influx Db Cloudlet Usage Metrics Retention",
	SettingsFieldCreateCloudletTimeout:                                          "Create Cloudlet Timeout",
	SettingsFieldUpdateCloudletTimeout:                                          "Update Cloudlet Timeout",
	SettingsFieldLocationTileSideLengthKm:                                       "Location Tile Side Length Km",
	SettingsFieldEdgeEventsMetricsContinuousQueriesCollectionIntervalsInterval:  "Edge Events Metrics Continuous Queries Collection Intervals Interval",
	SettingsFieldEdgeEventsMetricsContinuousQueriesCollectionIntervalsRetention: "Edge Events Metrics Continuous Queries Collection Intervals Retention",
	SettingsFieldInfluxDbDownsampledMetricsRetention:                            "Influx Db Downsampled Metrics Retention",
	SettingsFieldInfluxDbEdgeEventsMetricsRetention:                             "Influx Db Edge Events Metrics Retention",
	SettingsFieldAppinstClientCleanupInterval:                                   "Appinst Client Cleanup Interval",
	SettingsFieldClusterAutoScaleAveragingDurationSec:                           "Cluster Auto Scale Averaging Duration Sec",
	SettingsFieldClusterAutoScaleRetryDelay:                                     "Cluster Auto Scale Retry Delay",
	SettingsFieldAlertPolicyMinTriggerTime:                                      "Alert Policy Min Trigger Time",
	SettingsFieldDisableRateLimit:                                               "Disable Rate Limit",
	SettingsFieldRateLimitMaxTrackedIps:                                         "Rate Limit Max Tracked Ips",
	SettingsFieldShepherdMetricsScrapeInterval:                                  "Shepherd Metrics Scrape Interval",
	SettingsFieldResourceSnapshotThreadInterval:                                 "Resource Snapshot Thread Interval",
	SettingsFieldPlatformHaInstancePollInterval:                                 "Platform Ha Instance Poll Interval",
	SettingsFieldPlatformHaInstanceActiveExpireTime:                             "Platform Ha Instance Active Expire Time",
	SettingsFieldCcrmRedisapiTimeout:                                            "Ccrm Redisapi Timeout",
}

func (m *Settings) IsKeyField(s string) bool {
	return strings.HasPrefix(s, SettingsFieldShepherdMetricsCollectionInterval+".") || s == SettingsFieldShepherdMetricsCollectionInterval
}

func (m *Settings) DiffFields(o *Settings, fields map[string]struct{}) {
	if m.ShepherdMetricsCollectionInterval != o.ShepherdMetricsCollectionInterval {
		fields[SettingsFieldShepherdMetricsCollectionInterval] = struct{}{}
	}
	if m.ShepherdHealthCheckRetries != o.ShepherdHealthCheckRetries {
		fields[SettingsFieldShepherdHealthCheckRetries] = struct{}{}
	}
	if m.ShepherdHealthCheckInterval != o.ShepherdHealthCheckInterval {
		fields[SettingsFieldShepherdHealthCheckInterval] = struct{}{}
	}
	if m.AutoDeployIntervalSec != o.AutoDeployIntervalSec {
		fields[SettingsFieldAutoDeployIntervalSec] = struct{}{}
	}
	if m.AutoDeployOffsetSec != o.AutoDeployOffsetSec {
		fields[SettingsFieldAutoDeployOffsetSec] = struct{}{}
	}
	if m.AutoDeployMaxIntervals != o.AutoDeployMaxIntervals {
		fields[SettingsFieldAutoDeployMaxIntervals] = struct{}{}
	}
	if m.CreateAppInstTimeout != o.CreateAppInstTimeout {
		fields[SettingsFieldCreateAppInstTimeout] = struct{}{}
	}
	if m.UpdateAppInstTimeout != o.UpdateAppInstTimeout {
		fields[SettingsFieldUpdateAppInstTimeout] = struct{}{}
	}
	if m.DeleteAppInstTimeout != o.DeleteAppInstTimeout {
		fields[SettingsFieldDeleteAppInstTimeout] = struct{}{}
	}
	if m.CreateClusterInstTimeout != o.CreateClusterInstTimeout {
		fields[SettingsFieldCreateClusterInstTimeout] = struct{}{}
	}
	if m.UpdateClusterInstTimeout != o.UpdateClusterInstTimeout {
		fields[SettingsFieldUpdateClusterInstTimeout] = struct{}{}
	}
	if m.DeleteClusterInstTimeout != o.DeleteClusterInstTimeout {
		fields[SettingsFieldDeleteClusterInstTimeout] = struct{}{}
	}
	if m.MasterNodeFlavor != o.MasterNodeFlavor {
		fields[SettingsFieldMasterNodeFlavor] = struct{}{}
	}
	if m.MaxTrackedDmeClients != o.MaxTrackedDmeClients {
		fields[SettingsFieldMaxTrackedDmeClients] = struct{}{}
	}
	if m.ChefClientInterval != o.ChefClientInterval {
		fields[SettingsFieldChefClientInterval] = struct{}{}
	}
	if m.InfluxDbMetricsRetention != o.InfluxDbMetricsRetention {
		fields[SettingsFieldInfluxDbMetricsRetention] = struct{}{}
	}
	if m.CloudletMaintenanceTimeout != o.CloudletMaintenanceTimeout {
		fields[SettingsFieldCloudletMaintenanceTimeout] = struct{}{}
	}
	if m.ShepherdAlertEvaluationInterval != o.ShepherdAlertEvaluationInterval {
		fields[SettingsFieldShepherdAlertEvaluationInterval] = struct{}{}
	}
	if m.UpdateVmPoolTimeout != o.UpdateVmPoolTimeout {
		fields[SettingsFieldUpdateVmPoolTimeout] = struct{}{}
	}
	if m.UpdateTrustPolicyTimeout != o.UpdateTrustPolicyTimeout {
		fields[SettingsFieldUpdateTrustPolicyTimeout] = struct{}{}
	}
	if m.DmeApiMetricsCollectionInterval != o.DmeApiMetricsCollectionInterval {
		fields[SettingsFieldDmeApiMetricsCollectionInterval] = struct{}{}
	}
	if m.EdgeEventsMetricsCollectionInterval != o.EdgeEventsMetricsCollectionInterval {
		fields[SettingsFieldEdgeEventsMetricsCollectionInterval] = struct{}{}
	}
	if m.CleanupReservableAutoClusterIdletime != o.CleanupReservableAutoClusterIdletime {
		fields[SettingsFieldCleanupReservableAutoClusterIdletime] = struct{}{}
	}
	if m.InfluxDbCloudletUsageMetricsRetention != o.InfluxDbCloudletUsageMetricsRetention {
		fields[SettingsFieldInfluxDbCloudletUsageMetricsRetention] = struct{}{}
	}
	if m.CreateCloudletTimeout != o.CreateCloudletTimeout {
		fields[SettingsFieldCreateCloudletTimeout] = struct{}{}
	}
	if m.UpdateCloudletTimeout != o.UpdateCloudletTimeout {
		fields[SettingsFieldUpdateCloudletTimeout] = struct{}{}
	}
	if m.LocationTileSideLengthKm != o.LocationTileSideLengthKm {
		fields[SettingsFieldLocationTileSideLengthKm] = struct{}{}
	}
	if m.EdgeEventsMetricsContinuousQueriesCollectionIntervals != nil && o.EdgeEventsMetricsContinuousQueriesCollectionIntervals != nil {
		if len(m.EdgeEventsMetricsContinuousQueriesCollectionIntervals) != len(o.EdgeEventsMetricsContinuousQueriesCollectionIntervals) {
			fields[SettingsFieldEdgeEventsMetricsContinuousQueriesCollectionIntervals] = struct{}{}
		} else {
			for i0 := 0; i0 < len(m.EdgeEventsMetricsContinuousQueriesCollectionIntervals); i0++ {
				if m.EdgeEventsMetricsContinuousQueriesCollectionIntervals[i0].Interval != o.EdgeEventsMetricsContinuousQueriesCollectionIntervals[i0].Interval {
					fields[SettingsFieldEdgeEventsMetricsContinuousQueriesCollectionIntervalsInterval] = struct{}{}
					fields[SettingsFieldEdgeEventsMetricsContinuousQueriesCollectionIntervals] = struct{}{}
				}
				if m.EdgeEventsMetricsContinuousQueriesCollectionIntervals[i0].Retention != o.EdgeEventsMetricsContinuousQueriesCollectionIntervals[i0].Retention {
					fields[SettingsFieldEdgeEventsMetricsContinuousQueriesCollectionIntervalsRetention] = struct{}{}
					fields[SettingsFieldEdgeEventsMetricsContinuousQueriesCollectionIntervals] = struct{}{}
				}
			}
		}
	} else if (m.EdgeEventsMetricsContinuousQueriesCollectionIntervals != nil && o.EdgeEventsMetricsContinuousQueriesCollectionIntervals == nil) || (m.EdgeEventsMetricsContinuousQueriesCollectionIntervals == nil && o.EdgeEventsMetricsContinuousQueriesCollectionIntervals != nil) {
		fields[SettingsFieldEdgeEventsMetricsContinuousQueriesCollectionIntervals] = struct{}{}
	}
	if m.InfluxDbDownsampledMetricsRetention != o.InfluxDbDownsampledMetricsRetention {
		fields[SettingsFieldInfluxDbDownsampledMetricsRetention] = struct{}{}
	}
	if m.InfluxDbEdgeEventsMetricsRetention != o.InfluxDbEdgeEventsMetricsRetention {
		fields[SettingsFieldInfluxDbEdgeEventsMetricsRetention] = struct{}{}
	}
	if m.AppinstClientCleanupInterval != o.AppinstClientCleanupInterval {
		fields[SettingsFieldAppinstClientCleanupInterval] = struct{}{}
	}
	if m.ClusterAutoScaleAveragingDurationSec != o.ClusterAutoScaleAveragingDurationSec {
		fields[SettingsFieldClusterAutoScaleAveragingDurationSec] = struct{}{}
	}
	if m.ClusterAutoScaleRetryDelay != o.ClusterAutoScaleRetryDelay {
		fields[SettingsFieldClusterAutoScaleRetryDelay] = struct{}{}
	}
	if m.AlertPolicyMinTriggerTime != o.AlertPolicyMinTriggerTime {
		fields[SettingsFieldAlertPolicyMinTriggerTime] = struct{}{}
	}
	if m.DisableRateLimit != o.DisableRateLimit {
		fields[SettingsFieldDisableRateLimit] = struct{}{}
	}
	if m.RateLimitMaxTrackedIps != o.RateLimitMaxTrackedIps {
		fields[SettingsFieldRateLimitMaxTrackedIps] = struct{}{}
	}
	if m.ShepherdMetricsScrapeInterval != o.ShepherdMetricsScrapeInterval {
		fields[SettingsFieldShepherdMetricsScrapeInterval] = struct{}{}
	}
	if m.ResourceSnapshotThreadInterval != o.ResourceSnapshotThreadInterval {
		fields[SettingsFieldResourceSnapshotThreadInterval] = struct{}{}
	}
	if m.PlatformHaInstancePollInterval != o.PlatformHaInstancePollInterval {
		fields[SettingsFieldPlatformHaInstancePollInterval] = struct{}{}
	}
	if m.PlatformHaInstanceActiveExpireTime != o.PlatformHaInstanceActiveExpireTime {
		fields[SettingsFieldPlatformHaInstanceActiveExpireTime] = struct{}{}
	}
	if m.CcrmRedisapiTimeout != o.CcrmRedisapiTimeout {
		fields[SettingsFieldCcrmRedisapiTimeout] = struct{}{}
	}
}

var UpdateSettingsFieldsMap = map[string]struct{}{
	SettingsFieldShepherdMetricsCollectionInterval:                              struct{}{},
	SettingsFieldShepherdHealthCheckRetries:                                     struct{}{},
	SettingsFieldShepherdHealthCheckInterval:                                    struct{}{},
	SettingsFieldAutoDeployIntervalSec:                                          struct{}{},
	SettingsFieldAutoDeployOffsetSec:                                            struct{}{},
	SettingsFieldAutoDeployMaxIntervals:                                         struct{}{},
	SettingsFieldCreateAppInstTimeout:                                           struct{}{},
	SettingsFieldUpdateAppInstTimeout:                                           struct{}{},
	SettingsFieldDeleteAppInstTimeout:                                           struct{}{},
	SettingsFieldCreateClusterInstTimeout:                                       struct{}{},
	SettingsFieldUpdateClusterInstTimeout:                                       struct{}{},
	SettingsFieldDeleteClusterInstTimeout:                                       struct{}{},
	SettingsFieldMasterNodeFlavor:                                               struct{}{},
	SettingsFieldMaxTrackedDmeClients:                                           struct{}{},
	SettingsFieldChefClientInterval:                                             struct{}{},
	SettingsFieldInfluxDbMetricsRetention:                                       struct{}{},
	SettingsFieldCloudletMaintenanceTimeout:                                     struct{}{},
	SettingsFieldShepherdAlertEvaluationInterval:                                struct{}{},
	SettingsFieldUpdateVmPoolTimeout:                                            struct{}{},
	SettingsFieldUpdateTrustPolicyTimeout:                                       struct{}{},
	SettingsFieldDmeApiMetricsCollectionInterval:                                struct{}{},
	SettingsFieldEdgeEventsMetricsCollectionInterval:                            struct{}{},
	SettingsFieldCleanupReservableAutoClusterIdletime:                           struct{}{},
	SettingsFieldInfluxDbCloudletUsageMetricsRetention:                          struct{}{},
	SettingsFieldCreateCloudletTimeout:                                          struct{}{},
	SettingsFieldUpdateCloudletTimeout:                                          struct{}{},
	SettingsFieldLocationTileSideLengthKm:                                       struct{}{},
	SettingsFieldEdgeEventsMetricsContinuousQueriesCollectionIntervals:          struct{}{},
	SettingsFieldEdgeEventsMetricsContinuousQueriesCollectionIntervalsInterval:  struct{}{},
	SettingsFieldEdgeEventsMetricsContinuousQueriesCollectionIntervalsRetention: struct{}{},
	SettingsFieldInfluxDbDownsampledMetricsRetention:                            struct{}{},
	SettingsFieldInfluxDbEdgeEventsMetricsRetention:                             struct{}{},
	SettingsFieldAppinstClientCleanupInterval:                                   struct{}{},
	SettingsFieldClusterAutoScaleAveragingDurationSec:                           struct{}{},
	SettingsFieldClusterAutoScaleRetryDelay:                                     struct{}{},
	SettingsFieldAlertPolicyMinTriggerTime:                                      struct{}{},
	SettingsFieldDisableRateLimit:                                               struct{}{},
	SettingsFieldRateLimitMaxTrackedIps:                                         struct{}{},
	SettingsFieldShepherdMetricsScrapeInterval:                                  struct{}{},
	SettingsFieldResourceSnapshotThreadInterval:                                 struct{}{},
	SettingsFieldPlatformHaInstancePollInterval:                                 struct{}{},
	SettingsFieldPlatformHaInstanceActiveExpireTime:                             struct{}{},
	SettingsFieldCcrmRedisapiTimeout:                                            struct{}{},
}

func (m *Settings) ValidateUpdateFields() error {
	if m.Fields == nil {
		return fmt.Errorf("nothing specified to update")
	}
	fmap := MakeFieldMap(m.Fields)
	badFieldStrs := []string{}
	for field, _ := range fmap {
		if m.IsKeyField(field) {
			continue
		}
		if _, ok := UpdateSettingsFieldsMap[field]; !ok {
			if _, ok := SettingsAllFieldsStringMap[field]; !ok {
				continue
			}
			badFieldStrs = append(badFieldStrs, SettingsAllFieldsStringMap[field])
		}
	}
	if len(badFieldStrs) > 0 {
		return fmt.Errorf("specified field(s) %s cannot be modified", strings.Join(badFieldStrs, ","))
	}
	return nil
}

func (m *Settings) Clone() *Settings {
	cp := &Settings{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *Settings) AddEdgeEventsMetricsContinuousQueriesCollectionIntervals(vals ...*CollectionInterval) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.EdgeEventsMetricsContinuousQueriesCollectionIntervals {
		cur[v.String()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.String()]; found {
			continue // duplicate
		}
		m.EdgeEventsMetricsContinuousQueriesCollectionIntervals = append(m.EdgeEventsMetricsContinuousQueriesCollectionIntervals, v)
		changes++
	}
	return changes
}

func (m *Settings) RemoveEdgeEventsMetricsContinuousQueriesCollectionIntervals(vals ...*CollectionInterval) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.String()] = struct{}{}
	}
	for i := len(m.EdgeEventsMetricsContinuousQueriesCollectionIntervals); i >= 0; i-- {
		if _, found := remove[m.EdgeEventsMetricsContinuousQueriesCollectionIntervals[i].String()]; found {
			m.EdgeEventsMetricsContinuousQueriesCollectionIntervals = append(m.EdgeEventsMetricsContinuousQueriesCollectionIntervals[:i], m.EdgeEventsMetricsContinuousQueriesCollectionIntervals[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *Settings) CopyInFields(src *Settings) int {
	updateListAction := "replace"
	changed := 0
	fmap := MakeFieldMap(src.Fields)
	if _, set := fmap["2"]; set {
		if m.ShepherdMetricsCollectionInterval != src.ShepherdMetricsCollectionInterval {
			m.ShepherdMetricsCollectionInterval = src.ShepherdMetricsCollectionInterval
			changed++
		}
	}
	if _, set := fmap["3"]; set {
		if m.ShepherdHealthCheckRetries != src.ShepherdHealthCheckRetries {
			m.ShepherdHealthCheckRetries = src.ShepherdHealthCheckRetries
			changed++
		}
	}
	if _, set := fmap["4"]; set {
		if m.ShepherdHealthCheckInterval != src.ShepherdHealthCheckInterval {
			m.ShepherdHealthCheckInterval = src.ShepherdHealthCheckInterval
			changed++
		}
	}
	if _, set := fmap["5"]; set {
		if m.AutoDeployIntervalSec != src.AutoDeployIntervalSec {
			m.AutoDeployIntervalSec = src.AutoDeployIntervalSec
			changed++
		}
	}
	if _, set := fmap["6"]; set {
		if m.AutoDeployOffsetSec != src.AutoDeployOffsetSec {
			m.AutoDeployOffsetSec = src.AutoDeployOffsetSec
			changed++
		}
	}
	if _, set := fmap["7"]; set {
		if m.AutoDeployMaxIntervals != src.AutoDeployMaxIntervals {
			m.AutoDeployMaxIntervals = src.AutoDeployMaxIntervals
			changed++
		}
	}
	if _, set := fmap["8"]; set {
		if m.CreateAppInstTimeout != src.CreateAppInstTimeout {
			m.CreateAppInstTimeout = src.CreateAppInstTimeout
			changed++
		}
	}
	if _, set := fmap["9"]; set {
		if m.UpdateAppInstTimeout != src.UpdateAppInstTimeout {
			m.UpdateAppInstTimeout = src.UpdateAppInstTimeout
			changed++
		}
	}
	if _, set := fmap["10"]; set {
		if m.DeleteAppInstTimeout != src.DeleteAppInstTimeout {
			m.DeleteAppInstTimeout = src.DeleteAppInstTimeout
			changed++
		}
	}
	if _, set := fmap["11"]; set {
		if m.CreateClusterInstTimeout != src.CreateClusterInstTimeout {
			m.CreateClusterInstTimeout = src.CreateClusterInstTimeout
			changed++
		}
	}
	if _, set := fmap["12"]; set {
		if m.UpdateClusterInstTimeout != src.UpdateClusterInstTimeout {
			m.UpdateClusterInstTimeout = src.UpdateClusterInstTimeout
			changed++
		}
	}
	if _, set := fmap["13"]; set {
		if m.DeleteClusterInstTimeout != src.DeleteClusterInstTimeout {
			m.DeleteClusterInstTimeout = src.DeleteClusterInstTimeout
			changed++
		}
	}
	if _, set := fmap["14"]; set {
		if m.MasterNodeFlavor != src.MasterNodeFlavor {
			m.MasterNodeFlavor = src.MasterNodeFlavor
			changed++
		}
	}
	if _, set := fmap["16"]; set {
		if m.MaxTrackedDmeClients != src.MaxTrackedDmeClients {
			m.MaxTrackedDmeClients = src.MaxTrackedDmeClients
			changed++
		}
	}
	if _, set := fmap["17"]; set {
		if m.ChefClientInterval != src.ChefClientInterval {
			m.ChefClientInterval = src.ChefClientInterval
			changed++
		}
	}
	if _, set := fmap["18"]; set {
		if m.InfluxDbMetricsRetention != src.InfluxDbMetricsRetention {
			m.InfluxDbMetricsRetention = src.InfluxDbMetricsRetention
			changed++
		}
	}
	if _, set := fmap["19"]; set {
		if m.CloudletMaintenanceTimeout != src.CloudletMaintenanceTimeout {
			m.CloudletMaintenanceTimeout = src.CloudletMaintenanceTimeout
			changed++
		}
	}
	if _, set := fmap["20"]; set {
		if m.ShepherdAlertEvaluationInterval != src.ShepherdAlertEvaluationInterval {
			m.ShepherdAlertEvaluationInterval = src.ShepherdAlertEvaluationInterval
			changed++
		}
	}
	if _, set := fmap["21"]; set {
		if m.UpdateVmPoolTimeout != src.UpdateVmPoolTimeout {
			m.UpdateVmPoolTimeout = src.UpdateVmPoolTimeout
			changed++
		}
	}
	if _, set := fmap["22"]; set {
		if m.UpdateTrustPolicyTimeout != src.UpdateTrustPolicyTimeout {
			m.UpdateTrustPolicyTimeout = src.UpdateTrustPolicyTimeout
			changed++
		}
	}
	if _, set := fmap["23"]; set {
		if m.DmeApiMetricsCollectionInterval != src.DmeApiMetricsCollectionInterval {
			m.DmeApiMetricsCollectionInterval = src.DmeApiMetricsCollectionInterval
			changed++
		}
	}
	if _, set := fmap["24"]; set {
		if m.EdgeEventsMetricsCollectionInterval != src.EdgeEventsMetricsCollectionInterval {
			m.EdgeEventsMetricsCollectionInterval = src.EdgeEventsMetricsCollectionInterval
			changed++
		}
	}
	if _, set := fmap["25"]; set {
		if m.CleanupReservableAutoClusterIdletime != src.CleanupReservableAutoClusterIdletime {
			m.CleanupReservableAutoClusterIdletime = src.CleanupReservableAutoClusterIdletime
			changed++
		}
	}
	if _, set := fmap["26"]; set {
		if m.InfluxDbCloudletUsageMetricsRetention != src.InfluxDbCloudletUsageMetricsRetention {
			m.InfluxDbCloudletUsageMetricsRetention = src.InfluxDbCloudletUsageMetricsRetention
			changed++
		}
	}
	if _, set := fmap["27"]; set {
		if m.CreateCloudletTimeout != src.CreateCloudletTimeout {
			m.CreateCloudletTimeout = src.CreateCloudletTimeout
			changed++
		}
	}
	if _, set := fmap["28"]; set {
		if m.UpdateCloudletTimeout != src.UpdateCloudletTimeout {
			m.UpdateCloudletTimeout = src.UpdateCloudletTimeout
			changed++
		}
	}
	if _, set := fmap["29"]; set {
		if m.LocationTileSideLengthKm != src.LocationTileSideLengthKm {
			m.LocationTileSideLengthKm = src.LocationTileSideLengthKm
			changed++
		}
	}
	if _, set := fmap["30"]; set {
		if src.EdgeEventsMetricsContinuousQueriesCollectionIntervals != nil {
			if updateListAction == "add" {
				changed += m.AddEdgeEventsMetricsContinuousQueriesCollectionIntervals(src.EdgeEventsMetricsContinuousQueriesCollectionIntervals...)
			} else if updateListAction == "remove" {
				changed += m.RemoveEdgeEventsMetricsContinuousQueriesCollectionIntervals(src.EdgeEventsMetricsContinuousQueriesCollectionIntervals...)
			} else {
				m.EdgeEventsMetricsContinuousQueriesCollectionIntervals = make([]*CollectionInterval, 0)
				for k0, _ := range src.EdgeEventsMetricsContinuousQueriesCollectionIntervals {
					m.EdgeEventsMetricsContinuousQueriesCollectionIntervals = append(m.EdgeEventsMetricsContinuousQueriesCollectionIntervals, src.EdgeEventsMetricsContinuousQueriesCollectionIntervals[k0].Clone())
				}
				changed++
			}
		} else if m.EdgeEventsMetricsContinuousQueriesCollectionIntervals != nil {
			m.EdgeEventsMetricsContinuousQueriesCollectionIntervals = nil
			changed++
		}
	}
	if _, set := fmap["31"]; set {
		if m.InfluxDbDownsampledMetricsRetention != src.InfluxDbDownsampledMetricsRetention {
			m.InfluxDbDownsampledMetricsRetention = src.InfluxDbDownsampledMetricsRetention
			changed++
		}
	}
	if _, set := fmap["32"]; set {
		if m.InfluxDbEdgeEventsMetricsRetention != src.InfluxDbEdgeEventsMetricsRetention {
			m.InfluxDbEdgeEventsMetricsRetention = src.InfluxDbEdgeEventsMetricsRetention
			changed++
		}
	}
	if _, set := fmap["33"]; set {
		if m.AppinstClientCleanupInterval != src.AppinstClientCleanupInterval {
			m.AppinstClientCleanupInterval = src.AppinstClientCleanupInterval
			changed++
		}
	}
	if _, set := fmap["34"]; set {
		if m.ClusterAutoScaleAveragingDurationSec != src.ClusterAutoScaleAveragingDurationSec {
			m.ClusterAutoScaleAveragingDurationSec = src.ClusterAutoScaleAveragingDurationSec
			changed++
		}
	}
	if _, set := fmap["35"]; set {
		if m.ClusterAutoScaleRetryDelay != src.ClusterAutoScaleRetryDelay {
			m.ClusterAutoScaleRetryDelay = src.ClusterAutoScaleRetryDelay
			changed++
		}
	}
	if _, set := fmap["36"]; set {
		if m.AlertPolicyMinTriggerTime != src.AlertPolicyMinTriggerTime {
			m.AlertPolicyMinTriggerTime = src.AlertPolicyMinTriggerTime
			changed++
		}
	}
	if _, set := fmap["37"]; set {
		if m.DisableRateLimit != src.DisableRateLimit {
			m.DisableRateLimit = src.DisableRateLimit
			changed++
		}
	}
	if _, set := fmap["39"]; set {
		if m.RateLimitMaxTrackedIps != src.RateLimitMaxTrackedIps {
			m.RateLimitMaxTrackedIps = src.RateLimitMaxTrackedIps
			changed++
		}
	}
	if _, set := fmap["40"]; set {
		if m.ShepherdMetricsScrapeInterval != src.ShepherdMetricsScrapeInterval {
			m.ShepherdMetricsScrapeInterval = src.ShepherdMetricsScrapeInterval
			changed++
		}
	}
	if _, set := fmap["41"]; set {
		if m.ResourceSnapshotThreadInterval != src.ResourceSnapshotThreadInterval {
			m.ResourceSnapshotThreadInterval = src.ResourceSnapshotThreadInterval
			changed++
		}
	}
	if _, set := fmap["42"]; set {
		if m.PlatformHaInstancePollInterval != src.PlatformHaInstancePollInterval {
			m.PlatformHaInstancePollInterval = src.PlatformHaInstancePollInterval
			changed++
		}
	}
	if _, set := fmap["43"]; set {
		if m.PlatformHaInstanceActiveExpireTime != src.PlatformHaInstanceActiveExpireTime {
			m.PlatformHaInstanceActiveExpireTime = src.PlatformHaInstanceActiveExpireTime
			changed++
		}
	}
	if _, set := fmap["44"]; set {
		if m.CcrmRedisapiTimeout != src.CcrmRedisapiTimeout {
			m.CcrmRedisapiTimeout = src.CcrmRedisapiTimeout
			changed++
		}
	}
	return changed
}

func (m *Settings) DeepCopyIn(src *Settings) {
	m.ShepherdMetricsCollectionInterval = src.ShepherdMetricsCollectionInterval
	m.ShepherdHealthCheckRetries = src.ShepherdHealthCheckRetries
	m.ShepherdHealthCheckInterval = src.ShepherdHealthCheckInterval
	m.AutoDeployIntervalSec = src.AutoDeployIntervalSec
	m.AutoDeployOffsetSec = src.AutoDeployOffsetSec
	m.AutoDeployMaxIntervals = src.AutoDeployMaxIntervals
	m.CreateAppInstTimeout = src.CreateAppInstTimeout
	m.UpdateAppInstTimeout = src.UpdateAppInstTimeout
	m.DeleteAppInstTimeout = src.DeleteAppInstTimeout
	m.CreateClusterInstTimeout = src.CreateClusterInstTimeout
	m.UpdateClusterInstTimeout = src.UpdateClusterInstTimeout
	m.DeleteClusterInstTimeout = src.DeleteClusterInstTimeout
	m.MasterNodeFlavor = src.MasterNodeFlavor
	m.MaxTrackedDmeClients = src.MaxTrackedDmeClients
	m.ChefClientInterval = src.ChefClientInterval
	m.InfluxDbMetricsRetention = src.InfluxDbMetricsRetention
	m.CloudletMaintenanceTimeout = src.CloudletMaintenanceTimeout
	m.ShepherdAlertEvaluationInterval = src.ShepherdAlertEvaluationInterval
	m.UpdateVmPoolTimeout = src.UpdateVmPoolTimeout
	m.UpdateTrustPolicyTimeout = src.UpdateTrustPolicyTimeout
	m.DmeApiMetricsCollectionInterval = src.DmeApiMetricsCollectionInterval
	m.EdgeEventsMetricsCollectionInterval = src.EdgeEventsMetricsCollectionInterval
	m.CleanupReservableAutoClusterIdletime = src.CleanupReservableAutoClusterIdletime
	m.InfluxDbCloudletUsageMetricsRetention = src.InfluxDbCloudletUsageMetricsRetention
	m.CreateCloudletTimeout = src.CreateCloudletTimeout
	m.UpdateCloudletTimeout = src.UpdateCloudletTimeout
	m.LocationTileSideLengthKm = src.LocationTileSideLengthKm
	if src.EdgeEventsMetricsContinuousQueriesCollectionIntervals != nil {
		m.EdgeEventsMetricsContinuousQueriesCollectionIntervals = make([]*CollectionInterval, len(src.EdgeEventsMetricsContinuousQueriesCollectionIntervals), len(src.EdgeEventsMetricsContinuousQueriesCollectionIntervals))
		for ii, s := range src.EdgeEventsMetricsContinuousQueriesCollectionIntervals {
			var tmp_s CollectionInterval
			tmp_s.DeepCopyIn(s)
			m.EdgeEventsMetricsContinuousQueriesCollectionIntervals[ii] = &tmp_s
		}
	} else {
		m.EdgeEventsMetricsContinuousQueriesCollectionIntervals = nil
	}
	m.InfluxDbDownsampledMetricsRetention = src.InfluxDbDownsampledMetricsRetention
	m.InfluxDbEdgeEventsMetricsRetention = src.InfluxDbEdgeEventsMetricsRetention
	m.AppinstClientCleanupInterval = src.AppinstClientCleanupInterval
	m.ClusterAutoScaleAveragingDurationSec = src.ClusterAutoScaleAveragingDurationSec
	m.ClusterAutoScaleRetryDelay = src.ClusterAutoScaleRetryDelay
	m.AlertPolicyMinTriggerTime = src.AlertPolicyMinTriggerTime
	m.DisableRateLimit = src.DisableRateLimit
	m.RateLimitMaxTrackedIps = src.RateLimitMaxTrackedIps
	m.ShepherdMetricsScrapeInterval = src.ShepherdMetricsScrapeInterval
	m.ResourceSnapshotThreadInterval = src.ResourceSnapshotThreadInterval
	m.PlatformHaInstancePollInterval = src.PlatformHaInstancePollInterval
	m.PlatformHaInstanceActiveExpireTime = src.PlatformHaInstanceActiveExpireTime
	m.CcrmRedisapiTimeout = src.CcrmRedisapiTimeout
}

func (s *Settings) HasFields() bool {
	return true
}

type SettingsStore interface {
	Create(ctx context.Context, m *Settings, wait func(int64)) (*Result, error)
	Update(ctx context.Context, m *Settings, wait func(int64)) (*Result, error)
	Delete(ctx context.Context, m *Settings, wait func(int64)) (*Result, error)
	Put(ctx context.Context, m *Settings, wait func(int64), ops ...objstore.KVOp) (*Result, error)
	LoadOne(key string) (*Settings, int64, error)
	Get(ctx context.Context, key *SettingsKey, buf *Settings) bool
	STMGet(stm concurrency.STM, key *SettingsKey, buf *Settings) bool
	STMPut(stm concurrency.STM, obj *Settings, ops ...objstore.KVOp)
	STMDel(stm concurrency.STM, key *SettingsKey)
	STMHas(stm concurrency.STM, key *SettingsKey) bool
}

type SettingsStoreImpl struct {
	kvstore objstore.KVStore
}

func NewSettingsStore(kvstore objstore.KVStore) *SettingsStoreImpl {
	return &SettingsStoreImpl{kvstore: kvstore}
}

func (s *SettingsStoreImpl) Create(ctx context.Context, m *Settings, wait func(int64)) (*Result, error) {
	err := m.Validate(SettingsAllFieldsMap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("Settings", m.GetKey())
	val, err := json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Create(ctx, key, string(val))
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *SettingsStoreImpl) Update(ctx context.Context, m *Settings, wait func(int64)) (*Result, error) {
	fmap := MakeFieldMap(m.Fields)
	err := m.Validate(fmap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("Settings", m.GetKey())
	var vers int64 = 0
	curBytes, vers, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, err
	}
	var cur Settings
	err = json.Unmarshal(curBytes, &cur)
	if err != nil {
		return nil, err
	}
	cur.CopyInFields(m)
	// never save fields
	cur.Fields = nil
	val, err := json.Marshal(cur)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Update(ctx, key, string(val), vers)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *SettingsStoreImpl) Put(ctx context.Context, m *Settings, wait func(int64), ops ...objstore.KVOp) (*Result, error) {
	err := m.Validate(SettingsAllFieldsMap)
	m.Fields = nil
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("Settings", m.GetKey())
	var val []byte
	val, err = json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Put(ctx, key, string(val), ops...)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *SettingsStoreImpl) Delete(ctx context.Context, m *Settings, wait func(int64)) (*Result, error) {
	err := m.GetKey().ValidateKey()
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("Settings", m.GetKey())
	rev, err := s.kvstore.Delete(ctx, key)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *SettingsStoreImpl) LoadOne(key string) (*Settings, int64, error) {
	val, rev, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, 0, err
	}
	var obj Settings
	err = json.Unmarshal(val, &obj)
	if err != nil {
		log.DebugLog(log.DebugLevelApi, "Failed to parse Settings data", "val", string(val), "err", err)
		return nil, 0, err
	}
	return &obj, rev, nil
}

func (s *SettingsStoreImpl) Get(ctx context.Context, key *SettingsKey, buf *Settings) bool {
	keystr := objstore.DbKeyString("Settings", key)
	val, _, _, err := s.kvstore.Get(keystr)
	if err != nil {
		return false
	}
	return s.parseGetData(val, buf)
}

func (s *SettingsStoreImpl) STMGet(stm concurrency.STM, key *SettingsKey, buf *Settings) bool {
	keystr := objstore.DbKeyString("Settings", key)
	valstr := stm.Get(keystr)
	return s.parseGetData([]byte(valstr), buf)
}

func (s *SettingsStoreImpl) STMHas(stm concurrency.STM, key *SettingsKey) bool {
	keystr := objstore.DbKeyString("Settings", key)
	return stm.Get(keystr) != ""
}

func (s *SettingsStoreImpl) parseGetData(val []byte, buf *Settings) bool {
	if len(val) == 0 {
		return false
	}
	if buf != nil {
		// clear buf, because empty values in val won't
		// overwrite non-empty values in buf.
		*buf = Settings{}
		err := json.Unmarshal(val, buf)
		if err != nil {
			return false
		}
	}
	return true
}

func (s *SettingsStoreImpl) STMPut(stm concurrency.STM, obj *Settings, ops ...objstore.KVOp) {
	keystr := objstore.DbKeyString("Settings", obj.GetKey())

	val, err := json.Marshal(obj)
	if err != nil {
		log.InfoLog("Settings json marshal failed", "obj", obj, "err", err)
	}
	v3opts := GetSTMOpts(ops...)
	stm.Put(keystr, string(val), v3opts...)
}

func (s *SettingsStoreImpl) STMDel(stm concurrency.STM, key *SettingsKey) {
	keystr := objstore.DbKeyString("Settings", key)
	stm.Del(keystr)
}

type SettingsKeyWatcher struct {
	cb func(ctx context.Context)
}

type SettingsCacheData struct {
	Obj    *Settings
	ModRev int64
}

func (s *SettingsCacheData) Clone() *SettingsCacheData {
	cp := SettingsCacheData{}
	if s.Obj != nil {
		cp.Obj = &Settings{}
		cp.Obj.DeepCopyIn(s.Obj)
	}
	cp.ModRev = s.ModRev
	return &cp
}

// SettingsCache caches Settings objects in memory in a hash table
// and keeps them in sync with the database.
type SettingsCache struct {
	Objs          map[SettingsKey]*SettingsCacheData
	Mux           util.Mutex
	List          map[SettingsKey]struct{}
	FlushAll      bool
	NotifyCbs     []func(ctx context.Context, obj *Settings, modRev int64)
	UpdatedCbs    []func(ctx context.Context, old *Settings, new *Settings)
	DeletedCbs    []func(ctx context.Context, old *Settings)
	KeyWatchers   map[SettingsKey][]*SettingsKeyWatcher
	UpdatedKeyCbs []func(ctx context.Context, key *SettingsKey)
	DeletedKeyCbs []func(ctx context.Context, key *SettingsKey)
}

func NewSettingsCache() *SettingsCache {
	cache := SettingsCache{}
	InitSettingsCache(&cache)
	return &cache
}

func InitSettingsCache(cache *SettingsCache) {
	cache.Objs = make(map[SettingsKey]*SettingsCacheData)
	cache.KeyWatchers = make(map[SettingsKey][]*SettingsKeyWatcher)
	cache.NotifyCbs = nil
	cache.UpdatedCbs = nil
	cache.DeletedCbs = nil
	cache.UpdatedKeyCbs = nil
	cache.DeletedKeyCbs = nil
}

func (c *SettingsCache) GetTypeString() string {
	return "Settings"
}

func (c *SettingsCache) Get(key *SettingsKey, valbuf *Settings) bool {
	var modRev int64
	return c.GetWithRev(key, valbuf, &modRev)
}

func (c *SettingsCache) GetWithRev(key *SettingsKey, valbuf *Settings, modRev *int64) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	inst, found := c.Objs[*key]
	if found {
		valbuf.DeepCopyIn(inst.Obj)
		*modRev = inst.ModRev
	}
	return found
}

func (c *SettingsCache) HasKey(key *SettingsKey) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	_, found := c.Objs[*key]
	return found
}

func (c *SettingsCache) GetAllKeys(ctx context.Context, cb func(key *SettingsKey, modRev int64)) {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for key, data := range c.Objs {
		cb(&key, data.ModRev)
	}
}

func (c *SettingsCache) GetAllLocked(ctx context.Context, cb func(obj *Settings, modRev int64)) {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for _, data := range c.Objs {
		cb(data.Obj, data.ModRev)
	}
}

func (c *SettingsCache) Update(ctx context.Context, in *Settings, modRev int64) {
	c.UpdateModFunc(ctx, in.GetKey(), modRev, func(old *Settings) (*Settings, bool) {
		return in, true
	})
}

func (c *SettingsCache) UpdateModFunc(ctx context.Context, key *SettingsKey, modRev int64, modFunc func(old *Settings) (new *Settings, changed bool)) {
	c.Mux.Lock()
	var old *Settings
	if oldData, found := c.Objs[*key]; found {
		old = oldData.Obj
	}
	new, changed := modFunc(old)
	if !changed {
		c.Mux.Unlock()
		return
	}
	if len(c.UpdatedCbs) > 0 || len(c.NotifyCbs) > 0 {
		newCopy := &Settings{}
		newCopy.DeepCopyIn(new)
		for _, cb := range c.UpdatedCbs {
			defer cb(ctx, old, newCopy)
		}
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				defer cb(ctx, newCopy, modRev)
			}
		}
	}
	for _, cb := range c.UpdatedKeyCbs {
		defer cb(ctx, key)
	}
	store := &Settings{}
	store.DeepCopyIn(new)
	c.Objs[new.GetKeyVal()] = &SettingsCacheData{
		Obj:    store,
		ModRev: modRev,
	}
	log.SpanLog(ctx, log.DebugLevelApi, "cache update", "new", store)
	c.Mux.Unlock()
	c.TriggerKeyWatchers(ctx, new.GetKey())
}

func (c *SettingsCache) Delete(ctx context.Context, in *Settings, modRev int64) {
	c.DeleteCondFunc(ctx, in, modRev, func(old *Settings) bool {
		return true
	})
}

func (c *SettingsCache) DeleteCondFunc(ctx context.Context, in *Settings, modRev int64, condFunc func(old *Settings) bool) {
	c.Mux.Lock()
	var old *Settings
	oldData, found := c.Objs[in.GetKeyVal()]
	if found {
		old = oldData.Obj
		if !condFunc(old) {
			c.Mux.Unlock()
			return
		}
	}
	delete(c.Objs, in.GetKeyVal())
	log.SpanLog(ctx, log.DebugLevelApi, "cache delete", "key", in.GetKeyVal())
	c.Mux.Unlock()
	obj := old
	if obj == nil {
		obj = in
	}
	for _, cb := range c.NotifyCbs {
		if cb != nil {
			cb(ctx, obj, modRev)
		}
	}
	if old != nil {
		for _, cb := range c.DeletedCbs {
			cb(ctx, old)
		}
	}
	for _, cb := range c.DeletedKeyCbs {
		cb(ctx, in.GetKey())
	}
	c.TriggerKeyWatchers(ctx, in.GetKey())
}

func (c *SettingsCache) Prune(ctx context.Context, validKeys map[SettingsKey]struct{}) {
	log.SpanLog(ctx, log.DebugLevelApi, "Prune Settings", "numValidKeys", len(validKeys))
	notify := make(map[SettingsKey]*SettingsCacheData)
	c.Mux.Lock()
	for key, _ := range c.Objs {
		if _, ok := validKeys[key]; !ok {
			if len(c.NotifyCbs) > 0 || len(c.DeletedKeyCbs) > 0 || len(c.DeletedCbs) > 0 {
				notify[key] = c.Objs[key]
			}
			delete(c.Objs, key)
		}
	}
	c.Mux.Unlock()
	for key, old := range notify {
		obj := old.Obj
		if obj == nil {
			obj = &Settings{}
			obj.SetKey(&key)
		}
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, obj, old.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if old.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, old.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (c *SettingsCache) GetCount() int {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	return len(c.Objs)
}

func (c *SettingsCache) Flush(ctx context.Context, notifyId int64) {
}

func (c *SettingsCache) Show(filter *Settings, cb func(ret *Settings) error) error {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for _, data := range c.Objs {
		if !data.Obj.Matches(filter, MatchFilter()) {
			continue
		}
		err := cb(data.Obj)
		if err != nil {
			return err
		}
	}
	return nil
}

func SettingsGenericNotifyCb(fn func(key *SettingsKey, old *Settings)) func(objstore.ObjKey, objstore.Obj) {
	return func(objkey objstore.ObjKey, obj objstore.Obj) {
		fn(objkey.(*SettingsKey), obj.(*Settings))
	}
}

func (c *SettingsCache) SetNotifyCb(fn func(ctx context.Context, obj *Settings, modRev int64)) {
	c.NotifyCbs = []func(ctx context.Context, obj *Settings, modRev int64){fn}
}

func (c *SettingsCache) SetUpdatedCb(fn func(ctx context.Context, old *Settings, new *Settings)) {
	c.UpdatedCbs = []func(ctx context.Context, old *Settings, new *Settings){fn}
}

func (c *SettingsCache) SetDeletedCb(fn func(ctx context.Context, old *Settings)) {
	c.DeletedCbs = []func(ctx context.Context, old *Settings){fn}
}

func (c *SettingsCache) SetUpdatedKeyCb(fn func(ctx context.Context, key *SettingsKey)) {
	c.UpdatedKeyCbs = []func(ctx context.Context, key *SettingsKey){fn}
}

func (c *SettingsCache) SetDeletedKeyCb(fn func(ctx context.Context, key *SettingsKey)) {
	c.DeletedKeyCbs = []func(ctx context.Context, key *SettingsKey){fn}
}

func (c *SettingsCache) AddUpdatedCb(fn func(ctx context.Context, old *Settings, new *Settings)) {
	c.UpdatedCbs = append(c.UpdatedCbs, fn)
}

func (c *SettingsCache) AddDeletedCb(fn func(ctx context.Context, old *Settings)) {
	c.DeletedCbs = append(c.DeletedCbs, fn)
}

func (c *SettingsCache) AddNotifyCb(fn func(ctx context.Context, obj *Settings, modRev int64)) {
	c.NotifyCbs = append(c.NotifyCbs, fn)
}

func (c *SettingsCache) AddUpdatedKeyCb(fn func(ctx context.Context, key *SettingsKey)) {
	c.UpdatedKeyCbs = append(c.UpdatedKeyCbs, fn)
}

func (c *SettingsCache) AddDeletedKeyCb(fn func(ctx context.Context, key *SettingsKey)) {
	c.DeletedKeyCbs = append(c.DeletedKeyCbs, fn)
}

func (c *SettingsCache) SetFlushAll() {
	c.FlushAll = true
}

func (c *SettingsCache) WatchKey(key *SettingsKey, cb func(ctx context.Context)) context.CancelFunc {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	list, ok := c.KeyWatchers[*key]
	if !ok {
		list = make([]*SettingsKeyWatcher, 0)
	}
	watcher := SettingsKeyWatcher{cb: cb}
	c.KeyWatchers[*key] = append(list, &watcher)
	log.DebugLog(log.DebugLevelApi, "Watching Settings", "key", key)
	return func() {
		c.Mux.Lock()
		defer c.Mux.Unlock()
		list, ok := c.KeyWatchers[*key]
		if !ok {
			return
		}
		for ii, _ := range list {
			if list[ii] != &watcher {
				continue
			}
			if len(list) == 1 {
				delete(c.KeyWatchers, *key)
				return
			}
			list[ii] = list[len(list)-1]
			list[len(list)-1] = nil
			c.KeyWatchers[*key] = list[:len(list)-1]
			return
		}
	}
}

func (c *SettingsCache) TriggerKeyWatchers(ctx context.Context, key *SettingsKey) {
	watchers := make([]*SettingsKeyWatcher, 0)
	c.Mux.Lock()
	if list, ok := c.KeyWatchers[*key]; ok {
		watchers = append(watchers, list...)
	}
	c.Mux.Unlock()
	for ii, _ := range watchers {
		watchers[ii].cb(ctx)
	}
}

// Note that we explicitly ignore the global revision number, because of the way
// the notify framework sends updates (by hashing keys and doing lookups, instead
// of sequentially through a history buffer), updates may be done out-of-order
// or multiple updates compressed into one update, so the state of the cache at
// any point in time may not by in sync with a particular database revision number.

func (c *SettingsCache) SyncUpdate(ctx context.Context, key, val []byte, rev, modRev int64) {
	obj := Settings{}
	err := json.Unmarshal(val, &obj)
	if err != nil {
		log.WarnLog("Failed to parse Settings data", "val", string(val), "err", err)
		return
	}
	c.Update(ctx, &obj, modRev)
	c.Mux.Lock()
	if c.List != nil {
		c.List[obj.GetKeyVal()] = struct{}{}
	}
	c.Mux.Unlock()
}

func (c *SettingsCache) SyncDelete(ctx context.Context, key []byte, rev, modRev int64) {
	obj := Settings{}
	keystr := objstore.DbKeyPrefixRemove(string(key))
	SettingsKeyStringParse(keystr, &obj)
	c.Delete(ctx, &obj, modRev)
}

func (c *SettingsCache) SyncListStart(ctx context.Context) {
	c.List = make(map[SettingsKey]struct{})
}

func (c *SettingsCache) SyncListEnd(ctx context.Context) {
	deleted := make(map[SettingsKey]*SettingsCacheData)
	c.Mux.Lock()
	for key, val := range c.Objs {
		if _, found := c.List[key]; !found {
			deleted[key] = val
			delete(c.Objs, key)
		}
	}
	c.List = nil
	c.Mux.Unlock()
	for key, val := range deleted {
		obj := val.Obj
		if obj == nil {
			obj = &Settings{}
			obj.SetKey(&key)
		}
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, obj, val.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if val.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, val.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (c *SettingsCache) UsesOrg(org string) bool {
	return false
}

// Helper method to check that enums have valid values
// NOTE: ValidateEnums checks all Fields even if some are not set
func (m *Settings) ValidateEnums() error {
	for _, e := range m.EdgeEventsMetricsContinuousQueriesCollectionIntervals {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (s *Settings) ClearTagged(tags map[string]struct{}) {
	if s.EdgeEventsMetricsContinuousQueriesCollectionIntervals != nil {
		for ii := 0; ii < len(s.EdgeEventsMetricsContinuousQueriesCollectionIntervals); ii++ {
			s.EdgeEventsMetricsContinuousQueriesCollectionIntervals[ii].ClearTagged(tags)
		}
	}
}

func (m *CollectionInterval) Clone() *CollectionInterval {
	cp := &CollectionInterval{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *CollectionInterval) CopyInFields(src *CollectionInterval) int {
	changed := 0
	if m.Interval != src.Interval {
		m.Interval = src.Interval
		changed++
	}
	if m.Retention != src.Retention {
		m.Retention = src.Retention
		changed++
	}
	return changed
}

func (m *CollectionInterval) DeepCopyIn(src *CollectionInterval) {
	m.Interval = src.Interval
	m.Retention = src.Retention
}

// Helper method to check that enums have valid values
func (m *CollectionInterval) ValidateEnums() error {
	return nil
}

func (s *CollectionInterval) ClearTagged(tags map[string]struct{}) {
}

func (m *Settings) IsValidArgsForUpdateSettings() error {
	return nil
}

func (m *Settings) IsValidArgsForResetSettings() error {
	return nil
}

func (m *Settings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovSettings(uint64(l))
		}
	}
	if m.ShepherdMetricsCollectionInterval != 0 {
		n += 1 + sovSettings(uint64(m.ShepherdMetricsCollectionInterval))
	}
	if m.ShepherdHealthCheckRetries != 0 {
		n += 1 + sovSettings(uint64(m.ShepherdHealthCheckRetries))
	}
	if m.ShepherdHealthCheckInterval != 0 {
		n += 1 + sovSettings(uint64(m.ShepherdHealthCheckInterval))
	}
	if m.AutoDeployIntervalSec != 0 {
		n += 9
	}
	if m.AutoDeployOffsetSec != 0 {
		n += 9
	}
	if m.AutoDeployMaxIntervals != 0 {
		n += 1 + sovSettings(uint64(m.AutoDeployMaxIntervals))
	}
	if m.CreateAppInstTimeout != 0 {
		n += 1 + sovSettings(uint64(m.CreateAppInstTimeout))
	}
	if m.UpdateAppInstTimeout != 0 {
		n += 1 + sovSettings(uint64(m.UpdateAppInstTimeout))
	}
	if m.DeleteAppInstTimeout != 0 {
		n += 1 + sovSettings(uint64(m.DeleteAppInstTimeout))
	}
	if m.CreateClusterInstTimeout != 0 {
		n += 1 + sovSettings(uint64(m.CreateClusterInstTimeout))
	}
	if m.UpdateClusterInstTimeout != 0 {
		n += 1 + sovSettings(uint64(m.UpdateClusterInstTimeout))
	}
	if m.DeleteClusterInstTimeout != 0 {
		n += 1 + sovSettings(uint64(m.DeleteClusterInstTimeout))
	}
	l = len(m.MasterNodeFlavor)
	if l > 0 {
		n += 1 + l + sovSettings(uint64(l))
	}
	if m.MaxTrackedDmeClients != 0 {
		n += 2 + sovSettings(uint64(m.MaxTrackedDmeClients))
	}
	if m.ChefClientInterval != 0 {
		n += 2 + sovSettings(uint64(m.ChefClientInterval))
	}
	if m.InfluxDbMetricsRetention != 0 {
		n += 2 + sovSettings(uint64(m.InfluxDbMetricsRetention))
	}
	if m.CloudletMaintenanceTimeout != 0 {
		n += 2 + sovSettings(uint64(m.CloudletMaintenanceTimeout))
	}
	if m.ShepherdAlertEvaluationInterval != 0 {
		n += 2 + sovSettings(uint64(m.ShepherdAlertEvaluationInterval))
	}
	if m.UpdateVmPoolTimeout != 0 {
		n += 2 + sovSettings(uint64(m.UpdateVmPoolTimeout))
	}
	if m.UpdateTrustPolicyTimeout != 0 {
		n += 2 + sovSettings(uint64(m.UpdateTrustPolicyTimeout))
	}
	if m.DmeApiMetricsCollectionInterval != 0 {
		n += 2 + sovSettings(uint64(m.DmeApiMetricsCollectionInterval))
	}
	if m.EdgeEventsMetricsCollectionInterval != 0 {
		n += 2 + sovSettings(uint64(m.EdgeEventsMetricsCollectionInterval))
	}
	if m.CleanupReservableAutoClusterIdletime != 0 {
		n += 2 + sovSettings(uint64(m.CleanupReservableAutoClusterIdletime))
	}
	if m.InfluxDbCloudletUsageMetricsRetention != 0 {
		n += 2 + sovSettings(uint64(m.InfluxDbCloudletUsageMetricsRetention))
	}
	if m.CreateCloudletTimeout != 0 {
		n += 2 + sovSettings(uint64(m.CreateCloudletTimeout))
	}
	if m.UpdateCloudletTimeout != 0 {
		n += 2 + sovSettings(uint64(m.UpdateCloudletTimeout))
	}
	if m.LocationTileSideLengthKm != 0 {
		n += 2 + sovSettings(uint64(m.LocationTileSideLengthKm))
	}
	if len(m.EdgeEventsMetricsContinuousQueriesCollectionIntervals) > 0 {
		for _, e := range m.EdgeEventsMetricsContinuousQueriesCollectionIntervals {
			l = e.Size()
			n += 2 + l + sovSettings(uint64(l))
		}
	}
	if m.InfluxDbDownsampledMetricsRetention != 0 {
		n += 2 + sovSettings(uint64(m.InfluxDbDownsampledMetricsRetention))
	}
	if m.InfluxDbEdgeEventsMetricsRetention != 0 {
		n += 2 + sovSettings(uint64(m.InfluxDbEdgeEventsMetricsRetention))
	}
	if m.AppinstClientCleanupInterval != 0 {
		n += 2 + sovSettings(uint64(m.AppinstClientCleanupInterval))
	}
	if m.ClusterAutoScaleAveragingDurationSec != 0 {
		n += 2 + sovSettings(uint64(m.ClusterAutoScaleAveragingDurationSec))
	}
	if m.ClusterAutoScaleRetryDelay != 0 {
		n += 2 + sovSettings(uint64(m.ClusterAutoScaleRetryDelay))
	}
	if m.AlertPolicyMinTriggerTime != 0 {
		n += 2 + sovSettings(uint64(m.AlertPolicyMinTriggerTime))
	}
	if m.DisableRateLimit {
		n += 3
	}
	if m.RateLimitMaxTrackedIps != 0 {
		n += 2 + sovSettings(uint64(m.RateLimitMaxTrackedIps))
	}
	if m.ShepherdMetricsScrapeInterval != 0 {
		n += 2 + sovSettings(uint64(m.ShepherdMetricsScrapeInterval))
	}
	if m.ResourceSnapshotThreadInterval != 0 {
		n += 2 + sovSettings(uint64(m.ResourceSnapshotThreadInterval))
	}
	if m.PlatformHaInstancePollInterval != 0 {
		n += 2 + sovSettings(uint64(m.PlatformHaInstancePollInterval))
	}
	if m.PlatformHaInstanceActiveExpireTime != 0 {
		n += 2 + sovSettings(uint64(m.PlatformHaInstanceActiveExpireTime))
	}
	if m.CcrmRedisapiTimeout != 0 {
		n += 2 + sovSettings(uint64(m.CcrmRedisapiTimeout))
	}
	return n
}

func (m *CollectionInterval) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Interval != 0 {
		n += 1 + sovSettings(uint64(m.Interval))
	}
	if m.Retention != 0 {
		n += 1 + sovSettings(uint64(m.Retention))
	}
	return n
}

func sovSettings(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozSettings(x uint64) (n int) {
	return sovSettings(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Settings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSettings
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Settings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Settings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSettings
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSettings
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShepherdMetricsCollectionInterval", wireType)
			}
			m.ShepherdMetricsCollectionInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShepherdMetricsCollectionInterval |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShepherdHealthCheckRetries", wireType)
			}
			m.ShepherdHealthCheckRetries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShepherdHealthCheckRetries |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShepherdHealthCheckInterval", wireType)
			}
			m.ShepherdHealthCheckInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShepherdHealthCheckInterval |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoDeployIntervalSec", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.AutoDeployIntervalSec = float64(math.Float64frombits(v))
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoDeployOffsetSec", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.AutoDeployOffsetSec = float64(math.Float64frombits(v))
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoDeployMaxIntervals", wireType)
			}
			m.AutoDeployMaxIntervals = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AutoDeployMaxIntervals |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateAppInstTimeout", wireType)
			}
			m.CreateAppInstTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateAppInstTimeout |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateAppInstTimeout", wireType)
			}
			m.UpdateAppInstTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateAppInstTimeout |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteAppInstTimeout", wireType)
			}
			m.DeleteAppInstTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeleteAppInstTimeout |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateClusterInstTimeout", wireType)
			}
			m.CreateClusterInstTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateClusterInstTimeout |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateClusterInstTimeout", wireType)
			}
			m.UpdateClusterInstTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateClusterInstTimeout |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteClusterInstTimeout", wireType)
			}
			m.DeleteClusterInstTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeleteClusterInstTimeout |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MasterNodeFlavor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSettings
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSettings
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MasterNodeFlavor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTrackedDmeClients", wireType)
			}
			m.MaxTrackedDmeClients = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxTrackedDmeClients |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChefClientInterval", wireType)
			}
			m.ChefClientInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChefClientInterval |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InfluxDbMetricsRetention", wireType)
			}
			m.InfluxDbMetricsRetention = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InfluxDbMetricsRetention |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudletMaintenanceTimeout", wireType)
			}
			m.CloudletMaintenanceTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CloudletMaintenanceTimeout |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShepherdAlertEvaluationInterval", wireType)
			}
			m.ShepherdAlertEvaluationInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShepherdAlertEvaluationInterval |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateVmPoolTimeout", wireType)
			}
			m.UpdateVmPoolTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateVmPoolTimeout |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateTrustPolicyTimeout", wireType)
			}
			m.UpdateTrustPolicyTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateTrustPolicyTimeout |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DmeApiMetricsCollectionInterval", wireType)
			}
			m.DmeApiMetricsCollectionInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DmeApiMetricsCollectionInterval |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EdgeEventsMetricsCollectionInterval", wireType)
			}
			m.EdgeEventsMetricsCollectionInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EdgeEventsMetricsCollectionInterval |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CleanupReservableAutoClusterIdletime", wireType)
			}
			m.CleanupReservableAutoClusterIdletime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CleanupReservableAutoClusterIdletime |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InfluxDbCloudletUsageMetricsRetention", wireType)
			}
			m.InfluxDbCloudletUsageMetricsRetention = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InfluxDbCloudletUsageMetricsRetention |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateCloudletTimeout", wireType)
			}
			m.CreateCloudletTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateCloudletTimeout |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateCloudletTimeout", wireType)
			}
			m.UpdateCloudletTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateCloudletTimeout |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocationTileSideLengthKm", wireType)
			}
			m.LocationTileSideLengthKm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LocationTileSideLengthKm |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EdgeEventsMetricsContinuousQueriesCollectionIntervals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSettings
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSettings
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EdgeEventsMetricsContinuousQueriesCollectionIntervals = append(m.EdgeEventsMetricsContinuousQueriesCollectionIntervals, &CollectionInterval{})
			if err := m.EdgeEventsMetricsContinuousQueriesCollectionIntervals[len(m.EdgeEventsMetricsContinuousQueriesCollectionIntervals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InfluxDbDownsampledMetricsRetention", wireType)
			}
			m.InfluxDbDownsampledMetricsRetention = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InfluxDbDownsampledMetricsRetention |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InfluxDbEdgeEventsMetricsRetention", wireType)
			}
			m.InfluxDbEdgeEventsMetricsRetention = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InfluxDbEdgeEventsMetricsRetention |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppinstClientCleanupInterval", wireType)
			}
			m.AppinstClientCleanupInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AppinstClientCleanupInterval |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterAutoScaleAveragingDurationSec", wireType)
			}
			m.ClusterAutoScaleAveragingDurationSec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterAutoScaleAveragingDurationSec |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterAutoScaleRetryDelay", wireType)
			}
			m.ClusterAutoScaleRetryDelay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterAutoScaleRetryDelay |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlertPolicyMinTriggerTime", wireType)
			}
			m.AlertPolicyMinTriggerTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AlertPolicyMinTriggerTime |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableRateLimit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableRateLimit = bool(v != 0)
		case 39:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RateLimitMaxTrackedIps", wireType)
			}
			m.RateLimitMaxTrackedIps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RateLimitMaxTrackedIps |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShepherdMetricsScrapeInterval", wireType)
			}
			m.ShepherdMetricsScrapeInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShepherdMetricsScrapeInterval |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceSnapshotThreadInterval", wireType)
			}
			m.ResourceSnapshotThreadInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResourceSnapshotThreadInterval |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 42:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlatformHaInstancePollInterval", wireType)
			}
			m.PlatformHaInstancePollInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlatformHaInstancePollInterval |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 43:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlatformHaInstanceActiveExpireTime", wireType)
			}
			m.PlatformHaInstanceActiveExpireTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlatformHaInstanceActiveExpireTime |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 44:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CcrmRedisapiTimeout", wireType)
			}
			m.CcrmRedisapiTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CcrmRedisapiTimeout |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSettings(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSettings
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectionInterval) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSettings
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectionInterval: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectionInterval: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			m.Interval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Interval |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Retention", wireType)
			}
			m.Retention = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Retention |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSettings(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSettings
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSettings(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSettings
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSettings
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthSettings
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupSettings
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthSettings
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthSettings        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSettings          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupSettings = fmt.Errorf("proto: unexpected end of group")
)
