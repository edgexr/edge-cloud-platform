// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ccrm.proto

package edgeproto

import (
	context "context"
	fmt "fmt"
	_ "github.com/edgexr/edge-cloud-platform/tools/protogen"
	_ "github.com/gogo/googleapis/google/api"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type StreamStatus struct {
	// Cache update type
	CacheUpdateType int32 `protobuf:"varint,3,opt,name=cache_update_type,json=cacheUpdateType,proto3" json:"cache_update_type,omitempty"`
	// Status value
	Status string `protobuf:"bytes,4,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *StreamStatus) Reset()         { *m = StreamStatus{} }
func (m *StreamStatus) String() string { return proto.CompactTextString(m) }
func (*StreamStatus) ProtoMessage()    {}
func (*StreamStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_0502422f6eb3ccb5, []int{0}
}
func (m *StreamStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StreamStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StreamStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamStatus.Merge(m, src)
}
func (m *StreamStatus) XXX_Size() int {
	return m.Size()
}
func (m *StreamStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamStatus.DiscardUnknown(m)
}

var xxx_messageInfo_StreamStatus proto.InternalMessageInfo

type InfraResourceMap struct {
	// Infra resources map
	InfraResources map[string]InfraResource `protobuf:"bytes,1,rep,name=infra_resources,json=infraResources,proto3" json:"infra_resources" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *InfraResourceMap) Reset()         { *m = InfraResourceMap{} }
func (m *InfraResourceMap) String() string { return proto.CompactTextString(m) }
func (*InfraResourceMap) ProtoMessage()    {}
func (*InfraResourceMap) Descriptor() ([]byte, []int) {
	return fileDescriptor_0502422f6eb3ccb5, []int{1}
}
func (m *InfraResourceMap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InfraResourceMap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InfraResourceMap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InfraResourceMap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InfraResourceMap.Merge(m, src)
}
func (m *InfraResourceMap) XXX_Size() int {
	return m.Size()
}
func (m *InfraResourceMap) XXX_DiscardUnknown() {
	xxx_messageInfo_InfraResourceMap.DiscardUnknown(m)
}

var xxx_messageInfo_InfraResourceMap proto.InternalMessageInfo

type ClusterResourcesReq struct {
	// Cloudlet
	CloudletKey *CloudletKey `protobuf:"bytes,1,opt,name=cloudlet_key,json=cloudletKey,proto3" json:"cloudlet_key,omitempty"`
	// VM Resources
	VmResources []VMResource `protobuf:"bytes,2,rep,name=vm_resources,json=vmResources,proto3" json:"vm_resources"`
	// Infra Resources Map
	InfraResources map[string]InfraResource `protobuf:"bytes,3,rep,name=infra_resources,json=infraResources,proto3" json:"infra_resources" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *ClusterResourcesReq) Reset()         { *m = ClusterResourcesReq{} }
func (m *ClusterResourcesReq) String() string { return proto.CompactTextString(m) }
func (*ClusterResourcesReq) ProtoMessage()    {}
func (*ClusterResourcesReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_0502422f6eb3ccb5, []int{2}
}
func (m *ClusterResourcesReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterResourcesReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterResourcesReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterResourcesReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterResourcesReq.Merge(m, src)
}
func (m *ClusterResourcesReq) XXX_Size() int {
	return m.Size()
}
func (m *ClusterResourcesReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterResourcesReq.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterResourcesReq proto.InternalMessageInfo

type ClusterResourceMetricReq struct {
	// Cloudlet
	CloudletKey *CloudletKey `protobuf:"bytes,1,opt,name=cloudlet_key,json=cloudletKey,proto3" json:"cloudlet_key,omitempty"`
	// Resource Metric
	ResMetric *Metric `protobuf:"bytes,2,opt,name=res_metric,json=resMetric,proto3" json:"res_metric,omitempty"`
	// VM Resources
	VmResources []VMResource `protobuf:"bytes,3,rep,name=vm_resources,json=vmResources,proto3" json:"vm_resources"`
}

func (m *ClusterResourceMetricReq) Reset()         { *m = ClusterResourceMetricReq{} }
func (m *ClusterResourceMetricReq) String() string { return proto.CompactTextString(m) }
func (*ClusterResourceMetricReq) ProtoMessage()    {}
func (*ClusterResourceMetricReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_0502422f6eb3ccb5, []int{3}
}
func (m *ClusterResourceMetricReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterResourceMetricReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterResourceMetricReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterResourceMetricReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterResourceMetricReq.Merge(m, src)
}
func (m *ClusterResourceMetricReq) XXX_Size() int {
	return m.Size()
}
func (m *ClusterResourceMetricReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterResourceMetricReq.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterResourceMetricReq proto.InternalMessageInfo

type NameSanitizeReq struct {
	// Cloudlet
	CloudletKey *CloudletKey `protobuf:"bytes,1,opt,name=cloudlet_key,json=cloudletKey,proto3" json:"cloudlet_key,omitempty"`
	// String value
	Message string `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *NameSanitizeReq) Reset()         { *m = NameSanitizeReq{} }
func (m *NameSanitizeReq) String() string { return proto.CompactTextString(m) }
func (*NameSanitizeReq) ProtoMessage()    {}
func (*NameSanitizeReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_0502422f6eb3ccb5, []int{4}
}
func (m *NameSanitizeReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NameSanitizeReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NameSanitizeReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NameSanitizeReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NameSanitizeReq.Merge(m, src)
}
func (m *NameSanitizeReq) XXX_Size() int {
	return m.Size()
}
func (m *NameSanitizeReq) XXX_DiscardUnknown() {
	xxx_messageInfo_NameSanitizeReq.DiscardUnknown(m)
}

var xxx_messageInfo_NameSanitizeReq proto.InternalMessageInfo

type CloudletExecReq struct {
	// Cloudlet
	CloudletKey *CloudletKey `protobuf:"bytes,1,opt,name=cloudlet_key,json=cloudletKey,proto3" json:"cloudlet_key,omitempty"`
	// ExecRequest
	ExecReq *ExecRequest `protobuf:"bytes,2,opt,name=exec_req,json=execReq,proto3" json:"exec_req,omitempty"`
}

func (m *CloudletExecReq) Reset()         { *m = CloudletExecReq{} }
func (m *CloudletExecReq) String() string { return proto.CompactTextString(m) }
func (*CloudletExecReq) ProtoMessage()    {}
func (*CloudletExecReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_0502422f6eb3ccb5, []int{5}
}
func (m *CloudletExecReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CloudletExecReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CloudletExecReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CloudletExecReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloudletExecReq.Merge(m, src)
}
func (m *CloudletExecReq) XXX_Size() int {
	return m.Size()
}
func (m *CloudletExecReq) XXX_DiscardUnknown() {
	xxx_messageInfo_CloudletExecReq.DiscardUnknown(m)
}

var xxx_messageInfo_CloudletExecReq proto.InternalMessageInfo

func init() {
	proto.RegisterType((*StreamStatus)(nil), "edgeproto.StreamStatus")
	proto.RegisterType((*InfraResourceMap)(nil), "edgeproto.InfraResourceMap")
	proto.RegisterMapType((map[string]InfraResource)(nil), "edgeproto.InfraResourceMap.InfraResourcesEntry")
	proto.RegisterType((*ClusterResourcesReq)(nil), "edgeproto.ClusterResourcesReq")
	proto.RegisterMapType((map[string]InfraResource)(nil), "edgeproto.ClusterResourcesReq.InfraResourcesEntry")
	proto.RegisterType((*ClusterResourceMetricReq)(nil), "edgeproto.ClusterResourceMetricReq")
	proto.RegisterType((*NameSanitizeReq)(nil), "edgeproto.NameSanitizeReq")
	proto.RegisterType((*CloudletExecReq)(nil), "edgeproto.CloudletExecReq")
}

func init() { proto.RegisterFile("ccrm.proto", fileDescriptor_0502422f6eb3ccb5) }

var fileDescriptor_0502422f6eb3ccb5 = []byte{
	// 908 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x56, 0x41, 0x6f, 0xdc, 0x44,
	0x14, 0xb6, 0x93, 0x34, 0x25, 0x6f, 0xb7, 0xdd, 0x64, 0x12, 0x8a, 0x71, 0xdb, 0x25, 0x32, 0x97,
	0x88, 0x43, 0xb6, 0x2c, 0x97, 0xd2, 0x43, 0xd0, 0x36, 0x0a, 0x55, 0x42, 0x17, 0xad, 0x9c, 0x80,
	0x90, 0x90, 0xba, 0x9a, 0x7a, 0xdf, 0x6e, 0xad, 0x7a, 0x3d, 0xee, 0xcc, 0x38, 0xca, 0x72, 0xe1,
	0x2f, 0x20, 0xf1, 0x23, 0xf8, 0x1b, 0xdc, 0xc8, 0x8d, 0x1c, 0x39, 0x21, 0x48, 0x6e, 0x9c, 0x91,
	0xb8, 0x22, 0x8f, 0x67, 0x1c, 0x6f, 0xd6, 0x1b, 0x09, 0x85, 0x43, 0x6f, 0xf3, 0xde, 0x9b, 0xf7,
	0xbd, 0x6f, 0xde, 0x7c, 0x6f, 0x6c, 0x80, 0x20, 0xe0, 0xe3, 0xed, 0x84, 0x33, 0xc9, 0xc8, 0x0a,
	0x0e, 0x46, 0xa8, 0x96, 0xee, 0x83, 0x11, 0x63, 0xa3, 0x08, 0x5b, 0x34, 0x09, 0x5b, 0x34, 0x8e,
	0x99, 0xa4, 0x32, 0x64, 0xb1, 0xc8, 0x37, 0xba, 0x0f, 0x25, 0x63, 0x91, 0x68, 0x29, 0x63, 0x84,
	0x71, 0xb1, 0xd0, 0xe1, 0xb5, 0x20, 0x62, 0xe9, 0x20, 0x42, 0xf9, 0x1a, 0x27, 0xda, 0x75, 0xd7,
	0xb8, 0xb4, 0x5d, 0x1f, 0x46, 0xf4, 0x98, 0x71, 0x6d, 0x01, 0xc7, 0xa1, 0xc1, 0xae, 0x8f, 0x51,
	0xf2, 0x30, 0x30, 0x16, 0x47, 0x91, 0x46, 0x26, 0x0b, 0xf0, 0x04, 0x83, 0xcb, 0x22, 0xa9, 0x90,
	0xc8, 0xc3, 0x58, 0x98, 0xf0, 0x1d, 0x9a, 0x24, 0x25, 0xd3, 0x95, 0x3c, 0x15, 0x32, 0x61, 0x51,
	0x18, 0x4c, 0xf0, 0x24, 0xc0, 0x24, 0x3b, 0x82, 0x8e, 0x6d, 0x84, 0xf1, 0x90, 0x53, 0x8e, 0x82,
	0xa5, 0x3c, 0x40, 0x53, 0x7b, 0x63, 0xc4, 0x46, 0x4c, 0x2d, 0x5b, 0xd9, 0x2a, 0xf7, 0x7a, 0xdf,
	0x40, 0xfd, 0x50, 0x72, 0xa4, 0xe3, 0x43, 0x49, 0x65, 0x2a, 0xc8, 0x47, 0xb0, 0x16, 0xd0, 0xe0,
	0x15, 0xf6, 0xd3, 0x64, 0x40, 0x25, 0xf6, 0xe5, 0x24, 0x41, 0x67, 0x71, 0xd3, 0xde, 0xba, 0xe5,
	0x37, 0x54, 0xe0, 0x2b, 0xe5, 0x3f, 0x9a, 0x24, 0x48, 0xee, 0xc1, 0xb2, 0x50, 0x59, 0xce, 0xd2,
	0xa6, 0xbd, 0xb5, 0xe2, 0x6b, 0xeb, 0xc9, 0xd2, 0xcf, 0x7f, 0x3b, 0xb6, 0xf7, 0xab, 0x0d, 0xab,
	0xfb, 0x19, 0x11, 0x5f, 0x13, 0xe9, 0xd2, 0x84, 0xbc, 0x80, 0x86, 0x22, 0xd7, 0x2f, 0xd8, 0x39,
	0xf6, 0xe6, 0xe2, 0x56, 0xad, 0xdd, 0xda, 0x2e, 0xee, 0x67, 0xfb, 0x6a, 0xd6, 0xb4, 0x43, 0xec,
	0xc5, 0x92, 0x4f, 0x9e, 0x2e, 0x9d, 0xfe, 0xfe, 0x81, 0xe5, 0xdf, 0x0d, 0xa7, 0x42, 0xee, 0xb7,
	0xb0, 0x5e, 0xb1, 0x99, 0xac, 0xc2, 0xe2, 0x6b, 0x9c, 0x38, 0xb6, 0xa2, 0x99, 0x2d, 0xc9, 0x36,
	0xdc, 0x3a, 0xa6, 0x51, 0x8a, 0xce, 0xc2, 0xa6, 0xbd, 0x55, 0x6b, 0x3b, 0xf3, 0xca, 0xfb, 0xf9,
	0xb6, 0x27, 0x0b, 0x8f, 0x6d, 0xef, 0x6c, 0x01, 0xd6, 0x77, 0xf3, 0x8b, 0x29, 0xf0, 0x7d, 0x7c,
	0x43, 0x3e, 0x85, 0xba, 0x51, 0x40, 0xdf, 0x94, 0xa9, 0xb5, 0xef, 0x95, 0x20, 0x77, 0x75, 0xf8,
	0x0b, 0x9c, 0xf8, 0xb5, 0xe0, 0xd2, 0x20, 0x3b, 0x50, 0x3f, 0x1e, 0x97, 0x9a, 0xb1, 0xa0, 0x9a,
	0xf1, 0x6e, 0x29, 0xf5, 0xeb, 0xae, 0xa9, 0xa5, 0x8f, 0x5c, 0x3b, 0x1e, 0x17, 0xd5, 0x09, 0x9d,
	0xed, 0xe7, 0xa2, 0x82, 0x68, 0x4f, 0x55, 0x9f, 0xe1, 0xfc, 0xb6, 0xb4, 0xf4, 0x17, 0x1b, 0x9c,
	0x2b, 0xf4, 0xba, 0x6a, 0x44, 0x6e, 0xd8, 0xd7, 0x47, 0x00, 0x1c, 0x45, 0x3f, 0x1f, 0x37, 0x4d,
	0x68, 0xad, 0x94, 0xa8, 0x8b, 0xac, 0x70, 0x14, 0xf9, 0x72, 0xe6, 0x26, 0x16, 0xff, 0xdb, 0x4d,
	0x78, 0x43, 0x68, 0x7c, 0x49, 0xc7, 0x78, 0x48, 0xe3, 0x50, 0x86, 0xdf, 0xe1, 0x0d, 0xf9, 0x3b,
	0x70, 0x7b, 0x8c, 0x42, 0xd0, 0x51, 0xde, 0xcd, 0x15, 0xdf, 0x98, 0xde, 0xf7, 0xd0, 0x30, 0x59,
	0x7b, 0x27, 0x78, 0xd3, 0x3e, 0x7d, 0x0c, 0xef, 0x64, 0xcf, 0x4e, 0x9f, 0xe3, 0x1b, 0xdd, 0xa5,
	0x72, 0x9a, 0x2e, 0x90, 0xa2, 0x90, 0xfe, 0x6d, 0xcc, 0x8d, 0xf6, 0x8f, 0xcb, 0xd9, 0x14, 0xe4,
	0x10, 0xbd, 0x88, 0xca, 0x21, 0xe3, 0xe3, 0x4e, 0x6f, 0x9f, 0x3c, 0x87, 0xf5, 0x67, 0x28, 0x4d,
	0xa4, 0x4b, 0xe3, 0x70, 0x88, 0x42, 0x92, 0x39, 0x34, 0xdc, 0xfb, 0x15, 0x7e, 0x93, 0xe4, 0x59,
	0xe4, 0x05, 0x3c, 0x54, 0x68, 0x4a, 0x1a, 0x9d, 0xc1, 0x20, 0xcc, 0xde, 0x37, 0x1a, 0x5d, 0x2a,
	0xbf, 0x79, 0xbd, 0xc0, 0xa7, 0xf0, 0xaf, 0x3e, 0x28, 0x0a, 0xdf, 0xbb, 0x0e, 0x5f, 0x8b, 0xe2,
	0xc3, 0xf9, 0x45, 0x0a, 0x99, 0xba, 0xb3, 0xba, 0xf2, 0x2c, 0xe2, 0xc3, 0xfd, 0x67, 0x28, 0x7d,
	0x14, 0x99, 0x2d, 0x71, 0x60, 0x8e, 0xa8, 0x9f, 0xd9, 0x79, 0x5d, 0x79, 0xaf, 0xe4, 0x2f, 0xbf,
	0xcb, 0x9e, 0xf5, 0xc8, 0x26, 0x3b, 0xd0, 0xc8, 0x30, 0x19, 0x93, 0xcf, 0x5f, 0x7e, 0xae, 0x3e,
	0x31, 0x73, 0x71, 0xca, 0x9c, 0xf2, 0xad, 0x9e, 0x45, 0x0e, 0x80, 0xf4, 0x38, 0x0b, 0x50, 0x88,
	0xd2, 0xc5, 0x12, 0xb7, 0x02, 0x42, 0xc7, 0xdd, 0x39, 0x62, 0xf0, 0x2c, 0xf2, 0x19, 0xd4, 0xcb,
	0x72, 0x9f, 0x42, 0xb9, 0x32, 0x07, 0x53, 0x64, 0x7c, 0xf5, 0xc9, 0xf3, 0x2c, 0xd2, 0x81, 0x3b,
	0x9d, 0x24, 0x89, 0x26, 0xa6, 0x24, 0x59, 0xaf, 0xe0, 0x31, 0xd5, 0x0f, 0xe3, 0xdc, 0x8f, 0x87,
	0x4c, 0xf5, 0xe3, 0x31, 0xd4, 0x7d, 0x1c, 0x72, 0x14, 0xaf, 0x76, 0x91, 0x4b, 0x51, 0x8d, 0x50,
	0x59, 0xfc, 0x00, 0x36, 0x4a, 0x5a, 0xbd, 0x14, 0x55, 0x25, 0xc2, 0xf5, 0x4a, 0x72, 0x97, 0x4e,
	0xff, 0x71, 0xec, 0xf6, 0x4f, 0x36, 0x10, 0xad, 0x90, 0xf2, 0x50, 0x1c, 0xc0, 0xaa, 0x3e, 0xa5,
	0x0a, 0xed, 0xc7, 0x33, 0x13, 0x51, 0xf8, 0x5d, 0xb7, 0xda, 0x5f, 0x1c, 0xf7, 0xa6, 0x2d, 0xd7,
	0x4c, 0xff, 0xb2, 0x81, 0x74, 0x92, 0x24, 0x83, 0x2e, 0x33, 0xdd, 0x81, 0xba, 0x62, 0xaa, 0x43,
	0x84, 0x94, 0x10, 0xb4, 0x6f, 0x4a, 0x0e, 0xda, 0x57, 0xb0, 0xeb, 0xc2, 0xfb, 0x2a, 0xff, 0x28,
	0xfb, 0x2f, 0xe9, 0xa9, 0xff, 0x92, 0x3d, 0xf3, 0x5f, 0x42, 0xca, 0x2d, 0x3c, 0xea, 0xed, 0x65,
	0x89, 0x34, 0x0e, 0x30, 0xd3, 0x36, 0x56, 0xdf, 0xd0, 0xff, 0x73, 0xd8, 0xa7, 0x0f, 0x4e, 0xff,
	0x6c, 0x5a, 0xa7, 0xe7, 0x4d, 0xfb, 0xec, 0xbc, 0x69, 0xff, 0x71, 0xde, 0xb4, 0x7f, 0xb8, 0x68,
	0x5a, 0x67, 0x17, 0x4d, 0xeb, 0xb7, 0x8b, 0xa6, 0xf5, 0x72, 0x59, 0xe5, 0x7c, 0xf2, 0x6f, 0x00,
	0x00, 0x00, 0xff, 0xff, 0x4f, 0x7b, 0x8c, 0xea, 0x28, 0x0a, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// CloudletPlatformAPIClient is the client API for CloudletPlatformAPI service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type CloudletPlatformAPIClient interface {
	GetCloudletManifest(ctx context.Context, in *CloudletKey, opts ...grpc.CallOption) (*CloudletManifest, error)
	GetClusterAdditionalResources(ctx context.Context, in *ClusterResourcesReq, opts ...grpc.CallOption) (*InfraResourceMap, error)
	GetClusterAdditionalResourceMetric(ctx context.Context, in *ClusterResourceMetricReq, opts ...grpc.CallOption) (*Metric, error)
	GetRestrictedCloudletStatus(ctx context.Context, in *CloudletKey, opts ...grpc.CallOption) (CloudletPlatformAPI_GetRestrictedCloudletStatusClient, error)
	GetRootLbFlavor(ctx context.Context, in *CloudletKey, opts ...grpc.CallOption) (*Flavor, error)
	ProcessExecRequest(ctx context.Context, in *CloudletExecReq, opts ...grpc.CallOption) (*ExecRequest, error)
	NameSanitize(ctx context.Context, in *NameSanitizeReq, opts ...grpc.CallOption) (*Result, error)
	ApplyCloudlet(ctx context.Context, in *Cloudlet, opts ...grpc.CallOption) (CloudletPlatformAPI_ApplyCloudletClient, error)
	RefreshCerts(ctx context.Context, in *Cloudlet, opts ...grpc.CallOption) (*Result, error)
	GetCloudletResources(ctx context.Context, in *Cloudlet, opts ...grpc.CallOption) (*InfraResourceMap, error)
}

type cloudletPlatformAPIClient struct {
	cc *grpc.ClientConn
}

func NewCloudletPlatformAPIClient(cc *grpc.ClientConn) CloudletPlatformAPIClient {
	return &cloudletPlatformAPIClient{cc}
}

func (c *cloudletPlatformAPIClient) GetCloudletManifest(ctx context.Context, in *CloudletKey, opts ...grpc.CallOption) (*CloudletManifest, error) {
	out := new(CloudletManifest)
	err := c.cc.Invoke(ctx, "/edgeproto.CloudletPlatformAPI/GetCloudletManifest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cloudletPlatformAPIClient) GetClusterAdditionalResources(ctx context.Context, in *ClusterResourcesReq, opts ...grpc.CallOption) (*InfraResourceMap, error) {
	out := new(InfraResourceMap)
	err := c.cc.Invoke(ctx, "/edgeproto.CloudletPlatformAPI/GetClusterAdditionalResources", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cloudletPlatformAPIClient) GetClusterAdditionalResourceMetric(ctx context.Context, in *ClusterResourceMetricReq, opts ...grpc.CallOption) (*Metric, error) {
	out := new(Metric)
	err := c.cc.Invoke(ctx, "/edgeproto.CloudletPlatformAPI/GetClusterAdditionalResourceMetric", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cloudletPlatformAPIClient) GetRestrictedCloudletStatus(ctx context.Context, in *CloudletKey, opts ...grpc.CallOption) (CloudletPlatformAPI_GetRestrictedCloudletStatusClient, error) {
	stream, err := c.cc.NewStream(ctx, &_CloudletPlatformAPI_serviceDesc.Streams[0], "/edgeproto.CloudletPlatformAPI/GetRestrictedCloudletStatus", opts...)
	if err != nil {
		return nil, err
	}
	x := &cloudletPlatformAPIGetRestrictedCloudletStatusClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CloudletPlatformAPI_GetRestrictedCloudletStatusClient interface {
	Recv() (*StreamStatus, error)
	grpc.ClientStream
}

type cloudletPlatformAPIGetRestrictedCloudletStatusClient struct {
	grpc.ClientStream
}

func (x *cloudletPlatformAPIGetRestrictedCloudletStatusClient) Recv() (*StreamStatus, error) {
	m := new(StreamStatus)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *cloudletPlatformAPIClient) GetRootLbFlavor(ctx context.Context, in *CloudletKey, opts ...grpc.CallOption) (*Flavor, error) {
	out := new(Flavor)
	err := c.cc.Invoke(ctx, "/edgeproto.CloudletPlatformAPI/GetRootLbFlavor", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cloudletPlatformAPIClient) ProcessExecRequest(ctx context.Context, in *CloudletExecReq, opts ...grpc.CallOption) (*ExecRequest, error) {
	out := new(ExecRequest)
	err := c.cc.Invoke(ctx, "/edgeproto.CloudletPlatformAPI/ProcessExecRequest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cloudletPlatformAPIClient) NameSanitize(ctx context.Context, in *NameSanitizeReq, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/edgeproto.CloudletPlatformAPI/NameSanitize", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cloudletPlatformAPIClient) ApplyCloudlet(ctx context.Context, in *Cloudlet, opts ...grpc.CallOption) (CloudletPlatformAPI_ApplyCloudletClient, error) {
	stream, err := c.cc.NewStream(ctx, &_CloudletPlatformAPI_serviceDesc.Streams[1], "/edgeproto.CloudletPlatformAPI/ApplyCloudlet", opts...)
	if err != nil {
		return nil, err
	}
	x := &cloudletPlatformAPIApplyCloudletClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CloudletPlatformAPI_ApplyCloudletClient interface {
	Recv() (*CloudletInfo, error)
	grpc.ClientStream
}

type cloudletPlatformAPIApplyCloudletClient struct {
	grpc.ClientStream
}

func (x *cloudletPlatformAPIApplyCloudletClient) Recv() (*CloudletInfo, error) {
	m := new(CloudletInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *cloudletPlatformAPIClient) RefreshCerts(ctx context.Context, in *Cloudlet, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/edgeproto.CloudletPlatformAPI/RefreshCerts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cloudletPlatformAPIClient) GetCloudletResources(ctx context.Context, in *Cloudlet, opts ...grpc.CallOption) (*InfraResourceMap, error) {
	out := new(InfraResourceMap)
	err := c.cc.Invoke(ctx, "/edgeproto.CloudletPlatformAPI/GetCloudletResources", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CloudletPlatformAPIServer is the server API for CloudletPlatformAPI service.
type CloudletPlatformAPIServer interface {
	GetCloudletManifest(context.Context, *CloudletKey) (*CloudletManifest, error)
	GetClusterAdditionalResources(context.Context, *ClusterResourcesReq) (*InfraResourceMap, error)
	GetClusterAdditionalResourceMetric(context.Context, *ClusterResourceMetricReq) (*Metric, error)
	GetRestrictedCloudletStatus(*CloudletKey, CloudletPlatformAPI_GetRestrictedCloudletStatusServer) error
	GetRootLbFlavor(context.Context, *CloudletKey) (*Flavor, error)
	ProcessExecRequest(context.Context, *CloudletExecReq) (*ExecRequest, error)
	NameSanitize(context.Context, *NameSanitizeReq) (*Result, error)
	ApplyCloudlet(*Cloudlet, CloudletPlatformAPI_ApplyCloudletServer) error
	RefreshCerts(context.Context, *Cloudlet) (*Result, error)
	GetCloudletResources(context.Context, *Cloudlet) (*InfraResourceMap, error)
}

// UnimplementedCloudletPlatformAPIServer can be embedded to have forward compatible implementations.
type UnimplementedCloudletPlatformAPIServer struct {
}

func (*UnimplementedCloudletPlatformAPIServer) GetCloudletManifest(ctx context.Context, req *CloudletKey) (*CloudletManifest, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCloudletManifest not implemented")
}
func (*UnimplementedCloudletPlatformAPIServer) GetClusterAdditionalResources(ctx context.Context, req *ClusterResourcesReq) (*InfraResourceMap, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetClusterAdditionalResources not implemented")
}
func (*UnimplementedCloudletPlatformAPIServer) GetClusterAdditionalResourceMetric(ctx context.Context, req *ClusterResourceMetricReq) (*Metric, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetClusterAdditionalResourceMetric not implemented")
}
func (*UnimplementedCloudletPlatformAPIServer) GetRestrictedCloudletStatus(req *CloudletKey, srv CloudletPlatformAPI_GetRestrictedCloudletStatusServer) error {
	return status.Errorf(codes.Unimplemented, "method GetRestrictedCloudletStatus not implemented")
}
func (*UnimplementedCloudletPlatformAPIServer) GetRootLbFlavor(ctx context.Context, req *CloudletKey) (*Flavor, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRootLbFlavor not implemented")
}
func (*UnimplementedCloudletPlatformAPIServer) ProcessExecRequest(ctx context.Context, req *CloudletExecReq) (*ExecRequest, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProcessExecRequest not implemented")
}
func (*UnimplementedCloudletPlatformAPIServer) NameSanitize(ctx context.Context, req *NameSanitizeReq) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NameSanitize not implemented")
}
func (*UnimplementedCloudletPlatformAPIServer) ApplyCloudlet(req *Cloudlet, srv CloudletPlatformAPI_ApplyCloudletServer) error {
	return status.Errorf(codes.Unimplemented, "method ApplyCloudlet not implemented")
}
func (*UnimplementedCloudletPlatformAPIServer) RefreshCerts(ctx context.Context, req *Cloudlet) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RefreshCerts not implemented")
}
func (*UnimplementedCloudletPlatformAPIServer) GetCloudletResources(ctx context.Context, req *Cloudlet) (*InfraResourceMap, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCloudletResources not implemented")
}

func RegisterCloudletPlatformAPIServer(s *grpc.Server, srv CloudletPlatformAPIServer) {
	s.RegisterService(&_CloudletPlatformAPI_serviceDesc, srv)
}

func _CloudletPlatformAPI_GetCloudletManifest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloudletKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CloudletPlatformAPIServer).GetCloudletManifest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.CloudletPlatformAPI/GetCloudletManifest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CloudletPlatformAPIServer).GetCloudletManifest(ctx, req.(*CloudletKey))
	}
	return interceptor(ctx, in, info, handler)
}

func _CloudletPlatformAPI_GetClusterAdditionalResources_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClusterResourcesReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CloudletPlatformAPIServer).GetClusterAdditionalResources(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.CloudletPlatformAPI/GetClusterAdditionalResources",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CloudletPlatformAPIServer).GetClusterAdditionalResources(ctx, req.(*ClusterResourcesReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _CloudletPlatformAPI_GetClusterAdditionalResourceMetric_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClusterResourceMetricReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CloudletPlatformAPIServer).GetClusterAdditionalResourceMetric(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.CloudletPlatformAPI/GetClusterAdditionalResourceMetric",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CloudletPlatformAPIServer).GetClusterAdditionalResourceMetric(ctx, req.(*ClusterResourceMetricReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _CloudletPlatformAPI_GetRestrictedCloudletStatus_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(CloudletKey)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CloudletPlatformAPIServer).GetRestrictedCloudletStatus(m, &cloudletPlatformAPIGetRestrictedCloudletStatusServer{stream})
}

type CloudletPlatformAPI_GetRestrictedCloudletStatusServer interface {
	Send(*StreamStatus) error
	grpc.ServerStream
}

type cloudletPlatformAPIGetRestrictedCloudletStatusServer struct {
	grpc.ServerStream
}

func (x *cloudletPlatformAPIGetRestrictedCloudletStatusServer) Send(m *StreamStatus) error {
	return x.ServerStream.SendMsg(m)
}

func _CloudletPlatformAPI_GetRootLbFlavor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloudletKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CloudletPlatformAPIServer).GetRootLbFlavor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.CloudletPlatformAPI/GetRootLbFlavor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CloudletPlatformAPIServer).GetRootLbFlavor(ctx, req.(*CloudletKey))
	}
	return interceptor(ctx, in, info, handler)
}

func _CloudletPlatformAPI_ProcessExecRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloudletExecReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CloudletPlatformAPIServer).ProcessExecRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.CloudletPlatformAPI/ProcessExecRequest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CloudletPlatformAPIServer).ProcessExecRequest(ctx, req.(*CloudletExecReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _CloudletPlatformAPI_NameSanitize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NameSanitizeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CloudletPlatformAPIServer).NameSanitize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.CloudletPlatformAPI/NameSanitize",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CloudletPlatformAPIServer).NameSanitize(ctx, req.(*NameSanitizeReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _CloudletPlatformAPI_ApplyCloudlet_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Cloudlet)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CloudletPlatformAPIServer).ApplyCloudlet(m, &cloudletPlatformAPIApplyCloudletServer{stream})
}

type CloudletPlatformAPI_ApplyCloudletServer interface {
	Send(*CloudletInfo) error
	grpc.ServerStream
}

type cloudletPlatformAPIApplyCloudletServer struct {
	grpc.ServerStream
}

func (x *cloudletPlatformAPIApplyCloudletServer) Send(m *CloudletInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _CloudletPlatformAPI_RefreshCerts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Cloudlet)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CloudletPlatformAPIServer).RefreshCerts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.CloudletPlatformAPI/RefreshCerts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CloudletPlatformAPIServer).RefreshCerts(ctx, req.(*Cloudlet))
	}
	return interceptor(ctx, in, info, handler)
}

func _CloudletPlatformAPI_GetCloudletResources_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Cloudlet)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CloudletPlatformAPIServer).GetCloudletResources(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.CloudletPlatformAPI/GetCloudletResources",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CloudletPlatformAPIServer).GetCloudletResources(ctx, req.(*Cloudlet))
	}
	return interceptor(ctx, in, info, handler)
}

var _CloudletPlatformAPI_serviceDesc = grpc.ServiceDesc{
	ServiceName: "edgeproto.CloudletPlatformAPI",
	HandlerType: (*CloudletPlatformAPIServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetCloudletManifest",
			Handler:    _CloudletPlatformAPI_GetCloudletManifest_Handler,
		},
		{
			MethodName: "GetClusterAdditionalResources",
			Handler:    _CloudletPlatformAPI_GetClusterAdditionalResources_Handler,
		},
		{
			MethodName: "GetClusterAdditionalResourceMetric",
			Handler:    _CloudletPlatformAPI_GetClusterAdditionalResourceMetric_Handler,
		},
		{
			MethodName: "GetRootLbFlavor",
			Handler:    _CloudletPlatformAPI_GetRootLbFlavor_Handler,
		},
		{
			MethodName: "ProcessExecRequest",
			Handler:    _CloudletPlatformAPI_ProcessExecRequest_Handler,
		},
		{
			MethodName: "NameSanitize",
			Handler:    _CloudletPlatformAPI_NameSanitize_Handler,
		},
		{
			MethodName: "RefreshCerts",
			Handler:    _CloudletPlatformAPI_RefreshCerts_Handler,
		},
		{
			MethodName: "GetCloudletResources",
			Handler:    _CloudletPlatformAPI_GetCloudletResources_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetRestrictedCloudletStatus",
			Handler:       _CloudletPlatformAPI_GetRestrictedCloudletStatus_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ApplyCloudlet",
			Handler:       _CloudletPlatformAPI_ApplyCloudlet_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "ccrm.proto",
}

// ClusterPlatformAPIClient is the client API for ClusterPlatformAPI service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ClusterPlatformAPIClient interface {
	ApplyClusterInst(ctx context.Context, in *ClusterInst, opts ...grpc.CallOption) (ClusterPlatformAPI_ApplyClusterInstClient, error)
	NameSanitize(ctx context.Context, in *NameSanitizeReq, opts ...grpc.CallOption) (*Result, error)
}

type clusterPlatformAPIClient struct {
	cc *grpc.ClientConn
}

func NewClusterPlatformAPIClient(cc *grpc.ClientConn) ClusterPlatformAPIClient {
	return &clusterPlatformAPIClient{cc}
}

func (c *clusterPlatformAPIClient) ApplyClusterInst(ctx context.Context, in *ClusterInst, opts ...grpc.CallOption) (ClusterPlatformAPI_ApplyClusterInstClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ClusterPlatformAPI_serviceDesc.Streams[0], "/edgeproto.ClusterPlatformAPI/ApplyClusterInst", opts...)
	if err != nil {
		return nil, err
	}
	x := &clusterPlatformAPIApplyClusterInstClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ClusterPlatformAPI_ApplyClusterInstClient interface {
	Recv() (*ClusterInstInfo, error)
	grpc.ClientStream
}

type clusterPlatformAPIApplyClusterInstClient struct {
	grpc.ClientStream
}

func (x *clusterPlatformAPIApplyClusterInstClient) Recv() (*ClusterInstInfo, error) {
	m := new(ClusterInstInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *clusterPlatformAPIClient) NameSanitize(ctx context.Context, in *NameSanitizeReq, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/edgeproto.ClusterPlatformAPI/NameSanitize", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ClusterPlatformAPIServer is the server API for ClusterPlatformAPI service.
type ClusterPlatformAPIServer interface {
	ApplyClusterInst(*ClusterInst, ClusterPlatformAPI_ApplyClusterInstServer) error
	NameSanitize(context.Context, *NameSanitizeReq) (*Result, error)
}

// UnimplementedClusterPlatformAPIServer can be embedded to have forward compatible implementations.
type UnimplementedClusterPlatformAPIServer struct {
}

func (*UnimplementedClusterPlatformAPIServer) ApplyClusterInst(req *ClusterInst, srv ClusterPlatformAPI_ApplyClusterInstServer) error {
	return status.Errorf(codes.Unimplemented, "method ApplyClusterInst not implemented")
}
func (*UnimplementedClusterPlatformAPIServer) NameSanitize(ctx context.Context, req *NameSanitizeReq) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NameSanitize not implemented")
}

func RegisterClusterPlatformAPIServer(s *grpc.Server, srv ClusterPlatformAPIServer) {
	s.RegisterService(&_ClusterPlatformAPI_serviceDesc, srv)
}

func _ClusterPlatformAPI_ApplyClusterInst_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ClusterInst)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ClusterPlatformAPIServer).ApplyClusterInst(m, &clusterPlatformAPIApplyClusterInstServer{stream})
}

type ClusterPlatformAPI_ApplyClusterInstServer interface {
	Send(*ClusterInstInfo) error
	grpc.ServerStream
}

type clusterPlatformAPIApplyClusterInstServer struct {
	grpc.ServerStream
}

func (x *clusterPlatformAPIApplyClusterInstServer) Send(m *ClusterInstInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _ClusterPlatformAPI_NameSanitize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NameSanitizeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterPlatformAPIServer).NameSanitize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.ClusterPlatformAPI/NameSanitize",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterPlatformAPIServer).NameSanitize(ctx, req.(*NameSanitizeReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _ClusterPlatformAPI_serviceDesc = grpc.ServiceDesc{
	ServiceName: "edgeproto.ClusterPlatformAPI",
	HandlerType: (*ClusterPlatformAPIServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "NameSanitize",
			Handler:    _ClusterPlatformAPI_NameSanitize_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ApplyClusterInst",
			Handler:       _ClusterPlatformAPI_ApplyClusterInst_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "ccrm.proto",
}

// AppInstPlatformAPIClient is the client API for AppInstPlatformAPI service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AppInstPlatformAPIClient interface {
	ApplyAppInst(ctx context.Context, in *AppInst, opts ...grpc.CallOption) (AppInstPlatformAPI_ApplyAppInstClient, error)
	ApplyTrustPolicyException(ctx context.Context, in *TPEInstanceState, opts ...grpc.CallOption) (*Result, error)
	NameSanitize(ctx context.Context, in *NameSanitizeReq, opts ...grpc.CallOption) (*Result, error)
}

type appInstPlatformAPIClient struct {
	cc *grpc.ClientConn
}

func NewAppInstPlatformAPIClient(cc *grpc.ClientConn) AppInstPlatformAPIClient {
	return &appInstPlatformAPIClient{cc}
}

func (c *appInstPlatformAPIClient) ApplyAppInst(ctx context.Context, in *AppInst, opts ...grpc.CallOption) (AppInstPlatformAPI_ApplyAppInstClient, error) {
	stream, err := c.cc.NewStream(ctx, &_AppInstPlatformAPI_serviceDesc.Streams[0], "/edgeproto.AppInstPlatformAPI/ApplyAppInst", opts...)
	if err != nil {
		return nil, err
	}
	x := &appInstPlatformAPIApplyAppInstClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AppInstPlatformAPI_ApplyAppInstClient interface {
	Recv() (*AppInstInfo, error)
	grpc.ClientStream
}

type appInstPlatformAPIApplyAppInstClient struct {
	grpc.ClientStream
}

func (x *appInstPlatformAPIApplyAppInstClient) Recv() (*AppInstInfo, error) {
	m := new(AppInstInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *appInstPlatformAPIClient) ApplyTrustPolicyException(ctx context.Context, in *TPEInstanceState, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/edgeproto.AppInstPlatformAPI/ApplyTrustPolicyException", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appInstPlatformAPIClient) NameSanitize(ctx context.Context, in *NameSanitizeReq, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/edgeproto.AppInstPlatformAPI/NameSanitize", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AppInstPlatformAPIServer is the server API for AppInstPlatformAPI service.
type AppInstPlatformAPIServer interface {
	ApplyAppInst(*AppInst, AppInstPlatformAPI_ApplyAppInstServer) error
	ApplyTrustPolicyException(context.Context, *TPEInstanceState) (*Result, error)
	NameSanitize(context.Context, *NameSanitizeReq) (*Result, error)
}

// UnimplementedAppInstPlatformAPIServer can be embedded to have forward compatible implementations.
type UnimplementedAppInstPlatformAPIServer struct {
}

func (*UnimplementedAppInstPlatformAPIServer) ApplyAppInst(req *AppInst, srv AppInstPlatformAPI_ApplyAppInstServer) error {
	return status.Errorf(codes.Unimplemented, "method ApplyAppInst not implemented")
}
func (*UnimplementedAppInstPlatformAPIServer) ApplyTrustPolicyException(ctx context.Context, req *TPEInstanceState) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApplyTrustPolicyException not implemented")
}
func (*UnimplementedAppInstPlatformAPIServer) NameSanitize(ctx context.Context, req *NameSanitizeReq) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NameSanitize not implemented")
}

func RegisterAppInstPlatformAPIServer(s *grpc.Server, srv AppInstPlatformAPIServer) {
	s.RegisterService(&_AppInstPlatformAPI_serviceDesc, srv)
}

func _AppInstPlatformAPI_ApplyAppInst_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AppInst)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AppInstPlatformAPIServer).ApplyAppInst(m, &appInstPlatformAPIApplyAppInstServer{stream})
}

type AppInstPlatformAPI_ApplyAppInstServer interface {
	Send(*AppInstInfo) error
	grpc.ServerStream
}

type appInstPlatformAPIApplyAppInstServer struct {
	grpc.ServerStream
}

func (x *appInstPlatformAPIApplyAppInstServer) Send(m *AppInstInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _AppInstPlatformAPI_ApplyTrustPolicyException_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TPEInstanceState)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppInstPlatformAPIServer).ApplyTrustPolicyException(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.AppInstPlatformAPI/ApplyTrustPolicyException",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppInstPlatformAPIServer).ApplyTrustPolicyException(ctx, req.(*TPEInstanceState))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppInstPlatformAPI_NameSanitize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NameSanitizeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppInstPlatformAPIServer).NameSanitize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.AppInstPlatformAPI/NameSanitize",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppInstPlatformAPIServer).NameSanitize(ctx, req.(*NameSanitizeReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _AppInstPlatformAPI_serviceDesc = grpc.ServiceDesc{
	ServiceName: "edgeproto.AppInstPlatformAPI",
	HandlerType: (*AppInstPlatformAPIServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ApplyTrustPolicyException",
			Handler:    _AppInstPlatformAPI_ApplyTrustPolicyException_Handler,
		},
		{
			MethodName: "NameSanitize",
			Handler:    _AppInstPlatformAPI_NameSanitize_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ApplyAppInst",
			Handler:       _AppInstPlatformAPI_ApplyAppInst_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "ccrm.proto",
}

func (m *StreamStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StreamStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintCcrm(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x22
	}
	if m.CacheUpdateType != 0 {
		i = encodeVarintCcrm(dAtA, i, uint64(m.CacheUpdateType))
		i--
		dAtA[i] = 0x18
	}
	return len(dAtA) - i, nil
}

func (m *InfraResourceMap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InfraResourceMap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InfraResourceMap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.InfraResources) > 0 {
		for k := range m.InfraResources {
			v := m.InfraResources[k]
			baseI := i
			{
				size, err := (&v).MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCcrm(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCcrm(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCcrm(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ClusterResourcesReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterResourcesReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterResourcesReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.InfraResources) > 0 {
		for k := range m.InfraResources {
			v := m.InfraResources[k]
			baseI := i
			{
				size, err := (&v).MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCcrm(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCcrm(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCcrm(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.VmResources) > 0 {
		for iNdEx := len(m.VmResources) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.VmResources[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCcrm(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.CloudletKey != nil {
		{
			size, err := m.CloudletKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCcrm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClusterResourceMetricReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterResourceMetricReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterResourceMetricReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.VmResources) > 0 {
		for iNdEx := len(m.VmResources) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.VmResources[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCcrm(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.ResMetric != nil {
		{
			size, err := m.ResMetric.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCcrm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.CloudletKey != nil {
		{
			size, err := m.CloudletKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCcrm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NameSanitizeReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NameSanitizeReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NameSanitizeReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintCcrm(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.CloudletKey != nil {
		{
			size, err := m.CloudletKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCcrm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CloudletExecReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloudletExecReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudletExecReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExecReq != nil {
		{
			size, err := m.ExecReq.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCcrm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.CloudletKey != nil {
		{
			size, err := m.CloudletKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCcrm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintCcrm(dAtA []byte, offset int, v uint64) int {
	offset -= sovCcrm(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *StreamStatus) Clone() *StreamStatus {
	cp := &StreamStatus{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *StreamStatus) CopyInFields(src *StreamStatus) int {
	changed := 0
	if m.CacheUpdateType != src.CacheUpdateType {
		m.CacheUpdateType = src.CacheUpdateType
		changed++
	}
	if m.Status != src.Status {
		m.Status = src.Status
		changed++
	}
	return changed
}

func (m *StreamStatus) DeepCopyIn(src *StreamStatus) {
	m.CacheUpdateType = src.CacheUpdateType
	m.Status = src.Status
}

func (m *StreamStatus) MessageTypeKey() string {
	return "msg/type/StreamStatus"
}

// Helper method to check that enums have valid values
func (m *StreamStatus) ValidateEnums() error {
	return nil
}

func (s *StreamStatus) ClearTagged(tags map[string]struct{}) {
}

func (m *InfraResourceMap) Clone() *InfraResourceMap {
	cp := &InfraResourceMap{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *InfraResourceMap) CopyInFields(src *InfraResourceMap) int {
	updateListAction := "replace"
	changed := 0
	if src.InfraResources != nil {
		if updateListAction == "add" {
			for k0, v := range src.InfraResources {
				v = *v.Clone()
				m.InfraResources[k0] = v
				changed++
			}
		} else if updateListAction == "remove" {
			for k0, _ := range src.InfraResources {
				if _, ok := m.InfraResources[k0]; ok {
					delete(m.InfraResources, k0)
					changed++
				}
			}
		} else {
			m.InfraResources = make(map[string]InfraResource)
			for k0, v := range src.InfraResources {
				m.InfraResources[k0] = *v.Clone()
			}
			changed++
		}
	} else if m.InfraResources != nil {
		m.InfraResources = nil
		changed++
	}
	return changed
}

func (m *InfraResourceMap) DeepCopyIn(src *InfraResourceMap) {
	if src.InfraResources != nil {
		m.InfraResources = make(map[string]InfraResource)
		for k, v := range src.InfraResources {
			var tmp_v InfraResource
			tmp_v.DeepCopyIn(&v)
			m.InfraResources[k] = tmp_v
		}
	} else {
		m.InfraResources = nil
	}
}

// Helper method to check that enums have valid values
func (m *InfraResourceMap) ValidateEnums() error {
	return nil
}

func (s *InfraResourceMap) ClearTagged(tags map[string]struct{}) {
}

func (m *ClusterResourcesReq) Clone() *ClusterResourcesReq {
	cp := &ClusterResourcesReq{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *ClusterResourcesReq) AddVmResources(vals ...VMResource) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.VmResources {
		cur[v.GetKey().GetKeyString()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.GetKey().GetKeyString()]; found {
			continue // duplicate
		}
		m.VmResources = append(m.VmResources, v)
		changes++
	}
	return changes
}

func (m *ClusterResourcesReq) RemoveVmResources(vals ...VMResource) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.GetKey().GetKeyString()] = struct{}{}
	}
	for i := len(m.VmResources); i >= 0; i-- {
		if _, found := remove[m.VmResources[i].GetKey().GetKeyString()]; found {
			m.VmResources = append(m.VmResources[:i], m.VmResources[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *ClusterResourcesReq) CopyInFields(src *ClusterResourcesReq) int {
	updateListAction := "replace"
	changed := 0
	if src.CloudletKey != nil {
		if m.CloudletKey == nil {
			m.CloudletKey = &CloudletKey{}
		}
		if m.CloudletKey.Organization != src.CloudletKey.Organization {
			m.CloudletKey.Organization = src.CloudletKey.Organization
			changed++
		}
		if m.CloudletKey.Name != src.CloudletKey.Name {
			m.CloudletKey.Name = src.CloudletKey.Name
			changed++
		}
		if m.CloudletKey.FederatedOrganization != src.CloudletKey.FederatedOrganization {
			m.CloudletKey.FederatedOrganization = src.CloudletKey.FederatedOrganization
			changed++
		}
	} else if m.CloudletKey != nil {
		m.CloudletKey = nil
		changed++
	}
	if src.VmResources != nil {
		if updateListAction == "add" {
			changed += m.AddVmResources(src.VmResources...)
		} else if updateListAction == "remove" {
			changed += m.RemoveVmResources(src.VmResources...)
		} else {
			m.VmResources = make([]VMResource, 0)
			for k0, _ := range src.VmResources {
				m.VmResources = append(m.VmResources, *src.VmResources[k0].Clone())
			}
			changed++
		}
	} else if m.VmResources != nil {
		m.VmResources = nil
		changed++
	}
	if src.InfraResources != nil {
		if updateListAction == "add" {
			for k0, v := range src.InfraResources {
				v = *v.Clone()
				m.InfraResources[k0] = v
				changed++
			}
		} else if updateListAction == "remove" {
			for k0, _ := range src.InfraResources {
				if _, ok := m.InfraResources[k0]; ok {
					delete(m.InfraResources, k0)
					changed++
				}
			}
		} else {
			m.InfraResources = make(map[string]InfraResource)
			for k0, v := range src.InfraResources {
				m.InfraResources[k0] = *v.Clone()
			}
			changed++
		}
	} else if m.InfraResources != nil {
		m.InfraResources = nil
		changed++
	}
	return changed
}

func (m *ClusterResourcesReq) DeepCopyIn(src *ClusterResourcesReq) {
	if src.CloudletKey != nil {
		var tmp_CloudletKey CloudletKey
		tmp_CloudletKey.DeepCopyIn(src.CloudletKey)
		m.CloudletKey = &tmp_CloudletKey
	} else {
		m.CloudletKey = nil
	}
	if src.VmResources != nil {
		m.VmResources = make([]VMResource, len(src.VmResources), len(src.VmResources))
		for ii, s := range src.VmResources {
			m.VmResources[ii].DeepCopyIn(&s)
		}
	} else {
		m.VmResources = nil
	}
	if src.InfraResources != nil {
		m.InfraResources = make(map[string]InfraResource)
		for k, v := range src.InfraResources {
			var tmp_v InfraResource
			tmp_v.DeepCopyIn(&v)
			m.InfraResources[k] = tmp_v
		}
	} else {
		m.InfraResources = nil
	}
}

// Helper method to check that enums have valid values
func (m *ClusterResourcesReq) ValidateEnums() error {
	if m.CloudletKey != nil {
		if err := m.CloudletKey.ValidateEnums(); err != nil {
			return err
		}
	}
	for _, e := range m.VmResources {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (s *ClusterResourcesReq) ClearTagged(tags map[string]struct{}) {
	if s.CloudletKey != nil {
		s.CloudletKey.ClearTagged(tags)
	}
	if s.VmResources != nil {
		for ii := 0; ii < len(s.VmResources); ii++ {
			s.VmResources[ii].ClearTagged(tags)
		}
	}
}

func (m *ClusterResourceMetricReq) Clone() *ClusterResourceMetricReq {
	cp := &ClusterResourceMetricReq{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *ClusterResourceMetricReq) AddResMetricTags(vals ...*MetricTag) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.ResMetric.Tags {
		cur[v.String()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.String()]; found {
			continue // duplicate
		}
		m.ResMetric.Tags = append(m.ResMetric.Tags, v)
		changes++
	}
	return changes
}

func (m *ClusterResourceMetricReq) RemoveResMetricTags(vals ...*MetricTag) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.String()] = struct{}{}
	}
	for i := len(m.ResMetric.Tags); i >= 0; i-- {
		if _, found := remove[m.ResMetric.Tags[i].String()]; found {
			m.ResMetric.Tags = append(m.ResMetric.Tags[:i], m.ResMetric.Tags[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *ClusterResourceMetricReq) AddResMetricVals(vals ...*MetricVal) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.ResMetric.Vals {
		cur[v.String()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.String()]; found {
			continue // duplicate
		}
		m.ResMetric.Vals = append(m.ResMetric.Vals, v)
		changes++
	}
	return changes
}

func (m *ClusterResourceMetricReq) RemoveResMetricVals(vals ...*MetricVal) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.String()] = struct{}{}
	}
	for i := len(m.ResMetric.Vals); i >= 0; i-- {
		if _, found := remove[m.ResMetric.Vals[i].String()]; found {
			m.ResMetric.Vals = append(m.ResMetric.Vals[:i], m.ResMetric.Vals[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *ClusterResourceMetricReq) AddVmResources(vals ...VMResource) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.VmResources {
		cur[v.GetKey().GetKeyString()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.GetKey().GetKeyString()]; found {
			continue // duplicate
		}
		m.VmResources = append(m.VmResources, v)
		changes++
	}
	return changes
}

func (m *ClusterResourceMetricReq) RemoveVmResources(vals ...VMResource) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.GetKey().GetKeyString()] = struct{}{}
	}
	for i := len(m.VmResources); i >= 0; i-- {
		if _, found := remove[m.VmResources[i].GetKey().GetKeyString()]; found {
			m.VmResources = append(m.VmResources[:i], m.VmResources[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *ClusterResourceMetricReq) CopyInFields(src *ClusterResourceMetricReq) int {
	updateListAction := "replace"
	changed := 0
	if src.CloudletKey != nil {
		if m.CloudletKey == nil {
			m.CloudletKey = &CloudletKey{}
		}
		if m.CloudletKey.Organization != src.CloudletKey.Organization {
			m.CloudletKey.Organization = src.CloudletKey.Organization
			changed++
		}
		if m.CloudletKey.Name != src.CloudletKey.Name {
			m.CloudletKey.Name = src.CloudletKey.Name
			changed++
		}
		if m.CloudletKey.FederatedOrganization != src.CloudletKey.FederatedOrganization {
			m.CloudletKey.FederatedOrganization = src.CloudletKey.FederatedOrganization
			changed++
		}
	} else if m.CloudletKey != nil {
		m.CloudletKey = nil
		changed++
	}
	if src.ResMetric != nil {
		if m.ResMetric == nil {
			m.ResMetric = &Metric{}
		}
		if m.ResMetric.Name != src.ResMetric.Name {
			m.ResMetric.Name = src.ResMetric.Name
			changed++
		}
		if m.ResMetric.Timestamp.Seconds != src.ResMetric.Timestamp.Seconds {
			m.ResMetric.Timestamp.Seconds = src.ResMetric.Timestamp.Seconds
			changed++
		}
		if m.ResMetric.Timestamp.Nanos != src.ResMetric.Timestamp.Nanos {
			m.ResMetric.Timestamp.Nanos = src.ResMetric.Timestamp.Nanos
			changed++
		}
		if src.ResMetric.Tags != nil {
			if updateListAction == "add" {
				changed += m.AddResMetricTags(src.ResMetric.Tags...)
			} else if updateListAction == "remove" {
				changed += m.RemoveResMetricTags(src.ResMetric.Tags...)
			} else {
				m.ResMetric.Tags = make([]*MetricTag, 0)
				for k1, _ := range src.ResMetric.Tags {
					m.ResMetric.Tags = append(m.ResMetric.Tags, src.ResMetric.Tags[k1].Clone())
				}
				changed++
			}
		} else if m.ResMetric.Tags != nil {
			m.ResMetric.Tags = nil
			changed++
		}
		if src.ResMetric.Vals != nil {
			if updateListAction == "add" {
				changed += m.AddResMetricVals(src.ResMetric.Vals...)
			} else if updateListAction == "remove" {
				changed += m.RemoveResMetricVals(src.ResMetric.Vals...)
			} else {
				m.ResMetric.Vals = make([]*MetricVal, 0)
				for k1, _ := range src.ResMetric.Vals {
					m.ResMetric.Vals = append(m.ResMetric.Vals, src.ResMetric.Vals[k1].Clone())
				}
				changed++
			}
		} else if m.ResMetric.Vals != nil {
			m.ResMetric.Vals = nil
			changed++
		}
	} else if m.ResMetric != nil {
		m.ResMetric = nil
		changed++
	}
	if src.VmResources != nil {
		if updateListAction == "add" {
			changed += m.AddVmResources(src.VmResources...)
		} else if updateListAction == "remove" {
			changed += m.RemoveVmResources(src.VmResources...)
		} else {
			m.VmResources = make([]VMResource, 0)
			for k0, _ := range src.VmResources {
				m.VmResources = append(m.VmResources, *src.VmResources[k0].Clone())
			}
			changed++
		}
	} else if m.VmResources != nil {
		m.VmResources = nil
		changed++
	}
	return changed
}

func (m *ClusterResourceMetricReq) DeepCopyIn(src *ClusterResourceMetricReq) {
	if src.CloudletKey != nil {
		var tmp_CloudletKey CloudletKey
		tmp_CloudletKey.DeepCopyIn(src.CloudletKey)
		m.CloudletKey = &tmp_CloudletKey
	} else {
		m.CloudletKey = nil
	}
	if src.ResMetric != nil {
		var tmp_ResMetric Metric
		tmp_ResMetric.DeepCopyIn(src.ResMetric)
		m.ResMetric = &tmp_ResMetric
	} else {
		m.ResMetric = nil
	}
	if src.VmResources != nil {
		m.VmResources = make([]VMResource, len(src.VmResources), len(src.VmResources))
		for ii, s := range src.VmResources {
			m.VmResources[ii].DeepCopyIn(&s)
		}
	} else {
		m.VmResources = nil
	}
}

// Helper method to check that enums have valid values
func (m *ClusterResourceMetricReq) ValidateEnums() error {
	if m.CloudletKey != nil {
		if err := m.CloudletKey.ValidateEnums(); err != nil {
			return err
		}
	}
	if m.ResMetric != nil {
		if err := m.ResMetric.ValidateEnums(); err != nil {
			return err
		}
	}
	for _, e := range m.VmResources {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (s *ClusterResourceMetricReq) ClearTagged(tags map[string]struct{}) {
	if s.CloudletKey != nil {
		s.CloudletKey.ClearTagged(tags)
	}
	if s.ResMetric != nil {
		s.ResMetric.ClearTagged(tags)
	}
	if s.VmResources != nil {
		for ii := 0; ii < len(s.VmResources); ii++ {
			s.VmResources[ii].ClearTagged(tags)
		}
	}
}

func (m *NameSanitizeReq) Clone() *NameSanitizeReq {
	cp := &NameSanitizeReq{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *NameSanitizeReq) CopyInFields(src *NameSanitizeReq) int {
	changed := 0
	if src.CloudletKey != nil {
		if m.CloudletKey == nil {
			m.CloudletKey = &CloudletKey{}
		}
		if m.CloudletKey.Organization != src.CloudletKey.Organization {
			m.CloudletKey.Organization = src.CloudletKey.Organization
			changed++
		}
		if m.CloudletKey.Name != src.CloudletKey.Name {
			m.CloudletKey.Name = src.CloudletKey.Name
			changed++
		}
		if m.CloudletKey.FederatedOrganization != src.CloudletKey.FederatedOrganization {
			m.CloudletKey.FederatedOrganization = src.CloudletKey.FederatedOrganization
			changed++
		}
	} else if m.CloudletKey != nil {
		m.CloudletKey = nil
		changed++
	}
	if m.Message != src.Message {
		m.Message = src.Message
		changed++
	}
	return changed
}

func (m *NameSanitizeReq) DeepCopyIn(src *NameSanitizeReq) {
	if src.CloudletKey != nil {
		var tmp_CloudletKey CloudletKey
		tmp_CloudletKey.DeepCopyIn(src.CloudletKey)
		m.CloudletKey = &tmp_CloudletKey
	} else {
		m.CloudletKey = nil
	}
	m.Message = src.Message
}

// Helper method to check that enums have valid values
func (m *NameSanitizeReq) ValidateEnums() error {
	if m.CloudletKey != nil {
		if err := m.CloudletKey.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (s *NameSanitizeReq) ClearTagged(tags map[string]struct{}) {
	if s.CloudletKey != nil {
		s.CloudletKey.ClearTagged(tags)
	}
}

func (m *CloudletExecReq) Clone() *CloudletExecReq {
	cp := &CloudletExecReq{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *CloudletExecReq) CopyInFields(src *CloudletExecReq) int {
	changed := 0
	if src.CloudletKey != nil {
		if m.CloudletKey == nil {
			m.CloudletKey = &CloudletKey{}
		}
		if m.CloudletKey.Organization != src.CloudletKey.Organization {
			m.CloudletKey.Organization = src.CloudletKey.Organization
			changed++
		}
		if m.CloudletKey.Name != src.CloudletKey.Name {
			m.CloudletKey.Name = src.CloudletKey.Name
			changed++
		}
		if m.CloudletKey.FederatedOrganization != src.CloudletKey.FederatedOrganization {
			m.CloudletKey.FederatedOrganization = src.CloudletKey.FederatedOrganization
			changed++
		}
	} else if m.CloudletKey != nil {
		m.CloudletKey = nil
		changed++
	}
	if src.ExecReq != nil {
		if m.ExecReq == nil {
			m.ExecReq = &ExecRequest{}
		}
		if m.ExecReq.AppInstKey.Name != src.ExecReq.AppInstKey.Name {
			m.ExecReq.AppInstKey.Name = src.ExecReq.AppInstKey.Name
			changed++
		}
		if m.ExecReq.AppInstKey.Organization != src.ExecReq.AppInstKey.Organization {
			m.ExecReq.AppInstKey.Organization = src.ExecReq.AppInstKey.Organization
			changed++
		}
		if m.ExecReq.AppInstKey.CloudletKey.Organization != src.ExecReq.AppInstKey.CloudletKey.Organization {
			m.ExecReq.AppInstKey.CloudletKey.Organization = src.ExecReq.AppInstKey.CloudletKey.Organization
			changed++
		}
		if m.ExecReq.AppInstKey.CloudletKey.Name != src.ExecReq.AppInstKey.CloudletKey.Name {
			m.ExecReq.AppInstKey.CloudletKey.Name = src.ExecReq.AppInstKey.CloudletKey.Name
			changed++
		}
		if m.ExecReq.AppInstKey.CloudletKey.FederatedOrganization != src.ExecReq.AppInstKey.CloudletKey.FederatedOrganization {
			m.ExecReq.AppInstKey.CloudletKey.FederatedOrganization = src.ExecReq.AppInstKey.CloudletKey.FederatedOrganization
			changed++
		}
		if m.ExecReq.ContainerId != src.ExecReq.ContainerId {
			m.ExecReq.ContainerId = src.ExecReq.ContainerId
			changed++
		}
		if m.ExecReq.Offer != src.ExecReq.Offer {
			m.ExecReq.Offer = src.ExecReq.Offer
			changed++
		}
		if m.ExecReq.Answer != src.ExecReq.Answer {
			m.ExecReq.Answer = src.ExecReq.Answer
			changed++
		}
		if m.ExecReq.Err != src.ExecReq.Err {
			m.ExecReq.Err = src.ExecReq.Err
			changed++
		}
		if src.ExecReq.Cmd != nil {
			if m.ExecReq.Cmd == nil {
				m.ExecReq.Cmd = &RunCmd{}
			}
			if m.ExecReq.Cmd.Command != src.ExecReq.Cmd.Command {
				m.ExecReq.Cmd.Command = src.ExecReq.Cmd.Command
				changed++
			}
			if src.ExecReq.Cmd.CloudletMgmtNode != nil {
				if m.ExecReq.Cmd.CloudletMgmtNode == nil {
					m.ExecReq.Cmd.CloudletMgmtNode = &CloudletMgmtNode{}
				}
				if m.ExecReq.Cmd.CloudletMgmtNode.Type != src.ExecReq.Cmd.CloudletMgmtNode.Type {
					m.ExecReq.Cmd.CloudletMgmtNode.Type = src.ExecReq.Cmd.CloudletMgmtNode.Type
					changed++
				}
				if m.ExecReq.Cmd.CloudletMgmtNode.Name != src.ExecReq.Cmd.CloudletMgmtNode.Name {
					m.ExecReq.Cmd.CloudletMgmtNode.Name = src.ExecReq.Cmd.CloudletMgmtNode.Name
					changed++
				}
			} else if m.ExecReq.Cmd.CloudletMgmtNode != nil {
				m.ExecReq.Cmd.CloudletMgmtNode = nil
				changed++
			}
		} else if m.ExecReq.Cmd != nil {
			m.ExecReq.Cmd = nil
			changed++
		}
		if src.ExecReq.Log != nil {
			if m.ExecReq.Log == nil {
				m.ExecReq.Log = &ShowLog{}
			}
			if m.ExecReq.Log.Since != src.ExecReq.Log.Since {
				m.ExecReq.Log.Since = src.ExecReq.Log.Since
				changed++
			}
			if m.ExecReq.Log.Tail != src.ExecReq.Log.Tail {
				m.ExecReq.Log.Tail = src.ExecReq.Log.Tail
				changed++
			}
			if m.ExecReq.Log.Timestamps != src.ExecReq.Log.Timestamps {
				m.ExecReq.Log.Timestamps = src.ExecReq.Log.Timestamps
				changed++
			}
			if m.ExecReq.Log.Follow != src.ExecReq.Log.Follow {
				m.ExecReq.Log.Follow = src.ExecReq.Log.Follow
				changed++
			}
		} else if m.ExecReq.Log != nil {
			m.ExecReq.Log = nil
			changed++
		}
		if src.ExecReq.Console != nil {
			if m.ExecReq.Console == nil {
				m.ExecReq.Console = &RunVMConsole{}
			}
			if m.ExecReq.Console.Url != src.ExecReq.Console.Url {
				m.ExecReq.Console.Url = src.ExecReq.Console.Url
				changed++
			}
		} else if m.ExecReq.Console != nil {
			m.ExecReq.Console = nil
			changed++
		}
		if m.ExecReq.Timeout != src.ExecReq.Timeout {
			m.ExecReq.Timeout = src.ExecReq.Timeout
			changed++
		}
		if m.ExecReq.AccessUrl != src.ExecReq.AccessUrl {
			m.ExecReq.AccessUrl = src.ExecReq.AccessUrl
			changed++
		}
		if m.ExecReq.EdgeTurnAddr != src.ExecReq.EdgeTurnAddr {
			m.ExecReq.EdgeTurnAddr = src.ExecReq.EdgeTurnAddr
			changed++
		}
		if m.ExecReq.EdgeTurnProxyAddr != src.ExecReq.EdgeTurnProxyAddr {
			m.ExecReq.EdgeTurnProxyAddr = src.ExecReq.EdgeTurnProxyAddr
			changed++
		}
	} else if m.ExecReq != nil {
		m.ExecReq = nil
		changed++
	}
	return changed
}

func (m *CloudletExecReq) DeepCopyIn(src *CloudletExecReq) {
	if src.CloudletKey != nil {
		var tmp_CloudletKey CloudletKey
		tmp_CloudletKey.DeepCopyIn(src.CloudletKey)
		m.CloudletKey = &tmp_CloudletKey
	} else {
		m.CloudletKey = nil
	}
	if src.ExecReq != nil {
		var tmp_ExecReq ExecRequest
		tmp_ExecReq.DeepCopyIn(src.ExecReq)
		m.ExecReq = &tmp_ExecReq
	} else {
		m.ExecReq = nil
	}
}

// Helper method to check that enums have valid values
func (m *CloudletExecReq) ValidateEnums() error {
	if m.CloudletKey != nil {
		if err := m.CloudletKey.ValidateEnums(); err != nil {
			return err
		}
	}
	if m.ExecReq != nil {
		if err := m.ExecReq.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (s *CloudletExecReq) ClearTagged(tags map[string]struct{}) {
	if s.CloudletKey != nil {
		s.CloudletKey.ClearTagged(tags)
	}
	if s.ExecReq != nil {
		s.ExecReq.ClearTagged(tags)
	}
}

func IgnoreCloudletExecReqFields(taglist string) cmp.Option {
	names := []string{}
	tags := make(map[string]struct{})
	for _, tag := range strings.Split(taglist, ",") {
		tags[tag] = struct{}{}
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "ExecReq.Offer")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "ExecReq.Answer")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "ExecReq.Console.Url")
	}
	return cmpopts.IgnoreFields(CloudletExecReq{}, names...)
}

func (m *StreamStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CacheUpdateType != 0 {
		n += 1 + sovCcrm(uint64(m.CacheUpdateType))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovCcrm(uint64(l))
	}
	return n
}

func (m *InfraResourceMap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.InfraResources) > 0 {
		for k, v := range m.InfraResources {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + len(k) + sovCcrm(uint64(len(k))) + 1 + l + sovCcrm(uint64(l))
			n += mapEntrySize + 1 + sovCcrm(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ClusterResourcesReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CloudletKey != nil {
		l = m.CloudletKey.Size()
		n += 1 + l + sovCcrm(uint64(l))
	}
	if len(m.VmResources) > 0 {
		for _, e := range m.VmResources {
			l = e.Size()
			n += 1 + l + sovCcrm(uint64(l))
		}
	}
	if len(m.InfraResources) > 0 {
		for k, v := range m.InfraResources {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + len(k) + sovCcrm(uint64(len(k))) + 1 + l + sovCcrm(uint64(l))
			n += mapEntrySize + 1 + sovCcrm(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ClusterResourceMetricReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CloudletKey != nil {
		l = m.CloudletKey.Size()
		n += 1 + l + sovCcrm(uint64(l))
	}
	if m.ResMetric != nil {
		l = m.ResMetric.Size()
		n += 1 + l + sovCcrm(uint64(l))
	}
	if len(m.VmResources) > 0 {
		for _, e := range m.VmResources {
			l = e.Size()
			n += 1 + l + sovCcrm(uint64(l))
		}
	}
	return n
}

func (m *NameSanitizeReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CloudletKey != nil {
		l = m.CloudletKey.Size()
		n += 1 + l + sovCcrm(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovCcrm(uint64(l))
	}
	return n
}

func (m *CloudletExecReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CloudletKey != nil {
		l = m.CloudletKey.Size()
		n += 1 + l + sovCcrm(uint64(l))
	}
	if m.ExecReq != nil {
		l = m.ExecReq.Size()
		n += 1 + l + sovCcrm(uint64(l))
	}
	return n
}

func sovCcrm(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCcrm(x uint64) (n int) {
	return sovCcrm(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *StreamStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCcrm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheUpdateType", wireType)
			}
			m.CacheUpdateType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCcrm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CacheUpdateType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCcrm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCcrm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCcrm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCcrm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCcrm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InfraResourceMap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCcrm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InfraResourceMap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InfraResourceMap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InfraResources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCcrm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCcrm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCcrm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InfraResources == nil {
				m.InfraResources = make(map[string]InfraResource)
			}
			var mapkey string
			mapvalue := &InfraResource{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCcrm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCcrm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCcrm
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCcrm
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCcrm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCcrm
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthCcrm
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &InfraResource{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCcrm(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthCcrm
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.InfraResources[mapkey] = *mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCcrm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCcrm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterResourcesReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCcrm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterResourcesReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterResourcesReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudletKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCcrm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCcrm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCcrm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CloudletKey == nil {
				m.CloudletKey = &CloudletKey{}
			}
			if err := m.CloudletKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VmResources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCcrm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCcrm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCcrm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VmResources = append(m.VmResources, VMResource{})
			if err := m.VmResources[len(m.VmResources)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InfraResources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCcrm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCcrm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCcrm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InfraResources == nil {
				m.InfraResources = make(map[string]InfraResource)
			}
			var mapkey string
			mapvalue := &InfraResource{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCcrm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCcrm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCcrm
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCcrm
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCcrm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCcrm
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthCcrm
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &InfraResource{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCcrm(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthCcrm
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.InfraResources[mapkey] = *mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCcrm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCcrm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterResourceMetricReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCcrm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterResourceMetricReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterResourceMetricReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudletKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCcrm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCcrm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCcrm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CloudletKey == nil {
				m.CloudletKey = &CloudletKey{}
			}
			if err := m.CloudletKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResMetric", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCcrm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCcrm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCcrm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResMetric == nil {
				m.ResMetric = &Metric{}
			}
			if err := m.ResMetric.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VmResources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCcrm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCcrm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCcrm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VmResources = append(m.VmResources, VMResource{})
			if err := m.VmResources[len(m.VmResources)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCcrm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCcrm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NameSanitizeReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCcrm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NameSanitizeReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NameSanitizeReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudletKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCcrm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCcrm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCcrm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CloudletKey == nil {
				m.CloudletKey = &CloudletKey{}
			}
			if err := m.CloudletKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCcrm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCcrm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCcrm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCcrm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCcrm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloudletExecReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCcrm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloudletExecReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloudletExecReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudletKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCcrm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCcrm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCcrm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CloudletKey == nil {
				m.CloudletKey = &CloudletKey{}
			}
			if err := m.CloudletKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecReq", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCcrm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCcrm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCcrm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExecReq == nil {
				m.ExecReq = &ExecRequest{}
			}
			if err := m.ExecReq.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCcrm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCcrm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCcrm(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCcrm
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCcrm
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCcrm
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCcrm
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCcrm
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCcrm
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCcrm        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCcrm          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCcrm = fmt.Errorf("proto: unexpected end of group")
)
