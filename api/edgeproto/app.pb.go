// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: app.proto

package edgeproto

import (
	context "context"
	"encoding/json"
	"errors"
	fmt "fmt"
	distributed_match_engine "github.com/edgexr/edge-cloud-platform/api/distributed_match_engine"
	"github.com/edgexr/edge-cloud-platform/pkg/log"
	"github.com/edgexr/edge-cloud-platform/pkg/objstore"
	"github.com/edgexr/edge-cloud-platform/pkg/util"
	_ "github.com/edgexr/edge-cloud-platform/tools/protogen"
	_ "github.com/gogo/googleapis/google/api"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"go.etcd.io/etcd/client/v3/concurrency"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	"strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type ImageType int32

const (
	// Unknown image type
	ImageType_IMAGE_TYPE_UNKNOWN ImageType = 0
	// Docker container image type compatible either with Docker or Kubernetes
	ImageType_IMAGE_TYPE_DOCKER ImageType = 1
	// QCOW2 virtual machine image type
	ImageType_IMAGE_TYPE_QCOW ImageType = 2
	// Helm chart is a separate image type
	ImageType_IMAGE_TYPE_HELM ImageType = 3
	// OVF is for VMWare VCloud Director. A VMDK and optional MF file should also be present
	ImageType_IMAGE_TYPE_OVF ImageType = 4
	// OVA is for VMWare VCloud Director.
	ImageType_IMAGE_TYPE_OVA ImageType = 5
)

var ImageType_name = map[int32]string{
	0: "IMAGE_TYPE_UNKNOWN",
	1: "IMAGE_TYPE_DOCKER",
	2: "IMAGE_TYPE_QCOW",
	3: "IMAGE_TYPE_HELM",
	4: "IMAGE_TYPE_OVF",
	5: "IMAGE_TYPE_OVA",
}

var ImageType_value = map[string]int32{
	"IMAGE_TYPE_UNKNOWN": 0,
	"IMAGE_TYPE_DOCKER":  1,
	"IMAGE_TYPE_QCOW":    2,
	"IMAGE_TYPE_HELM":    3,
	"IMAGE_TYPE_OVF":     4,
	"IMAGE_TYPE_OVA":     5,
}

func (x ImageType) String() string {
	return proto.EnumName(ImageType_name, int32(x))
}

func (ImageType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e0f9056a14b86d47, []int{0}
}

// The selected profile name will be included
// as the "qos" value in the qos-senf/v1/sessions POST.
type QosSessionProfile int32

const (
	// Specifies that no priority session should be created
	QosSessionProfile_QOS_NO_PRIORITY QosSessionProfile = 0
	// Corresponds to a specific set of network parameters for low latency that will be
	// negotiated with the network provider in advance
	QosSessionProfile_QOS_LOW_LATENCY QosSessionProfile = 1
	// Downlink traffic from AppInst to client is prioritized up to 20Mbps
	QosSessionProfile_QOS_THROUGHPUT_DOWN_S QosSessionProfile = 2
	// Downlink traffic from AppInst to client is prioritized up to 50Mbps
	QosSessionProfile_QOS_THROUGHPUT_DOWN_M QosSessionProfile = 3
	// Downlink traffic from AppInst to client is prioritized up to 100Mbps
	QosSessionProfile_QOS_THROUGHPUT_DOWN_L QosSessionProfile = 4
)

var QosSessionProfile_name = map[int32]string{
	0: "QOS_NO_PRIORITY",
	1: "QOS_LOW_LATENCY",
	2: "QOS_THROUGHPUT_DOWN_S",
	3: "QOS_THROUGHPUT_DOWN_M",
	4: "QOS_THROUGHPUT_DOWN_L",
}

var QosSessionProfile_value = map[string]int32{
	"QOS_NO_PRIORITY":       0,
	"QOS_LOW_LATENCY":       1,
	"QOS_THROUGHPUT_DOWN_S": 2,
	"QOS_THROUGHPUT_DOWN_M": 3,
	"QOS_THROUGHPUT_DOWN_L": 4,
}

func (x QosSessionProfile) String() string {
	return proto.EnumName(QosSessionProfile_name, int32(x))
}

func (QosSessionProfile) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e0f9056a14b86d47, []int{1}
}

type VmAppOsType int32

const (
	// Unknown OS type
	VmAppOsType_VM_APP_OS_UNKNOWN VmAppOsType = 0
	// All Linux 64 bit varieties
	VmAppOsType_VM_APP_OS_LINUX VmAppOsType = 1
	// Windows 10
	VmAppOsType_VM_APP_OS_WINDOWS_10 VmAppOsType = 2
	// Windows 2012 Server
	VmAppOsType_VM_APP_OS_WINDOWS_2012 VmAppOsType = 3
	// Windows 2016 Server
	VmAppOsType_VM_APP_OS_WINDOWS_2016 VmAppOsType = 4
	// Windows 2019 Server
	VmAppOsType_VM_APP_OS_WINDOWS_2019 VmAppOsType = 5
)

var VmAppOsType_name = map[int32]string{
	0: "VM_APP_OS_UNKNOWN",
	1: "VM_APP_OS_LINUX",
	2: "VM_APP_OS_WINDOWS_10",
	3: "VM_APP_OS_WINDOWS_2012",
	4: "VM_APP_OS_WINDOWS_2016",
	5: "VM_APP_OS_WINDOWS_2019",
}

var VmAppOsType_value = map[string]int32{
	"VM_APP_OS_UNKNOWN":      0,
	"VM_APP_OS_LINUX":        1,
	"VM_APP_OS_WINDOWS_10":   2,
	"VM_APP_OS_WINDOWS_2012": 3,
	"VM_APP_OS_WINDOWS_2016": 4,
	"VM_APP_OS_WINDOWS_2019": 5,
}

func (x VmAppOsType) String() string {
	return proto.EnumName(VmAppOsType_name, int32(x))
}

func (VmAppOsType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e0f9056a14b86d47, []int{2}
}

// DeleteType
//
// # DeleteType specifies if AppInst can be auto deleted or not
//
// 0: `NO_AUTO_DELETE`
// 1: `AUTO_DELETE`
type DeleteType int32

const (
	// No autodelete
	DeleteType_NO_AUTO_DELETE DeleteType = 0
	// Autodelete
	DeleteType_AUTO_DELETE DeleteType = 1
)

var DeleteType_name = map[int32]string{
	0: "NO_AUTO_DELETE",
	1: "AUTO_DELETE",
}

var DeleteType_value = map[string]int32{
	"NO_AUTO_DELETE": 0,
	"AUTO_DELETE":    1,
}

func (x DeleteType) String() string {
	return proto.EnumName(DeleteType_name, int32(x))
}

func (DeleteType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e0f9056a14b86d47, []int{3}
}

// (Deprecated) AccessType
//
// # AccessType indicates how to access the app
//
// 0: `ACCESS_TYPE_DEFAULT_FOR_DEPLOYMENT`
// 1: `ACCESS_TYPE_DIRECT`
// 2: `ACCESS_TYPE_LOAD_BALANCER`
type AccessType int32

const (
	// Default load balancer or direct based on deployment
	AccessType_ACCESS_TYPE_DEFAULT_FOR_DEPLOYMENT AccessType = 0
	// Direct access with no load balancer
	AccessType_ACCESS_TYPE_DIRECT AccessType = 1
	// Access via a load balancer
	AccessType_ACCESS_TYPE_LOAD_BALANCER AccessType = 2
)

var AccessType_name = map[int32]string{
	0: "ACCESS_TYPE_DEFAULT_FOR_DEPLOYMENT",
	1: "ACCESS_TYPE_DIRECT",
	2: "ACCESS_TYPE_LOAD_BALANCER",
}

var AccessType_value = map[string]int32{
	"ACCESS_TYPE_DEFAULT_FOR_DEPLOYMENT": 0,
	"ACCESS_TYPE_DIRECT":                 1,
	"ACCESS_TYPE_LOAD_BALANCER":          2,
}

func (x AccessType) String() string {
	return proto.EnumName(AccessType_name, int32(x))
}

func (AccessType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e0f9056a14b86d47, []int{4}
}

type GpuType int32

const (
	// None
	GpuType_GPU_TYPE_NONE GpuType = 0
	// Any type
	GpuType_GPU_TYPE_ANY GpuType = 1
	// VGPU type
	GpuType_GPU_TYPE_VGPU GpuType = 2
	// PCI passthrough
	GpuType_GPU_TYPE_PCI GpuType = 3
)

var GpuType_name = map[int32]string{
	0: "GPU_TYPE_NONE",
	1: "GPU_TYPE_ANY",
	2: "GPU_TYPE_VGPU",
	3: "GPU_TYPE_PCI",
}

var GpuType_value = map[string]int32{
	"GPU_TYPE_NONE": 0,
	"GPU_TYPE_ANY":  1,
	"GPU_TYPE_VGPU": 2,
	"GPU_TYPE_PCI":  3,
}

func (x GpuType) String() string {
	return proto.EnumName(GpuType_name, int32(x))
}

func (GpuType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e0f9056a14b86d47, []int{5}
}

// Application unique key
//
// AppKey uniquely identifies an App
type AppKey struct {
	// App developer organization
	Organization string `protobuf:"bytes,1,opt,name=organization,proto3" json:"organization,omitempty"`
	// App name
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// App version
	Version string `protobuf:"bytes,3,opt,name=version,proto3" json:"version,omitempty"`
}

func (m *AppKey) Reset()         { *m = AppKey{} }
func (m *AppKey) String() string { return proto.CompactTextString(m) }
func (*AppKey) ProtoMessage()    {}
func (*AppKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_e0f9056a14b86d47, []int{0}
}
func (m *AppKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppKey.Merge(m, src)
}
func (m *AppKey) XXX_Size() int {
	return m.Size()
}
func (m *AppKey) XXX_DiscardUnknown() {
	xxx_messageInfo_AppKey.DiscardUnknown(m)
}

var xxx_messageInfo_AppKey proto.InternalMessageInfo

// ConfigFile
type ConfigFile struct {
	// Kind (type) of config, i.e. envVarsYaml, helmCustomizationYaml
	Kind string `protobuf:"bytes,1,opt,name=kind,proto3" json:"kind,omitempty"`
	// Config file contents or URI reference
	Config string `protobuf:"bytes,2,opt,name=config,proto3" json:"config,omitempty"`
}

func (m *ConfigFile) Reset()         { *m = ConfigFile{} }
func (m *ConfigFile) String() string { return proto.CompactTextString(m) }
func (*ConfigFile) ProtoMessage()    {}
func (*ConfigFile) Descriptor() ([]byte, []int) {
	return fileDescriptor_e0f9056a14b86d47, []int{1}
}
func (m *ConfigFile) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConfigFile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConfigFile.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConfigFile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigFile.Merge(m, src)
}
func (m *ConfigFile) XXX_Size() int {
	return m.Size()
}
func (m *ConfigFile) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigFile.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigFile proto.InternalMessageInfo

// Application
//
// App belongs to developer organizations and is used to provide information about their application.
type App struct {
	// Fields are used for the Update API to specify which fields to apply
	Fields []string `protobuf:"bytes,1,rep,name=fields,proto3" json:"fields,omitempty"`
	// Unique identifier key
	// required: true
	Key AppKey `protobuf:"bytes,2,opt,name=key,proto3" json:"key"`
	// URI of where image resides. For container images, this may be a path
	// on docker hub, i.e. "nginx:latest" or "nginx/nginx-ingress:5.2-alpine",
	// or a full path like "ghcr.io/cloudnative-pg/postgresql:14.9".
	// For helm charts, the format is either "https://<helm-repo>:<repo-name>/<chart-name>",
	// i.e. "https://charts.bitnami.com/bitnami:bitnami/redis",
	// or an OCI path, i.e. "oci://ghcr.io/company/chart". Note for Helm
	// the chart version goes on the App Annotations field, i.e.
	// "version=1.2.3,wait=true,timeout=60". For VM images, this should be
	// an http(s) URL to the image file.
	ImagePath string `protobuf:"bytes,4,opt,name=image_path,json=imagePath,proto3" json:"image_path,omitempty"`
	// Image type
	ImageType ImageType `protobuf:"varint,5,opt,name=image_type,json=imageType,proto3,enum=edgeproto.ImageType" json:"image_type,omitempty"`
	// Comma separated list of protocol:port pairs that the App listens on.
	// Ex: "tcp:80,udp:10002".
	// Also supports additional configurations per port:
	// (1) tls (tcp-only) - Enables TLS on specified port. Ex: "tcp:443:tls".
	// (2) nginx (udp-only) - Use NGINX LB instead of envoy for specified port. Ex: "udp:10001:nginx".
	// (3) maxpktsize (udp-only) - Configures maximum UDP datagram size allowed on port for both upstream/downstream traffic. Ex: "udp:10001:maxpktsize=8000".
	// (4) intvis (internal-visibility)- Port is not externally accessible. Ex: "tcp:9000:intvis"
	// (5) id - Port ID. Ex: "tcp:9000:id=p9000"
	// (6) pathprefix (http-only) - Specifies the path prefix to use in the kubernetes ingress, required if multiple http ports are present, defaults to "/"
	// (7) svcname - For Kubernetes apps, if there are multiple of the same port on different services, this denotes the service name. Ex: "tcp:9000:tls:svcname=svc1"
	AccessPorts string `protobuf:"bytes,7,opt,name=access_ports,json=accessPorts,proto3" json:"access_ports,omitempty"`
	// Default flavor for the App, which may be overridden by the AppInst
	DefaultFlavor FlavorKey `protobuf:"bytes,9,opt,name=default_flavor,json=defaultFlavor,proto3" json:"default_flavor"`
	// Username for authenticating to a private image registry
	Username string `protobuf:"bytes,57,opt,name=username,proto3" json:"username,omitempty"`
	// Credentials for authenticating to a private image registry, saved in encrypted storage
	Credentials string `protobuf:"bytes,58,opt,name=credentials,proto3" json:"credentials,omitempty"`
	// Public key used for authentication
	AuthPublicKey string `protobuf:"bytes,12,opt,name=auth_public_key,json=authPublicKey,proto3" json:"auth_public_key,omitempty"`
	// Command that the container runs to start service, separate multiple commands by a space
	Command string `protobuf:"bytes,13,opt,name=command,proto3" json:"command,omitempty"`
	// Command args to append to command, on cli specify multiple times in order
	CommandArgs []string `protobuf:"bytes,46,rep,name=command_args,json=commandArgs,proto3" json:"command_args,omitempty"`
	// Annotations is a comma separated map of arbitrary key value pairs,
	// for example: key1=val1,key2=val2,key3="val 3"
	Annotations string `protobuf:"bytes,14,opt,name=annotations,proto3" json:"annotations,omitempty"`
	// Deployment type (kubernetes, docker, or vm)
	Deployment string `protobuf:"bytes,15,opt,name=deployment,proto3" json:"deployment,omitempty"`
	// Deployment manifest is the deployment specific manifest file/config.
	// For docker deployment, this can be a docker-compose or docker run file.
	// For kubernetes deployment, this can be a kubernetes yaml or helm chart file.
	DeploymentManifest string `protobuf:"bytes,16,opt,name=deployment_manifest,json=deploymentManifest,proto3" json:"deployment_manifest,omitempty"`
	// Deployment generator target to generate a basic deployment manifest
	DeploymentGenerator string `protobuf:"bytes,17,opt,name=deployment_generator,json=deploymentGenerator,proto3" json:"deployment_generator,omitempty"`
	// Android package name used to match the App name from the Android package
	AndroidPackageName string `protobuf:"bytes,18,opt,name=android_package_name,json=androidPackageName,proto3" json:"android_package_name,omitempty"`
	// Override actions to Controller
	DelOpt DeleteType `protobuf:"varint,20,opt,name=del_opt,json=delOpt,proto3,enum=edgeproto.DeleteType" json:"del_opt,omitempty"`
	// Customization files passed through to implementing services
	Configs []*ConfigFile `protobuf:"bytes,21,rep,name=configs,proto3" json:"configs,omitempty"`
	// True indicates App runs on all nodes of the cluster as it scales
	ScaleWithCluster bool `protobuf:"varint,22,opt,name=scale_with_cluster,json=scaleWithCluster,proto3" json:"scale_with_cluster,omitempty"`
	// True indicates App is used internally with other Apps only, and no ports are exposed externally
	InternalPorts bool `protobuf:"varint,23,opt,name=internal_ports,json=internalPorts,proto3" json:"internal_ports,omitempty"`
	// Revision can be specified or defaults to current timestamp when app is updated
	Revision string `protobuf:"bytes,24,opt,name=revision,proto3" json:"revision,omitempty"`
	// Official FQDN is the FQDN that the app uses to connect by default
	OfficialFqdn string `protobuf:"bytes,25,opt,name=official_fqdn,json=officialFqdn,proto3" json:"official_fqdn,omitempty"`
	// MD5Sum of the VM-based app image
	Md5Sum string `protobuf:"bytes,26,opt,name=md5sum,proto3" json:"md5sum,omitempty"`
	// (_deprecated_) Auto provisioning policy name
	AutoProvPolicy string `protobuf:"bytes,28,opt,name=auto_prov_policy,json=autoProvPolicy,proto3" json:"auto_prov_policy,omitempty"`
	// (_deprecated_) Access type
	AccessType AccessType `protobuf:"varint,29,opt,name=access_type,json=accessType,proto3,enum=edgeproto.AccessType" json:"access_type,omitempty"`
	// Preparing to be deleted
	DeletePrepare bool `protobuf:"varint,31,opt,name=delete_prepare,json=deletePrepare,proto3" json:"delete_prepare,omitempty"`
	// Auto provisioning policy names, may be specified multiple times
	AutoProvPolicies []string `protobuf:"bytes,32,rep,name=auto_prov_policies,json=autoProvPolicies,proto3" json:"auto_prov_policies,omitempty"`
	// Delimiter to be used for template parsing, defaults to "[[ ]]"
	TemplateDelimiter string `protobuf:"bytes,33,opt,name=template_delimiter,json=templateDelimiter,proto3" json:"template_delimiter,omitempty"`
	// Comma separated list of protocol:port pairs that we should not run health check on.
	// Should be configured in case app does not always listen on these ports.
	// "all" can be specified if no health check to be run for this app.
	// Numerical values must be decimal format.
	// i.e. tcp:80,udp:10002
	SkipHcPorts string `protobuf:"bytes,34,opt,name=skip_hc_ports,json=skipHcPorts,proto3" json:"skip_hc_ports,omitempty"`
	// Created at time
	CreatedAt distributed_match_engine.Timestamp `protobuf:"bytes,35,opt,name=created_at,json=createdAt,proto3" json:"created_at"`
	// Updated at time
	UpdatedAt distributed_match_engine.Timestamp `protobuf:"bytes,36,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at"`
	// Indicates that an instance of this app can be started on a trusted cloudlet
	Trusted bool `protobuf:"varint,37,opt,name=trusted,proto3" json:"trusted,omitempty"`
	// Connections this app require to determine if the app is compatible with a trust policy
	RequiredOutboundConnections []SecurityRule `protobuf:"bytes,38,rep,name=required_outbound_connections,json=requiredOutboundConnections,proto3" json:"required_outbound_connections"`
	// App is allowed to deploy as serverless containers
	AllowServerless bool `protobuf:"varint,39,opt,name=allow_serverless,json=allowServerless,proto3" json:"allow_serverless,omitempty"`
	// (_deprecated_) Replaced by KubernetesResources
	ServerlessConfig *ServerlessConfig `protobuf:"bytes,40,opt,name=serverless_config,json=serverlessConfig,proto3" json:"serverless_config,omitempty"`
	// OS Type for VM Apps
	VmAppOsType VmAppOsType `protobuf:"varint,41,opt,name=vm_app_os_type,json=vmAppOsType,proto3,enum=edgeproto.VmAppOsType" json:"vm_app_os_type,omitempty"`
	// Alert Policies
	AlertPolicies []string `protobuf:"bytes,42,rep,name=alert_policies,json=alertPolicies,proto3" json:"alert_policies,omitempty"`
	// Qualifier for the requested latency profile
	QosSessionProfile QosSessionProfile `protobuf:"varint,43,opt,name=qos_session_profile,json=qosSessionProfile,proto3,enum=edgeproto.QosSessionProfile" json:"qos_session_profile,omitempty"`
	// Session duration in seconds. Maximal value of 24 hours is used if not set
	QosSessionDuration Duration `protobuf:"varint,44,opt,name=qos_session_duration,json=qosSessionDuration,proto3,casttype=Duration" json:"qos_session_duration,omitempty"`
	// A globally unique id for the App to be used with federation
	GlobalId string `protobuf:"bytes,45,opt,name=global_id,json=globalId,proto3" json:"global_id,omitempty"`
	// Environment variables
	EnvVars map[string]string `protobuf:"bytes,47,rep,name=env_vars,json=envVars,proto3" json:"env_vars,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Environment variables with sensitive information, stored in encrypted storage
	SecretEnvVars map[string]string `protobuf:"bytes,48,rep,name=secret_env_vars,json=secretEnvVars,proto3" json:"secret_env_vars,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// For updating list and map fields, set to 'add', 'remove', or 'replace' to define how to resolve specified entries against existing entries
	UpdateListAction string `protobuf:"bytes,49,opt,name=update_list_action,json=updateListAction,proto3" json:"update_list_action,omitempty"`
	// Required resources for kubernetes deployments
	KubernetesResources *KubernetesResources `protobuf:"bytes,50,opt,name=kubernetes_resources,json=kubernetesResources,proto3" json:"kubernetes_resources,omitempty"`
	// Required resources for VM/Docker deployments
	NodeResources *NodeResources `protobuf:"bytes,51,opt,name=node_resources,json=nodeResources,proto3" json:"node_resources,omitempty"`
	// Universally unique object ID
	ObjId string `protobuf:"bytes,52,opt,name=obj_id,json=objId,proto3" json:"obj_id,omitempty"`
	// Internal Annotations
	AppAnnotations map[string]string `protobuf:"bytes,53,rep,name=app_annotations,json=appAnnotations,proto3" json:"app_annotations,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// A standalone App will not share a cluster with another App unless explicitly targeted to the same cluster
	IsStandalone bool `protobuf:"varint,54,opt,name=is_standalone,json=isStandalone,proto3" json:"is_standalone,omitempty"`
	// Specifies if the kubernetes application manages creating and deleting its own namespaces. If true, it is disallowed from deployment to multi-tenant clusters, and it is up to the application developer to manage namespace conflicts if they deploy multiple applications to the same cluster. If false, each application instance is deployed to its own namespace set by the platform.
	ManagesOwnNamespaces bool `protobuf:"varint,55,opt,name=manages_own_namespaces,json=managesOwnNamespaces,proto3" json:"manages_own_namespaces,omitempty"`
	// Internal compatibility version
	CompatibilityVersion uint32 `protobuf:"varint,56,opt,name=compatibility_version,json=compatibilityVersion,proto3" json:"compatibility_version,omitempty"`
	// Vendor-specific data
	Tags map[string]string `protobuf:"bytes,100,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *App) Reset()         { *m = App{} }
func (m *App) String() string { return proto.CompactTextString(m) }
func (*App) ProtoMessage()    {}
func (*App) Descriptor() ([]byte, []int) {
	return fileDescriptor_e0f9056a14b86d47, []int{2}
}
func (m *App) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *App) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_App.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *App) XXX_Merge(src proto.Message) {
	xxx_messageInfo_App.Merge(m, src)
}
func (m *App) XXX_Size() int {
	return m.Size()
}
func (m *App) XXX_DiscardUnknown() {
	xxx_messageInfo_App.DiscardUnknown(m)
}

var xxx_messageInfo_App proto.InternalMessageInfo

type ServerlessConfig struct {
	// Virtual CPUs allocation per container when serverless, may be decimal in increments of 0.001
	Vcpus Udec64 `protobuf:"bytes,1,opt,name=vcpus,proto3" json:"vcpus"`
	// RAM allocation in megabytes per container when serverless
	Ram uint64 `protobuf:"varint,2,opt,name=ram,proto3" json:"ram,omitempty"`
	// Minimum number of replicas when serverless
	MinReplicas uint32 `protobuf:"varint,3,opt,name=min_replicas,json=minReplicas,proto3" json:"min_replicas,omitempty"`
	// GPU config
	GpuConfig GpuConfig `protobuf:"bytes,4,opt,name=gpu_config,json=gpuConfig,proto3" json:"gpu_config"`
}

func (m *ServerlessConfig) Reset()         { *m = ServerlessConfig{} }
func (m *ServerlessConfig) String() string { return proto.CompactTextString(m) }
func (*ServerlessConfig) ProtoMessage()    {}
func (*ServerlessConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_e0f9056a14b86d47, []int{3}
}
func (m *ServerlessConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServerlessConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServerlessConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServerlessConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServerlessConfig.Merge(m, src)
}
func (m *ServerlessConfig) XXX_Size() int {
	return m.Size()
}
func (m *ServerlessConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ServerlessConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ServerlessConfig proto.InternalMessageInfo

type GpuConfig struct {
	// GPU Type
	Type GpuType `protobuf:"varint,1,opt,name=type,proto3,enum=edgeproto.GpuType" json:"type,omitempty"`
	// Model name or vgpu type
	Model string `protobuf:"bytes,2,opt,name=model,proto3" json:"model,omitempty"`
	// Number of instances
	NumGpu int32 `protobuf:"varint,3,opt,name=num_gpu,json=numGpu,proto3" json:"num_gpu,omitempty"`
	// required memory in megabytes
	Ram uint64 `protobuf:"varint,4,opt,name=ram,proto3" json:"ram,omitempty"`
}

func (m *GpuConfig) Reset()         { *m = GpuConfig{} }
func (m *GpuConfig) String() string { return proto.CompactTextString(m) }
func (*GpuConfig) ProtoMessage()    {}
func (*GpuConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_e0f9056a14b86d47, []int{4}
}
func (m *GpuConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GpuConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GpuConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GpuConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GpuConfig.Merge(m, src)
}
func (m *GpuConfig) XXX_Size() int {
	return m.Size()
}
func (m *GpuConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_GpuConfig.DiscardUnknown(m)
}

var xxx_messageInfo_GpuConfig proto.InternalMessageInfo

// AutoProvPolicy belonging to an app
type AppAutoProvPolicy struct {
	// App key
	AppKey AppKey `protobuf:"bytes,1,opt,name=app_key,json=appKey,proto3" json:"app_key"`
	// Auto provisioning policy name
	AutoProvPolicy string `protobuf:"bytes,2,opt,name=auto_prov_policy,json=autoProvPolicy,proto3" json:"auto_prov_policy,omitempty"`
}

func (m *AppAutoProvPolicy) Reset()         { *m = AppAutoProvPolicy{} }
func (m *AppAutoProvPolicy) String() string { return proto.CompactTextString(m) }
func (*AppAutoProvPolicy) ProtoMessage()    {}
func (*AppAutoProvPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_e0f9056a14b86d47, []int{5}
}
func (m *AppAutoProvPolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppAutoProvPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppAutoProvPolicy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppAutoProvPolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppAutoProvPolicy.Merge(m, src)
}
func (m *AppAutoProvPolicy) XXX_Size() int {
	return m.Size()
}
func (m *AppAutoProvPolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_AppAutoProvPolicy.DiscardUnknown(m)
}

var xxx_messageInfo_AppAutoProvPolicy proto.InternalMessageInfo

type AppAlertPolicy struct {
	// App key
	AppKey AppKey `protobuf:"bytes,1,opt,name=app_key,json=appKey,proto3" json:"app_key"`
	// Alert name
	AlertPolicy string `protobuf:"bytes,2,opt,name=alert_policy,json=alertPolicy,proto3" json:"alert_policy,omitempty"`
}

func (m *AppAlertPolicy) Reset()         { *m = AppAlertPolicy{} }
func (m *AppAlertPolicy) String() string { return proto.CompactTextString(m) }
func (*AppAlertPolicy) ProtoMessage()    {}
func (*AppAlertPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_e0f9056a14b86d47, []int{6}
}
func (m *AppAlertPolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppAlertPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppAlertPolicy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppAlertPolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppAlertPolicy.Merge(m, src)
}
func (m *AppAlertPolicy) XXX_Size() int {
	return m.Size()
}
func (m *AppAlertPolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_AppAlertPolicy.DiscardUnknown(m)
}

var xxx_messageInfo_AppAlertPolicy proto.InternalMessageInfo

type DeploymentZoneRequest struct {
	// Discover potential App Zones
	App *App `protobuf:"bytes,1,opt,name=app,proto3" json:"app,omitempty"`
	// Attempt to qualify zones resources for deployment
	DryRunDeploy bool `protobuf:"varint,2,opt,name=dry_run_deploy,json=dryRunDeploy,proto3" json:"dry_run_deploy,omitempty"`
	// Optional number of worker VMs in dry run K8s Cluster, default = 2
	NumNodes uint32 `protobuf:"varint,3,opt,name=num_nodes,json=numNodes,proto3" json:"num_nodes,omitempty"`
}

func (m *DeploymentZoneRequest) Reset()         { *m = DeploymentZoneRequest{} }
func (m *DeploymentZoneRequest) String() string { return proto.CompactTextString(m) }
func (*DeploymentZoneRequest) ProtoMessage()    {}
func (*DeploymentZoneRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e0f9056a14b86d47, []int{7}
}
func (m *DeploymentZoneRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeploymentZoneRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeploymentZoneRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeploymentZoneRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeploymentZoneRequest.Merge(m, src)
}
func (m *DeploymentZoneRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeploymentZoneRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeploymentZoneRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeploymentZoneRequest proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("edgeproto.ImageType", ImageType_name, ImageType_value)
	proto.RegisterEnum("edgeproto.QosSessionProfile", QosSessionProfile_name, QosSessionProfile_value)
	proto.RegisterEnum("edgeproto.VmAppOsType", VmAppOsType_name, VmAppOsType_value)
	proto.RegisterEnum("edgeproto.DeleteType", DeleteType_name, DeleteType_value)
	proto.RegisterEnum("edgeproto.AccessType", AccessType_name, AccessType_value)
	proto.RegisterEnum("edgeproto.GpuType", GpuType_name, GpuType_value)
	proto.RegisterType((*AppKey)(nil), "edgeproto.AppKey")
	proto.RegisterType((*ConfigFile)(nil), "edgeproto.ConfigFile")
	proto.RegisterType((*App)(nil), "edgeproto.App")
	proto.RegisterMapType((map[string]string)(nil), "edgeproto.App.AppAnnotationsEntry")
	proto.RegisterMapType((map[string]string)(nil), "edgeproto.App.EnvVarsEntry")
	proto.RegisterMapType((map[string]string)(nil), "edgeproto.App.SecretEnvVarsEntry")
	proto.RegisterMapType((map[string]string)(nil), "edgeproto.App.TagsEntry")
	proto.RegisterType((*ServerlessConfig)(nil), "edgeproto.ServerlessConfig")
	proto.RegisterType((*GpuConfig)(nil), "edgeproto.GpuConfig")
	proto.RegisterType((*AppAutoProvPolicy)(nil), "edgeproto.AppAutoProvPolicy")
	proto.RegisterType((*AppAlertPolicy)(nil), "edgeproto.AppAlertPolicy")
	proto.RegisterType((*DeploymentZoneRequest)(nil), "edgeproto.DeploymentZoneRequest")
}

func init() { proto.RegisterFile("app.proto", fileDescriptor_e0f9056a14b86d47) }

var fileDescriptor_e0f9056a14b86d47 = []byte{
	// 2900 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x59, 0x4d, 0x6c, 0x1b, 0xc7,
	0x15, 0xd6, 0xea, 0x9f, 0x43, 0x91, 0x5a, 0x8d, 0x25, 0x7b, 0x24, 0xdb, 0xb2, 0x4c, 0xff, 0x54,
	0x51, 0x68, 0xc9, 0x76, 0x12, 0x3b, 0x51, 0x9b, 0x36, 0x2b, 0x89, 0xb6, 0x55, 0xd1, 0x24, 0xbd,
	0x94, 0xe4, 0xb8, 0x68, 0xb1, 0x18, 0xed, 0x8e, 0xa8, 0x8d, 0xf6, 0x67, 0xbc, 0x3f, 0x74, 0x99,
	0x53, 0x50, 0xa0, 0x87, 0x16, 0x41, 0x91, 0xa6, 0x40, 0x5b, 0x04, 0x05, 0xda, 0x22, 0x28, 0x9a,
	0x63, 0x9b, 0x4b, 0x8b, 0x9c, 0x8a, 0x9e, 0x8c, 0x9c, 0x02, 0xf4, 0x92, 0xf6, 0x10, 0xb4, 0x49,
	0x0f, 0x85, 0x4e, 0x05, 0x22, 0xa9, 0x3f, 0xa7, 0x62, 0x66, 0x76, 0xc9, 0x25, 0x45, 0x03, 0xb1,
	0x13, 0xa0, 0xb7, 0x9d, 0xef, 0xbd, 0x79, 0xf3, 0xe6, 0x9b, 0xf7, 0xe6, 0xbd, 0x21, 0x41, 0x0a,
	0x53, 0x3a, 0x4f, 0x3d, 0x37, 0x70, 0x61, 0x8a, 0x18, 0x35, 0xc2, 0x3f, 0xa7, 0x4e, 0xd5, 0x5c,
	0xb7, 0x66, 0x91, 0x05, 0x4c, 0xcd, 0x05, 0xec, 0x38, 0x6e, 0x80, 0x03, 0xd3, 0x75, 0x7c, 0xa1,
	0x38, 0x35, 0xe2, 0x11, 0x3f, 0xb4, 0x82, 0x68, 0x34, 0xa6, 0x5b, 0x6e, 0x68, 0x58, 0x24, 0xd8,
	0x25, 0x8d, 0x18, 0x0a, 0xbc, 0xd0, 0x0f, 0xa8, 0x6b, 0x99, 0x7a, 0x0c, 0x9d, 0x0e, 0x5c, 0xd7,
	0xf2, 0x17, 0xf8, 0xa0, 0x46, 0x9c, 0xe6, 0x47, 0x6c, 0x72, 0xdb, 0xc2, 0x75, 0xd7, 0x8b, 0x46,
	0xa3, 0x1e, 0xf1, 0xdd, 0xd0, 0xd3, 0x49, 0xbc, 0x62, 0xc6, 0x20, 0xba, 0x69, 0x63, 0x2b, 0x1a,
	0x8e, 0xd7, 0xdc, 0x9a, 0xcb, 0x3f, 0x17, 0xd8, 0x57, 0x53, 0xc9, 0x26, 0x0b, 0x96, 0xab, 0x8b,
	0x61, 0xee, 0x7b, 0x12, 0x18, 0x54, 0x28, 0x5d, 0x23, 0x0d, 0x38, 0x0f, 0x46, 0x5c, 0xaf, 0x86,
	0x1d, 0xf3, 0x55, 0xbe, 0x0f, 0x24, 0xcd, 0x48, 0xb3, 0xa9, 0x25, 0xf0, 0xde, 0x21, 0x1a, 0xc4,
	0x94, 0xba, 0x5e, 0x4d, 0x6d, 0x93, 0xc3, 0x93, 0xa0, 0xdf, 0xc1, 0x36, 0x41, 0xbd, 0x5c, 0x6f,
	0xe8, 0xbd, 0x43, 0xd4, 0x87, 0x29, 0x55, 0x39, 0x08, 0xcf, 0x83, 0xa1, 0x3a, 0xf1, 0x7c, 0x66,
	0xa7, 0xaf, 0xcd, 0x4e, 0x9d, 0x78, 0x6a, 0x2c, 0x5a, 0x1c, 0xf9, 0xc7, 0xa7, 0x48, 0xfa, 0xf7,
	0xa7, 0x48, 0xfa, 0xcd, 0x2f, 0xce, 0x48, 0xb9, 0xe7, 0x01, 0x58, 0x76, 0x9d, 0x6d, 0xb3, 0x76,
	0xc3, 0xb4, 0x08, 0x84, 0xa0, 0x7f, 0xd7, 0x74, 0x0c, 0xe1, 0x86, 0xca, 0xbf, 0xe1, 0x71, 0x30,
	0xa8, 0x73, 0x0d, 0xb1, 0xa8, 0x1a, 0x8d, 0x72, 0x7f, 0x46, 0xa0, 0x4f, 0xa1, 0x94, 0xc9, 0xb7,
	0x4d, 0x62, 0x19, 0x3e, 0x92, 0x66, 0xfa, 0x98, 0x5c, 0x8c, 0xe0, 0x53, 0xa0, 0x6f, 0x97, 0x34,
	0xf8, 0xa4, 0xf4, 0xd5, 0xb1, 0xf9, 0xe6, 0x11, 0xce, 0x8b, 0xad, 0x2f, 0xf5, 0x3f, 0xfc, 0xe8,
	0x4c, 0x8f, 0xca, 0x74, 0xe0, 0x39, 0x00, 0x4c, 0x1b, 0xd7, 0x88, 0x46, 0x71, 0xb0, 0x83, 0xfa,
	0xb9, 0xef, 0xfd, 0xef, 0xec, 0x23, 0x49, 0x4d, 0x71, 0xbc, 0x82, 0x83, 0x1d, 0xf8, 0x4c, 0xac,
	0x14, 0x34, 0x28, 0x41, 0x03, 0x33, 0xd2, 0x6c, 0xf6, 0xea, 0x78, 0xc2, 0xec, 0x2a, 0x13, 0xae,
	0x37, 0x28, 0x89, 0x26, 0xb1, 0x4f, 0x78, 0x16, 0x8c, 0x60, 0x5d, 0x27, 0xbe, 0xaf, 0x51, 0xd7,
	0x0b, 0x7c, 0x34, 0xc4, 0xb7, 0x90, 0x16, 0x58, 0x85, 0x41, 0x70, 0x0d, 0x64, 0x0d, 0xb2, 0x8d,
	0x43, 0x2b, 0xd0, 0xc4, 0x51, 0xa3, 0x14, 0x77, 0x39, 0x69, 0xfb, 0x06, 0x17, 0x30, 0xaf, 0xb3,
	0x7b, 0x87, 0x68, 0x50, 0x0c, 0xb9, 0xff, 0x99, 0x68, 0xae, 0x80, 0xe0, 0x14, 0x18, 0x0e, 0x7d,
	0xe2, 0xf1, 0x33, 0x7a, 0x81, 0xaf, 0xd5, 0x1c, 0xc3, 0x8b, 0x20, 0xad, 0x7b, 0xc4, 0x20, 0x4e,
	0x60, 0x62, 0xcb, 0x47, 0x8b, 0x89, 0x6d, 0x26, 0x05, 0xf0, 0x0a, 0x18, 0xc5, 0x61, 0xb0, 0xa3,
	0xd1, 0x70, 0xcb, 0x32, 0x75, 0x8d, 0x91, 0x38, 0xc2, 0x75, 0x53, 0x6f, 0xbe, 0x3b, 0x39, 0xe0,
	0xb8, 0xba, 0x4d, 0xd5, 0x0c, 0xd3, 0xa8, 0x70, 0x05, 0x16, 0x46, 0x08, 0x0c, 0xe9, 0xae, 0x6d,
	0x63, 0xc7, 0x40, 0x19, 0xbe, 0x6a, 0x3c, 0x64, 0x04, 0x44, 0x9f, 0x1a, 0xf6, 0x6a, 0x3e, 0x9a,
	0xe7, 0x67, 0x94, 0x8e, 0x30, 0xc5, 0xab, 0xf9, 0x70, 0x06, 0xa4, 0x13, 0x99, 0x84, 0xb2, 0x11,
	0x45, 0x2d, 0x08, 0x9e, 0x07, 0xc0, 0x20, 0xd4, 0x72, 0x1b, 0x36, 0x71, 0x02, 0x34, 0x9a, 0x70,
	0x3c, 0x81, 0xc3, 0xe7, 0xc0, 0xb1, 0xd6, 0x48, 0xb3, 0xb1, 0x63, 0x6e, 0x13, 0x3f, 0x40, 0x72,
	0x42, 0x1d, 0xb6, 0x14, 0x6e, 0x47, 0x72, 0x78, 0x1d, 0x8c, 0x27, 0xa6, 0xd5, 0x88, 0x43, 0x3c,
	0x1c, 0xb8, 0x1e, 0x1a, 0x4b, 0xcc, 0x4b, 0x18, 0xbe, 0x19, 0x2b, 0xc0, 0xcb, 0x60, 0x1c, 0x3b,
	0x86, 0xe7, 0x9a, 0x86, 0x46, 0xb1, 0xbe, 0xcb, 0x42, 0x83, 0xf3, 0x0e, 0xf9, 0x06, 0x60, 0x24,
	0xab, 0x08, 0x51, 0x89, 0x9d, 0xc0, 0x3c, 0x18, 0x32, 0x88, 0xa5, 0xb9, 0x34, 0x40, 0xe3, 0x3c,
	0x7e, 0x26, 0x12, 0x67, 0xbc, 0x42, 0x2c, 0x12, 0x88, 0x00, 0x1a, 0x34, 0x88, 0x55, 0xa6, 0x01,
	0x5c, 0x60, 0xb4, 0xb2, 0x60, 0xf7, 0xd1, 0xc4, 0x4c, 0xdf, 0x6c, 0xba, 0x4d, 0xbf, 0x95, 0x36,
	0x6a, 0xac, 0x05, 0xf3, 0x00, 0xfa, 0x3a, 0xb6, 0x88, 0xf6, 0xc0, 0x0c, 0x76, 0x34, 0xdd, 0x0a,
	0xfd, 0x80, 0x78, 0xe8, 0xf8, 0x8c, 0x34, 0x3b, 0xac, 0xca, 0x5c, 0x72, 0xd7, 0x0c, 0x76, 0x96,
	0x05, 0x0e, 0x2f, 0x80, 0xac, 0xe9, 0x04, 0x2c, 0x3a, 0xac, 0x28, 0x3c, 0x4f, 0x70, 0xcd, 0x4c,
	0x8c, 0x8a, 0x00, 0xbd, 0x00, 0x86, 0x3d, 0x52, 0x37, 0x79, 0x5e, 0xa3, 0xce, 0x40, 0x68, 0x8a,
	0xe0, 0x39, 0x90, 0x71, 0xb7, 0xb7, 0x4d, 0xdd, 0xc4, 0x96, 0xb6, 0x7d, 0xdf, 0x70, 0xd0, 0x24,
	0xe7, 0x61, 0x24, 0x06, 0x6f, 0xdc, 0x37, 0x1c, 0x96, 0xac, 0xb6, 0xf1, 0x9c, 0x1f, 0xda, 0x68,
	0x4a, 0x24, 0xb3, 0x18, 0xc1, 0x59, 0x20, 0xe3, 0x30, 0x70, 0x35, 0xea, 0xb9, 0x75, 0x4d, 0x5c,
	0x8f, 0xe8, 0x14, 0xd7, 0xc8, 0x32, 0xbc, 0xe2, 0xb9, 0xf5, 0x0a, 0x47, 0xe1, 0x35, 0x10, 0x65,
	0x8f, 0xc8, 0xc3, 0xd3, 0x47, 0x78, 0x54, 0xb8, 0x94, 0xf3, 0x08, 0x70, 0xf3, 0x1b, 0x3e, 0xcd,
	0xd2, 0x8c, 0x31, 0xac, 0x51, 0x8f, 0x50, 0xec, 0x11, 0x74, 0x86, 0x6d, 0x36, 0x3a, 0xe0, 0x8c,
	0x90, 0x55, 0x84, 0x08, 0xbe, 0x04, 0x60, 0x87, 0x3b, 0x26, 0xf1, 0xd1, 0x0c, 0x8b, 0xdd, 0x25,
	0xb8, 0x77, 0x88, 0xb2, 0x4a, 0x9b, 0x53, 0xaa, 0xdc, 0xe6, 0xa4, 0x49, 0x7c, 0x78, 0x09, 0xc0,
	0x80, 0xd8, 0xd4, 0xc2, 0x01, 0xd1, 0x0c, 0x62, 0x99, 0xb6, 0xc9, 0x4e, 0xe2, 0x2c, 0xdf, 0xd2,
	0x58, 0x2c, 0x59, 0x89, 0x05, 0x30, 0x07, 0x32, 0xfe, 0xae, 0x49, 0xb5, 0x1d, 0x3d, 0x3a, 0x89,
	0x9c, 0xc8, 0x02, 0x06, 0xde, 0xd2, 0xc5, 0x39, 0xdc, 0x03, 0x40, 0xf7, 0x08, 0x0e, 0x88, 0xa1,
	0xe1, 0x00, 0x9d, 0xe3, 0x97, 0xc4, 0xb9, 0x79, 0xc3, 0xf4, 0x03, 0xcf, 0xdc, 0x0a, 0x19, 0x6c,
	0xe3, 0x40, 0xdf, 0xd1, 0x88, 0x53, 0x33, 0x1d, 0x32, 0xbf, 0x6e, 0xda, 0xc4, 0x0f, 0xb0, 0x4d,
	0x97, 0x26, 0xd8, 0x16, 0xdf, 0x7c, 0x77, 0x32, 0x15, 0xc4, 0x10, 0xbf, 0x3a, 0x52, 0x91, 0x35,
	0x25, 0x60, 0xa6, 0x43, 0x6a, 0xc4, 0xa6, 0xcf, 0x7f, 0x7e, 0xd3, 0x91, 0x35, 0x25, 0x60, 0x57,
	0x03, 0xaf, 0x79, 0xc4, 0x40, 0x17, 0x78, 0x74, 0xc5, 0x43, 0x88, 0xc1, 0x69, 0x8f, 0xdc, 0x0f,
	0x4d, 0x8f, 0x18, 0x9a, 0x1b, 0x06, 0x5b, 0x6e, 0xe8, 0x18, 0x9a, 0xee, 0x3a, 0x0e, 0xd1, 0xc5,
	0x4d, 0x70, 0x91, 0xc7, 0xfc, 0x89, 0xc4, 0xd9, 0x56, 0x89, 0x1e, 0x7a, 0x66, 0xd0, 0x50, 0x43,
	0x8b, 0x44, 0x17, 0xf8, 0xc9, 0xd8, 0x46, 0x39, 0x32, 0xb1, 0xdc, 0xb2, 0x00, 0x9f, 0x02, 0x32,
	0xb6, 0x2c, 0xf7, 0x81, 0xe6, 0x13, 0xaf, 0x4e, 0x3c, 0x8b, 0xf8, 0x3e, 0xfa, 0x12, 0xf7, 0x62,
	0x94, 0xe3, 0xd5, 0x26, 0x0c, 0x6f, 0x81, 0xb1, 0x96, 0x92, 0x16, 0x55, 0x9c, 0x59, 0xce, 0xc4,
	0xc9, 0x36, 0x0f, 0x62, 0x1d, 0x91, 0x7f, 0xaa, 0xec, 0x77, 0x20, 0xf0, 0xcb, 0x20, 0x5b, 0xb7,
	0x35, 0x4c, 0xa9, 0xe6, 0x46, 0x41, 0xfa, 0x14, 0x0f, 0xd2, 0xe3, 0x09, 0x33, 0x9b, 0xb6, 0x42,
	0x69, 0x59, 0x44, 0x69, 0xba, 0xde, 0x1a, 0xc0, 0x6b, 0x20, 0x8b, 0x2d, 0xe2, 0x05, 0xad, 0xa8,
	0x9b, 0xe3, 0x51, 0x37, 0xba, 0x77, 0x88, 0xd2, 0x0a, 0x93, 0x44, 0x21, 0x97, 0xc1, 0xcd, 0x01,
	0x8b, 0xb7, 0x22, 0x38, 0x76, 0xdf, 0xf5, 0x35, 0x9f, 0xf8, 0x2c, 0x19, 0x59, 0xe0, 0x6e, 0x9b,
	0x16, 0x41, 0x4f, 0xf3, 0x95, 0x4f, 0x25, 0x56, 0xbe, 0xe3, 0xfa, 0x55, 0xa1, 0x54, 0x11, 0x3a,
	0xea, 0xd8, 0xfd, 0x4e, 0x08, 0x7e, 0x15, 0x8c, 0x27, 0xad, 0x19, 0xa1, 0x27, 0xda, 0x83, 0xfc,
	0x8c, 0x34, 0xdb, 0xb7, 0x34, 0xf2, 0xdf, 0x8f, 0xce, 0x0c, 0xaf, 0x44, 0x98, 0x0a, 0x5b, 0xd3,
	0x63, 0x0c, 0x9e, 0x05, 0xa9, 0x9a, 0xe5, 0x6e, 0x61, 0x4b, 0x33, 0x0d, 0x74, 0x29, 0x71, 0x91,
	0x0e, 0x0b, 0x78, 0xd5, 0x80, 0xd7, 0xc0, 0x30, 0x71, 0xea, 0x5a, 0x1d, 0x7b, 0x3e, 0x5a, 0xe0,
	0x07, 0x7d, 0xb2, 0xbd, 0x46, 0xcf, 0x17, 0x9c, 0xfa, 0x26, 0xf6, 0xfc, 0x82, 0x13, 0x78, 0x0d,
	0x75, 0x88, 0x88, 0x11, 0x5c, 0x05, 0xa3, 0x3e, 0xd1, 0x3d, 0x12, 0x68, 0xcd, 0xe9, 0x97, 0xf9,
	0xf4, 0xb3, 0x1d, 0xd3, 0xab, 0x5c, 0xab, 0xcd, 0x48, 0xc6, 0x4f, 0x62, 0xec, 0xb6, 0x14, 0x71,
	0xaa, 0x59, 0xa6, 0x1f, 0x68, 0x98, 0x07, 0x0d, 0xba, 0xc2, 0x33, 0x4f, 0x16, 0x92, 0xa2, 0xe9,
	0x07, 0x0a, 0xc7, 0xe1, 0x1d, 0x30, 0xbe, 0x1b, 0x6e, 0x11, 0xcf, 0x21, 0x01, 0xf1, 0xb5, 0x66,
	0x1f, 0x86, 0xae, 0xf2, 0x18, 0x99, 0x4e, 0xac, 0xbe, 0xd6, 0x54, 0x53, 0x63, 0x2d, 0xf5, 0xd8,
	0xee, 0x51, 0x10, 0x7e, 0x0d, 0x64, 0x1d, 0xd7, 0x20, 0x09, 0x63, 0xcf, 0x70, 0x63, 0x28, 0x61,
	0xac, 0xe4, 0x1a, 0xa4, 0x65, 0x26, 0xe3, 0x24, 0x87, 0xf0, 0x3c, 0x18, 0x74, 0xb7, 0x5e, 0x61,
	0x24, 0x3f, 0xcb, 0x49, 0xce, 0x44, 0xe9, 0x18, 0x5d, 0xce, 0x03, 0xee, 0xd6, 0x2b, 0xab, 0x06,
	0x5c, 0x03, 0xa3, 0x2c, 0x1a, 0x93, 0x45, 0xf6, 0x39, 0x4e, 0x59, 0xae, 0x83, 0x32, 0x85, 0x52,
	0xa5, 0xa5, 0x24, 0x38, 0xcb, 0xe2, 0x36, 0x90, 0x5d, 0xf3, 0xa6, 0xaf, 0xf9, 0x01, 0x76, 0x0c,
	0x6c, 0xb9, 0x0e, 0x41, 0xd7, 0x78, 0x3e, 0x8d, 0x98, 0x7e, 0xb5, 0x89, 0xc1, 0x67, 0xc1, 0x71,
	0x1b, 0x3b, 0xb8, 0x46, 0x7c, 0xcd, 0x7d, 0xe0, 0xf0, 0xb2, 0xe8, 0x53, 0xcc, 0x36, 0x78, 0x9d,
	0x6b, 0x8f, 0x47, 0xd2, 0xf2, 0x03, 0xa7, 0xd4, 0x94, 0xc1, 0x25, 0x30, 0xa1, 0xbb, 0x36, 0xc5,
	0x81, 0xb9, 0x65, 0x5a, 0x66, 0xd0, 0xd0, 0xe2, 0x6e, 0xf2, 0xf9, 0x19, 0x69, 0x36, 0xd3, 0xb9,
	0xb9, 0xf1, 0x36, 0xdd, 0x4d, 0xa1, 0x0a, 0xf3, 0xa0, 0x3f, 0xc0, 0x35, 0x1f, 0x19, 0x7c, 0x83,
	0xa8, 0x63, 0x83, 0xeb, 0xb8, 0x16, 0x6d, 0x8b, 0x6b, 0x4d, 0x2d, 0x82, 0x91, 0x64, 0x80, 0x40,
	0x59, 0xf4, 0x8c, 0xa2, 0xfd, 0xe4, 0xad, 0xe1, 0x38, 0x18, 0xa8, 0x63, 0x2b, 0x8c, 0x3a, 0x5e,
	0x55, 0x0c, 0x16, 0x7b, 0x9f, 0x97, 0xa6, 0x5e, 0x02, 0xf0, 0x68, 0x88, 0x3d, 0x96, 0x05, 0x05,
	0x1c, 0xeb, 0xc2, 0xf8, 0x63, 0x99, 0xb8, 0x0e, 0x52, 0xcd, 0x3d, 0x3d, 0xce, 0xc4, 0xc5, 0xff,
	0x48, 0xac, 0x0d, 0xff, 0xe7, 0xa7, 0x48, 0x7a, 0x6d, 0x1f, 0x49, 0x6f, 0xec, 0x23, 0xe9, 0xa7,
	0xfb, 0x48, 0x7a, 0xc8, 0x18, 0x3e, 0x40, 0xc5, 0x95, 0x64, 0x35, 0xcc, 0x2f, 0xc7, 0x75, 0x22,
	0xbf, 0x11, 0x5f, 0xeb, 0xf9, 0x15, 0xde, 0xa1, 0xe4, 0xdb, 0xeb, 0x60, 0x7e, 0xb9, 0xcb, 0x91,
	0xbc, 0x75, 0x80, 0xbe, 0x85, 0x29, 0x65, 0x31, 0xf0, 0xe2, 0x1a, 0x69, 0xcc, 0xb3, 0x03, 0xcf,
	0x8b, 0x47, 0x81, 0xcf, 0x81, 0x48, 0x2f, 0x2f, 0x1e, 0x1c, 0x1c, 0x2a, 0x27, 0xde, 0x1c, 0xf9,
	0xa8, 0xc3, 0x15, 0xcd, 0xf1, 0x8b, 0x2b, 0xc9, 0x7e, 0x97, 0x1b, 0x7b, 0xf7, 0x10, 0xc9, 0xbb,
	0xa4, 0xf1, 0x62, 0x72, 0xd2, 0x1f, 0x0f, 0x11, 0x12, 0x3e, 0xad, 0x91, 0xc6, 0x62, 0xbb, 0x97,
	0x5f, 0xef, 0x1f, 0x3e, 0x29, 0x9f, 0x52, 0xa7, 0xe2, 0xae, 0xdb, 0xdf, 0xc1, 0xac, 0x04, 0xd5,
	0x5d, 0x2b, 0xb4, 0x89, 0xe6, 0x9b, 0xaf, 0x92, 0xdc, 0x6f, 0x25, 0x20, 0x77, 0xde, 0xf4, 0xf0,
	0x12, 0x18, 0xa8, 0xeb, 0x34, 0xf4, 0x39, 0xc1, 0xed, 0x4f, 0x8a, 0x0d, 0x83, 0xe8, 0xd7, 0x9e,
	0x8d, 0x2a, 0x92, 0xd0, 0x62, 0xa7, 0xe1, 0x61, 0x9b, 0x33, 0xdf, 0xaf, 0xb2, 0x4f, 0xd6, 0x0b,
	0xdb, 0xa6, 0xa3, 0x79, 0x84, 0x5a, 0xa6, 0x8e, 0x7d, 0xfe, 0x48, 0xca, 0xa8, 0x69, 0xdb, 0x74,
	0xd4, 0x08, 0x82, 0x2f, 0x00, 0x50, 0xa3, 0x61, 0x5c, 0x7e, 0xfa, 0x8f, 0x3c, 0x04, 0x6e, 0xd2,
	0x50, 0x78, 0x13, 0xad, 0x95, 0xaa, 0xc5, 0x40, 0x2e, 0x00, 0xa9, 0xa6, 0x14, 0x5e, 0x04, 0xfd,
	0xbc, 0xf2, 0x48, 0xfc, 0xfe, 0x87, 0xed, 0x16, 0x78, 0xd5, 0xe1, 0x72, 0x16, 0x20, 0xb6, 0x6b,
	0x10, 0x2b, 0x0e, 0x10, 0x3e, 0x80, 0x27, 0xc0, 0x90, 0x13, 0xda, 0x5a, 0x8d, 0x86, 0xdc, 0xc7,
	0x01, 0x75, 0xd0, 0x09, 0xed, 0x9b, 0x34, 0x8c, 0xf7, 0xd4, 0xdf, 0xdc, 0x53, 0xee, 0x27, 0xbd,
	0x60, 0x8c, 0x05, 0x71, 0x7b, 0x93, 0x76, 0x1d, 0x0c, 0xb1, 0x1b, 0x27, 0x8e, 0xc6, 0xae, 0xef,
	0xaf, 0xf4, 0xde, 0x21, 0x62, 0x0f, 0x38, 0xbe, 0x0f, 0xf6, 0x4a, 0x64, 0x0f, 0x89, 0xaf, 0x74,
	0xe9, 0x03, 0xc5, 0x5b, 0xb3, 0x5b, 0xdb, 0xd5, 0xd1, 0x1b, 0x2e, 0x7e, 0x5f, 0x7a, 0xeb, 0x00,
	0x15, 0xe2, 0x60, 0x13, 0xeb, 0xb4, 0xc7, 0x5b, 0x84, 0x75, 0x84, 0x5c, 0x84, 0x26, 0x03, 0xe8,
	0xfd, 0x03, 0xd4, 0x66, 0xa0, 0x63, 0x62, 0x97, 0x19, 0x1d, 0xb9, 0x90, 0x7b, 0xbb, 0x17, 0x64,
	0x19, 0x33, 0xad, 0x9a, 0xfd, 0xe4, 0xb4, 0x5c, 0x05, 0x23, 0x89, 0xae, 0x20, 0xa6, 0xe4, 0x48,
	0x4f, 0x90, 0x6e, 0xf5, 0x04, 0x8d, 0xc5, 0xb7, 0x19, 0x19, 0xf8, 0x0b, 0x21, 0x23, 0xcf, 0xed,
	0x8a, 0xb5, 0x85, 0xb5, 0xd6, 0x3a, 0xef, 0x1f, 0xa0, 0xc5, 0xc7, 0x25, 0xaa, 0x35, 0x3b, 0xf7,
	0xbb, 0x5e, 0x30, 0xb1, 0xd2, 0x7c, 0x5c, 0x7d, 0xc3, 0x75, 0x88, 0x4a, 0xee, 0x87, 0xec, 0x5d,
	0x36, 0x03, 0xfa, 0x30, 0xa5, 0x11, 0x51, 0xd9, 0x76, 0xa2, 0x54, 0x26, 0x82, 0xe7, 0x41, 0xd6,
	0xf0, 0x1a, 0x9a, 0x17, 0x3a, 0x9a, 0x78, 0x9f, 0x71, 0x5e, 0x86, 0xd5, 0x11, 0xc3, 0x6b, 0xa8,
	0xa1, 0x23, 0xcc, 0xc2, 0x93, 0x20, 0xc5, 0x82, 0x99, 0x15, 0xce, 0x38, 0xe5, 0x86, 0x9d, 0xd0,
	0x66, 0x75, 0xd5, 0x5f, 0xfc, 0x3d, 0xbb, 0xee, 0xd6, 0x58, 0x69, 0x68, 0xbf, 0xf2, 0x18, 0xd2,
	0xba, 0xf6, 0xd8, 0xa8, 0x75, 0xf5, 0x45, 0xda, 0xfc, 0xfa, 0x63, 0x45, 0xb3, 0xed, 0xd8, 0xdf,
	0x3a, 0x40, 0x24, 0xc1, 0xf9, 0x7c, 0x37, 0xd2, 0xe7, 0xbf, 0x88, 0x5b, 0x6f, 0xee, 0x75, 0x09,
	0xa4, 0x9a, 0xbf, 0x39, 0xc0, 0xe3, 0x00, 0xae, 0xde, 0x56, 0x6e, 0x16, 0xb4, 0xf5, 0x7b, 0x95,
	0x82, 0xb6, 0x51, 0x5a, 0x2b, 0x95, 0xef, 0x96, 0xe4, 0x1e, 0x38, 0x01, 0xc6, 0x12, 0xf8, 0x4a,
	0x79, 0x79, 0xad, 0xa0, 0xca, 0x12, 0x3c, 0x06, 0x46, 0x13, 0xf0, 0x9d, 0xe5, 0xf2, 0x5d, 0xb9,
	0xb7, 0x03, 0xbc, 0x55, 0x28, 0xde, 0x96, 0xfb, 0x20, 0x04, 0xd9, 0x04, 0x58, 0xde, 0xbc, 0x21,
	0xf7, 0x1f, 0xc1, 0x14, 0x79, 0x60, 0xee, 0x07, 0x12, 0x18, 0x3b, 0xd2, 0x5b, 0x32, 0x93, 0x77,
	0xca, 0x55, 0xad, 0x54, 0xd6, 0x2a, 0xea, 0x6a, 0x59, 0x5d, 0x5d, 0xbf, 0x27, 0xf7, 0xc4, 0x60,
	0xb1, 0x7c, 0x57, 0x2b, 0x2a, 0xeb, 0x85, 0xd2, 0xf2, 0x3d, 0x59, 0x82, 0x93, 0x60, 0x82, 0x81,
	0xeb, 0xb7, 0xd4, 0xf2, 0xc6, 0xcd, 0x5b, 0x95, 0x8d, 0x75, 0x6d, 0xa5, 0x7c, 0xb7, 0xa4, 0x55,
	0xe5, 0xde, 0x47, 0x89, 0x98, 0x77, 0x8f, 0x10, 0x15, 0xe5, 0xfe, 0xb9, 0x5f, 0x4b, 0x20, 0x9d,
	0x68, 0xb3, 0x19, 0x13, 0x9b, 0xb7, 0x35, 0xa5, 0x52, 0xd1, 0xca, 0xd5, 0x04, 0x41, 0xc7, 0xc0,
	0x68, 0x0b, 0x2e, 0xae, 0x96, 0x36, 0x5e, 0x96, 0x25, 0x88, 0xc0, 0x78, 0x0b, 0xbc, 0xbb, 0x5a,
	0x5a, 0x29, 0xdf, 0xad, 0x6a, 0x57, 0x2e, 0xcb, 0xbd, 0x70, 0x0a, 0x1c, 0x3f, 0x2a, 0xb9, 0x7a,
	0xf9, 0xca, 0x55, 0xb9, 0xef, 0x91, 0xb2, 0x6b, 0x72, 0xff, 0x23, 0x65, 0x2f, 0xc8, 0x03, 0x73,
	0x57, 0x00, 0x68, 0x3d, 0xfe, 0x19, 0xb9, 0xa5, 0xb2, 0xa6, 0x6c, 0xac, 0x97, 0xb5, 0x95, 0x42,
	0xb1, 0xb0, 0x5e, 0x90, 0x7b, 0xe0, 0x28, 0x48, 0x27, 0x01, 0x69, 0x6e, 0x17, 0x80, 0xd6, 0x3b,
	0x17, 0x5e, 0x04, 0x39, 0x65, 0x79, 0xb9, 0x50, 0xad, 0x46, 0xa7, 0x5c, 0xb8, 0xa1, 0x6c, 0x14,
	0xd7, 0xb5, 0x1b, 0x65, 0x55, 0x5b, 0x29, 0x54, 0x8a, 0xe5, 0x7b, 0xb7, 0x0b, 0xa5, 0x75, 0xb9,
	0x87, 0x05, 0x49, 0x9b, 0xde, 0xaa, 0x5a, 0x58, 0x5e, 0x97, 0x25, 0x78, 0x1a, 0x4c, 0x26, 0xf1,
	0x62, 0x59, 0x59, 0xd1, 0x96, 0x94, 0xa2, 0x52, 0x5a, 0x2e, 0xa8, 0x72, 0xef, 0x5c, 0x15, 0x0c,
	0x45, 0x55, 0x03, 0x8e, 0x81, 0xcc, 0xcd, 0xca, 0x86, 0x50, 0x2b, 0x95, 0x4b, 0xcc, 0x37, 0x19,
	0x8c, 0x34, 0x21, 0xa5, 0xc4, 0x8e, 0x32, 0xa9, 0xb4, 0x79, 0xb3, 0xb2, 0x21, 0xf7, 0xb6, 0x29,
	0x55, 0x96, 0x57, 0xe5, 0xbe, 0xab, 0x3f, 0x1c, 0xe1, 0x3f, 0x42, 0x2a, 0xd4, 0x84, 0x2c, 0x92,
	0x45, 0xb2, 0x29, 0x94, 0xc2, 0x8e, 0x54, 0x9f, 0x4a, 0xde, 0x91, 0x2a, 0xff, 0x79, 0x35, 0xf7,
	0xcd, 0xbd, 0x7d, 0x34, 0x17, 0x77, 0xc1, 0x0a, 0xa5, 0x7e, 0x5e, 0xf4, 0xe8, 0xb7, 0x79, 0x57,
	0x99, 0xef, 0xcc, 0xa5, 0x0f, 0x0e, 0x90, 0xf4, 0x97, 0x03, 0x24, 0x6f, 0x74, 0xb4, 0xf4, 0xdf,
	0xf9, 0xd3, 0xdf, 0x7f, 0xd4, 0x2b, 0xe7, 0xd2, 0x0b, 0xe2, 0x21, 0xbc, 0x80, 0x29, 0x5d, 0x94,
	0xe6, 0xb8, 0x3b, 0xe2, 0x3c, 0xfe, 0x4f, 0xee, 0x88, 0xdf, 0x22, 0x62, 0x77, 0xbe, 0x0d, 0x52,
	0x42, 0xf3, 0x33, 0x7a, 0x73, 0xeb, 0xf1, 0xbd, 0x69, 0xae, 0x2c, 0x1e, 0x3d, 0xf1, 0xca, 0xdf,
	0x95, 0xc0, 0x50, 0x75, 0xc7, 0x7d, 0xd0, 0x6d, 0xe1, 0x8e, 0x71, 0xee, 0xe5, 0xbd, 0x7d, 0x34,
	0xdb, 0x65, 0xd5, 0x4d, 0x93, 0x3c, 0x78, 0x3c, 0x06, 0xb2, 0xb9, 0xd4, 0x82, 0xbf, 0xe3, 0x3e,
	0x88, 0xbc, 0xb8, 0x2c, 0xc1, 0x9f, 0x4b, 0x60, 0x5c, 0x31, 0x8c, 0xa3, 0x6d, 0xc6, 0xa9, 0x76,
	0x27, 0xda, 0xa5, 0xdd, 0xb8, 0xd9, 0xdc, 0xdb, 0x47, 0x97, 0x1e, 0xcd, 0x4d, 0x97, 0x62, 0xf5,
	0x30, 0xa6, 0xe7, 0x64, 0xee, 0xf8, 0x02, 0x36, 0x0c, 0xe6, 0x15, 0xeb, 0x3a, 0x58, 0x83, 0x22,
	0x0a, 0x22, 0x63, 0xea, 0x57, 0x12, 0x38, 0xa1, 0x12, 0xdb, 0xad, 0x93, 0x2f, 0xc0, 0xc9, 0x7b,
	0x4f, 0xee, 0xe4, 0x74, 0x6e, 0x72, 0xc1, 0xe3, 0x7e, 0x74, 0xf7, 0xf3, 0xc7, 0x12, 0x18, 0x8b,
	0x98, 0x4c, 0xb4, 0x25, 0x93, 0x1d, 0x1e, 0xb6, 0x44, 0xdd, 0xdc, 0xab, 0x3e, 0xb9, 0x7b, 0x28,
	0x77, 0xac, 0xc9, 0x61, 0xab, 0xa3, 0x60, 0x8e, 0xfd, 0x4c, 0x02, 0xe3, 0x2d, 0x02, 0x9f, 0xd8,
	0xb7, 0xcf, 0x79, 0xbe, 0x09, 0xea, 0xda, 0xdd, 0xfb, 0xa5, 0x04, 0x26, 0x59, 0x26, 0xb0, 0xfe,
	0xc4, 0xbf, 0xe1, 0x7a, 0x0a, 0xa5, 0xad, 0xa6, 0x05, 0xce, 0xb4, 0xfd, 0x8a, 0xdb, 0xa5, 0x97,
	0x99, 0x4a, 0x36, 0xe0, 0x0c, 0x5f, 0x23, 0x8d, 0x5c, 0x71, 0x6f, 0x1f, 0x4d, 0xc6, 0xbe, 0x72,
	0xc3, 0xc9, 0x94, 0x79, 0xe7, 0x00, 0x49, 0xcd, 0xd4, 0x3c, 0x9b, 0x3b, 0xc5, 0x53, 0xc2, 0xc6,
	0x94, 0x9a, 0x4e, 0x6d, 0xa1, 0xf5, 0x6b, 0xf4, 0xab, 0x6c, 0x9e, 0xc8, 0x92, 0x3f, 0x48, 0x20,
	0xc3, 0x7c, 0x14, 0xbf, 0xca, 0x7f, 0x96, 0x9c, 0x7d, 0x5d, 0x7a, 0x9c, 0xa4, 0xed, 0x96, 0xb0,
	0x7b, 0x07, 0xe8, 0x42, 0xb3, 0xc3, 0x39, 0xd2, 0xc2, 0x24, 0xda, 0x9c, 0xd7, 0x0e, 0x91, 0xf4,
	0xe1, 0xbf, 0xa2, 0xed, 0x4c, 0xe4, 0x64, 0x91, 0xe1, 0xe2, 0x1f, 0x06, 0x4c, 0xa9, 0xd8, 0xc2,
	0xd2, 0xa9, 0x87, 0x7f, 0x9b, 0xee, 0x79, 0xf8, 0xf1, 0xb4, 0xf4, 0xc1, 0xc7, 0xd3, 0xd2, 0x5f,
	0x3f, 0x9e, 0x96, 0xde, 0xf8, 0x64, 0xba, 0xe7, 0x83, 0x4f, 0xa6, 0x7b, 0x3e, 0xfc, 0x64, 0xba,
	0x67, 0x6b, 0x90, 0x7b, 0xfe, 0xcc, 0xff, 0x02, 0x00, 0x00, 0xff, 0xff, 0x4f, 0xe4, 0x50, 0x12,
	0x99, 0x1b, 0x00, 0x00,
}

func (this *AppKey) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&edgeproto.AppKey{")
	s = append(s, "Organization: "+fmt.Sprintf("%#v", this.Organization)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringApp(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// AppApiClient is the client API for AppApi service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AppApiClient interface {
	// Create Application. Creates a definition for an application for Cloudlet deployment.
	CreateApp(ctx context.Context, in *App, opts ...grpc.CallOption) (*Result, error)
	// Delete Application. Deletes a definition of an application. Instances of the application must be deleted first.
	DeleteApp(ctx context.Context, in *App, opts ...grpc.CallOption) (*Result, error)
	// Update Application. Updates the definition of an application.
	UpdateApp(ctx context.Context, in *App, opts ...grpc.CallOption) (*Result, error)
	// Show Applications. Lists all application definitions. Any fields specified will be used to filter results.
	ShowApp(ctx context.Context, in *App, opts ...grpc.CallOption) (AppApi_ShowAppClient, error)
	// Add an AutoProvPolicy to the application definition
	AddAppAutoProvPolicy(ctx context.Context, in *AppAutoProvPolicy, opts ...grpc.CallOption) (*Result, error)
	// Remove an AutoProvPolicy from the application definition
	RemoveAppAutoProvPolicy(ctx context.Context, in *AppAutoProvPolicy, opts ...grpc.CallOption) (*Result, error)
	// Add an AlertPolicy to the application definition
	AddAppAlertPolicy(ctx context.Context, in *AppAlertPolicy, opts ...grpc.CallOption) (*Result, error)
	// Remove an AlertPolicy from the application definition
	RemoveAppAlertPolicy(ctx context.Context, in *AppAlertPolicy, opts ...grpc.CallOption) (*Result, error)
	// Discover zones supporting deployments of App.DefaultFlavor
	ShowZonesForAppDeployment(ctx context.Context, in *DeploymentZoneRequest, opts ...grpc.CallOption) (AppApi_ShowZonesForAppDeploymentClient, error)
	// Show Public Applications. Lists all public application definitions.
	ShowPublicApp(ctx context.Context, in *App, opts ...grpc.CallOption) (AppApi_ShowPublicAppClient, error)
}

type appApiClient struct {
	cc *grpc.ClientConn
}

func NewAppApiClient(cc *grpc.ClientConn) AppApiClient {
	return &appApiClient{cc}
}

func (c *appApiClient) CreateApp(ctx context.Context, in *App, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/edgeproto.AppApi/CreateApp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appApiClient) DeleteApp(ctx context.Context, in *App, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/edgeproto.AppApi/DeleteApp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appApiClient) UpdateApp(ctx context.Context, in *App, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/edgeproto.AppApi/UpdateApp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appApiClient) ShowApp(ctx context.Context, in *App, opts ...grpc.CallOption) (AppApi_ShowAppClient, error) {
	stream, err := c.cc.NewStream(ctx, &_AppApi_serviceDesc.Streams[0], "/edgeproto.AppApi/ShowApp", opts...)
	if err != nil {
		return nil, err
	}
	x := &appApiShowAppClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AppApi_ShowAppClient interface {
	Recv() (*App, error)
	grpc.ClientStream
}

type appApiShowAppClient struct {
	grpc.ClientStream
}

func (x *appApiShowAppClient) Recv() (*App, error) {
	m := new(App)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *appApiClient) AddAppAutoProvPolicy(ctx context.Context, in *AppAutoProvPolicy, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/edgeproto.AppApi/AddAppAutoProvPolicy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appApiClient) RemoveAppAutoProvPolicy(ctx context.Context, in *AppAutoProvPolicy, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/edgeproto.AppApi/RemoveAppAutoProvPolicy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appApiClient) AddAppAlertPolicy(ctx context.Context, in *AppAlertPolicy, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/edgeproto.AppApi/AddAppAlertPolicy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appApiClient) RemoveAppAlertPolicy(ctx context.Context, in *AppAlertPolicy, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/edgeproto.AppApi/RemoveAppAlertPolicy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appApiClient) ShowZonesForAppDeployment(ctx context.Context, in *DeploymentZoneRequest, opts ...grpc.CallOption) (AppApi_ShowZonesForAppDeploymentClient, error) {
	stream, err := c.cc.NewStream(ctx, &_AppApi_serviceDesc.Streams[1], "/edgeproto.AppApi/ShowZonesForAppDeployment", opts...)
	if err != nil {
		return nil, err
	}
	x := &appApiShowZonesForAppDeploymentClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AppApi_ShowZonesForAppDeploymentClient interface {
	Recv() (*ZoneKey, error)
	grpc.ClientStream
}

type appApiShowZonesForAppDeploymentClient struct {
	grpc.ClientStream
}

func (x *appApiShowZonesForAppDeploymentClient) Recv() (*ZoneKey, error) {
	m := new(ZoneKey)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *appApiClient) ShowPublicApp(ctx context.Context, in *App, opts ...grpc.CallOption) (AppApi_ShowPublicAppClient, error) {
	stream, err := c.cc.NewStream(ctx, &_AppApi_serviceDesc.Streams[2], "/edgeproto.AppApi/ShowPublicApp", opts...)
	if err != nil {
		return nil, err
	}
	x := &appApiShowPublicAppClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AppApi_ShowPublicAppClient interface {
	Recv() (*App, error)
	grpc.ClientStream
}

type appApiShowPublicAppClient struct {
	grpc.ClientStream
}

func (x *appApiShowPublicAppClient) Recv() (*App, error) {
	m := new(App)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// AppApiServer is the server API for AppApi service.
type AppApiServer interface {
	// Create Application. Creates a definition for an application for Cloudlet deployment.
	CreateApp(context.Context, *App) (*Result, error)
	// Delete Application. Deletes a definition of an application. Instances of the application must be deleted first.
	DeleteApp(context.Context, *App) (*Result, error)
	// Update Application. Updates the definition of an application.
	UpdateApp(context.Context, *App) (*Result, error)
	// Show Applications. Lists all application definitions. Any fields specified will be used to filter results.
	ShowApp(*App, AppApi_ShowAppServer) error
	// Add an AutoProvPolicy to the application definition
	AddAppAutoProvPolicy(context.Context, *AppAutoProvPolicy) (*Result, error)
	// Remove an AutoProvPolicy from the application definition
	RemoveAppAutoProvPolicy(context.Context, *AppAutoProvPolicy) (*Result, error)
	// Add an AlertPolicy to the application definition
	AddAppAlertPolicy(context.Context, *AppAlertPolicy) (*Result, error)
	// Remove an AlertPolicy from the application definition
	RemoveAppAlertPolicy(context.Context, *AppAlertPolicy) (*Result, error)
	// Discover zones supporting deployments of App.DefaultFlavor
	ShowZonesForAppDeployment(*DeploymentZoneRequest, AppApi_ShowZonesForAppDeploymentServer) error
	// Show Public Applications. Lists all public application definitions.
	ShowPublicApp(*App, AppApi_ShowPublicAppServer) error
}

// UnimplementedAppApiServer can be embedded to have forward compatible implementations.
type UnimplementedAppApiServer struct {
}

func (*UnimplementedAppApiServer) CreateApp(ctx context.Context, req *App) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateApp not implemented")
}
func (*UnimplementedAppApiServer) DeleteApp(ctx context.Context, req *App) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteApp not implemented")
}
func (*UnimplementedAppApiServer) UpdateApp(ctx context.Context, req *App) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateApp not implemented")
}
func (*UnimplementedAppApiServer) ShowApp(req *App, srv AppApi_ShowAppServer) error {
	return status.Errorf(codes.Unimplemented, "method ShowApp not implemented")
}
func (*UnimplementedAppApiServer) AddAppAutoProvPolicy(ctx context.Context, req *AppAutoProvPolicy) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddAppAutoProvPolicy not implemented")
}
func (*UnimplementedAppApiServer) RemoveAppAutoProvPolicy(ctx context.Context, req *AppAutoProvPolicy) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveAppAutoProvPolicy not implemented")
}
func (*UnimplementedAppApiServer) AddAppAlertPolicy(ctx context.Context, req *AppAlertPolicy) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddAppAlertPolicy not implemented")
}
func (*UnimplementedAppApiServer) RemoveAppAlertPolicy(ctx context.Context, req *AppAlertPolicy) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveAppAlertPolicy not implemented")
}
func (*UnimplementedAppApiServer) ShowZonesForAppDeployment(req *DeploymentZoneRequest, srv AppApi_ShowZonesForAppDeploymentServer) error {
	return status.Errorf(codes.Unimplemented, "method ShowZonesForAppDeployment not implemented")
}
func (*UnimplementedAppApiServer) ShowPublicApp(req *App, srv AppApi_ShowPublicAppServer) error {
	return status.Errorf(codes.Unimplemented, "method ShowPublicApp not implemented")
}

func RegisterAppApiServer(s *grpc.Server, srv AppApiServer) {
	s.RegisterService(&_AppApi_serviceDesc, srv)
}

func _AppApi_CreateApp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(App)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppApiServer).CreateApp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.AppApi/CreateApp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppApiServer).CreateApp(ctx, req.(*App))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppApi_DeleteApp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(App)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppApiServer).DeleteApp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.AppApi/DeleteApp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppApiServer).DeleteApp(ctx, req.(*App))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppApi_UpdateApp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(App)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppApiServer).UpdateApp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.AppApi/UpdateApp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppApiServer).UpdateApp(ctx, req.(*App))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppApi_ShowApp_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(App)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AppApiServer).ShowApp(m, &appApiShowAppServer{stream})
}

type AppApi_ShowAppServer interface {
	Send(*App) error
	grpc.ServerStream
}

type appApiShowAppServer struct {
	grpc.ServerStream
}

func (x *appApiShowAppServer) Send(m *App) error {
	return x.ServerStream.SendMsg(m)
}

func _AppApi_AddAppAutoProvPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppAutoProvPolicy)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppApiServer).AddAppAutoProvPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.AppApi/AddAppAutoProvPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppApiServer).AddAppAutoProvPolicy(ctx, req.(*AppAutoProvPolicy))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppApi_RemoveAppAutoProvPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppAutoProvPolicy)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppApiServer).RemoveAppAutoProvPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.AppApi/RemoveAppAutoProvPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppApiServer).RemoveAppAutoProvPolicy(ctx, req.(*AppAutoProvPolicy))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppApi_AddAppAlertPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppAlertPolicy)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppApiServer).AddAppAlertPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.AppApi/AddAppAlertPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppApiServer).AddAppAlertPolicy(ctx, req.(*AppAlertPolicy))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppApi_RemoveAppAlertPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppAlertPolicy)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppApiServer).RemoveAppAlertPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.AppApi/RemoveAppAlertPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppApiServer).RemoveAppAlertPolicy(ctx, req.(*AppAlertPolicy))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppApi_ShowZonesForAppDeployment_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DeploymentZoneRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AppApiServer).ShowZonesForAppDeployment(m, &appApiShowZonesForAppDeploymentServer{stream})
}

type AppApi_ShowZonesForAppDeploymentServer interface {
	Send(*ZoneKey) error
	grpc.ServerStream
}

type appApiShowZonesForAppDeploymentServer struct {
	grpc.ServerStream
}

func (x *appApiShowZonesForAppDeploymentServer) Send(m *ZoneKey) error {
	return x.ServerStream.SendMsg(m)
}

func _AppApi_ShowPublicApp_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(App)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AppApiServer).ShowPublicApp(m, &appApiShowPublicAppServer{stream})
}

type AppApi_ShowPublicAppServer interface {
	Send(*App) error
	grpc.ServerStream
}

type appApiShowPublicAppServer struct {
	grpc.ServerStream
}

func (x *appApiShowPublicAppServer) Send(m *App) error {
	return x.ServerStream.SendMsg(m)
}

var _AppApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "edgeproto.AppApi",
	HandlerType: (*AppApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateApp",
			Handler:    _AppApi_CreateApp_Handler,
		},
		{
			MethodName: "DeleteApp",
			Handler:    _AppApi_DeleteApp_Handler,
		},
		{
			MethodName: "UpdateApp",
			Handler:    _AppApi_UpdateApp_Handler,
		},
		{
			MethodName: "AddAppAutoProvPolicy",
			Handler:    _AppApi_AddAppAutoProvPolicy_Handler,
		},
		{
			MethodName: "RemoveAppAutoProvPolicy",
			Handler:    _AppApi_RemoveAppAutoProvPolicy_Handler,
		},
		{
			MethodName: "AddAppAlertPolicy",
			Handler:    _AppApi_AddAppAlertPolicy_Handler,
		},
		{
			MethodName: "RemoveAppAlertPolicy",
			Handler:    _AppApi_RemoveAppAlertPolicy_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ShowApp",
			Handler:       _AppApi_ShowApp_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ShowZonesForAppDeployment",
			Handler:       _AppApi_ShowZonesForAppDeployment_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ShowPublicApp",
			Handler:       _AppApi_ShowPublicApp_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "app.proto",
}

func (m *AppKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintApp(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintApp(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Organization) > 0 {
		i -= len(m.Organization)
		copy(dAtA[i:], m.Organization)
		i = encodeVarintApp(dAtA, i, uint64(len(m.Organization)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConfigFile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigFile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConfigFile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Config) > 0 {
		i -= len(m.Config)
		copy(dAtA[i:], m.Config)
		i = encodeVarintApp(dAtA, i, uint64(len(m.Config)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintApp(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *App) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *App) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *App) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Tags) > 0 {
		for k := range m.Tags {
			v := m.Tags[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintApp(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintApp(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintApp(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.Credentials) > 0 {
		i -= len(m.Credentials)
		copy(dAtA[i:], m.Credentials)
		i = encodeVarintApp(dAtA, i, uint64(len(m.Credentials)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xd2
	}
	if len(m.Username) > 0 {
		i -= len(m.Username)
		copy(dAtA[i:], m.Username)
		i = encodeVarintApp(dAtA, i, uint64(len(m.Username)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xca
	}
	if m.CompatibilityVersion != 0 {
		i = encodeVarintApp(dAtA, i, uint64(m.CompatibilityVersion))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xc0
	}
	if m.ManagesOwnNamespaces {
		i--
		if m.ManagesOwnNamespaces {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xb8
	}
	if m.IsStandalone {
		i--
		if m.IsStandalone {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xb0
	}
	if len(m.AppAnnotations) > 0 {
		for k := range m.AppAnnotations {
			v := m.AppAnnotations[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintApp(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintApp(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintApp(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xaa
		}
	}
	if len(m.ObjId) > 0 {
		i -= len(m.ObjId)
		copy(dAtA[i:], m.ObjId)
		i = encodeVarintApp(dAtA, i, uint64(len(m.ObjId)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa2
	}
	if m.NodeResources != nil {
		{
			size, err := m.NodeResources.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x9a
	}
	if m.KubernetesResources != nil {
		{
			size, err := m.KubernetesResources.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x92
	}
	if len(m.UpdateListAction) > 0 {
		i -= len(m.UpdateListAction)
		copy(dAtA[i:], m.UpdateListAction)
		i = encodeVarintApp(dAtA, i, uint64(len(m.UpdateListAction)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x8a
	}
	if len(m.SecretEnvVars) > 0 {
		for k := range m.SecretEnvVars {
			v := m.SecretEnvVars[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintApp(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintApp(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintApp(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0x82
		}
	}
	if len(m.EnvVars) > 0 {
		for k := range m.EnvVars {
			v := m.EnvVars[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintApp(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintApp(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintApp(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xfa
		}
	}
	if len(m.CommandArgs) > 0 {
		for iNdEx := len(m.CommandArgs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.CommandArgs[iNdEx])
			copy(dAtA[i:], m.CommandArgs[iNdEx])
			i = encodeVarintApp(dAtA, i, uint64(len(m.CommandArgs[iNdEx])))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xf2
		}
	}
	if len(m.GlobalId) > 0 {
		i -= len(m.GlobalId)
		copy(dAtA[i:], m.GlobalId)
		i = encodeVarintApp(dAtA, i, uint64(len(m.GlobalId)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xea
	}
	if m.QosSessionDuration != 0 {
		i = encodeVarintApp(dAtA, i, uint64(m.QosSessionDuration))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe0
	}
	if m.QosSessionProfile != 0 {
		i = encodeVarintApp(dAtA, i, uint64(m.QosSessionProfile))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd8
	}
	if len(m.AlertPolicies) > 0 {
		for iNdEx := len(m.AlertPolicies) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AlertPolicies[iNdEx])
			copy(dAtA[i:], m.AlertPolicies[iNdEx])
			i = encodeVarintApp(dAtA, i, uint64(len(m.AlertPolicies[iNdEx])))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xd2
		}
	}
	if m.VmAppOsType != 0 {
		i = encodeVarintApp(dAtA, i, uint64(m.VmAppOsType))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc8
	}
	if m.ServerlessConfig != nil {
		{
			size, err := m.ServerlessConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc2
	}
	if m.AllowServerless {
		i--
		if m.AllowServerless {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb8
	}
	if len(m.RequiredOutboundConnections) > 0 {
		for iNdEx := len(m.RequiredOutboundConnections) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RequiredOutboundConnections[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApp(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xb2
		}
	}
	if m.Trusted {
		i--
		if m.Trusted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa8
	}
	{
		size, err := m.UpdatedAt.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApp(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0xa2
	{
		size, err := m.CreatedAt.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApp(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0x9a
	if len(m.SkipHcPorts) > 0 {
		i -= len(m.SkipHcPorts)
		copy(dAtA[i:], m.SkipHcPorts)
		i = encodeVarintApp(dAtA, i, uint64(len(m.SkipHcPorts)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x92
	}
	if len(m.TemplateDelimiter) > 0 {
		i -= len(m.TemplateDelimiter)
		copy(dAtA[i:], m.TemplateDelimiter)
		i = encodeVarintApp(dAtA, i, uint64(len(m.TemplateDelimiter)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x8a
	}
	if len(m.AutoProvPolicies) > 0 {
		for iNdEx := len(m.AutoProvPolicies) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AutoProvPolicies[iNdEx])
			copy(dAtA[i:], m.AutoProvPolicies[iNdEx])
			i = encodeVarintApp(dAtA, i, uint64(len(m.AutoProvPolicies[iNdEx])))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0x82
		}
	}
	if m.DeletePrepare {
		i--
		if m.DeletePrepare {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if m.AccessType != 0 {
		i = encodeVarintApp(dAtA, i, uint64(m.AccessType))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe8
	}
	if len(m.AutoProvPolicy) > 0 {
		i -= len(m.AutoProvPolicy)
		copy(dAtA[i:], m.AutoProvPolicy)
		i = encodeVarintApp(dAtA, i, uint64(len(m.AutoProvPolicy)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe2
	}
	if len(m.Md5Sum) > 0 {
		i -= len(m.Md5Sum)
		copy(dAtA[i:], m.Md5Sum)
		i = encodeVarintApp(dAtA, i, uint64(len(m.Md5Sum)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	if len(m.OfficialFqdn) > 0 {
		i -= len(m.OfficialFqdn)
		copy(dAtA[i:], m.OfficialFqdn)
		i = encodeVarintApp(dAtA, i, uint64(len(m.OfficialFqdn)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if len(m.Revision) > 0 {
		i -= len(m.Revision)
		copy(dAtA[i:], m.Revision)
		i = encodeVarintApp(dAtA, i, uint64(len(m.Revision)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.InternalPorts {
		i--
		if m.InternalPorts {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.ScaleWithCluster {
		i--
		if m.ScaleWithCluster {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if len(m.Configs) > 0 {
		for iNdEx := len(m.Configs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Configs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApp(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xaa
		}
	}
	if m.DelOpt != 0 {
		i = encodeVarintApp(dAtA, i, uint64(m.DelOpt))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if len(m.AndroidPackageName) > 0 {
		i -= len(m.AndroidPackageName)
		copy(dAtA[i:], m.AndroidPackageName)
		i = encodeVarintApp(dAtA, i, uint64(len(m.AndroidPackageName)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if len(m.DeploymentGenerator) > 0 {
		i -= len(m.DeploymentGenerator)
		copy(dAtA[i:], m.DeploymentGenerator)
		i = encodeVarintApp(dAtA, i, uint64(len(m.DeploymentGenerator)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.DeploymentManifest) > 0 {
		i -= len(m.DeploymentManifest)
		copy(dAtA[i:], m.DeploymentManifest)
		i = encodeVarintApp(dAtA, i, uint64(len(m.DeploymentManifest)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.Deployment) > 0 {
		i -= len(m.Deployment)
		copy(dAtA[i:], m.Deployment)
		i = encodeVarintApp(dAtA, i, uint64(len(m.Deployment)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.Annotations) > 0 {
		i -= len(m.Annotations)
		copy(dAtA[i:], m.Annotations)
		i = encodeVarintApp(dAtA, i, uint64(len(m.Annotations)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.Command) > 0 {
		i -= len(m.Command)
		copy(dAtA[i:], m.Command)
		i = encodeVarintApp(dAtA, i, uint64(len(m.Command)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.AuthPublicKey) > 0 {
		i -= len(m.AuthPublicKey)
		copy(dAtA[i:], m.AuthPublicKey)
		i = encodeVarintApp(dAtA, i, uint64(len(m.AuthPublicKey)))
		i--
		dAtA[i] = 0x62
	}
	{
		size, err := m.DefaultFlavor.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApp(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	if len(m.AccessPorts) > 0 {
		i -= len(m.AccessPorts)
		copy(dAtA[i:], m.AccessPorts)
		i = encodeVarintApp(dAtA, i, uint64(len(m.AccessPorts)))
		i--
		dAtA[i] = 0x3a
	}
	if m.ImageType != 0 {
		i = encodeVarintApp(dAtA, i, uint64(m.ImageType))
		i--
		dAtA[i] = 0x28
	}
	if len(m.ImagePath) > 0 {
		i -= len(m.ImagePath)
		copy(dAtA[i:], m.ImagePath)
		i = encodeVarintApp(dAtA, i, uint64(len(m.ImagePath)))
		i--
		dAtA[i] = 0x22
	}
	{
		size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApp(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Fields) > 0 {
		for iNdEx := len(m.Fields) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Fields[iNdEx])
			copy(dAtA[i:], m.Fields[iNdEx])
			i = encodeVarintApp(dAtA, i, uint64(len(m.Fields[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ServerlessConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServerlessConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServerlessConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.GpuConfig.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApp(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.MinReplicas != 0 {
		i = encodeVarintApp(dAtA, i, uint64(m.MinReplicas))
		i--
		dAtA[i] = 0x18
	}
	if m.Ram != 0 {
		i = encodeVarintApp(dAtA, i, uint64(m.Ram))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.Vcpus.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApp(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *GpuConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GpuConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GpuConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Ram != 0 {
		i = encodeVarintApp(dAtA, i, uint64(m.Ram))
		i--
		dAtA[i] = 0x20
	}
	if m.NumGpu != 0 {
		i = encodeVarintApp(dAtA, i, uint64(m.NumGpu))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Model) > 0 {
		i -= len(m.Model)
		copy(dAtA[i:], m.Model)
		i = encodeVarintApp(dAtA, i, uint64(len(m.Model)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintApp(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AppAutoProvPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppAutoProvPolicy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppAutoProvPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AutoProvPolicy) > 0 {
		i -= len(m.AutoProvPolicy)
		copy(dAtA[i:], m.AutoProvPolicy)
		i = encodeVarintApp(dAtA, i, uint64(len(m.AutoProvPolicy)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.AppKey.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApp(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AppAlertPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppAlertPolicy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppAlertPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AlertPolicy) > 0 {
		i -= len(m.AlertPolicy)
		copy(dAtA[i:], m.AlertPolicy)
		i = encodeVarintApp(dAtA, i, uint64(len(m.AlertPolicy)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.AppKey.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApp(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *DeploymentZoneRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeploymentZoneRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeploymentZoneRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NumNodes != 0 {
		i = encodeVarintApp(dAtA, i, uint64(m.NumNodes))
		i--
		dAtA[i] = 0x18
	}
	if m.DryRunDeploy {
		i--
		if m.DryRunDeploy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.App != nil {
		{
			size, err := m.App.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintApp(dAtA []byte, offset int, v uint64) int {
	offset -= sovApp(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *AppKey) Matches(o *AppKey, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !opts.Filter || o.Organization != "" {
		if o.Organization != m.Organization {
			return false
		}
	}
	if !opts.Filter || o.Name != "" {
		if o.Name != m.Name {
			return false
		}
	}
	if !opts.Filter || o.Version != "" {
		if o.Version != m.Version {
			return false
		}
	}
	return true
}

func (m *AppKey) Clone() *AppKey {
	cp := &AppKey{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *AppKey) CopyInFields(src *AppKey) int {
	changed := 0
	if m.Organization != src.Organization {
		m.Organization = src.Organization
		changed++
	}
	if m.Name != src.Name {
		m.Name = src.Name
		changed++
	}
	if m.Version != src.Version {
		m.Version = src.Version
		changed++
	}
	return changed
}

func (m *AppKey) DeepCopyIn(src *AppKey) {
	m.Organization = src.Organization
	m.Name = src.Name
	m.Version = src.Version
}

func (m *AppKey) GetKeyString() string {
	key, err := json.Marshal(m)
	if err != nil {
		log.FatalLog("Failed to marshal AppKey key string", "obj", m)
	}
	return string(key)
}

func AppKeyStringParse(str string, key *AppKey) {
	err := json.Unmarshal([]byte(str), key)
	if err != nil {
		log.FatalLog("Failed to unmarshal AppKey key string", "str", str)
	}
}

func (m *AppKey) NotFoundError() error {
	return fmt.Errorf("App key %s not found", m.GetKeyString())
}

func (m *AppKey) ExistsError() error {
	return fmt.Errorf("App key %s already exists", m.GetKeyString())
}

func (m *AppKey) BeingDeletedError() error {
	return fmt.Errorf("App %s is being deleted", m.GetKeyString())
}

var AppKeyTagOrganization = "apporg"
var AppKeyTagName = "app"
var AppKeyTagVersion = "appver"

func (m *AppKey) GetTags() map[string]string {
	tags := make(map[string]string)
	m.AddTags(tags)
	return tags
}

func (m *AppKey) AddTagsByFunc(addTag AddTagFunc) {
	addTag("apporg", m.Organization)
	addTag("app", m.Name)
	addTag("appver", m.Version)
}

func (m *AppKey) AddTags(tags map[string]string) {
	tagMap := TagMap(tags)
	m.AddTagsByFunc(tagMap.AddTag)
}

// Helper method to check that enums have valid values
func (m *AppKey) ValidateEnums() error {
	return nil
}

func (s *AppKey) ClearTagged(tags map[string]struct{}) {
}

func (m *ConfigFile) Clone() *ConfigFile {
	cp := &ConfigFile{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *ConfigFile) CopyInFields(src *ConfigFile) int {
	changed := 0
	if m.Kind != src.Kind {
		m.Kind = src.Kind
		changed++
	}
	if m.Config != src.Config {
		m.Config = src.Config
		changed++
	}
	return changed
}

func (m *ConfigFile) DeepCopyIn(src *ConfigFile) {
	m.Kind = src.Kind
	m.Config = src.Config
}

// Helper method to check that enums have valid values
func (m *ConfigFile) ValidateEnums() error {
	return nil
}

func (s *ConfigFile) ClearTagged(tags map[string]struct{}) {
}

func (m *App) Matches(o *App, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !m.Key.Matches(&o.Key, fopts...) {
		return false
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.ImagePath != "" {
			if o.ImagePath != m.ImagePath {
				return false
			}
		}
	}
	if !opts.Filter || o.ImageType != 0 {
		if o.ImageType != m.ImageType {
			return false
		}
	}
	if !opts.Filter || o.AccessPorts != "" {
		if o.AccessPorts != m.AccessPorts {
			return false
		}
	}
	if !m.DefaultFlavor.Matches(&o.DefaultFlavor, fopts...) {
		return false
	}
	if !opts.Filter || o.AuthPublicKey != "" {
		if o.AuthPublicKey != m.AuthPublicKey {
			return false
		}
	}
	if !opts.Filter || o.Command != "" {
		if o.Command != m.Command {
			return false
		}
	}
	if !opts.Filter || o.Annotations != "" {
		if o.Annotations != m.Annotations {
			return false
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.Deployment != "" {
			if o.Deployment != m.Deployment {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.DeploymentManifest != "" {
			if o.DeploymentManifest != m.DeploymentManifest {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.DeploymentGenerator != "" {
			if o.DeploymentGenerator != m.DeploymentGenerator {
				return false
			}
		}
	}
	if !opts.Filter || o.AndroidPackageName != "" {
		if o.AndroidPackageName != m.AndroidPackageName {
			return false
		}
	}
	if !opts.Filter || o.DelOpt != 0 {
		if o.DelOpt != m.DelOpt {
			return false
		}
	}
	if !opts.Filter || o.Configs != nil {
		if len(m.Configs) == 0 && len(o.Configs) > 0 || len(m.Configs) > 0 && len(o.Configs) == 0 {
			return false
		} else if m.Configs != nil && o.Configs != nil {
			if !opts.Filter && len(m.Configs) != len(o.Configs) {
				return false
			}
		}
	}
	if !opts.Filter || o.ScaleWithCluster != false {
		if o.ScaleWithCluster != m.ScaleWithCluster {
			return false
		}
	}
	if !opts.Filter || o.InternalPorts != false {
		if o.InternalPorts != m.InternalPorts {
			return false
		}
	}
	if !opts.Filter || o.Revision != "" {
		if o.Revision != m.Revision {
			return false
		}
	}
	if !opts.Filter || o.OfficialFqdn != "" {
		if o.OfficialFqdn != m.OfficialFqdn {
			return false
		}
	}
	if !opts.Filter || o.Md5Sum != "" {
		if o.Md5Sum != m.Md5Sum {
			return false
		}
	}
	if !opts.Filter || o.AutoProvPolicy != "" {
		if o.AutoProvPolicy != m.AutoProvPolicy {
			return false
		}
	}
	if !opts.Filter || o.AccessType != 0 {
		if o.AccessType != m.AccessType {
			return false
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.DeletePrepare != false {
			if o.DeletePrepare != m.DeletePrepare {
				return false
			}
		}
	}
	if !opts.Filter || o.AutoProvPolicies != nil {
		if len(m.AutoProvPolicies) == 0 && len(o.AutoProvPolicies) > 0 || len(m.AutoProvPolicies) > 0 && len(o.AutoProvPolicies) == 0 {
			return false
		} else if m.AutoProvPolicies != nil && o.AutoProvPolicies != nil {
			if !opts.Filter && len(m.AutoProvPolicies) != len(o.AutoProvPolicies) {
				return false
			}
			found := 0
			for oIndex, _ := range o.AutoProvPolicies {
				for mIndex, _ := range m.AutoProvPolicies {
					if o.AutoProvPolicies[oIndex] == m.AutoProvPolicies[mIndex] {
						found++
						break
					}
				}
			}
			if found != len(o.AutoProvPolicies) {
				return false
			}
		}
	}
	if !opts.Filter || o.TemplateDelimiter != "" {
		if o.TemplateDelimiter != m.TemplateDelimiter {
			return false
		}
	}
	if !opts.Filter || o.SkipHcPorts != "" {
		if o.SkipHcPorts != m.SkipHcPorts {
			return false
		}
	}
	if !opts.IgnoreBackend {
	}
	if !opts.IgnoreBackend {
	}
	if !opts.Filter || o.Trusted != false {
		if o.Trusted != m.Trusted {
			return false
		}
	}
	if !opts.Filter || o.RequiredOutboundConnections != nil {
		if len(m.RequiredOutboundConnections) == 0 && len(o.RequiredOutboundConnections) > 0 || len(m.RequiredOutboundConnections) > 0 && len(o.RequiredOutboundConnections) == 0 {
			return false
		} else if m.RequiredOutboundConnections != nil && o.RequiredOutboundConnections != nil {
			if !opts.Filter && len(m.RequiredOutboundConnections) != len(o.RequiredOutboundConnections) {
				return false
			}
		}
	}
	if !opts.Filter || o.AllowServerless != false {
		if o.AllowServerless != m.AllowServerless {
			return false
		}
	}
	if !opts.Filter || o.ServerlessConfig != nil {
		if m.ServerlessConfig == nil && o.ServerlessConfig != nil || m.ServerlessConfig != nil && o.ServerlessConfig == nil {
			return false
		} else if m.ServerlessConfig != nil && o.ServerlessConfig != nil {
		}
	}
	if !opts.Filter || o.VmAppOsType != 0 {
		if o.VmAppOsType != m.VmAppOsType {
			return false
		}
	}
	if !opts.Filter || o.AlertPolicies != nil {
		if len(m.AlertPolicies) == 0 && len(o.AlertPolicies) > 0 || len(m.AlertPolicies) > 0 && len(o.AlertPolicies) == 0 {
			return false
		} else if m.AlertPolicies != nil && o.AlertPolicies != nil {
			if !opts.Filter && len(m.AlertPolicies) != len(o.AlertPolicies) {
				return false
			}
			found := 0
			for oIndex, _ := range o.AlertPolicies {
				for mIndex, _ := range m.AlertPolicies {
					if o.AlertPolicies[oIndex] == m.AlertPolicies[mIndex] {
						found++
						break
					}
				}
			}
			if found != len(o.AlertPolicies) {
				return false
			}
		}
	}
	if !opts.Filter || o.QosSessionProfile != 0 {
		if o.QosSessionProfile != m.QosSessionProfile {
			return false
		}
	}
	if !opts.Filter || o.QosSessionDuration != 0 {
		if o.QosSessionDuration != m.QosSessionDuration {
			return false
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.GlobalId != "" {
			if o.GlobalId != m.GlobalId {
				return false
			}
		}
	}
	if !opts.Filter || o.CommandArgs != nil {
		if len(m.CommandArgs) == 0 && len(o.CommandArgs) > 0 || len(m.CommandArgs) > 0 && len(o.CommandArgs) == 0 {
			return false
		} else if m.CommandArgs != nil && o.CommandArgs != nil {
			if !opts.Filter && len(m.CommandArgs) != len(o.CommandArgs) {
				return false
			}
			found := 0
			for oIndex, _ := range o.CommandArgs {
				for mIndex, _ := range m.CommandArgs {
					if o.CommandArgs[oIndex] == m.CommandArgs[mIndex] {
						found++
						break
					}
				}
			}
			if found != len(o.CommandArgs) {
				return false
			}
		}
	}
	if !opts.Filter || o.EnvVars != nil {
		if len(m.EnvVars) == 0 && len(o.EnvVars) > 0 || len(m.EnvVars) > 0 && len(o.EnvVars) == 0 {
			return false
		} else if m.EnvVars != nil && o.EnvVars != nil {
			if !opts.Filter && len(m.EnvVars) != len(o.EnvVars) {
				return false
			}
			for k, _ := range o.EnvVars {
				_, ok := m.EnvVars[k]
				if !ok {
					return false
				}
				if o.EnvVars[k] != m.EnvVars[k] {
					return false
				}
			}
		}
	}
	if !opts.Filter || o.SecretEnvVars != nil {
		if len(m.SecretEnvVars) == 0 && len(o.SecretEnvVars) > 0 || len(m.SecretEnvVars) > 0 && len(o.SecretEnvVars) == 0 {
			return false
		} else if m.SecretEnvVars != nil && o.SecretEnvVars != nil {
			if !opts.Filter && len(m.SecretEnvVars) != len(o.SecretEnvVars) {
				return false
			}
			for k, _ := range o.SecretEnvVars {
				_, ok := m.SecretEnvVars[k]
				if !ok {
					return false
				}
				if o.SecretEnvVars[k] != m.SecretEnvVars[k] {
					return false
				}
			}
		}
	}
	if !opts.Filter || o.UpdateListAction != "" {
		if o.UpdateListAction != m.UpdateListAction {
			return false
		}
	}
	if !opts.Filter || o.KubernetesResources != nil {
		if m.KubernetesResources == nil && o.KubernetesResources != nil || m.KubernetesResources != nil && o.KubernetesResources == nil {
			return false
		} else if m.KubernetesResources != nil && o.KubernetesResources != nil {
		}
	}
	if !opts.Filter || o.NodeResources != nil {
		if m.NodeResources == nil && o.NodeResources != nil || m.NodeResources != nil && o.NodeResources == nil {
			return false
		} else if m.NodeResources != nil && o.NodeResources != nil {
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.ObjId != "" {
			if o.ObjId != m.ObjId {
				return false
			}
		}
	}
	if !opts.Filter || o.AppAnnotations != nil {
		if len(m.AppAnnotations) == 0 && len(o.AppAnnotations) > 0 || len(m.AppAnnotations) > 0 && len(o.AppAnnotations) == 0 {
			return false
		} else if m.AppAnnotations != nil && o.AppAnnotations != nil {
			if !opts.Filter && len(m.AppAnnotations) != len(o.AppAnnotations) {
				return false
			}
			for k, _ := range o.AppAnnotations {
				_, ok := m.AppAnnotations[k]
				if !ok {
					return false
				}
				if o.AppAnnotations[k] != m.AppAnnotations[k] {
					return false
				}
			}
		}
	}
	if !opts.Filter || o.IsStandalone != false {
		if o.IsStandalone != m.IsStandalone {
			return false
		}
	}
	if !opts.Filter || o.ManagesOwnNamespaces != false {
		if o.ManagesOwnNamespaces != m.ManagesOwnNamespaces {
			return false
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.CompatibilityVersion != 0 {
			if o.CompatibilityVersion != m.CompatibilityVersion {
				return false
			}
		}
	}
	if !opts.Filter || o.Username != "" {
		if o.Username != m.Username {
			return false
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.Credentials != "" {
			if o.Credentials != m.Credentials {
				return false
			}
		}
	}
	if !opts.Filter || o.Tags != nil {
		if len(m.Tags) == 0 && len(o.Tags) > 0 || len(m.Tags) > 0 && len(o.Tags) == 0 {
			return false
		} else if m.Tags != nil && o.Tags != nil {
			if !opts.Filter && len(m.Tags) != len(o.Tags) {
				return false
			}
			for k, _ := range o.Tags {
				_, ok := m.Tags[k]
				if !ok {
					return false
				}
				if o.Tags[k] != m.Tags[k] {
					return false
				}
			}
		}
	}
	return true
}

const AppFieldKey = "2"
const AppFieldKeyOrganization = "2.1"
const AppFieldKeyName = "2.2"
const AppFieldKeyVersion = "2.3"
const AppFieldImagePath = "4"
const AppFieldImageType = "5"
const AppFieldAccessPorts = "7"
const AppFieldDefaultFlavor = "9"
const AppFieldDefaultFlavorName = "9.1"
const AppFieldAuthPublicKey = "12"
const AppFieldCommand = "13"
const AppFieldAnnotations = "14"
const AppFieldDeployment = "15"
const AppFieldDeploymentManifest = "16"
const AppFieldDeploymentGenerator = "17"
const AppFieldAndroidPackageName = "18"
const AppFieldDelOpt = "20"
const AppFieldConfigs = "21"
const AppFieldConfigsKind = "21.1"
const AppFieldConfigsConfig = "21.2"
const AppFieldScaleWithCluster = "22"
const AppFieldInternalPorts = "23"
const AppFieldRevision = "24"
const AppFieldOfficialFqdn = "25"
const AppFieldMd5Sum = "26"
const AppFieldAutoProvPolicy = "28"
const AppFieldAccessType = "29"
const AppFieldDeletePrepare = "31"
const AppFieldAutoProvPolicies = "32"
const AppFieldTemplateDelimiter = "33"
const AppFieldSkipHcPorts = "34"
const AppFieldCreatedAt = "35"
const AppFieldCreatedAtSeconds = "35.1"
const AppFieldCreatedAtNanos = "35.2"
const AppFieldUpdatedAt = "36"
const AppFieldUpdatedAtSeconds = "36.1"
const AppFieldUpdatedAtNanos = "36.2"
const AppFieldTrusted = "37"
const AppFieldRequiredOutboundConnections = "38"
const AppFieldRequiredOutboundConnectionsProtocol = "38.1"
const AppFieldRequiredOutboundConnectionsPortRangeMin = "38.2"
const AppFieldRequiredOutboundConnectionsPortRangeMax = "38.3"
const AppFieldRequiredOutboundConnectionsRemoteCidr = "38.4"
const AppFieldAllowServerless = "39"
const AppFieldServerlessConfig = "40"
const AppFieldServerlessConfigVcpus = "40.1"
const AppFieldServerlessConfigVcpusWhole = "40.1.1"
const AppFieldServerlessConfigVcpusNanos = "40.1.2"
const AppFieldServerlessConfigRam = "40.2"
const AppFieldServerlessConfigMinReplicas = "40.3"
const AppFieldServerlessConfigGpuConfig = "40.4"
const AppFieldServerlessConfigGpuConfigType = "40.4.1"
const AppFieldServerlessConfigGpuConfigModel = "40.4.2"
const AppFieldServerlessConfigGpuConfigNumGpu = "40.4.3"
const AppFieldServerlessConfigGpuConfigRam = "40.4.4"
const AppFieldVmAppOsType = "41"
const AppFieldAlertPolicies = "42"
const AppFieldQosSessionProfile = "43"
const AppFieldQosSessionDuration = "44"
const AppFieldGlobalId = "45"
const AppFieldCommandArgs = "46"
const AppFieldEnvVars = "47"
const AppFieldEnvVarsKey = "47.1"
const AppFieldEnvVarsValue = "47.2"
const AppFieldSecretEnvVars = "48"
const AppFieldSecretEnvVarsKey = "48.1"
const AppFieldSecretEnvVarsValue = "48.2"
const AppFieldUpdateListAction = "49"
const AppFieldKubernetesResources = "50"
const AppFieldKubernetesResourcesCpuPool = "50.1"
const AppFieldKubernetesResourcesCpuPoolTotalVcpus = "50.1.1"
const AppFieldKubernetesResourcesCpuPoolTotalVcpusWhole = "50.1.1.1"
const AppFieldKubernetesResourcesCpuPoolTotalVcpusNanos = "50.1.1.2"
const AppFieldKubernetesResourcesCpuPoolTotalMemory = "50.1.2"
const AppFieldKubernetesResourcesCpuPoolTotalDisk = "50.1.3"
const AppFieldKubernetesResourcesCpuPoolTotalOptRes = "50.1.4"
const AppFieldKubernetesResourcesCpuPoolTotalOptResKey = "50.1.4.1"
const AppFieldKubernetesResourcesCpuPoolTotalOptResValue = "50.1.4.2"
const AppFieldKubernetesResourcesCpuPoolTopology = "50.1.5"
const AppFieldKubernetesResourcesCpuPoolTopologyMinNodeVcpus = "50.1.5.1"
const AppFieldKubernetesResourcesCpuPoolTopologyMinNodeMemory = "50.1.5.2"
const AppFieldKubernetesResourcesCpuPoolTopologyMinNodeDisk = "50.1.5.3"
const AppFieldKubernetesResourcesCpuPoolTopologyMinNodeOptRes = "50.1.5.4"
const AppFieldKubernetesResourcesCpuPoolTopologyMinNodeOptResKey = "50.1.5.4.1"
const AppFieldKubernetesResourcesCpuPoolTopologyMinNodeOptResValue = "50.1.5.4.2"
const AppFieldKubernetesResourcesCpuPoolTopologyMinNumberOfNodes = "50.1.5.5"
const AppFieldKubernetesResourcesCpuPoolTopologyMinNodeGpus = "50.1.5.6"
const AppFieldKubernetesResourcesCpuPoolTopologyMinNodeGpusModelId = "50.1.5.6.1"
const AppFieldKubernetesResourcesCpuPoolTopologyMinNodeGpusCount = "50.1.5.6.2"
const AppFieldKubernetesResourcesCpuPoolTopologyMinNodeGpusVendor = "50.1.5.6.3"
const AppFieldKubernetesResourcesCpuPoolTopologyMinNodeGpusMemory = "50.1.5.6.4"
const AppFieldKubernetesResourcesCpuPoolTopologyMinNodeGpusInUse = "50.1.5.6.5"
const AppFieldKubernetesResourcesCpuPoolTotalGpus = "50.1.6"
const AppFieldKubernetesResourcesCpuPoolTotalGpusModelId = "50.1.6.1"
const AppFieldKubernetesResourcesCpuPoolTotalGpusCount = "50.1.6.2"
const AppFieldKubernetesResourcesCpuPoolTotalGpusVendor = "50.1.6.3"
const AppFieldKubernetesResourcesCpuPoolTotalGpusMemory = "50.1.6.4"
const AppFieldKubernetesResourcesCpuPoolTotalGpusInUse = "50.1.6.5"
const AppFieldKubernetesResourcesGpuPool = "50.2"
const AppFieldKubernetesResourcesGpuPoolTotalVcpus = "50.2.1"
const AppFieldKubernetesResourcesGpuPoolTotalVcpusWhole = "50.2.1.1"
const AppFieldKubernetesResourcesGpuPoolTotalVcpusNanos = "50.2.1.2"
const AppFieldKubernetesResourcesGpuPoolTotalMemory = "50.2.2"
const AppFieldKubernetesResourcesGpuPoolTotalDisk = "50.2.3"
const AppFieldKubernetesResourcesGpuPoolTotalOptRes = "50.2.4"
const AppFieldKubernetesResourcesGpuPoolTotalOptResKey = "50.2.4.1"
const AppFieldKubernetesResourcesGpuPoolTotalOptResValue = "50.2.4.2"
const AppFieldKubernetesResourcesGpuPoolTopology = "50.2.5"
const AppFieldKubernetesResourcesGpuPoolTopologyMinNodeVcpus = "50.2.5.1"
const AppFieldKubernetesResourcesGpuPoolTopologyMinNodeMemory = "50.2.5.2"
const AppFieldKubernetesResourcesGpuPoolTopologyMinNodeDisk = "50.2.5.3"
const AppFieldKubernetesResourcesGpuPoolTopologyMinNodeOptRes = "50.2.5.4"
const AppFieldKubernetesResourcesGpuPoolTopologyMinNodeOptResKey = "50.2.5.4.1"
const AppFieldKubernetesResourcesGpuPoolTopologyMinNodeOptResValue = "50.2.5.4.2"
const AppFieldKubernetesResourcesGpuPoolTopologyMinNumberOfNodes = "50.2.5.5"
const AppFieldKubernetesResourcesGpuPoolTopologyMinNodeGpus = "50.2.5.6"
const AppFieldKubernetesResourcesGpuPoolTopologyMinNodeGpusModelId = "50.2.5.6.1"
const AppFieldKubernetesResourcesGpuPoolTopologyMinNodeGpusCount = "50.2.5.6.2"
const AppFieldKubernetesResourcesGpuPoolTopologyMinNodeGpusVendor = "50.2.5.6.3"
const AppFieldKubernetesResourcesGpuPoolTopologyMinNodeGpusMemory = "50.2.5.6.4"
const AppFieldKubernetesResourcesGpuPoolTopologyMinNodeGpusInUse = "50.2.5.6.5"
const AppFieldKubernetesResourcesGpuPoolTotalGpus = "50.2.6"
const AppFieldKubernetesResourcesGpuPoolTotalGpusModelId = "50.2.6.1"
const AppFieldKubernetesResourcesGpuPoolTotalGpusCount = "50.2.6.2"
const AppFieldKubernetesResourcesGpuPoolTotalGpusVendor = "50.2.6.3"
const AppFieldKubernetesResourcesGpuPoolTotalGpusMemory = "50.2.6.4"
const AppFieldKubernetesResourcesGpuPoolTotalGpusInUse = "50.2.6.5"
const AppFieldKubernetesResourcesMinKubernetesVersion = "50.4"
const AppFieldNodeResources = "51"
const AppFieldNodeResourcesVcpus = "51.1"
const AppFieldNodeResourcesRam = "51.2"
const AppFieldNodeResourcesDisk = "51.3"
const AppFieldNodeResourcesOptResMap = "51.4"
const AppFieldNodeResourcesOptResMapKey = "51.4.1"
const AppFieldNodeResourcesOptResMapValue = "51.4.2"
const AppFieldNodeResourcesInfraNodeFlavor = "51.5"
const AppFieldNodeResourcesExternalVolumeSize = "51.6"
const AppFieldNodeResourcesGpus = "51.7"
const AppFieldNodeResourcesGpusModelId = "51.7.1"
const AppFieldNodeResourcesGpusCount = "51.7.2"
const AppFieldNodeResourcesGpusVendor = "51.7.3"
const AppFieldNodeResourcesGpusMemory = "51.7.4"
const AppFieldNodeResourcesGpusInUse = "51.7.5"
const AppFieldObjId = "52"
const AppFieldAppAnnotations = "53"
const AppFieldAppAnnotationsKey = "53.1"
const AppFieldAppAnnotationsValue = "53.2"
const AppFieldIsStandalone = "54"
const AppFieldManagesOwnNamespaces = "55"
const AppFieldCompatibilityVersion = "56"
const AppFieldUsername = "57"
const AppFieldCredentials = "58"
const AppFieldTags = "100"
const AppFieldTagsKey = "100.1"
const AppFieldTagsValue = "100.2"

var AppAllFields = []string{
	AppFieldKeyOrganization,
	AppFieldKeyName,
	AppFieldKeyVersion,
	AppFieldImagePath,
	AppFieldImageType,
	AppFieldAccessPorts,
	AppFieldDefaultFlavorName,
	AppFieldAuthPublicKey,
	AppFieldCommand,
	AppFieldAnnotations,
	AppFieldDeployment,
	AppFieldDeploymentManifest,
	AppFieldDeploymentGenerator,
	AppFieldAndroidPackageName,
	AppFieldDelOpt,
	AppFieldConfigsKind,
	AppFieldConfigsConfig,
	AppFieldScaleWithCluster,
	AppFieldInternalPorts,
	AppFieldRevision,
	AppFieldOfficialFqdn,
	AppFieldMd5Sum,
	AppFieldAutoProvPolicy,
	AppFieldAccessType,
	AppFieldDeletePrepare,
	AppFieldAutoProvPolicies,
	AppFieldTemplateDelimiter,
	AppFieldSkipHcPorts,
	AppFieldCreatedAtSeconds,
	AppFieldCreatedAtNanos,
	AppFieldUpdatedAtSeconds,
	AppFieldUpdatedAtNanos,
	AppFieldTrusted,
	AppFieldRequiredOutboundConnectionsProtocol,
	AppFieldRequiredOutboundConnectionsPortRangeMin,
	AppFieldRequiredOutboundConnectionsPortRangeMax,
	AppFieldRequiredOutboundConnectionsRemoteCidr,
	AppFieldAllowServerless,
	AppFieldServerlessConfigVcpusWhole,
	AppFieldServerlessConfigVcpusNanos,
	AppFieldServerlessConfigRam,
	AppFieldServerlessConfigMinReplicas,
	AppFieldServerlessConfigGpuConfigType,
	AppFieldServerlessConfigGpuConfigModel,
	AppFieldServerlessConfigGpuConfigNumGpu,
	AppFieldServerlessConfigGpuConfigRam,
	AppFieldVmAppOsType,
	AppFieldAlertPolicies,
	AppFieldQosSessionProfile,
	AppFieldQosSessionDuration,
	AppFieldGlobalId,
	AppFieldCommandArgs,
	AppFieldEnvVarsKey,
	AppFieldEnvVarsValue,
	AppFieldSecretEnvVarsKey,
	AppFieldSecretEnvVarsValue,
	AppFieldUpdateListAction,
	AppFieldKubernetesResourcesCpuPoolTotalVcpusWhole,
	AppFieldKubernetesResourcesCpuPoolTotalVcpusNanos,
	AppFieldKubernetesResourcesCpuPoolTotalMemory,
	AppFieldKubernetesResourcesCpuPoolTotalDisk,
	AppFieldKubernetesResourcesCpuPoolTotalOptResKey,
	AppFieldKubernetesResourcesCpuPoolTotalOptResValue,
	AppFieldKubernetesResourcesCpuPoolTopologyMinNodeVcpus,
	AppFieldKubernetesResourcesCpuPoolTopologyMinNodeMemory,
	AppFieldKubernetesResourcesCpuPoolTopologyMinNodeDisk,
	AppFieldKubernetesResourcesCpuPoolTopologyMinNodeOptResKey,
	AppFieldKubernetesResourcesCpuPoolTopologyMinNodeOptResValue,
	AppFieldKubernetesResourcesCpuPoolTopologyMinNumberOfNodes,
	AppFieldKubernetesResourcesCpuPoolTopologyMinNodeGpusModelId,
	AppFieldKubernetesResourcesCpuPoolTopologyMinNodeGpusCount,
	AppFieldKubernetesResourcesCpuPoolTopologyMinNodeGpusVendor,
	AppFieldKubernetesResourcesCpuPoolTopologyMinNodeGpusMemory,
	AppFieldKubernetesResourcesCpuPoolTopologyMinNodeGpusInUse,
	AppFieldKubernetesResourcesCpuPoolTotalGpusModelId,
	AppFieldKubernetesResourcesCpuPoolTotalGpusCount,
	AppFieldKubernetesResourcesCpuPoolTotalGpusVendor,
	AppFieldKubernetesResourcesCpuPoolTotalGpusMemory,
	AppFieldKubernetesResourcesCpuPoolTotalGpusInUse,
	AppFieldKubernetesResourcesGpuPoolTotalVcpusWhole,
	AppFieldKubernetesResourcesGpuPoolTotalVcpusNanos,
	AppFieldKubernetesResourcesGpuPoolTotalMemory,
	AppFieldKubernetesResourcesGpuPoolTotalDisk,
	AppFieldKubernetesResourcesGpuPoolTotalOptResKey,
	AppFieldKubernetesResourcesGpuPoolTotalOptResValue,
	AppFieldKubernetesResourcesGpuPoolTopologyMinNodeVcpus,
	AppFieldKubernetesResourcesGpuPoolTopologyMinNodeMemory,
	AppFieldKubernetesResourcesGpuPoolTopologyMinNodeDisk,
	AppFieldKubernetesResourcesGpuPoolTopologyMinNodeOptResKey,
	AppFieldKubernetesResourcesGpuPoolTopologyMinNodeOptResValue,
	AppFieldKubernetesResourcesGpuPoolTopologyMinNumberOfNodes,
	AppFieldKubernetesResourcesGpuPoolTopologyMinNodeGpusModelId,
	AppFieldKubernetesResourcesGpuPoolTopologyMinNodeGpusCount,
	AppFieldKubernetesResourcesGpuPoolTopologyMinNodeGpusVendor,
	AppFieldKubernetesResourcesGpuPoolTopologyMinNodeGpusMemory,
	AppFieldKubernetesResourcesGpuPoolTopologyMinNodeGpusInUse,
	AppFieldKubernetesResourcesGpuPoolTotalGpusModelId,
	AppFieldKubernetesResourcesGpuPoolTotalGpusCount,
	AppFieldKubernetesResourcesGpuPoolTotalGpusVendor,
	AppFieldKubernetesResourcesGpuPoolTotalGpusMemory,
	AppFieldKubernetesResourcesGpuPoolTotalGpusInUse,
	AppFieldKubernetesResourcesMinKubernetesVersion,
	AppFieldNodeResourcesVcpus,
	AppFieldNodeResourcesRam,
	AppFieldNodeResourcesDisk,
	AppFieldNodeResourcesOptResMapKey,
	AppFieldNodeResourcesOptResMapValue,
	AppFieldNodeResourcesInfraNodeFlavor,
	AppFieldNodeResourcesExternalVolumeSize,
	AppFieldNodeResourcesGpusModelId,
	AppFieldNodeResourcesGpusCount,
	AppFieldNodeResourcesGpusVendor,
	AppFieldNodeResourcesGpusMemory,
	AppFieldNodeResourcesGpusInUse,
	AppFieldObjId,
	AppFieldAppAnnotationsKey,
	AppFieldAppAnnotationsValue,
	AppFieldIsStandalone,
	AppFieldManagesOwnNamespaces,
	AppFieldCompatibilityVersion,
	AppFieldUsername,
	AppFieldCredentials,
	AppFieldTagsKey,
	AppFieldTagsValue,
}

var AppAllFieldsMap = NewFieldMap(map[string]struct{}{
	AppFieldKeyOrganization:                                      struct{}{},
	AppFieldKeyName:                                              struct{}{},
	AppFieldKeyVersion:                                           struct{}{},
	AppFieldImagePath:                                            struct{}{},
	AppFieldImageType:                                            struct{}{},
	AppFieldAccessPorts:                                          struct{}{},
	AppFieldDefaultFlavorName:                                    struct{}{},
	AppFieldAuthPublicKey:                                        struct{}{},
	AppFieldCommand:                                              struct{}{},
	AppFieldAnnotations:                                          struct{}{},
	AppFieldDeployment:                                           struct{}{},
	AppFieldDeploymentManifest:                                   struct{}{},
	AppFieldDeploymentGenerator:                                  struct{}{},
	AppFieldAndroidPackageName:                                   struct{}{},
	AppFieldDelOpt:                                               struct{}{},
	AppFieldConfigsKind:                                          struct{}{},
	AppFieldConfigsConfig:                                        struct{}{},
	AppFieldScaleWithCluster:                                     struct{}{},
	AppFieldInternalPorts:                                        struct{}{},
	AppFieldRevision:                                             struct{}{},
	AppFieldOfficialFqdn:                                         struct{}{},
	AppFieldMd5Sum:                                               struct{}{},
	AppFieldAutoProvPolicy:                                       struct{}{},
	AppFieldAccessType:                                           struct{}{},
	AppFieldDeletePrepare:                                        struct{}{},
	AppFieldAutoProvPolicies:                                     struct{}{},
	AppFieldTemplateDelimiter:                                    struct{}{},
	AppFieldSkipHcPorts:                                          struct{}{},
	AppFieldCreatedAtSeconds:                                     struct{}{},
	AppFieldCreatedAtNanos:                                       struct{}{},
	AppFieldUpdatedAtSeconds:                                     struct{}{},
	AppFieldUpdatedAtNanos:                                       struct{}{},
	AppFieldTrusted:                                              struct{}{},
	AppFieldRequiredOutboundConnectionsProtocol:                  struct{}{},
	AppFieldRequiredOutboundConnectionsPortRangeMin:              struct{}{},
	AppFieldRequiredOutboundConnectionsPortRangeMax:              struct{}{},
	AppFieldRequiredOutboundConnectionsRemoteCidr:                struct{}{},
	AppFieldAllowServerless:                                      struct{}{},
	AppFieldServerlessConfigVcpusWhole:                           struct{}{},
	AppFieldServerlessConfigVcpusNanos:                           struct{}{},
	AppFieldServerlessConfigRam:                                  struct{}{},
	AppFieldServerlessConfigMinReplicas:                          struct{}{},
	AppFieldServerlessConfigGpuConfigType:                        struct{}{},
	AppFieldServerlessConfigGpuConfigModel:                       struct{}{},
	AppFieldServerlessConfigGpuConfigNumGpu:                      struct{}{},
	AppFieldServerlessConfigGpuConfigRam:                         struct{}{},
	AppFieldVmAppOsType:                                          struct{}{},
	AppFieldAlertPolicies:                                        struct{}{},
	AppFieldQosSessionProfile:                                    struct{}{},
	AppFieldQosSessionDuration:                                   struct{}{},
	AppFieldGlobalId:                                             struct{}{},
	AppFieldCommandArgs:                                          struct{}{},
	AppFieldEnvVarsKey:                                           struct{}{},
	AppFieldEnvVarsValue:                                         struct{}{},
	AppFieldSecretEnvVarsKey:                                     struct{}{},
	AppFieldSecretEnvVarsValue:                                   struct{}{},
	AppFieldUpdateListAction:                                     struct{}{},
	AppFieldKubernetesResourcesCpuPoolTotalVcpusWhole:            struct{}{},
	AppFieldKubernetesResourcesCpuPoolTotalVcpusNanos:            struct{}{},
	AppFieldKubernetesResourcesCpuPoolTotalMemory:                struct{}{},
	AppFieldKubernetesResourcesCpuPoolTotalDisk:                  struct{}{},
	AppFieldKubernetesResourcesCpuPoolTotalOptResKey:             struct{}{},
	AppFieldKubernetesResourcesCpuPoolTotalOptResValue:           struct{}{},
	AppFieldKubernetesResourcesCpuPoolTopologyMinNodeVcpus:       struct{}{},
	AppFieldKubernetesResourcesCpuPoolTopologyMinNodeMemory:      struct{}{},
	AppFieldKubernetesResourcesCpuPoolTopologyMinNodeDisk:        struct{}{},
	AppFieldKubernetesResourcesCpuPoolTopologyMinNodeOptResKey:   struct{}{},
	AppFieldKubernetesResourcesCpuPoolTopologyMinNodeOptResValue: struct{}{},
	AppFieldKubernetesResourcesCpuPoolTopologyMinNumberOfNodes:   struct{}{},
	AppFieldKubernetesResourcesCpuPoolTopologyMinNodeGpusModelId: struct{}{},
	AppFieldKubernetesResourcesCpuPoolTopologyMinNodeGpusCount:   struct{}{},
	AppFieldKubernetesResourcesCpuPoolTopologyMinNodeGpusVendor:  struct{}{},
	AppFieldKubernetesResourcesCpuPoolTopologyMinNodeGpusMemory:  struct{}{},
	AppFieldKubernetesResourcesCpuPoolTopologyMinNodeGpusInUse:   struct{}{},
	AppFieldKubernetesResourcesCpuPoolTotalGpusModelId:           struct{}{},
	AppFieldKubernetesResourcesCpuPoolTotalGpusCount:             struct{}{},
	AppFieldKubernetesResourcesCpuPoolTotalGpusVendor:            struct{}{},
	AppFieldKubernetesResourcesCpuPoolTotalGpusMemory:            struct{}{},
	AppFieldKubernetesResourcesCpuPoolTotalGpusInUse:             struct{}{},
	AppFieldKubernetesResourcesGpuPoolTotalVcpusWhole:            struct{}{},
	AppFieldKubernetesResourcesGpuPoolTotalVcpusNanos:            struct{}{},
	AppFieldKubernetesResourcesGpuPoolTotalMemory:                struct{}{},
	AppFieldKubernetesResourcesGpuPoolTotalDisk:                  struct{}{},
	AppFieldKubernetesResourcesGpuPoolTotalOptResKey:             struct{}{},
	AppFieldKubernetesResourcesGpuPoolTotalOptResValue:           struct{}{},
	AppFieldKubernetesResourcesGpuPoolTopologyMinNodeVcpus:       struct{}{},
	AppFieldKubernetesResourcesGpuPoolTopologyMinNodeMemory:      struct{}{},
	AppFieldKubernetesResourcesGpuPoolTopologyMinNodeDisk:        struct{}{},
	AppFieldKubernetesResourcesGpuPoolTopologyMinNodeOptResKey:   struct{}{},
	AppFieldKubernetesResourcesGpuPoolTopologyMinNodeOptResValue: struct{}{},
	AppFieldKubernetesResourcesGpuPoolTopologyMinNumberOfNodes:   struct{}{},
	AppFieldKubernetesResourcesGpuPoolTopologyMinNodeGpusModelId: struct{}{},
	AppFieldKubernetesResourcesGpuPoolTopologyMinNodeGpusCount:   struct{}{},
	AppFieldKubernetesResourcesGpuPoolTopologyMinNodeGpusVendor:  struct{}{},
	AppFieldKubernetesResourcesGpuPoolTopologyMinNodeGpusMemory:  struct{}{},
	AppFieldKubernetesResourcesGpuPoolTopologyMinNodeGpusInUse:   struct{}{},
	AppFieldKubernetesResourcesGpuPoolTotalGpusModelId:           struct{}{},
	AppFieldKubernetesResourcesGpuPoolTotalGpusCount:             struct{}{},
	AppFieldKubernetesResourcesGpuPoolTotalGpusVendor:            struct{}{},
	AppFieldKubernetesResourcesGpuPoolTotalGpusMemory:            struct{}{},
	AppFieldKubernetesResourcesGpuPoolTotalGpusInUse:             struct{}{},
	AppFieldKubernetesResourcesMinKubernetesVersion:              struct{}{},
	AppFieldNodeResourcesVcpus:                                   struct{}{},
	AppFieldNodeResourcesRam:                                     struct{}{},
	AppFieldNodeResourcesDisk:                                    struct{}{},
	AppFieldNodeResourcesOptResMapKey:                            struct{}{},
	AppFieldNodeResourcesOptResMapValue:                          struct{}{},
	AppFieldNodeResourcesInfraNodeFlavor:                         struct{}{},
	AppFieldNodeResourcesExternalVolumeSize:                      struct{}{},
	AppFieldNodeResourcesGpusModelId:                             struct{}{},
	AppFieldNodeResourcesGpusCount:                               struct{}{},
	AppFieldNodeResourcesGpusVendor:                              struct{}{},
	AppFieldNodeResourcesGpusMemory:                              struct{}{},
	AppFieldNodeResourcesGpusInUse:                               struct{}{},
	AppFieldObjId:                                                struct{}{},
	AppFieldAppAnnotationsKey:                                    struct{}{},
	AppFieldAppAnnotationsValue:                                  struct{}{},
	AppFieldIsStandalone:                                         struct{}{},
	AppFieldManagesOwnNamespaces:                                 struct{}{},
	AppFieldCompatibilityVersion:                                 struct{}{},
	AppFieldUsername:                                             struct{}{},
	AppFieldCredentials:                                          struct{}{},
	AppFieldTagsKey:                                              struct{}{},
	AppFieldTagsValue:                                            struct{}{},
})

var AppAllFieldsStringMap = map[string]string{
	AppFieldKeyOrganization:                                      "Key Organization",
	AppFieldKeyName:                                              "Key Name",
	AppFieldKeyVersion:                                           "Key Version",
	AppFieldImagePath:                                            "Image Path",
	AppFieldImageType:                                            "Image Type",
	AppFieldAccessPorts:                                          "Access Ports",
	AppFieldDefaultFlavorName:                                    "Default Flavor Name",
	AppFieldAuthPublicKey:                                        "Auth Public Key",
	AppFieldCommand:                                              "Command",
	AppFieldAnnotations:                                          "Annotations",
	AppFieldDeployment:                                           "Deployment",
	AppFieldDeploymentManifest:                                   "Deployment Manifest",
	AppFieldDeploymentGenerator:                                  "Deployment Generator",
	AppFieldAndroidPackageName:                                   "Android Package Name",
	AppFieldDelOpt:                                               "Del Opt",
	AppFieldConfigsKind:                                          "Configs Kind",
	AppFieldConfigsConfig:                                        "Configs Config",
	AppFieldScaleWithCluster:                                     "Scale With Cluster",
	AppFieldInternalPorts:                                        "Internal Ports",
	AppFieldRevision:                                             "Revision",
	AppFieldOfficialFqdn:                                         "Official Fqdn",
	AppFieldMd5Sum:                                               "Md5 Sum",
	AppFieldAutoProvPolicy:                                       "Auto Prov Policy",
	AppFieldAccessType:                                           "Access Type",
	AppFieldDeletePrepare:                                        "Delete Prepare",
	AppFieldAutoProvPolicies:                                     "Auto Prov Policies",
	AppFieldTemplateDelimiter:                                    "Template Delimiter",
	AppFieldSkipHcPorts:                                          "Skip Hc Ports",
	AppFieldCreatedAtSeconds:                                     "Created At Seconds",
	AppFieldCreatedAtNanos:                                       "Created At Nanos",
	AppFieldUpdatedAtSeconds:                                     "Updated At Seconds",
	AppFieldUpdatedAtNanos:                                       "Updated At Nanos",
	AppFieldTrusted:                                              "Trusted",
	AppFieldRequiredOutboundConnectionsProtocol:                  "Required Outbound Connections Protocol",
	AppFieldRequiredOutboundConnectionsPortRangeMin:              "Required Outbound Connections Port Range Min",
	AppFieldRequiredOutboundConnectionsPortRangeMax:              "Required Outbound Connections Port Range Max",
	AppFieldRequiredOutboundConnectionsRemoteCidr:                "Required Outbound Connections Remote Cidr",
	AppFieldAllowServerless:                                      "Allow Serverless",
	AppFieldServerlessConfigVcpusWhole:                           "Serverless Config Vcpus Whole",
	AppFieldServerlessConfigVcpusNanos:                           "Serverless Config Vcpus Nanos",
	AppFieldServerlessConfigRam:                                  "Serverless Config Ram",
	AppFieldServerlessConfigMinReplicas:                          "Serverless Config Min Replicas",
	AppFieldServerlessConfigGpuConfigType:                        "Serverless Config Gpu Config Type",
	AppFieldServerlessConfigGpuConfigModel:                       "Serverless Config Gpu Config Model",
	AppFieldServerlessConfigGpuConfigNumGpu:                      "Serverless Config Gpu Config Num Gpu",
	AppFieldServerlessConfigGpuConfigRam:                         "Serverless Config Gpu Config Ram",
	AppFieldVmAppOsType:                                          "Vm App Os Type",
	AppFieldAlertPolicies:                                        "Alert Policies",
	AppFieldQosSessionProfile:                                    "Qos Session Profile",
	AppFieldQosSessionDuration:                                   "Qos Session Duration",
	AppFieldGlobalId:                                             "Global Id",
	AppFieldCommandArgs:                                          "Command Args",
	AppFieldEnvVarsKey:                                           "Env Vars Key",
	AppFieldEnvVarsValue:                                         "Env Vars Value",
	AppFieldSecretEnvVarsKey:                                     "Secret Env Vars Key",
	AppFieldSecretEnvVarsValue:                                   "Secret Env Vars Value",
	AppFieldUpdateListAction:                                     "Update List Action",
	AppFieldKubernetesResourcesCpuPoolTotalVcpusWhole:            "Kubernetes Resources Cpu Pool Total Vcpus Whole",
	AppFieldKubernetesResourcesCpuPoolTotalVcpusNanos:            "Kubernetes Resources Cpu Pool Total Vcpus Nanos",
	AppFieldKubernetesResourcesCpuPoolTotalMemory:                "Kubernetes Resources Cpu Pool Total Memory",
	AppFieldKubernetesResourcesCpuPoolTotalDisk:                  "Kubernetes Resources Cpu Pool Total Disk",
	AppFieldKubernetesResourcesCpuPoolTotalOptResKey:             "Kubernetes Resources Cpu Pool Total Opt Res Key",
	AppFieldKubernetesResourcesCpuPoolTotalOptResValue:           "Kubernetes Resources Cpu Pool Total Opt Res Value",
	AppFieldKubernetesResourcesCpuPoolTopologyMinNodeVcpus:       "Kubernetes Resources Cpu Pool Topology Min Node Vcpus",
	AppFieldKubernetesResourcesCpuPoolTopologyMinNodeMemory:      "Kubernetes Resources Cpu Pool Topology Min Node Memory",
	AppFieldKubernetesResourcesCpuPoolTopologyMinNodeDisk:        "Kubernetes Resources Cpu Pool Topology Min Node Disk",
	AppFieldKubernetesResourcesCpuPoolTopologyMinNodeOptResKey:   "Kubernetes Resources Cpu Pool Topology Min Node Opt Res Key",
	AppFieldKubernetesResourcesCpuPoolTopologyMinNodeOptResValue: "Kubernetes Resources Cpu Pool Topology Min Node Opt Res Value",
	AppFieldKubernetesResourcesCpuPoolTopologyMinNumberOfNodes:   "Kubernetes Resources Cpu Pool Topology Min Number Of Nodes",
	AppFieldKubernetesResourcesCpuPoolTopologyMinNodeGpusModelId: "Kubernetes Resources Cpu Pool Topology Min Node Gpus Model Id",
	AppFieldKubernetesResourcesCpuPoolTopologyMinNodeGpusCount:   "Kubernetes Resources Cpu Pool Topology Min Node Gpus Count",
	AppFieldKubernetesResourcesCpuPoolTopologyMinNodeGpusVendor:  "Kubernetes Resources Cpu Pool Topology Min Node Gpus Vendor",
	AppFieldKubernetesResourcesCpuPoolTopologyMinNodeGpusMemory:  "Kubernetes Resources Cpu Pool Topology Min Node Gpus Memory",
	AppFieldKubernetesResourcesCpuPoolTopologyMinNodeGpusInUse:   "Kubernetes Resources Cpu Pool Topology Min Node Gpus In Use",
	AppFieldKubernetesResourcesCpuPoolTotalGpusModelId:           "Kubernetes Resources Cpu Pool Total Gpus Model Id",
	AppFieldKubernetesResourcesCpuPoolTotalGpusCount:             "Kubernetes Resources Cpu Pool Total Gpus Count",
	AppFieldKubernetesResourcesCpuPoolTotalGpusVendor:            "Kubernetes Resources Cpu Pool Total Gpus Vendor",
	AppFieldKubernetesResourcesCpuPoolTotalGpusMemory:            "Kubernetes Resources Cpu Pool Total Gpus Memory",
	AppFieldKubernetesResourcesCpuPoolTotalGpusInUse:             "Kubernetes Resources Cpu Pool Total Gpus In Use",
	AppFieldKubernetesResourcesGpuPoolTotalVcpusWhole:            "Kubernetes Resources Gpu Pool Total Vcpus Whole",
	AppFieldKubernetesResourcesGpuPoolTotalVcpusNanos:            "Kubernetes Resources Gpu Pool Total Vcpus Nanos",
	AppFieldKubernetesResourcesGpuPoolTotalMemory:                "Kubernetes Resources Gpu Pool Total Memory",
	AppFieldKubernetesResourcesGpuPoolTotalDisk:                  "Kubernetes Resources Gpu Pool Total Disk",
	AppFieldKubernetesResourcesGpuPoolTotalOptResKey:             "Kubernetes Resources Gpu Pool Total Opt Res Key",
	AppFieldKubernetesResourcesGpuPoolTotalOptResValue:           "Kubernetes Resources Gpu Pool Total Opt Res Value",
	AppFieldKubernetesResourcesGpuPoolTopologyMinNodeVcpus:       "Kubernetes Resources Gpu Pool Topology Min Node Vcpus",
	AppFieldKubernetesResourcesGpuPoolTopologyMinNodeMemory:      "Kubernetes Resources Gpu Pool Topology Min Node Memory",
	AppFieldKubernetesResourcesGpuPoolTopologyMinNodeDisk:        "Kubernetes Resources Gpu Pool Topology Min Node Disk",
	AppFieldKubernetesResourcesGpuPoolTopologyMinNodeOptResKey:   "Kubernetes Resources Gpu Pool Topology Min Node Opt Res Key",
	AppFieldKubernetesResourcesGpuPoolTopologyMinNodeOptResValue: "Kubernetes Resources Gpu Pool Topology Min Node Opt Res Value",
	AppFieldKubernetesResourcesGpuPoolTopologyMinNumberOfNodes:   "Kubernetes Resources Gpu Pool Topology Min Number Of Nodes",
	AppFieldKubernetesResourcesGpuPoolTopologyMinNodeGpusModelId: "Kubernetes Resources Gpu Pool Topology Min Node Gpus Model Id",
	AppFieldKubernetesResourcesGpuPoolTopologyMinNodeGpusCount:   "Kubernetes Resources Gpu Pool Topology Min Node Gpus Count",
	AppFieldKubernetesResourcesGpuPoolTopologyMinNodeGpusVendor:  "Kubernetes Resources Gpu Pool Topology Min Node Gpus Vendor",
	AppFieldKubernetesResourcesGpuPoolTopologyMinNodeGpusMemory:  "Kubernetes Resources Gpu Pool Topology Min Node Gpus Memory",
	AppFieldKubernetesResourcesGpuPoolTopologyMinNodeGpusInUse:   "Kubernetes Resources Gpu Pool Topology Min Node Gpus In Use",
	AppFieldKubernetesResourcesGpuPoolTotalGpusModelId:           "Kubernetes Resources Gpu Pool Total Gpus Model Id",
	AppFieldKubernetesResourcesGpuPoolTotalGpusCount:             "Kubernetes Resources Gpu Pool Total Gpus Count",
	AppFieldKubernetesResourcesGpuPoolTotalGpusVendor:            "Kubernetes Resources Gpu Pool Total Gpus Vendor",
	AppFieldKubernetesResourcesGpuPoolTotalGpusMemory:            "Kubernetes Resources Gpu Pool Total Gpus Memory",
	AppFieldKubernetesResourcesGpuPoolTotalGpusInUse:             "Kubernetes Resources Gpu Pool Total Gpus In Use",
	AppFieldKubernetesResourcesMinKubernetesVersion:              "Kubernetes Resources Min Kubernetes Version",
	AppFieldNodeResourcesVcpus:                                   "Node Resources Vcpus",
	AppFieldNodeResourcesRam:                                     "Node Resources Ram",
	AppFieldNodeResourcesDisk:                                    "Node Resources Disk",
	AppFieldNodeResourcesOptResMapKey:                            "Node Resources Opt Res Map Key",
	AppFieldNodeResourcesOptResMapValue:                          "Node Resources Opt Res Map Value",
	AppFieldNodeResourcesInfraNodeFlavor:                         "Node Resources Infra Node Flavor",
	AppFieldNodeResourcesExternalVolumeSize:                      "Node Resources External Volume Size",
	AppFieldNodeResourcesGpusModelId:                             "Node Resources Gpus Model Id",
	AppFieldNodeResourcesGpusCount:                               "Node Resources Gpus Count",
	AppFieldNodeResourcesGpusVendor:                              "Node Resources Gpus Vendor",
	AppFieldNodeResourcesGpusMemory:                              "Node Resources Gpus Memory",
	AppFieldNodeResourcesGpusInUse:                               "Node Resources Gpus In Use",
	AppFieldObjId:                                                "Obj Id",
	AppFieldAppAnnotationsKey:                                    "App Annotations Key",
	AppFieldAppAnnotationsValue:                                  "App Annotations Value",
	AppFieldIsStandalone:                                         "Is Standalone",
	AppFieldManagesOwnNamespaces:                                 "Manages Own Namespaces",
	AppFieldCompatibilityVersion:                                 "Compatibility Version",
	AppFieldUsername:                                             "Username",
	AppFieldCredentials:                                          "Credentials",
	AppFieldTagsKey:                                              "Tags Key",
	AppFieldTagsValue:                                            "Tags Value",
}

func (m *App) IsKeyField(s string) bool {
	return strings.HasPrefix(s, AppFieldKey+".") || s == AppFieldKey
}

func (m *App) DiffFields(o *App, fields *FieldMap) {
	if m.Key.Organization != o.Key.Organization {
		fields.Set(AppFieldKeyOrganization)
		fields.Set(AppFieldKey)
	}
	if m.Key.Name != o.Key.Name {
		fields.Set(AppFieldKeyName)
		fields.Set(AppFieldKey)
	}
	if m.Key.Version != o.Key.Version {
		fields.Set(AppFieldKeyVersion)
		fields.Set(AppFieldKey)
	}
	if m.ImagePath != o.ImagePath {
		fields.Set(AppFieldImagePath)
	}
	if m.ImageType != o.ImageType {
		fields.Set(AppFieldImageType)
	}
	if m.AccessPorts != o.AccessPorts {
		fields.Set(AppFieldAccessPorts)
	}
	if m.DefaultFlavor.Name != o.DefaultFlavor.Name {
		fields.Set(AppFieldDefaultFlavorName)
		fields.Set(AppFieldDefaultFlavor)
	}
	if m.AuthPublicKey != o.AuthPublicKey {
		fields.Set(AppFieldAuthPublicKey)
	}
	if m.Command != o.Command {
		fields.Set(AppFieldCommand)
	}
	if m.Annotations != o.Annotations {
		fields.Set(AppFieldAnnotations)
	}
	if m.Deployment != o.Deployment {
		fields.Set(AppFieldDeployment)
	}
	if m.DeploymentManifest != o.DeploymentManifest {
		fields.Set(AppFieldDeploymentManifest)
	}
	if m.DeploymentGenerator != o.DeploymentGenerator {
		fields.Set(AppFieldDeploymentGenerator)
	}
	if m.AndroidPackageName != o.AndroidPackageName {
		fields.Set(AppFieldAndroidPackageName)
	}
	if m.DelOpt != o.DelOpt {
		fields.Set(AppFieldDelOpt)
	}
	if m.Configs != nil && o.Configs != nil {
		if len(m.Configs) != len(o.Configs) {
			fields.Set(AppFieldConfigs)
		} else {
			for i0 := 0; i0 < len(m.Configs); i0++ {
				if m.Configs[i0].Kind != o.Configs[i0].Kind {
					fields.Set(AppFieldConfigsKind)
					fields.Set(AppFieldConfigs)
				}
				if m.Configs[i0].Config != o.Configs[i0].Config {
					fields.Set(AppFieldConfigsConfig)
					fields.Set(AppFieldConfigs)
				}
			}
		}
	} else if (m.Configs != nil && o.Configs == nil) || (m.Configs == nil && o.Configs != nil) {
		fields.Set(AppFieldConfigs)
	}
	if m.ScaleWithCluster != o.ScaleWithCluster {
		fields.Set(AppFieldScaleWithCluster)
	}
	if m.InternalPorts != o.InternalPorts {
		fields.Set(AppFieldInternalPorts)
	}
	if m.Revision != o.Revision {
		fields.Set(AppFieldRevision)
	}
	if m.OfficialFqdn != o.OfficialFqdn {
		fields.Set(AppFieldOfficialFqdn)
	}
	if m.Md5Sum != o.Md5Sum {
		fields.Set(AppFieldMd5Sum)
	}
	if m.AutoProvPolicy != o.AutoProvPolicy {
		fields.Set(AppFieldAutoProvPolicy)
	}
	if m.AccessType != o.AccessType {
		fields.Set(AppFieldAccessType)
	}
	if m.DeletePrepare != o.DeletePrepare {
		fields.Set(AppFieldDeletePrepare)
	}
	if len(m.AutoProvPolicies) != len(o.AutoProvPolicies) {
		fields.Set(AppFieldAutoProvPolicies)
	} else {
		for i0 := 0; i0 < len(m.AutoProvPolicies); i0++ {
			if m.AutoProvPolicies[i0] != o.AutoProvPolicies[i0] {
				fields.Set(AppFieldAutoProvPolicies)
				break
			}
		}
	}
	if m.TemplateDelimiter != o.TemplateDelimiter {
		fields.Set(AppFieldTemplateDelimiter)
	}
	if m.SkipHcPorts != o.SkipHcPorts {
		fields.Set(AppFieldSkipHcPorts)
	}
	if m.CreatedAt.Seconds != o.CreatedAt.Seconds {
		fields.Set(AppFieldCreatedAtSeconds)
		fields.Set(AppFieldCreatedAt)
	}
	if m.CreatedAt.Nanos != o.CreatedAt.Nanos {
		fields.Set(AppFieldCreatedAtNanos)
		fields.Set(AppFieldCreatedAt)
	}
	if m.UpdatedAt.Seconds != o.UpdatedAt.Seconds {
		fields.Set(AppFieldUpdatedAtSeconds)
		fields.Set(AppFieldUpdatedAt)
	}
	if m.UpdatedAt.Nanos != o.UpdatedAt.Nanos {
		fields.Set(AppFieldUpdatedAtNanos)
		fields.Set(AppFieldUpdatedAt)
	}
	if m.Trusted != o.Trusted {
		fields.Set(AppFieldTrusted)
	}
	if len(m.RequiredOutboundConnections) != len(o.RequiredOutboundConnections) {
		fields.Set(AppFieldRequiredOutboundConnections)
	} else {
		for i0 := 0; i0 < len(m.RequiredOutboundConnections); i0++ {
			if m.RequiredOutboundConnections[i0].Protocol != o.RequiredOutboundConnections[i0].Protocol {
				fields.Set(AppFieldRequiredOutboundConnectionsProtocol)
				fields.Set(AppFieldRequiredOutboundConnections)
			}
			if m.RequiredOutboundConnections[i0].PortRangeMin != o.RequiredOutboundConnections[i0].PortRangeMin {
				fields.Set(AppFieldRequiredOutboundConnectionsPortRangeMin)
				fields.Set(AppFieldRequiredOutboundConnections)
			}
			if m.RequiredOutboundConnections[i0].PortRangeMax != o.RequiredOutboundConnections[i0].PortRangeMax {
				fields.Set(AppFieldRequiredOutboundConnectionsPortRangeMax)
				fields.Set(AppFieldRequiredOutboundConnections)
			}
			if m.RequiredOutboundConnections[i0].RemoteCidr != o.RequiredOutboundConnections[i0].RemoteCidr {
				fields.Set(AppFieldRequiredOutboundConnectionsRemoteCidr)
				fields.Set(AppFieldRequiredOutboundConnections)
			}
		}
	}
	if m.AllowServerless != o.AllowServerless {
		fields.Set(AppFieldAllowServerless)
	}
	if m.ServerlessConfig != nil && o.ServerlessConfig != nil {
		if m.ServerlessConfig.Vcpus.Whole != o.ServerlessConfig.Vcpus.Whole {
			fields.Set(AppFieldServerlessConfigVcpusWhole)
			fields.Set(AppFieldServerlessConfigVcpus)
			fields.Set(AppFieldServerlessConfig)
		}
		if m.ServerlessConfig.Vcpus.Nanos != o.ServerlessConfig.Vcpus.Nanos {
			fields.Set(AppFieldServerlessConfigVcpusNanos)
			fields.Set(AppFieldServerlessConfigVcpus)
			fields.Set(AppFieldServerlessConfig)
		}
		if m.ServerlessConfig.Ram != o.ServerlessConfig.Ram {
			fields.Set(AppFieldServerlessConfigRam)
			fields.Set(AppFieldServerlessConfig)
		}
		if m.ServerlessConfig.MinReplicas != o.ServerlessConfig.MinReplicas {
			fields.Set(AppFieldServerlessConfigMinReplicas)
			fields.Set(AppFieldServerlessConfig)
		}
		if m.ServerlessConfig.GpuConfig.Type != o.ServerlessConfig.GpuConfig.Type {
			fields.Set(AppFieldServerlessConfigGpuConfigType)
			fields.Set(AppFieldServerlessConfigGpuConfig)
			fields.Set(AppFieldServerlessConfig)
		}
		if m.ServerlessConfig.GpuConfig.Model != o.ServerlessConfig.GpuConfig.Model {
			fields.Set(AppFieldServerlessConfigGpuConfigModel)
			fields.Set(AppFieldServerlessConfigGpuConfig)
			fields.Set(AppFieldServerlessConfig)
		}
		if m.ServerlessConfig.GpuConfig.NumGpu != o.ServerlessConfig.GpuConfig.NumGpu {
			fields.Set(AppFieldServerlessConfigGpuConfigNumGpu)
			fields.Set(AppFieldServerlessConfigGpuConfig)
			fields.Set(AppFieldServerlessConfig)
		}
		if m.ServerlessConfig.GpuConfig.Ram != o.ServerlessConfig.GpuConfig.Ram {
			fields.Set(AppFieldServerlessConfigGpuConfigRam)
			fields.Set(AppFieldServerlessConfigGpuConfig)
			fields.Set(AppFieldServerlessConfig)
		}
	} else if (m.ServerlessConfig != nil && o.ServerlessConfig == nil) || (m.ServerlessConfig == nil && o.ServerlessConfig != nil) {
		fields.Set(AppFieldServerlessConfig)
	}
	if m.VmAppOsType != o.VmAppOsType {
		fields.Set(AppFieldVmAppOsType)
	}
	if len(m.AlertPolicies) != len(o.AlertPolicies) {
		fields.Set(AppFieldAlertPolicies)
	} else {
		for i0 := 0; i0 < len(m.AlertPolicies); i0++ {
			if m.AlertPolicies[i0] != o.AlertPolicies[i0] {
				fields.Set(AppFieldAlertPolicies)
				break
			}
		}
	}
	if m.QosSessionProfile != o.QosSessionProfile {
		fields.Set(AppFieldQosSessionProfile)
	}
	if m.QosSessionDuration != o.QosSessionDuration {
		fields.Set(AppFieldQosSessionDuration)
	}
	if m.GlobalId != o.GlobalId {
		fields.Set(AppFieldGlobalId)
	}
	if len(m.CommandArgs) != len(o.CommandArgs) {
		fields.Set(AppFieldCommandArgs)
	} else {
		for i0 := 0; i0 < len(m.CommandArgs); i0++ {
			if m.CommandArgs[i0] != o.CommandArgs[i0] {
				fields.Set(AppFieldCommandArgs)
				break
			}
		}
	}
	if m.EnvVars != nil && o.EnvVars != nil {
		if len(m.EnvVars) != len(o.EnvVars) {
			fields.Set(AppFieldEnvVars)
		} else {
			for k0, _ := range m.EnvVars {
				_, vok0 := o.EnvVars[k0]
				if !vok0 {
					fields.Set(AppFieldEnvVars)
				} else {
					if m.EnvVars[k0] != o.EnvVars[k0] {
						fields.Set(AppFieldEnvVars)
						break
					}
				}
			}
		}
	} else if (m.EnvVars != nil && o.EnvVars == nil) || (m.EnvVars == nil && o.EnvVars != nil) {
		fields.Set(AppFieldEnvVars)
	}
	if m.SecretEnvVars != nil && o.SecretEnvVars != nil {
		if len(m.SecretEnvVars) != len(o.SecretEnvVars) {
			fields.Set(AppFieldSecretEnvVars)
		} else {
			for k0, _ := range m.SecretEnvVars {
				_, vok0 := o.SecretEnvVars[k0]
				if !vok0 {
					fields.Set(AppFieldSecretEnvVars)
				} else {
					if m.SecretEnvVars[k0] != o.SecretEnvVars[k0] {
						fields.Set(AppFieldSecretEnvVars)
						break
					}
				}
			}
		}
	} else if (m.SecretEnvVars != nil && o.SecretEnvVars == nil) || (m.SecretEnvVars == nil && o.SecretEnvVars != nil) {
		fields.Set(AppFieldSecretEnvVars)
	}
	if m.UpdateListAction != o.UpdateListAction {
		fields.Set(AppFieldUpdateListAction)
	}
	if m.KubernetesResources != nil && o.KubernetesResources != nil {
		if m.KubernetesResources.CpuPool != nil && o.KubernetesResources.CpuPool != nil {
			if m.KubernetesResources.CpuPool.TotalVcpus.Whole != o.KubernetesResources.CpuPool.TotalVcpus.Whole {
				fields.Set(AppFieldKubernetesResourcesCpuPoolTotalVcpusWhole)
				fields.Set(AppFieldKubernetesResourcesCpuPoolTotalVcpus)
				fields.Set(AppFieldKubernetesResourcesCpuPool)
				fields.Set(AppFieldKubernetesResources)
			}
			if m.KubernetesResources.CpuPool.TotalVcpus.Nanos != o.KubernetesResources.CpuPool.TotalVcpus.Nanos {
				fields.Set(AppFieldKubernetesResourcesCpuPoolTotalVcpusNanos)
				fields.Set(AppFieldKubernetesResourcesCpuPoolTotalVcpus)
				fields.Set(AppFieldKubernetesResourcesCpuPool)
				fields.Set(AppFieldKubernetesResources)
			}
			if m.KubernetesResources.CpuPool.TotalMemory != o.KubernetesResources.CpuPool.TotalMemory {
				fields.Set(AppFieldKubernetesResourcesCpuPoolTotalMemory)
				fields.Set(AppFieldKubernetesResourcesCpuPool)
				fields.Set(AppFieldKubernetesResources)
			}
			if m.KubernetesResources.CpuPool.TotalDisk != o.KubernetesResources.CpuPool.TotalDisk {
				fields.Set(AppFieldKubernetesResourcesCpuPoolTotalDisk)
				fields.Set(AppFieldKubernetesResourcesCpuPool)
				fields.Set(AppFieldKubernetesResources)
			}
			if m.KubernetesResources.CpuPool.TotalOptRes != nil && o.KubernetesResources.CpuPool.TotalOptRes != nil {
				if len(m.KubernetesResources.CpuPool.TotalOptRes) != len(o.KubernetesResources.CpuPool.TotalOptRes) {
					fields.Set(AppFieldKubernetesResourcesCpuPoolTotalOptRes)
					fields.Set(AppFieldKubernetesResourcesCpuPool)
					fields.Set(AppFieldKubernetesResources)
				} else {
					for k2, _ := range m.KubernetesResources.CpuPool.TotalOptRes {
						_, vok2 := o.KubernetesResources.CpuPool.TotalOptRes[k2]
						if !vok2 {
							fields.Set(AppFieldKubernetesResourcesCpuPoolTotalOptRes)
							fields.Set(AppFieldKubernetesResourcesCpuPool)
							fields.Set(AppFieldKubernetesResources)
						} else {
							if m.KubernetesResources.CpuPool.TotalOptRes[k2] != o.KubernetesResources.CpuPool.TotalOptRes[k2] {
								fields.Set(AppFieldKubernetesResourcesCpuPoolTotalOptRes)
								fields.Set(AppFieldKubernetesResourcesCpuPool)
								fields.Set(AppFieldKubernetesResources)
								break
							}
						}
					}
				}
			} else if (m.KubernetesResources.CpuPool.TotalOptRes != nil && o.KubernetesResources.CpuPool.TotalOptRes == nil) || (m.KubernetesResources.CpuPool.TotalOptRes == nil && o.KubernetesResources.CpuPool.TotalOptRes != nil) {
				fields.Set(AppFieldKubernetesResourcesCpuPoolTotalOptRes)
				fields.Set(AppFieldKubernetesResourcesCpuPool)
				fields.Set(AppFieldKubernetesResources)
			}
			if m.KubernetesResources.CpuPool.Topology.MinNodeVcpus != o.KubernetesResources.CpuPool.Topology.MinNodeVcpus {
				fields.Set(AppFieldKubernetesResourcesCpuPoolTopologyMinNodeVcpus)
				fields.Set(AppFieldKubernetesResourcesCpuPoolTopology)
				fields.Set(AppFieldKubernetesResourcesCpuPool)
				fields.Set(AppFieldKubernetesResources)
			}
			if m.KubernetesResources.CpuPool.Topology.MinNodeMemory != o.KubernetesResources.CpuPool.Topology.MinNodeMemory {
				fields.Set(AppFieldKubernetesResourcesCpuPoolTopologyMinNodeMemory)
				fields.Set(AppFieldKubernetesResourcesCpuPoolTopology)
				fields.Set(AppFieldKubernetesResourcesCpuPool)
				fields.Set(AppFieldKubernetesResources)
			}
			if m.KubernetesResources.CpuPool.Topology.MinNodeDisk != o.KubernetesResources.CpuPool.Topology.MinNodeDisk {
				fields.Set(AppFieldKubernetesResourcesCpuPoolTopologyMinNodeDisk)
				fields.Set(AppFieldKubernetesResourcesCpuPoolTopology)
				fields.Set(AppFieldKubernetesResourcesCpuPool)
				fields.Set(AppFieldKubernetesResources)
			}
			if m.KubernetesResources.CpuPool.Topology.MinNodeOptRes != nil && o.KubernetesResources.CpuPool.Topology.MinNodeOptRes != nil {
				if len(m.KubernetesResources.CpuPool.Topology.MinNodeOptRes) != len(o.KubernetesResources.CpuPool.Topology.MinNodeOptRes) {
					fields.Set(AppFieldKubernetesResourcesCpuPoolTopologyMinNodeOptRes)
					fields.Set(AppFieldKubernetesResourcesCpuPoolTopology)
					fields.Set(AppFieldKubernetesResourcesCpuPool)
					fields.Set(AppFieldKubernetesResources)
				} else {
					for k3, _ := range m.KubernetesResources.CpuPool.Topology.MinNodeOptRes {
						_, vok3 := o.KubernetesResources.CpuPool.Topology.MinNodeOptRes[k3]
						if !vok3 {
							fields.Set(AppFieldKubernetesResourcesCpuPoolTopologyMinNodeOptRes)
							fields.Set(AppFieldKubernetesResourcesCpuPoolTopology)
							fields.Set(AppFieldKubernetesResourcesCpuPool)
							fields.Set(AppFieldKubernetesResources)
						} else {
							if m.KubernetesResources.CpuPool.Topology.MinNodeOptRes[k3] != o.KubernetesResources.CpuPool.Topology.MinNodeOptRes[k3] {
								fields.Set(AppFieldKubernetesResourcesCpuPoolTopologyMinNodeOptRes)
								fields.Set(AppFieldKubernetesResourcesCpuPoolTopology)
								fields.Set(AppFieldKubernetesResourcesCpuPool)
								fields.Set(AppFieldKubernetesResources)
								break
							}
						}
					}
				}
			} else if (m.KubernetesResources.CpuPool.Topology.MinNodeOptRes != nil && o.KubernetesResources.CpuPool.Topology.MinNodeOptRes == nil) || (m.KubernetesResources.CpuPool.Topology.MinNodeOptRes == nil && o.KubernetesResources.CpuPool.Topology.MinNodeOptRes != nil) {
				fields.Set(AppFieldKubernetesResourcesCpuPoolTopologyMinNodeOptRes)
				fields.Set(AppFieldKubernetesResourcesCpuPoolTopology)
				fields.Set(AppFieldKubernetesResourcesCpuPool)
				fields.Set(AppFieldKubernetesResources)
			}
			if m.KubernetesResources.CpuPool.Topology.MinNumberOfNodes != o.KubernetesResources.CpuPool.Topology.MinNumberOfNodes {
				fields.Set(AppFieldKubernetesResourcesCpuPoolTopologyMinNumberOfNodes)
				fields.Set(AppFieldKubernetesResourcesCpuPoolTopology)
				fields.Set(AppFieldKubernetesResourcesCpuPool)
				fields.Set(AppFieldKubernetesResources)
			}
			if m.KubernetesResources.CpuPool.Topology.MinNodeGpus != nil && o.KubernetesResources.CpuPool.Topology.MinNodeGpus != nil {
				if len(m.KubernetesResources.CpuPool.Topology.MinNodeGpus) != len(o.KubernetesResources.CpuPool.Topology.MinNodeGpus) {
					fields.Set(AppFieldKubernetesResourcesCpuPoolTopologyMinNodeGpus)
					fields.Set(AppFieldKubernetesResourcesCpuPoolTopology)
					fields.Set(AppFieldKubernetesResourcesCpuPool)
					fields.Set(AppFieldKubernetesResources)
				} else {
					for i3 := 0; i3 < len(m.KubernetesResources.CpuPool.Topology.MinNodeGpus); i3++ {
						if m.KubernetesResources.CpuPool.Topology.MinNodeGpus[i3].ModelId != o.KubernetesResources.CpuPool.Topology.MinNodeGpus[i3].ModelId {
							fields.Set(AppFieldKubernetesResourcesCpuPoolTopologyMinNodeGpusModelId)
							fields.Set(AppFieldKubernetesResourcesCpuPoolTopologyMinNodeGpus)
							fields.Set(AppFieldKubernetesResourcesCpuPoolTopology)
							fields.Set(AppFieldKubernetesResourcesCpuPool)
							fields.Set(AppFieldKubernetesResources)
						}
						if m.KubernetesResources.CpuPool.Topology.MinNodeGpus[i3].Count != o.KubernetesResources.CpuPool.Topology.MinNodeGpus[i3].Count {
							fields.Set(AppFieldKubernetesResourcesCpuPoolTopologyMinNodeGpusCount)
							fields.Set(AppFieldKubernetesResourcesCpuPoolTopologyMinNodeGpus)
							fields.Set(AppFieldKubernetesResourcesCpuPoolTopology)
							fields.Set(AppFieldKubernetesResourcesCpuPool)
							fields.Set(AppFieldKubernetesResources)
						}
						if m.KubernetesResources.CpuPool.Topology.MinNodeGpus[i3].Vendor != o.KubernetesResources.CpuPool.Topology.MinNodeGpus[i3].Vendor {
							fields.Set(AppFieldKubernetesResourcesCpuPoolTopologyMinNodeGpusVendor)
							fields.Set(AppFieldKubernetesResourcesCpuPoolTopologyMinNodeGpus)
							fields.Set(AppFieldKubernetesResourcesCpuPoolTopology)
							fields.Set(AppFieldKubernetesResourcesCpuPool)
							fields.Set(AppFieldKubernetesResources)
						}
						if m.KubernetesResources.CpuPool.Topology.MinNodeGpus[i3].Memory != o.KubernetesResources.CpuPool.Topology.MinNodeGpus[i3].Memory {
							fields.Set(AppFieldKubernetesResourcesCpuPoolTopologyMinNodeGpusMemory)
							fields.Set(AppFieldKubernetesResourcesCpuPoolTopologyMinNodeGpus)
							fields.Set(AppFieldKubernetesResourcesCpuPoolTopology)
							fields.Set(AppFieldKubernetesResourcesCpuPool)
							fields.Set(AppFieldKubernetesResources)
						}
						if m.KubernetesResources.CpuPool.Topology.MinNodeGpus[i3].InUse != o.KubernetesResources.CpuPool.Topology.MinNodeGpus[i3].InUse {
							fields.Set(AppFieldKubernetesResourcesCpuPoolTopologyMinNodeGpusInUse)
							fields.Set(AppFieldKubernetesResourcesCpuPoolTopologyMinNodeGpus)
							fields.Set(AppFieldKubernetesResourcesCpuPoolTopology)
							fields.Set(AppFieldKubernetesResourcesCpuPool)
							fields.Set(AppFieldKubernetesResources)
						}
					}
				}
			} else if (m.KubernetesResources.CpuPool.Topology.MinNodeGpus != nil && o.KubernetesResources.CpuPool.Topology.MinNodeGpus == nil) || (m.KubernetesResources.CpuPool.Topology.MinNodeGpus == nil && o.KubernetesResources.CpuPool.Topology.MinNodeGpus != nil) {
				fields.Set(AppFieldKubernetesResourcesCpuPoolTopologyMinNodeGpus)
				fields.Set(AppFieldKubernetesResourcesCpuPoolTopology)
				fields.Set(AppFieldKubernetesResourcesCpuPool)
				fields.Set(AppFieldKubernetesResources)
			}
			if m.KubernetesResources.CpuPool.TotalGpus != nil && o.KubernetesResources.CpuPool.TotalGpus != nil {
				if len(m.KubernetesResources.CpuPool.TotalGpus) != len(o.KubernetesResources.CpuPool.TotalGpus) {
					fields.Set(AppFieldKubernetesResourcesCpuPoolTotalGpus)
					fields.Set(AppFieldKubernetesResourcesCpuPool)
					fields.Set(AppFieldKubernetesResources)
				} else {
					for i2 := 0; i2 < len(m.KubernetesResources.CpuPool.TotalGpus); i2++ {
						if m.KubernetesResources.CpuPool.TotalGpus[i2].ModelId != o.KubernetesResources.CpuPool.TotalGpus[i2].ModelId {
							fields.Set(AppFieldKubernetesResourcesCpuPoolTotalGpusModelId)
							fields.Set(AppFieldKubernetesResourcesCpuPoolTotalGpus)
							fields.Set(AppFieldKubernetesResourcesCpuPool)
							fields.Set(AppFieldKubernetesResources)
						}
						if m.KubernetesResources.CpuPool.TotalGpus[i2].Count != o.KubernetesResources.CpuPool.TotalGpus[i2].Count {
							fields.Set(AppFieldKubernetesResourcesCpuPoolTotalGpusCount)
							fields.Set(AppFieldKubernetesResourcesCpuPoolTotalGpus)
							fields.Set(AppFieldKubernetesResourcesCpuPool)
							fields.Set(AppFieldKubernetesResources)
						}
						if m.KubernetesResources.CpuPool.TotalGpus[i2].Vendor != o.KubernetesResources.CpuPool.TotalGpus[i2].Vendor {
							fields.Set(AppFieldKubernetesResourcesCpuPoolTotalGpusVendor)
							fields.Set(AppFieldKubernetesResourcesCpuPoolTotalGpus)
							fields.Set(AppFieldKubernetesResourcesCpuPool)
							fields.Set(AppFieldKubernetesResources)
						}
						if m.KubernetesResources.CpuPool.TotalGpus[i2].Memory != o.KubernetesResources.CpuPool.TotalGpus[i2].Memory {
							fields.Set(AppFieldKubernetesResourcesCpuPoolTotalGpusMemory)
							fields.Set(AppFieldKubernetesResourcesCpuPoolTotalGpus)
							fields.Set(AppFieldKubernetesResourcesCpuPool)
							fields.Set(AppFieldKubernetesResources)
						}
						if m.KubernetesResources.CpuPool.TotalGpus[i2].InUse != o.KubernetesResources.CpuPool.TotalGpus[i2].InUse {
							fields.Set(AppFieldKubernetesResourcesCpuPoolTotalGpusInUse)
							fields.Set(AppFieldKubernetesResourcesCpuPoolTotalGpus)
							fields.Set(AppFieldKubernetesResourcesCpuPool)
							fields.Set(AppFieldKubernetesResources)
						}
					}
				}
			} else if (m.KubernetesResources.CpuPool.TotalGpus != nil && o.KubernetesResources.CpuPool.TotalGpus == nil) || (m.KubernetesResources.CpuPool.TotalGpus == nil && o.KubernetesResources.CpuPool.TotalGpus != nil) {
				fields.Set(AppFieldKubernetesResourcesCpuPoolTotalGpus)
				fields.Set(AppFieldKubernetesResourcesCpuPool)
				fields.Set(AppFieldKubernetesResources)
			}
		} else if (m.KubernetesResources.CpuPool != nil && o.KubernetesResources.CpuPool == nil) || (m.KubernetesResources.CpuPool == nil && o.KubernetesResources.CpuPool != nil) {
			fields.Set(AppFieldKubernetesResourcesCpuPool)
			fields.Set(AppFieldKubernetesResources)
		}
		if m.KubernetesResources.GpuPool != nil && o.KubernetesResources.GpuPool != nil {
			if m.KubernetesResources.GpuPool.TotalVcpus.Whole != o.KubernetesResources.GpuPool.TotalVcpus.Whole {
				fields.Set(AppFieldKubernetesResourcesGpuPoolTotalVcpusWhole)
				fields.Set(AppFieldKubernetesResourcesGpuPoolTotalVcpus)
				fields.Set(AppFieldKubernetesResourcesGpuPool)
				fields.Set(AppFieldKubernetesResources)
			}
			if m.KubernetesResources.GpuPool.TotalVcpus.Nanos != o.KubernetesResources.GpuPool.TotalVcpus.Nanos {
				fields.Set(AppFieldKubernetesResourcesGpuPoolTotalVcpusNanos)
				fields.Set(AppFieldKubernetesResourcesGpuPoolTotalVcpus)
				fields.Set(AppFieldKubernetesResourcesGpuPool)
				fields.Set(AppFieldKubernetesResources)
			}
			if m.KubernetesResources.GpuPool.TotalMemory != o.KubernetesResources.GpuPool.TotalMemory {
				fields.Set(AppFieldKubernetesResourcesGpuPoolTotalMemory)
				fields.Set(AppFieldKubernetesResourcesGpuPool)
				fields.Set(AppFieldKubernetesResources)
			}
			if m.KubernetesResources.GpuPool.TotalDisk != o.KubernetesResources.GpuPool.TotalDisk {
				fields.Set(AppFieldKubernetesResourcesGpuPoolTotalDisk)
				fields.Set(AppFieldKubernetesResourcesGpuPool)
				fields.Set(AppFieldKubernetesResources)
			}
			if m.KubernetesResources.GpuPool.TotalOptRes != nil && o.KubernetesResources.GpuPool.TotalOptRes != nil {
				if len(m.KubernetesResources.GpuPool.TotalOptRes) != len(o.KubernetesResources.GpuPool.TotalOptRes) {
					fields.Set(AppFieldKubernetesResourcesGpuPoolTotalOptRes)
					fields.Set(AppFieldKubernetesResourcesGpuPool)
					fields.Set(AppFieldKubernetesResources)
				} else {
					for k2, _ := range m.KubernetesResources.GpuPool.TotalOptRes {
						_, vok2 := o.KubernetesResources.GpuPool.TotalOptRes[k2]
						if !vok2 {
							fields.Set(AppFieldKubernetesResourcesGpuPoolTotalOptRes)
							fields.Set(AppFieldKubernetesResourcesGpuPool)
							fields.Set(AppFieldKubernetesResources)
						} else {
							if m.KubernetesResources.GpuPool.TotalOptRes[k2] != o.KubernetesResources.GpuPool.TotalOptRes[k2] {
								fields.Set(AppFieldKubernetesResourcesGpuPoolTotalOptRes)
								fields.Set(AppFieldKubernetesResourcesGpuPool)
								fields.Set(AppFieldKubernetesResources)
								break
							}
						}
					}
				}
			} else if (m.KubernetesResources.GpuPool.TotalOptRes != nil && o.KubernetesResources.GpuPool.TotalOptRes == nil) || (m.KubernetesResources.GpuPool.TotalOptRes == nil && o.KubernetesResources.GpuPool.TotalOptRes != nil) {
				fields.Set(AppFieldKubernetesResourcesGpuPoolTotalOptRes)
				fields.Set(AppFieldKubernetesResourcesGpuPool)
				fields.Set(AppFieldKubernetesResources)
			}
			if m.KubernetesResources.GpuPool.Topology.MinNodeVcpus != o.KubernetesResources.GpuPool.Topology.MinNodeVcpus {
				fields.Set(AppFieldKubernetesResourcesGpuPoolTopologyMinNodeVcpus)
				fields.Set(AppFieldKubernetesResourcesGpuPoolTopology)
				fields.Set(AppFieldKubernetesResourcesGpuPool)
				fields.Set(AppFieldKubernetesResources)
			}
			if m.KubernetesResources.GpuPool.Topology.MinNodeMemory != o.KubernetesResources.GpuPool.Topology.MinNodeMemory {
				fields.Set(AppFieldKubernetesResourcesGpuPoolTopologyMinNodeMemory)
				fields.Set(AppFieldKubernetesResourcesGpuPoolTopology)
				fields.Set(AppFieldKubernetesResourcesGpuPool)
				fields.Set(AppFieldKubernetesResources)
			}
			if m.KubernetesResources.GpuPool.Topology.MinNodeDisk != o.KubernetesResources.GpuPool.Topology.MinNodeDisk {
				fields.Set(AppFieldKubernetesResourcesGpuPoolTopologyMinNodeDisk)
				fields.Set(AppFieldKubernetesResourcesGpuPoolTopology)
				fields.Set(AppFieldKubernetesResourcesGpuPool)
				fields.Set(AppFieldKubernetesResources)
			}
			if m.KubernetesResources.GpuPool.Topology.MinNodeOptRes != nil && o.KubernetesResources.GpuPool.Topology.MinNodeOptRes != nil {
				if len(m.KubernetesResources.GpuPool.Topology.MinNodeOptRes) != len(o.KubernetesResources.GpuPool.Topology.MinNodeOptRes) {
					fields.Set(AppFieldKubernetesResourcesGpuPoolTopologyMinNodeOptRes)
					fields.Set(AppFieldKubernetesResourcesGpuPoolTopology)
					fields.Set(AppFieldKubernetesResourcesGpuPool)
					fields.Set(AppFieldKubernetesResources)
				} else {
					for k3, _ := range m.KubernetesResources.GpuPool.Topology.MinNodeOptRes {
						_, vok3 := o.KubernetesResources.GpuPool.Topology.MinNodeOptRes[k3]
						if !vok3 {
							fields.Set(AppFieldKubernetesResourcesGpuPoolTopologyMinNodeOptRes)
							fields.Set(AppFieldKubernetesResourcesGpuPoolTopology)
							fields.Set(AppFieldKubernetesResourcesGpuPool)
							fields.Set(AppFieldKubernetesResources)
						} else {
							if m.KubernetesResources.GpuPool.Topology.MinNodeOptRes[k3] != o.KubernetesResources.GpuPool.Topology.MinNodeOptRes[k3] {
								fields.Set(AppFieldKubernetesResourcesGpuPoolTopologyMinNodeOptRes)
								fields.Set(AppFieldKubernetesResourcesGpuPoolTopology)
								fields.Set(AppFieldKubernetesResourcesGpuPool)
								fields.Set(AppFieldKubernetesResources)
								break
							}
						}
					}
				}
			} else if (m.KubernetesResources.GpuPool.Topology.MinNodeOptRes != nil && o.KubernetesResources.GpuPool.Topology.MinNodeOptRes == nil) || (m.KubernetesResources.GpuPool.Topology.MinNodeOptRes == nil && o.KubernetesResources.GpuPool.Topology.MinNodeOptRes != nil) {
				fields.Set(AppFieldKubernetesResourcesGpuPoolTopologyMinNodeOptRes)
				fields.Set(AppFieldKubernetesResourcesGpuPoolTopology)
				fields.Set(AppFieldKubernetesResourcesGpuPool)
				fields.Set(AppFieldKubernetesResources)
			}
			if m.KubernetesResources.GpuPool.Topology.MinNumberOfNodes != o.KubernetesResources.GpuPool.Topology.MinNumberOfNodes {
				fields.Set(AppFieldKubernetesResourcesGpuPoolTopologyMinNumberOfNodes)
				fields.Set(AppFieldKubernetesResourcesGpuPoolTopology)
				fields.Set(AppFieldKubernetesResourcesGpuPool)
				fields.Set(AppFieldKubernetesResources)
			}
			if m.KubernetesResources.GpuPool.Topology.MinNodeGpus != nil && o.KubernetesResources.GpuPool.Topology.MinNodeGpus != nil {
				if len(m.KubernetesResources.GpuPool.Topology.MinNodeGpus) != len(o.KubernetesResources.GpuPool.Topology.MinNodeGpus) {
					fields.Set(AppFieldKubernetesResourcesGpuPoolTopologyMinNodeGpus)
					fields.Set(AppFieldKubernetesResourcesGpuPoolTopology)
					fields.Set(AppFieldKubernetesResourcesGpuPool)
					fields.Set(AppFieldKubernetesResources)
				} else {
					for i3 := 0; i3 < len(m.KubernetesResources.GpuPool.Topology.MinNodeGpus); i3++ {
						if m.KubernetesResources.GpuPool.Topology.MinNodeGpus[i3].ModelId != o.KubernetesResources.GpuPool.Topology.MinNodeGpus[i3].ModelId {
							fields.Set(AppFieldKubernetesResourcesGpuPoolTopologyMinNodeGpusModelId)
							fields.Set(AppFieldKubernetesResourcesGpuPoolTopologyMinNodeGpus)
							fields.Set(AppFieldKubernetesResourcesGpuPoolTopology)
							fields.Set(AppFieldKubernetesResourcesGpuPool)
							fields.Set(AppFieldKubernetesResources)
						}
						if m.KubernetesResources.GpuPool.Topology.MinNodeGpus[i3].Count != o.KubernetesResources.GpuPool.Topology.MinNodeGpus[i3].Count {
							fields.Set(AppFieldKubernetesResourcesGpuPoolTopologyMinNodeGpusCount)
							fields.Set(AppFieldKubernetesResourcesGpuPoolTopologyMinNodeGpus)
							fields.Set(AppFieldKubernetesResourcesGpuPoolTopology)
							fields.Set(AppFieldKubernetesResourcesGpuPool)
							fields.Set(AppFieldKubernetesResources)
						}
						if m.KubernetesResources.GpuPool.Topology.MinNodeGpus[i3].Vendor != o.KubernetesResources.GpuPool.Topology.MinNodeGpus[i3].Vendor {
							fields.Set(AppFieldKubernetesResourcesGpuPoolTopologyMinNodeGpusVendor)
							fields.Set(AppFieldKubernetesResourcesGpuPoolTopologyMinNodeGpus)
							fields.Set(AppFieldKubernetesResourcesGpuPoolTopology)
							fields.Set(AppFieldKubernetesResourcesGpuPool)
							fields.Set(AppFieldKubernetesResources)
						}
						if m.KubernetesResources.GpuPool.Topology.MinNodeGpus[i3].Memory != o.KubernetesResources.GpuPool.Topology.MinNodeGpus[i3].Memory {
							fields.Set(AppFieldKubernetesResourcesGpuPoolTopologyMinNodeGpusMemory)
							fields.Set(AppFieldKubernetesResourcesGpuPoolTopologyMinNodeGpus)
							fields.Set(AppFieldKubernetesResourcesGpuPoolTopology)
							fields.Set(AppFieldKubernetesResourcesGpuPool)
							fields.Set(AppFieldKubernetesResources)
						}
						if m.KubernetesResources.GpuPool.Topology.MinNodeGpus[i3].InUse != o.KubernetesResources.GpuPool.Topology.MinNodeGpus[i3].InUse {
							fields.Set(AppFieldKubernetesResourcesGpuPoolTopologyMinNodeGpusInUse)
							fields.Set(AppFieldKubernetesResourcesGpuPoolTopologyMinNodeGpus)
							fields.Set(AppFieldKubernetesResourcesGpuPoolTopology)
							fields.Set(AppFieldKubernetesResourcesGpuPool)
							fields.Set(AppFieldKubernetesResources)
						}
					}
				}
			} else if (m.KubernetesResources.GpuPool.Topology.MinNodeGpus != nil && o.KubernetesResources.GpuPool.Topology.MinNodeGpus == nil) || (m.KubernetesResources.GpuPool.Topology.MinNodeGpus == nil && o.KubernetesResources.GpuPool.Topology.MinNodeGpus != nil) {
				fields.Set(AppFieldKubernetesResourcesGpuPoolTopologyMinNodeGpus)
				fields.Set(AppFieldKubernetesResourcesGpuPoolTopology)
				fields.Set(AppFieldKubernetesResourcesGpuPool)
				fields.Set(AppFieldKubernetesResources)
			}
			if m.KubernetesResources.GpuPool.TotalGpus != nil && o.KubernetesResources.GpuPool.TotalGpus != nil {
				if len(m.KubernetesResources.GpuPool.TotalGpus) != len(o.KubernetesResources.GpuPool.TotalGpus) {
					fields.Set(AppFieldKubernetesResourcesGpuPoolTotalGpus)
					fields.Set(AppFieldKubernetesResourcesGpuPool)
					fields.Set(AppFieldKubernetesResources)
				} else {
					for i2 := 0; i2 < len(m.KubernetesResources.GpuPool.TotalGpus); i2++ {
						if m.KubernetesResources.GpuPool.TotalGpus[i2].ModelId != o.KubernetesResources.GpuPool.TotalGpus[i2].ModelId {
							fields.Set(AppFieldKubernetesResourcesGpuPoolTotalGpusModelId)
							fields.Set(AppFieldKubernetesResourcesGpuPoolTotalGpus)
							fields.Set(AppFieldKubernetesResourcesGpuPool)
							fields.Set(AppFieldKubernetesResources)
						}
						if m.KubernetesResources.GpuPool.TotalGpus[i2].Count != o.KubernetesResources.GpuPool.TotalGpus[i2].Count {
							fields.Set(AppFieldKubernetesResourcesGpuPoolTotalGpusCount)
							fields.Set(AppFieldKubernetesResourcesGpuPoolTotalGpus)
							fields.Set(AppFieldKubernetesResourcesGpuPool)
							fields.Set(AppFieldKubernetesResources)
						}
						if m.KubernetesResources.GpuPool.TotalGpus[i2].Vendor != o.KubernetesResources.GpuPool.TotalGpus[i2].Vendor {
							fields.Set(AppFieldKubernetesResourcesGpuPoolTotalGpusVendor)
							fields.Set(AppFieldKubernetesResourcesGpuPoolTotalGpus)
							fields.Set(AppFieldKubernetesResourcesGpuPool)
							fields.Set(AppFieldKubernetesResources)
						}
						if m.KubernetesResources.GpuPool.TotalGpus[i2].Memory != o.KubernetesResources.GpuPool.TotalGpus[i2].Memory {
							fields.Set(AppFieldKubernetesResourcesGpuPoolTotalGpusMemory)
							fields.Set(AppFieldKubernetesResourcesGpuPoolTotalGpus)
							fields.Set(AppFieldKubernetesResourcesGpuPool)
							fields.Set(AppFieldKubernetesResources)
						}
						if m.KubernetesResources.GpuPool.TotalGpus[i2].InUse != o.KubernetesResources.GpuPool.TotalGpus[i2].InUse {
							fields.Set(AppFieldKubernetesResourcesGpuPoolTotalGpusInUse)
							fields.Set(AppFieldKubernetesResourcesGpuPoolTotalGpus)
							fields.Set(AppFieldKubernetesResourcesGpuPool)
							fields.Set(AppFieldKubernetesResources)
						}
					}
				}
			} else if (m.KubernetesResources.GpuPool.TotalGpus != nil && o.KubernetesResources.GpuPool.TotalGpus == nil) || (m.KubernetesResources.GpuPool.TotalGpus == nil && o.KubernetesResources.GpuPool.TotalGpus != nil) {
				fields.Set(AppFieldKubernetesResourcesGpuPoolTotalGpus)
				fields.Set(AppFieldKubernetesResourcesGpuPool)
				fields.Set(AppFieldKubernetesResources)
			}
		} else if (m.KubernetesResources.GpuPool != nil && o.KubernetesResources.GpuPool == nil) || (m.KubernetesResources.GpuPool == nil && o.KubernetesResources.GpuPool != nil) {
			fields.Set(AppFieldKubernetesResourcesGpuPool)
			fields.Set(AppFieldKubernetesResources)
		}
		if m.KubernetesResources.MinKubernetesVersion != o.KubernetesResources.MinKubernetesVersion {
			fields.Set(AppFieldKubernetesResourcesMinKubernetesVersion)
			fields.Set(AppFieldKubernetesResources)
		}
	} else if (m.KubernetesResources != nil && o.KubernetesResources == nil) || (m.KubernetesResources == nil && o.KubernetesResources != nil) {
		fields.Set(AppFieldKubernetesResources)
	}
	if m.NodeResources != nil && o.NodeResources != nil {
		if m.NodeResources.Vcpus != o.NodeResources.Vcpus {
			fields.Set(AppFieldNodeResourcesVcpus)
			fields.Set(AppFieldNodeResources)
		}
		if m.NodeResources.Ram != o.NodeResources.Ram {
			fields.Set(AppFieldNodeResourcesRam)
			fields.Set(AppFieldNodeResources)
		}
		if m.NodeResources.Disk != o.NodeResources.Disk {
			fields.Set(AppFieldNodeResourcesDisk)
			fields.Set(AppFieldNodeResources)
		}
		if m.NodeResources.OptResMap != nil && o.NodeResources.OptResMap != nil {
			if len(m.NodeResources.OptResMap) != len(o.NodeResources.OptResMap) {
				fields.Set(AppFieldNodeResourcesOptResMap)
				fields.Set(AppFieldNodeResources)
			} else {
				for k1, _ := range m.NodeResources.OptResMap {
					_, vok1 := o.NodeResources.OptResMap[k1]
					if !vok1 {
						fields.Set(AppFieldNodeResourcesOptResMap)
						fields.Set(AppFieldNodeResources)
					} else {
						if m.NodeResources.OptResMap[k1] != o.NodeResources.OptResMap[k1] {
							fields.Set(AppFieldNodeResourcesOptResMap)
							fields.Set(AppFieldNodeResources)
							break
						}
					}
				}
			}
		} else if (m.NodeResources.OptResMap != nil && o.NodeResources.OptResMap == nil) || (m.NodeResources.OptResMap == nil && o.NodeResources.OptResMap != nil) {
			fields.Set(AppFieldNodeResourcesOptResMap)
			fields.Set(AppFieldNodeResources)
		}
		if m.NodeResources.InfraNodeFlavor != o.NodeResources.InfraNodeFlavor {
			fields.Set(AppFieldNodeResourcesInfraNodeFlavor)
			fields.Set(AppFieldNodeResources)
		}
		if m.NodeResources.ExternalVolumeSize != o.NodeResources.ExternalVolumeSize {
			fields.Set(AppFieldNodeResourcesExternalVolumeSize)
			fields.Set(AppFieldNodeResources)
		}
		if m.NodeResources.Gpus != nil && o.NodeResources.Gpus != nil {
			if len(m.NodeResources.Gpus) != len(o.NodeResources.Gpus) {
				fields.Set(AppFieldNodeResourcesGpus)
				fields.Set(AppFieldNodeResources)
			} else {
				for i1 := 0; i1 < len(m.NodeResources.Gpus); i1++ {
					if m.NodeResources.Gpus[i1].ModelId != o.NodeResources.Gpus[i1].ModelId {
						fields.Set(AppFieldNodeResourcesGpusModelId)
						fields.Set(AppFieldNodeResourcesGpus)
						fields.Set(AppFieldNodeResources)
					}
					if m.NodeResources.Gpus[i1].Count != o.NodeResources.Gpus[i1].Count {
						fields.Set(AppFieldNodeResourcesGpusCount)
						fields.Set(AppFieldNodeResourcesGpus)
						fields.Set(AppFieldNodeResources)
					}
					if m.NodeResources.Gpus[i1].Vendor != o.NodeResources.Gpus[i1].Vendor {
						fields.Set(AppFieldNodeResourcesGpusVendor)
						fields.Set(AppFieldNodeResourcesGpus)
						fields.Set(AppFieldNodeResources)
					}
					if m.NodeResources.Gpus[i1].Memory != o.NodeResources.Gpus[i1].Memory {
						fields.Set(AppFieldNodeResourcesGpusMemory)
						fields.Set(AppFieldNodeResourcesGpus)
						fields.Set(AppFieldNodeResources)
					}
					if m.NodeResources.Gpus[i1].InUse != o.NodeResources.Gpus[i1].InUse {
						fields.Set(AppFieldNodeResourcesGpusInUse)
						fields.Set(AppFieldNodeResourcesGpus)
						fields.Set(AppFieldNodeResources)
					}
				}
			}
		} else if (m.NodeResources.Gpus != nil && o.NodeResources.Gpus == nil) || (m.NodeResources.Gpus == nil && o.NodeResources.Gpus != nil) {
			fields.Set(AppFieldNodeResourcesGpus)
			fields.Set(AppFieldNodeResources)
		}
	} else if (m.NodeResources != nil && o.NodeResources == nil) || (m.NodeResources == nil && o.NodeResources != nil) {
		fields.Set(AppFieldNodeResources)
	}
	if m.ObjId != o.ObjId {
		fields.Set(AppFieldObjId)
	}
	if m.AppAnnotations != nil && o.AppAnnotations != nil {
		if len(m.AppAnnotations) != len(o.AppAnnotations) {
			fields.Set(AppFieldAppAnnotations)
		} else {
			for k0, _ := range m.AppAnnotations {
				_, vok0 := o.AppAnnotations[k0]
				if !vok0 {
					fields.Set(AppFieldAppAnnotations)
				} else {
					if m.AppAnnotations[k0] != o.AppAnnotations[k0] {
						fields.Set(AppFieldAppAnnotations)
						break
					}
				}
			}
		}
	} else if (m.AppAnnotations != nil && o.AppAnnotations == nil) || (m.AppAnnotations == nil && o.AppAnnotations != nil) {
		fields.Set(AppFieldAppAnnotations)
	}
	if m.IsStandalone != o.IsStandalone {
		fields.Set(AppFieldIsStandalone)
	}
	if m.ManagesOwnNamespaces != o.ManagesOwnNamespaces {
		fields.Set(AppFieldManagesOwnNamespaces)
	}
	if m.CompatibilityVersion != o.CompatibilityVersion {
		fields.Set(AppFieldCompatibilityVersion)
	}
	if m.Username != o.Username {
		fields.Set(AppFieldUsername)
	}
	if m.Credentials != o.Credentials {
		fields.Set(AppFieldCredentials)
	}
	if m.Tags != nil && o.Tags != nil {
		if len(m.Tags) != len(o.Tags) {
			fields.Set(AppFieldTags)
		} else {
			for k0, _ := range m.Tags {
				_, vok0 := o.Tags[k0]
				if !vok0 {
					fields.Set(AppFieldTags)
				} else {
					if m.Tags[k0] != o.Tags[k0] {
						fields.Set(AppFieldTags)
						break
					}
				}
			}
		}
	} else if (m.Tags != nil && o.Tags == nil) || (m.Tags == nil && o.Tags != nil) {
		fields.Set(AppFieldTags)
	}
}

func (m *App) GetDiffFields(o *App) *FieldMap {
	diffFields := NewFieldMap(nil)
	m.DiffFields(o, diffFields)
	return diffFields
}

var UpdateAppFieldsMap = NewFieldMap(map[string]struct{}{
	AppFieldImagePath:                                            struct{}{},
	AppFieldImageType:                                            struct{}{},
	AppFieldAccessPorts:                                          struct{}{},
	AppFieldDefaultFlavor:                                        struct{}{},
	AppFieldDefaultFlavorName:                                    struct{}{},
	AppFieldAuthPublicKey:                                        struct{}{},
	AppFieldCommand:                                              struct{}{},
	AppFieldAnnotations:                                          struct{}{},
	AppFieldDeployment:                                           struct{}{},
	AppFieldDeploymentManifest:                                   struct{}{},
	AppFieldDeploymentGenerator:                                  struct{}{},
	AppFieldAndroidPackageName:                                   struct{}{},
	AppFieldConfigs:                                              struct{}{},
	AppFieldConfigsKind:                                          struct{}{},
	AppFieldConfigsConfig:                                        struct{}{},
	AppFieldScaleWithCluster:                                     struct{}{},
	AppFieldInternalPorts:                                        struct{}{},
	AppFieldRevision:                                             struct{}{},
	AppFieldOfficialFqdn:                                         struct{}{},
	AppFieldMd5Sum:                                               struct{}{},
	AppFieldAccessType:                                           struct{}{},
	AppFieldAutoProvPolicies:                                     struct{}{},
	AppFieldTemplateDelimiter:                                    struct{}{},
	AppFieldSkipHcPorts:                                          struct{}{},
	AppFieldTrusted:                                              struct{}{},
	AppFieldRequiredOutboundConnections:                          struct{}{},
	AppFieldRequiredOutboundConnectionsProtocol:                  struct{}{},
	AppFieldRequiredOutboundConnectionsPortRangeMin:              struct{}{},
	AppFieldRequiredOutboundConnectionsPortRangeMax:              struct{}{},
	AppFieldRequiredOutboundConnectionsRemoteCidr:                struct{}{},
	AppFieldAllowServerless:                                      struct{}{},
	AppFieldServerlessConfig:                                     struct{}{},
	AppFieldServerlessConfigVcpus:                                struct{}{},
	AppFieldServerlessConfigVcpusWhole:                           struct{}{},
	AppFieldServerlessConfigVcpusNanos:                           struct{}{},
	AppFieldServerlessConfigRam:                                  struct{}{},
	AppFieldServerlessConfigMinReplicas:                          struct{}{},
	AppFieldServerlessConfigGpuConfig:                            struct{}{},
	AppFieldServerlessConfigGpuConfigType:                        struct{}{},
	AppFieldServerlessConfigGpuConfigModel:                       struct{}{},
	AppFieldServerlessConfigGpuConfigNumGpu:                      struct{}{},
	AppFieldServerlessConfigGpuConfigRam:                         struct{}{},
	AppFieldVmAppOsType:                                          struct{}{},
	AppFieldAlertPolicies:                                        struct{}{},
	AppFieldQosSessionProfile:                                    struct{}{},
	AppFieldQosSessionDuration:                                   struct{}{},
	AppFieldGlobalId:                                             struct{}{},
	AppFieldCommandArgs:                                          struct{}{},
	AppFieldEnvVars:                                              struct{}{},
	AppFieldEnvVarsKey:                                           struct{}{},
	AppFieldEnvVarsValue:                                         struct{}{},
	AppFieldSecretEnvVars:                                        struct{}{},
	AppFieldSecretEnvVarsKey:                                     struct{}{},
	AppFieldSecretEnvVarsValue:                                   struct{}{},
	AppFieldUpdateListAction:                                     struct{}{},
	AppFieldKubernetesResources:                                  struct{}{},
	AppFieldKubernetesResourcesCpuPool:                           struct{}{},
	AppFieldKubernetesResourcesCpuPoolTotalVcpus:                 struct{}{},
	AppFieldKubernetesResourcesCpuPoolTotalVcpusWhole:            struct{}{},
	AppFieldKubernetesResourcesCpuPoolTotalVcpusNanos:            struct{}{},
	AppFieldKubernetesResourcesCpuPoolTotalMemory:                struct{}{},
	AppFieldKubernetesResourcesCpuPoolTotalDisk:                  struct{}{},
	AppFieldKubernetesResourcesCpuPoolTotalOptRes:                struct{}{},
	AppFieldKubernetesResourcesCpuPoolTotalOptResKey:             struct{}{},
	AppFieldKubernetesResourcesCpuPoolTotalOptResValue:           struct{}{},
	AppFieldKubernetesResourcesCpuPoolTopology:                   struct{}{},
	AppFieldKubernetesResourcesCpuPoolTopologyMinNodeVcpus:       struct{}{},
	AppFieldKubernetesResourcesCpuPoolTopologyMinNodeMemory:      struct{}{},
	AppFieldKubernetesResourcesCpuPoolTopologyMinNodeDisk:        struct{}{},
	AppFieldKubernetesResourcesCpuPoolTopologyMinNodeOptRes:      struct{}{},
	AppFieldKubernetesResourcesCpuPoolTopologyMinNodeOptResKey:   struct{}{},
	AppFieldKubernetesResourcesCpuPoolTopologyMinNodeOptResValue: struct{}{},
	AppFieldKubernetesResourcesCpuPoolTopologyMinNumberOfNodes:   struct{}{},
	AppFieldKubernetesResourcesCpuPoolTopologyMinNodeGpus:        struct{}{},
	AppFieldKubernetesResourcesCpuPoolTopologyMinNodeGpusModelId: struct{}{},
	AppFieldKubernetesResourcesCpuPoolTopologyMinNodeGpusCount:   struct{}{},
	AppFieldKubernetesResourcesCpuPoolTopologyMinNodeGpusVendor:  struct{}{},
	AppFieldKubernetesResourcesCpuPoolTopologyMinNodeGpusMemory:  struct{}{},
	AppFieldKubernetesResourcesCpuPoolTopologyMinNodeGpusInUse:   struct{}{},
	AppFieldKubernetesResourcesCpuPoolTotalGpus:                  struct{}{},
	AppFieldKubernetesResourcesCpuPoolTotalGpusModelId:           struct{}{},
	AppFieldKubernetesResourcesCpuPoolTotalGpusCount:             struct{}{},
	AppFieldKubernetesResourcesCpuPoolTotalGpusVendor:            struct{}{},
	AppFieldKubernetesResourcesCpuPoolTotalGpusMemory:            struct{}{},
	AppFieldKubernetesResourcesCpuPoolTotalGpusInUse:             struct{}{},
	AppFieldKubernetesResourcesGpuPool:                           struct{}{},
	AppFieldKubernetesResourcesGpuPoolTotalVcpus:                 struct{}{},
	AppFieldKubernetesResourcesGpuPoolTotalVcpusWhole:            struct{}{},
	AppFieldKubernetesResourcesGpuPoolTotalVcpusNanos:            struct{}{},
	AppFieldKubernetesResourcesGpuPoolTotalMemory:                struct{}{},
	AppFieldKubernetesResourcesGpuPoolTotalDisk:                  struct{}{},
	AppFieldKubernetesResourcesGpuPoolTotalOptRes:                struct{}{},
	AppFieldKubernetesResourcesGpuPoolTotalOptResKey:             struct{}{},
	AppFieldKubernetesResourcesGpuPoolTotalOptResValue:           struct{}{},
	AppFieldKubernetesResourcesGpuPoolTopology:                   struct{}{},
	AppFieldKubernetesResourcesGpuPoolTopologyMinNodeVcpus:       struct{}{},
	AppFieldKubernetesResourcesGpuPoolTopologyMinNodeMemory:      struct{}{},
	AppFieldKubernetesResourcesGpuPoolTopologyMinNodeDisk:        struct{}{},
	AppFieldKubernetesResourcesGpuPoolTopologyMinNodeOptRes:      struct{}{},
	AppFieldKubernetesResourcesGpuPoolTopologyMinNodeOptResKey:   struct{}{},
	AppFieldKubernetesResourcesGpuPoolTopologyMinNodeOptResValue: struct{}{},
	AppFieldKubernetesResourcesGpuPoolTopologyMinNumberOfNodes:   struct{}{},
	AppFieldKubernetesResourcesGpuPoolTopologyMinNodeGpus:        struct{}{},
	AppFieldKubernetesResourcesGpuPoolTopologyMinNodeGpusModelId: struct{}{},
	AppFieldKubernetesResourcesGpuPoolTopologyMinNodeGpusCount:   struct{}{},
	AppFieldKubernetesResourcesGpuPoolTopologyMinNodeGpusVendor:  struct{}{},
	AppFieldKubernetesResourcesGpuPoolTopologyMinNodeGpusMemory:  struct{}{},
	AppFieldKubernetesResourcesGpuPoolTopologyMinNodeGpusInUse:   struct{}{},
	AppFieldKubernetesResourcesGpuPoolTotalGpus:                  struct{}{},
	AppFieldKubernetesResourcesGpuPoolTotalGpusModelId:           struct{}{},
	AppFieldKubernetesResourcesGpuPoolTotalGpusCount:             struct{}{},
	AppFieldKubernetesResourcesGpuPoolTotalGpusVendor:            struct{}{},
	AppFieldKubernetesResourcesGpuPoolTotalGpusMemory:            struct{}{},
	AppFieldKubernetesResourcesGpuPoolTotalGpusInUse:             struct{}{},
	AppFieldKubernetesResourcesMinKubernetesVersion:              struct{}{},
	AppFieldNodeResources:                                        struct{}{},
	AppFieldNodeResourcesVcpus:                                   struct{}{},
	AppFieldNodeResourcesRam:                                     struct{}{},
	AppFieldNodeResourcesDisk:                                    struct{}{},
	AppFieldNodeResourcesOptResMap:                               struct{}{},
	AppFieldNodeResourcesOptResMapKey:                            struct{}{},
	AppFieldNodeResourcesOptResMapValue:                          struct{}{},
	AppFieldNodeResourcesInfraNodeFlavor:                         struct{}{},
	AppFieldNodeResourcesExternalVolumeSize:                      struct{}{},
	AppFieldNodeResourcesGpus:                                    struct{}{},
	AppFieldNodeResourcesGpusModelId:                             struct{}{},
	AppFieldNodeResourcesGpusCount:                               struct{}{},
	AppFieldNodeResourcesGpusVendor:                              struct{}{},
	AppFieldNodeResourcesGpusMemory:                              struct{}{},
	AppFieldNodeResourcesGpusInUse:                               struct{}{},
	AppFieldObjId:                                                struct{}{},
	AppFieldAppAnnotations:                                       struct{}{},
	AppFieldAppAnnotationsKey:                                    struct{}{},
	AppFieldAppAnnotationsValue:                                  struct{}{},
	AppFieldIsStandalone:                                         struct{}{},
	AppFieldManagesOwnNamespaces:                                 struct{}{},
	AppFieldUsername:                                             struct{}{},
	AppFieldCredentials:                                          struct{}{},
	AppFieldTags:                                                 struct{}{},
	AppFieldTagsKey:                                              struct{}{},
	AppFieldTagsValue:                                            struct{}{},
})

func (m *App) ValidateUpdateFields() error {
	return m.ValidateUpdateFieldsCustom(UpdateAppFieldsMap)
}

func (m *App) ValidateUpdateFieldsCustom(allowedFields *FieldMap) error {
	if m.Fields == nil {
		return fmt.Errorf("nothing specified to update")
	}
	fmap := MakeFieldMap(m.Fields)
	badFieldStrs := []string{}
	for _, field := range fmap.Fields() {
		if m.IsKeyField(field) {
			continue
		}
		if !allowedFields.Has(field) {
			if _, ok := AppAllFieldsStringMap[field]; !ok {
				continue
			}
			badFieldStrs = append(badFieldStrs, AppAllFieldsStringMap[field])
		}
	}
	if len(badFieldStrs) > 0 {
		return fmt.Errorf("specified field(s) %s cannot be modified", strings.Join(badFieldStrs, ","))
	}
	return nil
}

func (m *App) Clone() *App {
	cp := &App{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *App) AddConfigs(vals ...*ConfigFile) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.Configs {
		cur[v.String()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.String()]; found {
			continue // duplicate
		}
		m.Configs = append(m.Configs, v)
		changes++
	}
	return changes
}

func (m *App) RemoveConfigs(vals ...*ConfigFile) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.String()] = struct{}{}
	}
	for i := len(m.Configs); i >= 0; i-- {
		if _, found := remove[m.Configs[i].String()]; found {
			m.Configs = append(m.Configs[:i], m.Configs[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *App) AddAutoProvPolicies(vals ...string) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.AutoProvPolicies {
		cur[v] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v]; found {
			continue // duplicate
		}
		m.AutoProvPolicies = append(m.AutoProvPolicies, v)
		changes++
	}
	return changes
}

func (m *App) RemoveAutoProvPolicies(vals ...string) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v] = struct{}{}
	}
	for i := len(m.AutoProvPolicies); i >= 0; i-- {
		if _, found := remove[m.AutoProvPolicies[i]]; found {
			m.AutoProvPolicies = append(m.AutoProvPolicies[:i], m.AutoProvPolicies[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *App) AddRequiredOutboundConnections(vals ...SecurityRule) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.RequiredOutboundConnections {
		cur[v.String()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.String()]; found {
			continue // duplicate
		}
		m.RequiredOutboundConnections = append(m.RequiredOutboundConnections, v)
		changes++
	}
	return changes
}

func (m *App) RemoveRequiredOutboundConnections(vals ...SecurityRule) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.String()] = struct{}{}
	}
	for i := len(m.RequiredOutboundConnections); i >= 0; i-- {
		if _, found := remove[m.RequiredOutboundConnections[i].String()]; found {
			m.RequiredOutboundConnections = append(m.RequiredOutboundConnections[:i], m.RequiredOutboundConnections[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *App) AddAlertPolicies(vals ...string) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.AlertPolicies {
		cur[v] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v]; found {
			continue // duplicate
		}
		m.AlertPolicies = append(m.AlertPolicies, v)
		changes++
	}
	return changes
}

func (m *App) RemoveAlertPolicies(vals ...string) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v] = struct{}{}
	}
	for i := len(m.AlertPolicies); i >= 0; i-- {
		if _, found := remove[m.AlertPolicies[i]]; found {
			m.AlertPolicies = append(m.AlertPolicies[:i], m.AlertPolicies[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *App) AddCommandArgs(vals ...string) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.CommandArgs {
		cur[v] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v]; found {
			continue // duplicate
		}
		m.CommandArgs = append(m.CommandArgs, v)
		changes++
	}
	return changes
}

func (m *App) RemoveCommandArgs(vals ...string) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v] = struct{}{}
	}
	for i := len(m.CommandArgs); i >= 0; i-- {
		if _, found := remove[m.CommandArgs[i]]; found {
			m.CommandArgs = append(m.CommandArgs[:i], m.CommandArgs[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *App) AddKubernetesResourcesCpuPoolTopologyMinNodeGpus(vals ...*GPUResource) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.KubernetesResources.CpuPool.Topology.MinNodeGpus {
		cur[v.GetKey().GetKeyString()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.GetKey().GetKeyString()]; found {
			continue // duplicate
		}
		m.KubernetesResources.CpuPool.Topology.MinNodeGpus = append(m.KubernetesResources.CpuPool.Topology.MinNodeGpus, v)
		changes++
	}
	return changes
}

func (m *App) RemoveKubernetesResourcesCpuPoolTopologyMinNodeGpus(vals ...*GPUResource) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.GetKey().GetKeyString()] = struct{}{}
	}
	for i := len(m.KubernetesResources.CpuPool.Topology.MinNodeGpus); i >= 0; i-- {
		if _, found := remove[m.KubernetesResources.CpuPool.Topology.MinNodeGpus[i].GetKey().GetKeyString()]; found {
			m.KubernetesResources.CpuPool.Topology.MinNodeGpus = append(m.KubernetesResources.CpuPool.Topology.MinNodeGpus[:i], m.KubernetesResources.CpuPool.Topology.MinNodeGpus[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *App) AddKubernetesResourcesCpuPoolTotalGpus(vals ...*GPUResource) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.KubernetesResources.CpuPool.TotalGpus {
		cur[v.GetKey().GetKeyString()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.GetKey().GetKeyString()]; found {
			continue // duplicate
		}
		m.KubernetesResources.CpuPool.TotalGpus = append(m.KubernetesResources.CpuPool.TotalGpus, v)
		changes++
	}
	return changes
}

func (m *App) RemoveKubernetesResourcesCpuPoolTotalGpus(vals ...*GPUResource) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.GetKey().GetKeyString()] = struct{}{}
	}
	for i := len(m.KubernetesResources.CpuPool.TotalGpus); i >= 0; i-- {
		if _, found := remove[m.KubernetesResources.CpuPool.TotalGpus[i].GetKey().GetKeyString()]; found {
			m.KubernetesResources.CpuPool.TotalGpus = append(m.KubernetesResources.CpuPool.TotalGpus[:i], m.KubernetesResources.CpuPool.TotalGpus[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *App) AddKubernetesResourcesGpuPoolTopologyMinNodeGpus(vals ...*GPUResource) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.KubernetesResources.GpuPool.Topology.MinNodeGpus {
		cur[v.GetKey().GetKeyString()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.GetKey().GetKeyString()]; found {
			continue // duplicate
		}
		m.KubernetesResources.GpuPool.Topology.MinNodeGpus = append(m.KubernetesResources.GpuPool.Topology.MinNodeGpus, v)
		changes++
	}
	return changes
}

func (m *App) RemoveKubernetesResourcesGpuPoolTopologyMinNodeGpus(vals ...*GPUResource) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.GetKey().GetKeyString()] = struct{}{}
	}
	for i := len(m.KubernetesResources.GpuPool.Topology.MinNodeGpus); i >= 0; i-- {
		if _, found := remove[m.KubernetesResources.GpuPool.Topology.MinNodeGpus[i].GetKey().GetKeyString()]; found {
			m.KubernetesResources.GpuPool.Topology.MinNodeGpus = append(m.KubernetesResources.GpuPool.Topology.MinNodeGpus[:i], m.KubernetesResources.GpuPool.Topology.MinNodeGpus[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *App) AddKubernetesResourcesGpuPoolTotalGpus(vals ...*GPUResource) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.KubernetesResources.GpuPool.TotalGpus {
		cur[v.GetKey().GetKeyString()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.GetKey().GetKeyString()]; found {
			continue // duplicate
		}
		m.KubernetesResources.GpuPool.TotalGpus = append(m.KubernetesResources.GpuPool.TotalGpus, v)
		changes++
	}
	return changes
}

func (m *App) RemoveKubernetesResourcesGpuPoolTotalGpus(vals ...*GPUResource) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.GetKey().GetKeyString()] = struct{}{}
	}
	for i := len(m.KubernetesResources.GpuPool.TotalGpus); i >= 0; i-- {
		if _, found := remove[m.KubernetesResources.GpuPool.TotalGpus[i].GetKey().GetKeyString()]; found {
			m.KubernetesResources.GpuPool.TotalGpus = append(m.KubernetesResources.GpuPool.TotalGpus[:i], m.KubernetesResources.GpuPool.TotalGpus[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *App) AddNodeResourcesGpus(vals ...*GPUResource) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.NodeResources.Gpus {
		cur[v.GetKey().GetKeyString()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.GetKey().GetKeyString()]; found {
			continue // duplicate
		}
		m.NodeResources.Gpus = append(m.NodeResources.Gpus, v)
		changes++
	}
	return changes
}

func (m *App) RemoveNodeResourcesGpus(vals ...*GPUResource) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.GetKey().GetKeyString()] = struct{}{}
	}
	for i := len(m.NodeResources.Gpus); i >= 0; i-- {
		if _, found := remove[m.NodeResources.Gpus[i].GetKey().GetKeyString()]; found {
			m.NodeResources.Gpus = append(m.NodeResources.Gpus[:i], m.NodeResources.Gpus[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *App) CopyInFields(src *App) int {
	updateListAction := src.UpdateListAction
	changed := 0
	fmap := MakeFieldMap(src.Fields)
	if fmap.HasOrHasChild("2") {
		if fmap.Has("2.1") {
			if m.Key.Organization != src.Key.Organization {
				m.Key.Organization = src.Key.Organization
				changed++
			}
		}
		if fmap.Has("2.2") {
			if m.Key.Name != src.Key.Name {
				m.Key.Name = src.Key.Name
				changed++
			}
		}
		if fmap.Has("2.3") {
			if m.Key.Version != src.Key.Version {
				m.Key.Version = src.Key.Version
				changed++
			}
		}
	}
	if fmap.Has("4") {
		if m.ImagePath != src.ImagePath {
			m.ImagePath = src.ImagePath
			changed++
		}
	}
	if fmap.Has("5") {
		if m.ImageType != src.ImageType {
			m.ImageType = src.ImageType
			changed++
		}
	}
	if fmap.Has("7") {
		if m.AccessPorts != src.AccessPorts {
			m.AccessPorts = src.AccessPorts
			changed++
		}
	}
	if fmap.HasOrHasChild("9") {
		if fmap.Has("9.1") {
			if m.DefaultFlavor.Name != src.DefaultFlavor.Name {
				m.DefaultFlavor.Name = src.DefaultFlavor.Name
				changed++
			}
		}
	}
	if fmap.Has("12") {
		if m.AuthPublicKey != src.AuthPublicKey {
			m.AuthPublicKey = src.AuthPublicKey
			changed++
		}
	}
	if fmap.Has("13") {
		if m.Command != src.Command {
			m.Command = src.Command
			changed++
		}
	}
	if fmap.Has("14") {
		if m.Annotations != src.Annotations {
			m.Annotations = src.Annotations
			changed++
		}
	}
	if fmap.Has("15") {
		if m.Deployment != src.Deployment {
			m.Deployment = src.Deployment
			changed++
		}
	}
	if fmap.Has("16") {
		if m.DeploymentManifest != src.DeploymentManifest {
			m.DeploymentManifest = src.DeploymentManifest
			changed++
		}
	}
	if fmap.Has("17") {
		if m.DeploymentGenerator != src.DeploymentGenerator {
			m.DeploymentGenerator = src.DeploymentGenerator
			changed++
		}
	}
	if fmap.Has("18") {
		if m.AndroidPackageName != src.AndroidPackageName {
			m.AndroidPackageName = src.AndroidPackageName
			changed++
		}
	}
	if fmap.Has("20") {
		if m.DelOpt != src.DelOpt {
			m.DelOpt = src.DelOpt
			changed++
		}
	}
	if fmap.HasOrHasChild("21") {
		if src.Configs != nil {
			if updateListAction == "add" {
				changed += m.AddConfigs(src.Configs...)
			} else if updateListAction == "remove" {
				changed += m.RemoveConfigs(src.Configs...)
			} else {
				m.Configs = make([]*ConfigFile, 0)
				for k0, _ := range src.Configs {
					m.Configs = append(m.Configs, src.Configs[k0].Clone())
				}
				changed++
			}
		} else if m.Configs != nil {
			m.Configs = nil
			changed++
		}
	}
	if fmap.Has("22") {
		if m.ScaleWithCluster != src.ScaleWithCluster {
			m.ScaleWithCluster = src.ScaleWithCluster
			changed++
		}
	}
	if fmap.Has("23") {
		if m.InternalPorts != src.InternalPorts {
			m.InternalPorts = src.InternalPorts
			changed++
		}
	}
	if fmap.Has("24") {
		if m.Revision != src.Revision {
			m.Revision = src.Revision
			changed++
		}
	}
	if fmap.Has("25") {
		if m.OfficialFqdn != src.OfficialFqdn {
			m.OfficialFqdn = src.OfficialFqdn
			changed++
		}
	}
	if fmap.Has("26") {
		if m.Md5Sum != src.Md5Sum {
			m.Md5Sum = src.Md5Sum
			changed++
		}
	}
	if fmap.Has("28") {
		if m.AutoProvPolicy != src.AutoProvPolicy {
			m.AutoProvPolicy = src.AutoProvPolicy
			changed++
		}
	}
	if fmap.Has("29") {
		if m.AccessType != src.AccessType {
			m.AccessType = src.AccessType
			changed++
		}
	}
	if fmap.Has("31") {
		if m.DeletePrepare != src.DeletePrepare {
			m.DeletePrepare = src.DeletePrepare
			changed++
		}
	}
	if fmap.Has("32") {
		if src.AutoProvPolicies != nil {
			if updateListAction == "add" {
				changed += m.AddAutoProvPolicies(src.AutoProvPolicies...)
			} else if updateListAction == "remove" {
				changed += m.RemoveAutoProvPolicies(src.AutoProvPolicies...)
			} else {
				m.AutoProvPolicies = make([]string, 0)
				m.AutoProvPolicies = append(m.AutoProvPolicies, src.AutoProvPolicies...)
				changed++
			}
		} else if m.AutoProvPolicies != nil {
			m.AutoProvPolicies = nil
			changed++
		}
	}
	if fmap.Has("33") {
		if m.TemplateDelimiter != src.TemplateDelimiter {
			m.TemplateDelimiter = src.TemplateDelimiter
			changed++
		}
	}
	if fmap.Has("34") {
		if m.SkipHcPorts != src.SkipHcPorts {
			m.SkipHcPorts = src.SkipHcPorts
			changed++
		}
	}
	if fmap.HasOrHasChild("35") {
		if fmap.Has("35.1") {
			if m.CreatedAt.Seconds != src.CreatedAt.Seconds {
				m.CreatedAt.Seconds = src.CreatedAt.Seconds
				changed++
			}
		}
		if fmap.Has("35.2") {
			if m.CreatedAt.Nanos != src.CreatedAt.Nanos {
				m.CreatedAt.Nanos = src.CreatedAt.Nanos
				changed++
			}
		}
	}
	if fmap.HasOrHasChild("36") {
		if fmap.Has("36.1") {
			if m.UpdatedAt.Seconds != src.UpdatedAt.Seconds {
				m.UpdatedAt.Seconds = src.UpdatedAt.Seconds
				changed++
			}
		}
		if fmap.Has("36.2") {
			if m.UpdatedAt.Nanos != src.UpdatedAt.Nanos {
				m.UpdatedAt.Nanos = src.UpdatedAt.Nanos
				changed++
			}
		}
	}
	if fmap.Has("37") {
		if m.Trusted != src.Trusted {
			m.Trusted = src.Trusted
			changed++
		}
	}
	if fmap.HasOrHasChild("38") {
		if src.RequiredOutboundConnections != nil {
			if updateListAction == "add" {
				changed += m.AddRequiredOutboundConnections(src.RequiredOutboundConnections...)
			} else if updateListAction == "remove" {
				changed += m.RemoveRequiredOutboundConnections(src.RequiredOutboundConnections...)
			} else {
				m.RequiredOutboundConnections = make([]SecurityRule, 0)
				for k0, _ := range src.RequiredOutboundConnections {
					m.RequiredOutboundConnections = append(m.RequiredOutboundConnections, *src.RequiredOutboundConnections[k0].Clone())
				}
				changed++
			}
		} else if m.RequiredOutboundConnections != nil {
			m.RequiredOutboundConnections = nil
			changed++
		}
	}
	if fmap.Has("39") {
		if m.AllowServerless != src.AllowServerless {
			m.AllowServerless = src.AllowServerless
			changed++
		}
	}
	if fmap.HasOrHasChild("40") {
		if src.ServerlessConfig != nil {
			if m.ServerlessConfig == nil {
				m.ServerlessConfig = &ServerlessConfig{}
			}
			if fmap.HasOrHasChild("40.1") {
				if m.ServerlessConfig.Vcpus.Whole != src.ServerlessConfig.Vcpus.Whole {
					m.ServerlessConfig.Vcpus.Whole = src.ServerlessConfig.Vcpus.Whole
					changed++
				}
				if m.ServerlessConfig.Vcpus.Nanos != src.ServerlessConfig.Vcpus.Nanos {
					m.ServerlessConfig.Vcpus.Nanos = src.ServerlessConfig.Vcpus.Nanos
					changed++
				}
			}
			if fmap.Has("40.2") {
				if m.ServerlessConfig.Ram != src.ServerlessConfig.Ram {
					m.ServerlessConfig.Ram = src.ServerlessConfig.Ram
					changed++
				}
			}
			if fmap.Has("40.3") {
				if m.ServerlessConfig.MinReplicas != src.ServerlessConfig.MinReplicas {
					m.ServerlessConfig.MinReplicas = src.ServerlessConfig.MinReplicas
					changed++
				}
			}
			if fmap.HasOrHasChild("40.4") {
				if fmap.Has("40.4.1") {
					if m.ServerlessConfig.GpuConfig.Type != src.ServerlessConfig.GpuConfig.Type {
						m.ServerlessConfig.GpuConfig.Type = src.ServerlessConfig.GpuConfig.Type
						changed++
					}
				}
				if fmap.Has("40.4.2") {
					if m.ServerlessConfig.GpuConfig.Model != src.ServerlessConfig.GpuConfig.Model {
						m.ServerlessConfig.GpuConfig.Model = src.ServerlessConfig.GpuConfig.Model
						changed++
					}
				}
				if fmap.Has("40.4.3") {
					if m.ServerlessConfig.GpuConfig.NumGpu != src.ServerlessConfig.GpuConfig.NumGpu {
						m.ServerlessConfig.GpuConfig.NumGpu = src.ServerlessConfig.GpuConfig.NumGpu
						changed++
					}
				}
				if fmap.Has("40.4.4") {
					if m.ServerlessConfig.GpuConfig.Ram != src.ServerlessConfig.GpuConfig.Ram {
						m.ServerlessConfig.GpuConfig.Ram = src.ServerlessConfig.GpuConfig.Ram
						changed++
					}
				}
			}
		} else if m.ServerlessConfig != nil {
			m.ServerlessConfig = nil
			changed++
		}
	}
	if fmap.Has("41") {
		if m.VmAppOsType != src.VmAppOsType {
			m.VmAppOsType = src.VmAppOsType
			changed++
		}
	}
	if fmap.Has("42") {
		if src.AlertPolicies != nil {
			if updateListAction == "add" {
				changed += m.AddAlertPolicies(src.AlertPolicies...)
			} else if updateListAction == "remove" {
				changed += m.RemoveAlertPolicies(src.AlertPolicies...)
			} else {
				m.AlertPolicies = make([]string, 0)
				m.AlertPolicies = append(m.AlertPolicies, src.AlertPolicies...)
				changed++
			}
		} else if m.AlertPolicies != nil {
			m.AlertPolicies = nil
			changed++
		}
	}
	if fmap.Has("43") {
		if m.QosSessionProfile != src.QosSessionProfile {
			m.QosSessionProfile = src.QosSessionProfile
			changed++
		}
	}
	if fmap.Has("44") {
		if m.QosSessionDuration != src.QosSessionDuration {
			m.QosSessionDuration = src.QosSessionDuration
			changed++
		}
	}
	if fmap.Has("45") {
		if m.GlobalId != src.GlobalId {
			m.GlobalId = src.GlobalId
			changed++
		}
	}
	if fmap.Has("46") {
		if src.CommandArgs != nil {
			if updateListAction == "add" {
				changed += m.AddCommandArgs(src.CommandArgs...)
			} else if updateListAction == "remove" {
				changed += m.RemoveCommandArgs(src.CommandArgs...)
			} else {
				m.CommandArgs = make([]string, 0)
				m.CommandArgs = append(m.CommandArgs, src.CommandArgs...)
				changed++
			}
		} else if m.CommandArgs != nil {
			m.CommandArgs = nil
			changed++
		}
	}
	if fmap.HasOrHasChild("47") {
		if src.EnvVars != nil {
			if updateListAction == "add" {
				for k0, v := range src.EnvVars {
					m.EnvVars[k0] = v
					changed++
				}
			} else if updateListAction == "remove" {
				for k0, _ := range src.EnvVars {
					if _, ok := m.EnvVars[k0]; ok {
						delete(m.EnvVars, k0)
						changed++
					}
				}
			} else {
				m.EnvVars = make(map[string]string)
				for k0, v := range src.EnvVars {
					m.EnvVars[k0] = v
				}
				changed++
			}
		} else if m.EnvVars != nil {
			m.EnvVars = nil
			changed++
		}
	}
	if fmap.HasOrHasChild("48") {
		if src.SecretEnvVars != nil {
			if updateListAction == "add" {
				for k0, v := range src.SecretEnvVars {
					m.SecretEnvVars[k0] = v
					changed++
				}
			} else if updateListAction == "remove" {
				for k0, _ := range src.SecretEnvVars {
					if _, ok := m.SecretEnvVars[k0]; ok {
						delete(m.SecretEnvVars, k0)
						changed++
					}
				}
			} else {
				m.SecretEnvVars = make(map[string]string)
				for k0, v := range src.SecretEnvVars {
					m.SecretEnvVars[k0] = v
				}
				changed++
			}
		} else if m.SecretEnvVars != nil {
			m.SecretEnvVars = nil
			changed++
		}
	}
	if fmap.Has("49") {
		if m.UpdateListAction != src.UpdateListAction {
			m.UpdateListAction = src.UpdateListAction
			changed++
		}
	}
	if fmap.HasOrHasChild("50") {
		if src.KubernetesResources != nil {
			if m.KubernetesResources == nil {
				m.KubernetesResources = &KubernetesResources{}
			}
			if fmap.HasOrHasChild("50.1") {
				if src.KubernetesResources.CpuPool != nil {
					if m.KubernetesResources.CpuPool == nil {
						m.KubernetesResources.CpuPool = &NodePoolResources{}
					}
					if fmap.HasOrHasChild("50.1.1") {
						if m.KubernetesResources.CpuPool.TotalVcpus.Whole != src.KubernetesResources.CpuPool.TotalVcpus.Whole {
							m.KubernetesResources.CpuPool.TotalVcpus.Whole = src.KubernetesResources.CpuPool.TotalVcpus.Whole
							changed++
						}
						if m.KubernetesResources.CpuPool.TotalVcpus.Nanos != src.KubernetesResources.CpuPool.TotalVcpus.Nanos {
							m.KubernetesResources.CpuPool.TotalVcpus.Nanos = src.KubernetesResources.CpuPool.TotalVcpus.Nanos
							changed++
						}
					}
					if fmap.Has("50.1.2") {
						if m.KubernetesResources.CpuPool.TotalMemory != src.KubernetesResources.CpuPool.TotalMemory {
							m.KubernetesResources.CpuPool.TotalMemory = src.KubernetesResources.CpuPool.TotalMemory
							changed++
						}
					}
					if fmap.Has("50.1.3") {
						if m.KubernetesResources.CpuPool.TotalDisk != src.KubernetesResources.CpuPool.TotalDisk {
							m.KubernetesResources.CpuPool.TotalDisk = src.KubernetesResources.CpuPool.TotalDisk
							changed++
						}
					}
					if fmap.HasOrHasChild("50.1.4") {
						if src.KubernetesResources.CpuPool.TotalOptRes != nil {
							if updateListAction == "add" {
								for k2, v := range src.KubernetesResources.CpuPool.TotalOptRes {
									m.KubernetesResources.CpuPool.TotalOptRes[k2] = v
									changed++
								}
							} else if updateListAction == "remove" {
								for k2, _ := range src.KubernetesResources.CpuPool.TotalOptRes {
									if _, ok := m.KubernetesResources.CpuPool.TotalOptRes[k2]; ok {
										delete(m.KubernetesResources.CpuPool.TotalOptRes, k2)
										changed++
									}
								}
							} else {
								m.KubernetesResources.CpuPool.TotalOptRes = make(map[string]string)
								for k2, v := range src.KubernetesResources.CpuPool.TotalOptRes {
									m.KubernetesResources.CpuPool.TotalOptRes[k2] = v
								}
								changed++
							}
						} else if m.KubernetesResources.CpuPool.TotalOptRes != nil {
							m.KubernetesResources.CpuPool.TotalOptRes = nil
							changed++
						}
					}
					if fmap.HasOrHasChild("50.1.5") {
						if fmap.Has("50.1.5.1") {
							if m.KubernetesResources.CpuPool.Topology.MinNodeVcpus != src.KubernetesResources.CpuPool.Topology.MinNodeVcpus {
								m.KubernetesResources.CpuPool.Topology.MinNodeVcpus = src.KubernetesResources.CpuPool.Topology.MinNodeVcpus
								changed++
							}
						}
						if fmap.Has("50.1.5.2") {
							if m.KubernetesResources.CpuPool.Topology.MinNodeMemory != src.KubernetesResources.CpuPool.Topology.MinNodeMemory {
								m.KubernetesResources.CpuPool.Topology.MinNodeMemory = src.KubernetesResources.CpuPool.Topology.MinNodeMemory
								changed++
							}
						}
						if fmap.Has("50.1.5.3") {
							if m.KubernetesResources.CpuPool.Topology.MinNodeDisk != src.KubernetesResources.CpuPool.Topology.MinNodeDisk {
								m.KubernetesResources.CpuPool.Topology.MinNodeDisk = src.KubernetesResources.CpuPool.Topology.MinNodeDisk
								changed++
							}
						}
						if fmap.HasOrHasChild("50.1.5.4") {
							if src.KubernetesResources.CpuPool.Topology.MinNodeOptRes != nil {
								if updateListAction == "add" {
									for k3, v := range src.KubernetesResources.CpuPool.Topology.MinNodeOptRes {
										m.KubernetesResources.CpuPool.Topology.MinNodeOptRes[k3] = v
										changed++
									}
								} else if updateListAction == "remove" {
									for k3, _ := range src.KubernetesResources.CpuPool.Topology.MinNodeOptRes {
										if _, ok := m.KubernetesResources.CpuPool.Topology.MinNodeOptRes[k3]; ok {
											delete(m.KubernetesResources.CpuPool.Topology.MinNodeOptRes, k3)
											changed++
										}
									}
								} else {
									m.KubernetesResources.CpuPool.Topology.MinNodeOptRes = make(map[string]string)
									for k3, v := range src.KubernetesResources.CpuPool.Topology.MinNodeOptRes {
										m.KubernetesResources.CpuPool.Topology.MinNodeOptRes[k3] = v
									}
									changed++
								}
							} else if m.KubernetesResources.CpuPool.Topology.MinNodeOptRes != nil {
								m.KubernetesResources.CpuPool.Topology.MinNodeOptRes = nil
								changed++
							}
						}
						if fmap.Has("50.1.5.5") {
							if m.KubernetesResources.CpuPool.Topology.MinNumberOfNodes != src.KubernetesResources.CpuPool.Topology.MinNumberOfNodes {
								m.KubernetesResources.CpuPool.Topology.MinNumberOfNodes = src.KubernetesResources.CpuPool.Topology.MinNumberOfNodes
								changed++
							}
						}
						if fmap.HasOrHasChild("50.1.5.6") {
							if src.KubernetesResources.CpuPool.Topology.MinNodeGpus != nil {
								if updateListAction == "add" {
									changed += m.AddKubernetesResourcesCpuPoolTopologyMinNodeGpus(src.KubernetesResources.CpuPool.Topology.MinNodeGpus...)
								} else if updateListAction == "remove" {
									changed += m.RemoveKubernetesResourcesCpuPoolTopologyMinNodeGpus(src.KubernetesResources.CpuPool.Topology.MinNodeGpus...)
								} else {
									m.KubernetesResources.CpuPool.Topology.MinNodeGpus = make([]*GPUResource, 0)
									for k3, _ := range src.KubernetesResources.CpuPool.Topology.MinNodeGpus {
										m.KubernetesResources.CpuPool.Topology.MinNodeGpus = append(m.KubernetesResources.CpuPool.Topology.MinNodeGpus, src.KubernetesResources.CpuPool.Topology.MinNodeGpus[k3].Clone())
									}
									changed++
								}
							} else if m.KubernetesResources.CpuPool.Topology.MinNodeGpus != nil {
								m.KubernetesResources.CpuPool.Topology.MinNodeGpus = nil
								changed++
							}
						}
					}
					if fmap.HasOrHasChild("50.1.6") {
						if src.KubernetesResources.CpuPool.TotalGpus != nil {
							if updateListAction == "add" {
								changed += m.AddKubernetesResourcesCpuPoolTotalGpus(src.KubernetesResources.CpuPool.TotalGpus...)
							} else if updateListAction == "remove" {
								changed += m.RemoveKubernetesResourcesCpuPoolTotalGpus(src.KubernetesResources.CpuPool.TotalGpus...)
							} else {
								m.KubernetesResources.CpuPool.TotalGpus = make([]*GPUResource, 0)
								for k2, _ := range src.KubernetesResources.CpuPool.TotalGpus {
									m.KubernetesResources.CpuPool.TotalGpus = append(m.KubernetesResources.CpuPool.TotalGpus, src.KubernetesResources.CpuPool.TotalGpus[k2].Clone())
								}
								changed++
							}
						} else if m.KubernetesResources.CpuPool.TotalGpus != nil {
							m.KubernetesResources.CpuPool.TotalGpus = nil
							changed++
						}
					}
				} else if m.KubernetesResources.CpuPool != nil {
					m.KubernetesResources.CpuPool = nil
					changed++
				}
			}
			if fmap.HasOrHasChild("50.2") {
				if src.KubernetesResources.GpuPool != nil {
					if m.KubernetesResources.GpuPool == nil {
						m.KubernetesResources.GpuPool = &NodePoolResources{}
					}
					if fmap.HasOrHasChild("50.2.1") {
						if m.KubernetesResources.GpuPool.TotalVcpus.Whole != src.KubernetesResources.GpuPool.TotalVcpus.Whole {
							m.KubernetesResources.GpuPool.TotalVcpus.Whole = src.KubernetesResources.GpuPool.TotalVcpus.Whole
							changed++
						}
						if m.KubernetesResources.GpuPool.TotalVcpus.Nanos != src.KubernetesResources.GpuPool.TotalVcpus.Nanos {
							m.KubernetesResources.GpuPool.TotalVcpus.Nanos = src.KubernetesResources.GpuPool.TotalVcpus.Nanos
							changed++
						}
					}
					if fmap.Has("50.2.2") {
						if m.KubernetesResources.GpuPool.TotalMemory != src.KubernetesResources.GpuPool.TotalMemory {
							m.KubernetesResources.GpuPool.TotalMemory = src.KubernetesResources.GpuPool.TotalMemory
							changed++
						}
					}
					if fmap.Has("50.2.3") {
						if m.KubernetesResources.GpuPool.TotalDisk != src.KubernetesResources.GpuPool.TotalDisk {
							m.KubernetesResources.GpuPool.TotalDisk = src.KubernetesResources.GpuPool.TotalDisk
							changed++
						}
					}
					if fmap.HasOrHasChild("50.2.4") {
						if src.KubernetesResources.GpuPool.TotalOptRes != nil {
							if updateListAction == "add" {
								for k2, v := range src.KubernetesResources.GpuPool.TotalOptRes {
									m.KubernetesResources.GpuPool.TotalOptRes[k2] = v
									changed++
								}
							} else if updateListAction == "remove" {
								for k2, _ := range src.KubernetesResources.GpuPool.TotalOptRes {
									if _, ok := m.KubernetesResources.GpuPool.TotalOptRes[k2]; ok {
										delete(m.KubernetesResources.GpuPool.TotalOptRes, k2)
										changed++
									}
								}
							} else {
								m.KubernetesResources.GpuPool.TotalOptRes = make(map[string]string)
								for k2, v := range src.KubernetesResources.GpuPool.TotalOptRes {
									m.KubernetesResources.GpuPool.TotalOptRes[k2] = v
								}
								changed++
							}
						} else if m.KubernetesResources.GpuPool.TotalOptRes != nil {
							m.KubernetesResources.GpuPool.TotalOptRes = nil
							changed++
						}
					}
					if fmap.HasOrHasChild("50.2.5") {
						if fmap.Has("50.2.5.1") {
							if m.KubernetesResources.GpuPool.Topology.MinNodeVcpus != src.KubernetesResources.GpuPool.Topology.MinNodeVcpus {
								m.KubernetesResources.GpuPool.Topology.MinNodeVcpus = src.KubernetesResources.GpuPool.Topology.MinNodeVcpus
								changed++
							}
						}
						if fmap.Has("50.2.5.2") {
							if m.KubernetesResources.GpuPool.Topology.MinNodeMemory != src.KubernetesResources.GpuPool.Topology.MinNodeMemory {
								m.KubernetesResources.GpuPool.Topology.MinNodeMemory = src.KubernetesResources.GpuPool.Topology.MinNodeMemory
								changed++
							}
						}
						if fmap.Has("50.2.5.3") {
							if m.KubernetesResources.GpuPool.Topology.MinNodeDisk != src.KubernetesResources.GpuPool.Topology.MinNodeDisk {
								m.KubernetesResources.GpuPool.Topology.MinNodeDisk = src.KubernetesResources.GpuPool.Topology.MinNodeDisk
								changed++
							}
						}
						if fmap.HasOrHasChild("50.2.5.4") {
							if src.KubernetesResources.GpuPool.Topology.MinNodeOptRes != nil {
								if updateListAction == "add" {
									for k3, v := range src.KubernetesResources.GpuPool.Topology.MinNodeOptRes {
										m.KubernetesResources.GpuPool.Topology.MinNodeOptRes[k3] = v
										changed++
									}
								} else if updateListAction == "remove" {
									for k3, _ := range src.KubernetesResources.GpuPool.Topology.MinNodeOptRes {
										if _, ok := m.KubernetesResources.GpuPool.Topology.MinNodeOptRes[k3]; ok {
											delete(m.KubernetesResources.GpuPool.Topology.MinNodeOptRes, k3)
											changed++
										}
									}
								} else {
									m.KubernetesResources.GpuPool.Topology.MinNodeOptRes = make(map[string]string)
									for k3, v := range src.KubernetesResources.GpuPool.Topology.MinNodeOptRes {
										m.KubernetesResources.GpuPool.Topology.MinNodeOptRes[k3] = v
									}
									changed++
								}
							} else if m.KubernetesResources.GpuPool.Topology.MinNodeOptRes != nil {
								m.KubernetesResources.GpuPool.Topology.MinNodeOptRes = nil
								changed++
							}
						}
						if fmap.Has("50.2.5.5") {
							if m.KubernetesResources.GpuPool.Topology.MinNumberOfNodes != src.KubernetesResources.GpuPool.Topology.MinNumberOfNodes {
								m.KubernetesResources.GpuPool.Topology.MinNumberOfNodes = src.KubernetesResources.GpuPool.Topology.MinNumberOfNodes
								changed++
							}
						}
						if fmap.HasOrHasChild("50.2.5.6") {
							if src.KubernetesResources.GpuPool.Topology.MinNodeGpus != nil {
								if updateListAction == "add" {
									changed += m.AddKubernetesResourcesGpuPoolTopologyMinNodeGpus(src.KubernetesResources.GpuPool.Topology.MinNodeGpus...)
								} else if updateListAction == "remove" {
									changed += m.RemoveKubernetesResourcesGpuPoolTopologyMinNodeGpus(src.KubernetesResources.GpuPool.Topology.MinNodeGpus...)
								} else {
									m.KubernetesResources.GpuPool.Topology.MinNodeGpus = make([]*GPUResource, 0)
									for k3, _ := range src.KubernetesResources.GpuPool.Topology.MinNodeGpus {
										m.KubernetesResources.GpuPool.Topology.MinNodeGpus = append(m.KubernetesResources.GpuPool.Topology.MinNodeGpus, src.KubernetesResources.GpuPool.Topology.MinNodeGpus[k3].Clone())
									}
									changed++
								}
							} else if m.KubernetesResources.GpuPool.Topology.MinNodeGpus != nil {
								m.KubernetesResources.GpuPool.Topology.MinNodeGpus = nil
								changed++
							}
						}
					}
					if fmap.HasOrHasChild("50.2.6") {
						if src.KubernetesResources.GpuPool.TotalGpus != nil {
							if updateListAction == "add" {
								changed += m.AddKubernetesResourcesGpuPoolTotalGpus(src.KubernetesResources.GpuPool.TotalGpus...)
							} else if updateListAction == "remove" {
								changed += m.RemoveKubernetesResourcesGpuPoolTotalGpus(src.KubernetesResources.GpuPool.TotalGpus...)
							} else {
								m.KubernetesResources.GpuPool.TotalGpus = make([]*GPUResource, 0)
								for k2, _ := range src.KubernetesResources.GpuPool.TotalGpus {
									m.KubernetesResources.GpuPool.TotalGpus = append(m.KubernetesResources.GpuPool.TotalGpus, src.KubernetesResources.GpuPool.TotalGpus[k2].Clone())
								}
								changed++
							}
						} else if m.KubernetesResources.GpuPool.TotalGpus != nil {
							m.KubernetesResources.GpuPool.TotalGpus = nil
							changed++
						}
					}
				} else if m.KubernetesResources.GpuPool != nil {
					m.KubernetesResources.GpuPool = nil
					changed++
				}
			}
			if fmap.Has("50.4") {
				if m.KubernetesResources.MinKubernetesVersion != src.KubernetesResources.MinKubernetesVersion {
					m.KubernetesResources.MinKubernetesVersion = src.KubernetesResources.MinKubernetesVersion
					changed++
				}
			}
		} else if m.KubernetesResources != nil {
			m.KubernetesResources = nil
			changed++
		}
	}
	if fmap.HasOrHasChild("51") {
		if src.NodeResources != nil {
			if m.NodeResources == nil {
				m.NodeResources = &NodeResources{}
			}
			if fmap.Has("51.1") {
				if m.NodeResources.Vcpus != src.NodeResources.Vcpus {
					m.NodeResources.Vcpus = src.NodeResources.Vcpus
					changed++
				}
			}
			if fmap.Has("51.2") {
				if m.NodeResources.Ram != src.NodeResources.Ram {
					m.NodeResources.Ram = src.NodeResources.Ram
					changed++
				}
			}
			if fmap.Has("51.3") {
				if m.NodeResources.Disk != src.NodeResources.Disk {
					m.NodeResources.Disk = src.NodeResources.Disk
					changed++
				}
			}
			if fmap.HasOrHasChild("51.4") {
				if src.NodeResources.OptResMap != nil {
					if updateListAction == "add" {
						for k1, v := range src.NodeResources.OptResMap {
							m.NodeResources.OptResMap[k1] = v
							changed++
						}
					} else if updateListAction == "remove" {
						for k1, _ := range src.NodeResources.OptResMap {
							if _, ok := m.NodeResources.OptResMap[k1]; ok {
								delete(m.NodeResources.OptResMap, k1)
								changed++
							}
						}
					} else {
						m.NodeResources.OptResMap = make(map[string]string)
						for k1, v := range src.NodeResources.OptResMap {
							m.NodeResources.OptResMap[k1] = v
						}
						changed++
					}
				} else if m.NodeResources.OptResMap != nil {
					m.NodeResources.OptResMap = nil
					changed++
				}
			}
			if fmap.Has("51.5") {
				if m.NodeResources.InfraNodeFlavor != src.NodeResources.InfraNodeFlavor {
					m.NodeResources.InfraNodeFlavor = src.NodeResources.InfraNodeFlavor
					changed++
				}
			}
			if fmap.Has("51.6") {
				if m.NodeResources.ExternalVolumeSize != src.NodeResources.ExternalVolumeSize {
					m.NodeResources.ExternalVolumeSize = src.NodeResources.ExternalVolumeSize
					changed++
				}
			}
			if fmap.HasOrHasChild("51.7") {
				if src.NodeResources.Gpus != nil {
					if updateListAction == "add" {
						changed += m.AddNodeResourcesGpus(src.NodeResources.Gpus...)
					} else if updateListAction == "remove" {
						changed += m.RemoveNodeResourcesGpus(src.NodeResources.Gpus...)
					} else {
						m.NodeResources.Gpus = make([]*GPUResource, 0)
						for k1, _ := range src.NodeResources.Gpus {
							m.NodeResources.Gpus = append(m.NodeResources.Gpus, src.NodeResources.Gpus[k1].Clone())
						}
						changed++
					}
				} else if m.NodeResources.Gpus != nil {
					m.NodeResources.Gpus = nil
					changed++
				}
			}
		} else if m.NodeResources != nil {
			m.NodeResources = nil
			changed++
		}
	}
	if fmap.Has("52") {
		if m.ObjId != src.ObjId {
			m.ObjId = src.ObjId
			changed++
		}
	}
	if fmap.HasOrHasChild("53") {
		if src.AppAnnotations != nil {
			if updateListAction == "add" {
				for k0, v := range src.AppAnnotations {
					m.AppAnnotations[k0] = v
					changed++
				}
			} else if updateListAction == "remove" {
				for k0, _ := range src.AppAnnotations {
					if _, ok := m.AppAnnotations[k0]; ok {
						delete(m.AppAnnotations, k0)
						changed++
					}
				}
			} else {
				m.AppAnnotations = make(map[string]string)
				for k0, v := range src.AppAnnotations {
					m.AppAnnotations[k0] = v
				}
				changed++
			}
		} else if m.AppAnnotations != nil {
			m.AppAnnotations = nil
			changed++
		}
	}
	if fmap.Has("54") {
		if m.IsStandalone != src.IsStandalone {
			m.IsStandalone = src.IsStandalone
			changed++
		}
	}
	if fmap.Has("55") {
		if m.ManagesOwnNamespaces != src.ManagesOwnNamespaces {
			m.ManagesOwnNamespaces = src.ManagesOwnNamespaces
			changed++
		}
	}
	if fmap.Has("56") {
		if m.CompatibilityVersion != src.CompatibilityVersion {
			m.CompatibilityVersion = src.CompatibilityVersion
			changed++
		}
	}
	if fmap.Has("57") {
		if m.Username != src.Username {
			m.Username = src.Username
			changed++
		}
	}
	if fmap.Has("58") {
		if m.Credentials != src.Credentials {
			m.Credentials = src.Credentials
			changed++
		}
	}
	if fmap.HasOrHasChild("100") {
		if src.Tags != nil {
			if updateListAction == "add" {
				for k0, v := range src.Tags {
					m.Tags[k0] = v
					changed++
				}
			} else if updateListAction == "remove" {
				for k0, _ := range src.Tags {
					if _, ok := m.Tags[k0]; ok {
						delete(m.Tags, k0)
						changed++
					}
				}
			} else {
				m.Tags = make(map[string]string)
				for k0, v := range src.Tags {
					m.Tags[k0] = v
				}
				changed++
			}
		} else if m.Tags != nil {
			m.Tags = nil
			changed++
		}
	}
	return changed
}

func (m *App) DeepCopyIn(src *App) {
	m.Key.DeepCopyIn(&src.Key)
	m.ImagePath = src.ImagePath
	m.ImageType = src.ImageType
	m.AccessPorts = src.AccessPorts
	m.DefaultFlavor.DeepCopyIn(&src.DefaultFlavor)
	m.AuthPublicKey = src.AuthPublicKey
	m.Command = src.Command
	m.Annotations = src.Annotations
	m.Deployment = src.Deployment
	m.DeploymentManifest = src.DeploymentManifest
	m.DeploymentGenerator = src.DeploymentGenerator
	m.AndroidPackageName = src.AndroidPackageName
	m.DelOpt = src.DelOpt
	if src.Configs != nil {
		m.Configs = make([]*ConfigFile, len(src.Configs), len(src.Configs))
		for ii, s := range src.Configs {
			var tmp_s ConfigFile
			tmp_s.DeepCopyIn(s)
			m.Configs[ii] = &tmp_s
		}
	} else {
		m.Configs = nil
	}
	m.ScaleWithCluster = src.ScaleWithCluster
	m.InternalPorts = src.InternalPorts
	m.Revision = src.Revision
	m.OfficialFqdn = src.OfficialFqdn
	m.Md5Sum = src.Md5Sum
	m.AutoProvPolicy = src.AutoProvPolicy
	m.AccessType = src.AccessType
	m.DeletePrepare = src.DeletePrepare
	if src.AutoProvPolicies != nil {
		m.AutoProvPolicies = make([]string, len(src.AutoProvPolicies), len(src.AutoProvPolicies))
		for ii, s := range src.AutoProvPolicies {
			m.AutoProvPolicies[ii] = s
		}
	} else {
		m.AutoProvPolicies = nil
	}
	m.TemplateDelimiter = src.TemplateDelimiter
	m.SkipHcPorts = src.SkipHcPorts
	m.CreatedAt = src.CreatedAt
	m.UpdatedAt = src.UpdatedAt
	m.Trusted = src.Trusted
	if src.RequiredOutboundConnections != nil {
		m.RequiredOutboundConnections = make([]SecurityRule, len(src.RequiredOutboundConnections), len(src.RequiredOutboundConnections))
		for ii, s := range src.RequiredOutboundConnections {
			m.RequiredOutboundConnections[ii].DeepCopyIn(&s)
		}
	} else {
		m.RequiredOutboundConnections = nil
	}
	m.AllowServerless = src.AllowServerless
	if src.ServerlessConfig != nil {
		var tmp_ServerlessConfig ServerlessConfig
		tmp_ServerlessConfig.DeepCopyIn(src.ServerlessConfig)
		m.ServerlessConfig = &tmp_ServerlessConfig
	} else {
		m.ServerlessConfig = nil
	}
	m.VmAppOsType = src.VmAppOsType
	if src.AlertPolicies != nil {
		m.AlertPolicies = make([]string, len(src.AlertPolicies), len(src.AlertPolicies))
		for ii, s := range src.AlertPolicies {
			m.AlertPolicies[ii] = s
		}
	} else {
		m.AlertPolicies = nil
	}
	m.QosSessionProfile = src.QosSessionProfile
	m.QosSessionDuration = src.QosSessionDuration
	m.GlobalId = src.GlobalId
	if src.CommandArgs != nil {
		m.CommandArgs = make([]string, len(src.CommandArgs), len(src.CommandArgs))
		for ii, s := range src.CommandArgs {
			m.CommandArgs[ii] = s
		}
	} else {
		m.CommandArgs = nil
	}
	if src.EnvVars != nil {
		m.EnvVars = make(map[string]string)
		for k, v := range src.EnvVars {
			m.EnvVars[k] = v
		}
	} else {
		m.EnvVars = nil
	}
	if src.SecretEnvVars != nil {
		m.SecretEnvVars = make(map[string]string)
		for k, v := range src.SecretEnvVars {
			m.SecretEnvVars[k] = v
		}
	} else {
		m.SecretEnvVars = nil
	}
	m.UpdateListAction = src.UpdateListAction
	if src.KubernetesResources != nil {
		var tmp_KubernetesResources KubernetesResources
		tmp_KubernetesResources.DeepCopyIn(src.KubernetesResources)
		m.KubernetesResources = &tmp_KubernetesResources
	} else {
		m.KubernetesResources = nil
	}
	if src.NodeResources != nil {
		var tmp_NodeResources NodeResources
		tmp_NodeResources.DeepCopyIn(src.NodeResources)
		m.NodeResources = &tmp_NodeResources
	} else {
		m.NodeResources = nil
	}
	m.ObjId = src.ObjId
	if src.AppAnnotations != nil {
		m.AppAnnotations = make(map[string]string)
		for k, v := range src.AppAnnotations {
			m.AppAnnotations[k] = v
		}
	} else {
		m.AppAnnotations = nil
	}
	m.IsStandalone = src.IsStandalone
	m.ManagesOwnNamespaces = src.ManagesOwnNamespaces
	m.CompatibilityVersion = src.CompatibilityVersion
	m.Username = src.Username
	m.Credentials = src.Credentials
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k, v := range src.Tags {
			m.Tags[k] = v
		}
	} else {
		m.Tags = nil
	}
}

func (s *App) HasFields() bool {
	return true
}

type AppStore interface {
	Create(ctx context.Context, m *App, wait func(int64)) (*Result, error)
	Update(ctx context.Context, m *App, wait func(int64)) (*Result, error)
	Delete(ctx context.Context, m *App, wait func(int64)) (*Result, error)
	Put(ctx context.Context, m *App, wait func(int64), ops ...objstore.KVOp) (*Result, error)
	LoadOne(key string) (*App, int64, error)
	Get(ctx context.Context, key *AppKey, buf *App) bool
	STMGet(stm concurrency.STM, key *AppKey, buf *App) bool
	STMPut(stm concurrency.STM, obj *App, ops ...objstore.KVOp)
	STMDel(stm concurrency.STM, key *AppKey)
	STMHas(stm concurrency.STM, key *AppKey) bool
}

type AppStoreImpl struct {
	kvstore objstore.KVStore
}

func NewAppStore(kvstore objstore.KVStore) *AppStoreImpl {
	return &AppStoreImpl{kvstore: kvstore}
}

func (s *AppStoreImpl) Create(ctx context.Context, m *App, wait func(int64)) (*Result, error) {
	err := m.Validate(AppAllFieldsMap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("App", m.GetKey())
	val, err := json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Create(ctx, key, string(val))
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *AppStoreImpl) Update(ctx context.Context, m *App, wait func(int64)) (*Result, error) {
	fmap := MakeFieldMap(m.Fields)
	err := m.Validate(fmap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("App", m.GetKey())
	var vers int64 = 0
	curBytes, vers, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, err
	}
	var cur App
	err = json.Unmarshal(curBytes, &cur)
	if err != nil {
		return nil, err
	}
	cur.CopyInFields(m)
	// never save fields
	cur.Fields = nil
	val, err := json.Marshal(cur)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Update(ctx, key, string(val), vers)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *AppStoreImpl) Put(ctx context.Context, m *App, wait func(int64), ops ...objstore.KVOp) (*Result, error) {
	err := m.Validate(AppAllFieldsMap)
	m.Fields = nil
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("App", m.GetKey())
	var val []byte
	val, err = json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Put(ctx, key, string(val), ops...)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *AppStoreImpl) Delete(ctx context.Context, m *App, wait func(int64)) (*Result, error) {
	err := m.GetKey().ValidateKey()
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("App", m.GetKey())
	rev, err := s.kvstore.Delete(ctx, key)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *AppStoreImpl) LoadOne(key string) (*App, int64, error) {
	val, rev, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, 0, err
	}
	var obj App
	err = json.Unmarshal(val, &obj)
	if err != nil {
		log.DebugLog(log.DebugLevelApi, "Failed to parse App data", "val", string(val), "err", err)
		return nil, 0, err
	}
	return &obj, rev, nil
}

func (s *AppStoreImpl) Get(ctx context.Context, key *AppKey, buf *App) bool {
	keystr := objstore.DbKeyString("App", key)
	val, _, _, err := s.kvstore.Get(keystr)
	if err != nil {
		return false
	}
	return s.parseGetData(val, buf)
}

func (s *AppStoreImpl) STMGet(stm concurrency.STM, key *AppKey, buf *App) bool {
	keystr := objstore.DbKeyString("App", key)
	valstr := stm.Get(keystr)
	return s.parseGetData([]byte(valstr), buf)
}

func (s *AppStoreImpl) STMHas(stm concurrency.STM, key *AppKey) bool {
	keystr := objstore.DbKeyString("App", key)
	return stm.Get(keystr) != ""
}

func (s *AppStoreImpl) parseGetData(val []byte, buf *App) bool {
	if len(val) == 0 {
		return false
	}
	if buf != nil {
		// clear buf, because empty values in val won't
		// overwrite non-empty values in buf.
		*buf = App{}
		err := json.Unmarshal(val, buf)
		if err != nil {
			return false
		}
	}
	return true
}

func (s *AppStoreImpl) STMPut(stm concurrency.STM, obj *App, ops ...objstore.KVOp) {
	keystr := objstore.DbKeyString("App", obj.GetKey())

	val, err := json.Marshal(obj)
	if err != nil {
		log.InfoLog("App json marshal failed", "obj", obj, "err", err)
	}
	v3opts := GetSTMOpts(ops...)
	stm.Put(keystr, string(val), v3opts...)
}

func (s *AppStoreImpl) STMDel(stm concurrency.STM, key *AppKey) {
	keystr := objstore.DbKeyString("App", key)
	stm.Del(keystr)
}

func StoreListApp(ctx context.Context, kvstore objstore.KVStore) ([]App, error) {
	keyPrefix := objstore.DbKeyPrefixString("App") + "/"
	objs := []App{}
	err := kvstore.List(keyPrefix, func(key, val []byte, rev, modRev int64) error {
		obj := App{}
		err := json.Unmarshal(val, &obj)
		if err != nil {
			return fmt.Errorf("failed to unmarshal App json %s, %s", string(val), err)
		}
		objs = append(objs, obj)
		return nil
	})
	return objs, err
}

type AppKeyWatcher struct {
	cb func(ctx context.Context)
}

type AppCacheData struct {
	Obj    *App
	ModRev int64
}

func (s *AppCacheData) Clone() *AppCacheData {
	cp := AppCacheData{}
	if s.Obj != nil {
		cp.Obj = &App{}
		cp.Obj.DeepCopyIn(s.Obj)
	}
	cp.ModRev = s.ModRev
	return &cp
}

// AppCache caches App objects in memory in a hash table
// and keeps them in sync with the database.
type AppCache struct {
	Objs          map[AppKey]*AppCacheData
	Mux           util.Mutex
	List          map[AppKey]struct{}
	FlushAll      bool
	NotifyCbs     []func(ctx context.Context, obj *App, modRev int64)
	UpdatedCbs    []func(ctx context.Context, old *App, new *App)
	DeletedCbs    []func(ctx context.Context, old *App)
	KeyWatchers   map[AppKey][]*AppKeyWatcher
	UpdatedKeyCbs []func(ctx context.Context, key *AppKey)
	DeletedKeyCbs []func(ctx context.Context, key *AppKey)
	Store         AppStore
}

func NewAppCache() *AppCache {
	cache := AppCache{}
	InitAppCache(&cache)
	return &cache
}

func InitAppCache(cache *AppCache) {
	cache.Objs = make(map[AppKey]*AppCacheData)
	cache.KeyWatchers = make(map[AppKey][]*AppKeyWatcher)
	cache.NotifyCbs = nil
	cache.UpdatedCbs = nil
	cache.DeletedCbs = nil
	cache.UpdatedKeyCbs = nil
	cache.DeletedKeyCbs = nil
}

func (c *AppCache) GetTypeString() string {
	return "App"
}

func (c *AppCache) Get(key *AppKey, valbuf *App) bool {
	var modRev int64
	return c.GetWithRev(key, valbuf, &modRev)
}

// STMGet gets from the store if STM is set, otherwise gets from cache
func (c *AppCache) STMGet(ostm *OptionalSTM, key *AppKey, valbuf *App) bool {
	if ostm.stm != nil {
		if c.Store == nil {
			// panic, otherwise if we fallback to cache, we may silently
			// introduce race conditions and intermittent failures due to
			// reading from cache during a transaction.
			panic("AppCache store not set, cannot read via STM")
		}
		return c.Store.STMGet(ostm.stm, key, valbuf)
	}
	var modRev int64
	return c.GetWithRev(key, valbuf, &modRev)
}

func (c *AppCache) GetWithRev(key *AppKey, valbuf *App, modRev *int64) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	inst, found := c.Objs[*key]
	if found {
		valbuf.DeepCopyIn(inst.Obj)
		*modRev = inst.ModRev
	}
	return found
}

func (c *AppCache) HasKey(key *AppKey) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	_, found := c.Objs[*key]
	return found
}

func (c *AppCache) GetAllKeys(ctx context.Context, cb func(key *AppKey, modRev int64)) {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for key, data := range c.Objs {
		cb(&key, data.ModRev)
	}
}

func (c *AppCache) GetAllLocked(ctx context.Context, cb func(obj *App, modRev int64)) {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for _, data := range c.Objs {
		cb(data.Obj, data.ModRev)
	}
}

func (c *AppCache) Update(ctx context.Context, in *App, modRev int64) {
	c.UpdateModFunc(ctx, in.GetKey(), modRev, func(old *App) (*App, bool) {
		return in, true
	})
}

func (c *AppCache) UpdateModFunc(ctx context.Context, key *AppKey, modRev int64, modFunc func(old *App) (new *App, changed bool)) {
	c.Mux.Lock()
	var old *App
	if oldData, found := c.Objs[*key]; found {
		old = oldData.Obj
	}
	new, changed := modFunc(old)
	if !changed {
		c.Mux.Unlock()
		return
	}
	if len(c.UpdatedCbs) > 0 || len(c.NotifyCbs) > 0 {
		newCopy := &App{}
		newCopy.DeepCopyIn(new)
		for _, cb := range c.UpdatedCbs {
			defer cb(ctx, old, newCopy)
		}
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				defer cb(ctx, newCopy, modRev)
			}
		}
	}
	for _, cb := range c.UpdatedKeyCbs {
		defer cb(ctx, key)
	}
	store := &App{}
	store.DeepCopyIn(new)
	c.Objs[new.GetKeyVal()] = &AppCacheData{
		Obj:    store,
		ModRev: modRev,
	}
	log.SpanLog(ctx, log.DebugLevelApi, "cache update", "new", store)
	c.Mux.Unlock()
	c.TriggerKeyWatchers(ctx, new.GetKey())
}

func (c *AppCache) Delete(ctx context.Context, in *App, modRev int64) {
	c.DeleteCondFunc(ctx, in, modRev, func(old *App) bool {
		return true
	})
}

func (c *AppCache) DeleteCondFunc(ctx context.Context, in *App, modRev int64, condFunc func(old *App) bool) {
	c.Mux.Lock()
	var old *App
	oldData, found := c.Objs[in.GetKeyVal()]
	if found {
		old = oldData.Obj
		if !condFunc(old) {
			c.Mux.Unlock()
			return
		}
	}
	delete(c.Objs, in.GetKeyVal())
	log.SpanLog(ctx, log.DebugLevelApi, "cache delete", "key", in.GetKeyVal())
	c.Mux.Unlock()
	obj := old
	if obj == nil {
		obj = in
	}
	for _, cb := range c.NotifyCbs {
		if cb != nil {
			cb(ctx, obj, modRev)
		}
	}
	if old != nil {
		for _, cb := range c.DeletedCbs {
			cb(ctx, old)
		}
	}
	for _, cb := range c.DeletedKeyCbs {
		cb(ctx, in.GetKey())
	}
	c.TriggerKeyWatchers(ctx, in.GetKey())
}

func (c *AppCache) Prune(ctx context.Context, validKeys map[AppKey]struct{}) {
	log.SpanLog(ctx, log.DebugLevelApi, "Prune App", "numValidKeys", len(validKeys))
	notify := make(map[AppKey]*AppCacheData)
	c.Mux.Lock()
	for key, _ := range c.Objs {
		if _, ok := validKeys[key]; !ok {
			if len(c.NotifyCbs) > 0 || len(c.DeletedKeyCbs) > 0 || len(c.DeletedCbs) > 0 {
				notify[key] = c.Objs[key]
			}
			delete(c.Objs, key)
		}
	}
	c.Mux.Unlock()
	for key, old := range notify {
		obj := old.Obj
		if obj == nil {
			obj = &App{}
			obj.SetKey(&key)
		}
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, obj, old.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if old.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, old.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (c *AppCache) GetCount() int {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	return len(c.Objs)
}

func (c *AppCache) Flush(ctx context.Context, notifyId int64) {
}

func (c *AppCache) Show(filter *App, cb func(ret *App) error) error {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for _, data := range c.Objs {
		if !data.Obj.Matches(filter, MatchFilter()) {
			continue
		}
		err := cb(data.Obj)
		if err != nil {
			return err
		}
	}
	return nil
}

func AppGenericNotifyCb(fn func(key *AppKey, old *App)) func(objstore.ObjKey, objstore.Obj) {
	return func(objkey objstore.ObjKey, obj objstore.Obj) {
		fn(objkey.(*AppKey), obj.(*App))
	}
}

func (c *AppCache) SetNotifyCb(fn func(ctx context.Context, obj *App, modRev int64)) {
	c.NotifyCbs = []func(ctx context.Context, obj *App, modRev int64){fn}
}

func (c *AppCache) SetUpdatedCb(fn func(ctx context.Context, old *App, new *App)) {
	c.UpdatedCbs = []func(ctx context.Context, old *App, new *App){fn}
}

func (c *AppCache) SetDeletedCb(fn func(ctx context.Context, old *App)) {
	c.DeletedCbs = []func(ctx context.Context, old *App){fn}
}

func (c *AppCache) SetUpdatedKeyCb(fn func(ctx context.Context, key *AppKey)) {
	c.UpdatedKeyCbs = []func(ctx context.Context, key *AppKey){fn}
}

func (c *AppCache) SetDeletedKeyCb(fn func(ctx context.Context, key *AppKey)) {
	c.DeletedKeyCbs = []func(ctx context.Context, key *AppKey){fn}
}

func (c *AppCache) AddUpdatedCb(fn func(ctx context.Context, old *App, new *App)) {
	c.UpdatedCbs = append(c.UpdatedCbs, fn)
}

func (c *AppCache) AddDeletedCb(fn func(ctx context.Context, old *App)) {
	c.DeletedCbs = append(c.DeletedCbs, fn)
}

func (c *AppCache) AddNotifyCb(fn func(ctx context.Context, obj *App, modRev int64)) {
	c.NotifyCbs = append(c.NotifyCbs, fn)
}

func (c *AppCache) AddUpdatedKeyCb(fn func(ctx context.Context, key *AppKey)) {
	c.UpdatedKeyCbs = append(c.UpdatedKeyCbs, fn)
}

func (c *AppCache) AddDeletedKeyCb(fn func(ctx context.Context, key *AppKey)) {
	c.DeletedKeyCbs = append(c.DeletedKeyCbs, fn)
}

func (c *AppCache) SetFlushAll() {
	c.FlushAll = true
}

func (c *AppCache) WatchKey(key *AppKey, cb func(ctx context.Context)) context.CancelFunc {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	list, ok := c.KeyWatchers[*key]
	if !ok {
		list = make([]*AppKeyWatcher, 0)
	}
	watcher := AppKeyWatcher{cb: cb}
	c.KeyWatchers[*key] = append(list, &watcher)
	log.DebugLog(log.DebugLevelApi, "Watching App", "key", key)
	return func() {
		c.Mux.Lock()
		defer c.Mux.Unlock()
		list, ok := c.KeyWatchers[*key]
		if !ok {
			return
		}
		for ii, _ := range list {
			if list[ii] != &watcher {
				continue
			}
			if len(list) == 1 {
				delete(c.KeyWatchers, *key)
				return
			}
			list[ii] = list[len(list)-1]
			list[len(list)-1] = nil
			c.KeyWatchers[*key] = list[:len(list)-1]
			return
		}
	}
}

func (c *AppCache) TriggerKeyWatchers(ctx context.Context, key *AppKey) {
	watchers := make([]*AppKeyWatcher, 0)
	c.Mux.Lock()
	if list, ok := c.KeyWatchers[*key]; ok {
		watchers = append(watchers, list...)
	}
	c.Mux.Unlock()
	for ii, _ := range watchers {
		watchers[ii].cb(ctx)
	}
}

// Note that we explicitly ignore the global revision number, because of the way
// the notify framework sends updates (by hashing keys and doing lookups, instead
// of sequentially through a history buffer), updates may be done out-of-order
// or multiple updates compressed into one update, so the state of the cache at
// any point in time may not by in sync with a particular database revision number.

func (c *AppCache) SyncUpdate(ctx context.Context, key, val []byte, rev, modRev int64) {
	obj := App{}
	err := json.Unmarshal(val, &obj)
	if err != nil {
		log.WarnLog("Failed to parse App data", "val", string(val), "err", err)
		return
	}
	c.Update(ctx, &obj, modRev)
	c.Mux.Lock()
	if c.List != nil {
		c.List[obj.GetKeyVal()] = struct{}{}
	}
	c.Mux.Unlock()
}

func (c *AppCache) SyncDelete(ctx context.Context, key []byte, rev, modRev int64) {
	obj := App{}
	keystr := objstore.DbKeyPrefixRemove(string(key))
	AppKeyStringParse(keystr, obj.GetKey())
	c.Delete(ctx, &obj, modRev)
}

func (c *AppCache) SyncListStart(ctx context.Context) {
	c.List = make(map[AppKey]struct{})
}

func (c *AppCache) SyncListEnd(ctx context.Context) {
	deleted := make(map[AppKey]*AppCacheData)
	c.Mux.Lock()
	for key, val := range c.Objs {
		if _, found := c.List[key]; !found {
			deleted[key] = val
			delete(c.Objs, key)
		}
	}
	c.List = nil
	c.Mux.Unlock()
	for key, val := range deleted {
		obj := val.Obj
		if obj == nil {
			obj = &App{}
			obj.SetKey(&key)
		}
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, obj, val.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if val.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, val.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (s *AppCache) InitCacheWithSync(sync DataSync) {
	InitAppCache(s)
	s.InitSync(sync)
}

func (s *AppCache) InitSync(sync DataSync) {
	if sync != nil {
		s.Store = NewAppStore(sync.GetKVStore())
		sync.RegisterCache(s)
	}
}

func InitAppCacheWithStore(cache *AppCache, store AppStore) {
	InitAppCache(cache)
	cache.Store = store
}

func (c *AppCache) UsesOrg(org string) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for key, _ := range c.Objs {
		if key.Organization == org {
			return true
		}
	}
	return false
}

type AppByAutoProvPolicy struct {
	AutoProvPolicys map[PolicyKey]map[AppKey]struct{}
	Mux             util.Mutex
}

func (s *AppByAutoProvPolicy) Init() {
	s.AutoProvPolicys = make(map[PolicyKey]map[AppKey]struct{})
}

func (s *AppByAutoProvPolicy) Updated(old *App, new *App) map[PolicyKey]struct{} {
	// the below func must be implemented by the user:
	// App.GetAutoProvPolicys() map[PolicyKey]struct{}
	oldAutoProvPolicys := make(map[PolicyKey]struct{})
	if old != nil {
		oldAutoProvPolicys = old.GetAutoProvPolicys()
	}
	newAutoProvPolicys := new.GetAutoProvPolicys()

	for lookup, _ := range oldAutoProvPolicys {
		if _, found := newAutoProvPolicys[lookup]; found {
			delete(oldAutoProvPolicys, lookup)
			delete(newAutoProvPolicys, lookup)
		}
	}

	s.Mux.Lock()
	defer s.Mux.Unlock()

	changed := make(map[PolicyKey]struct{})
	for lookup, _ := range oldAutoProvPolicys {
		// remove
		s.removeRef(lookup, old.GetKeyVal())
		changed[lookup] = struct{}{}
	}
	for lookup, _ := range newAutoProvPolicys {
		// add
		s.addRef(lookup, new.GetKeyVal())
		changed[lookup] = struct{}{}
	}
	return changed
}

func (s *AppByAutoProvPolicy) Deleted(old *App) {
	oldAutoProvPolicys := old.GetAutoProvPolicys()

	s.Mux.Lock()
	defer s.Mux.Unlock()

	for lookup, _ := range oldAutoProvPolicys {
		s.removeRef(lookup, old.GetKeyVal())
	}
}

func (s *AppByAutoProvPolicy) addRef(lookup PolicyKey, key AppKey) {
	AppKeys, found := s.AutoProvPolicys[lookup]
	if !found {
		AppKeys = make(map[AppKey]struct{})
		s.AutoProvPolicys[lookup] = AppKeys
	}
	AppKeys[key] = struct{}{}
}

func (s *AppByAutoProvPolicy) removeRef(lookup PolicyKey, key AppKey) {
	AppKeys, found := s.AutoProvPolicys[lookup]
	if found {
		delete(AppKeys, key)
		if len(AppKeys) == 0 {
			delete(s.AutoProvPolicys, lookup)
		}
	}
}

func (s *AppByAutoProvPolicy) Find(lookup PolicyKey) []AppKey {
	s.Mux.Lock()
	defer s.Mux.Unlock()

	list := []AppKey{}
	for k, _ := range s.AutoProvPolicys[lookup] {
		list = append(list, k)
	}
	return list
}

func (s *AppByAutoProvPolicy) HasRef(lookup PolicyKey) bool {
	s.Mux.Lock()
	defer s.Mux.Unlock()

	_, found := s.AutoProvPolicys[lookup]
	return found
}

// Convert to dumpable format. JSON cannot marshal maps with struct keys.
func (s *AppByAutoProvPolicy) Dumpable() map[string]interface{} {
	s.Mux.Lock()
	defer s.Mux.Unlock()

	dat := make(map[string]interface{})
	for lookup, keys := range s.AutoProvPolicys {
		keystrs := make(map[string]interface{})
		for k, _ := range keys {
			keystrs[k.GetKeyString()] = struct{}{}
		}
		dat[lookup.GetKeyString()] = keystrs
	}
	return dat
}

func (m *App) GetObjKey() objstore.ObjKey {
	return m.GetKey()
}

func (m *App) GetKey() *AppKey {
	return &m.Key
}

func (m *App) GetKeyVal() AppKey {
	return m.Key
}

func (m *App) SetKey(key *AppKey) {
	m.Key = *key
}

func CmpSortApp(a App, b App) bool {
	return a.Key.GetKeyString() < b.Key.GetKeyString()
}

// Helper method to check that enums have valid values
// NOTE: ValidateEnums checks all Fields even if some are not set
func (m *App) ValidateEnums() error {
	if err := m.Key.ValidateEnums(); err != nil {
		return err
	}
	if _, ok := ImageType_name[int32(m.ImageType)]; !ok {
		return errors.New("invalid ImageType")
	}
	if err := m.DefaultFlavor.ValidateEnums(); err != nil {
		return err
	}
	if _, ok := DeleteType_name[int32(m.DelOpt)]; !ok {
		return errors.New("invalid DelOpt")
	}
	for _, e := range m.Configs {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	if _, ok := AccessType_name[int32(m.AccessType)]; !ok {
		return errors.New("invalid AccessType")
	}
	for _, e := range m.RequiredOutboundConnections {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	if m.ServerlessConfig != nil {
		if err := m.ServerlessConfig.ValidateEnums(); err != nil {
			return err
		}
	}
	if _, ok := VmAppOsType_name[int32(m.VmAppOsType)]; !ok {
		return errors.New("invalid VmAppOsType")
	}
	if _, ok := QosSessionProfile_name[int32(m.QosSessionProfile)]; !ok {
		return errors.New("invalid QosSessionProfile")
	}
	if m.KubernetesResources != nil {
		if err := m.KubernetesResources.ValidateEnums(); err != nil {
			return err
		}
	}
	if m.NodeResources != nil {
		if err := m.NodeResources.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (s *App) ClearTagged(tags map[string]struct{}) {
	s.Key.ClearTagged(tags)
	s.DefaultFlavor.ClearTagged(tags)
	if _, found := tags["nocmp"]; found {
		s.AuthPublicKey = ""
	}
	if s.Configs != nil {
		for ii := 0; ii < len(s.Configs); ii++ {
			s.Configs[ii].ClearTagged(tags)
		}
	}
	if _, found := tags["nocmp"]; found {
		s.Revision = ""
	}
	if _, found := tags["timestamp"]; found {
		s.CreatedAt = distributed_match_engine.Timestamp{}
	}
	if _, found := tags["timestamp"]; found {
		s.UpdatedAt = distributed_match_engine.Timestamp{}
	}
	if s.RequiredOutboundConnections != nil {
		for ii := 0; ii < len(s.RequiredOutboundConnections); ii++ {
			s.RequiredOutboundConnections[ii].ClearTagged(tags)
		}
	}
	if s.ServerlessConfig != nil {
		s.ServerlessConfig.ClearTagged(tags)
	}
	if s.KubernetesResources != nil {
		s.KubernetesResources.ClearTagged(tags)
	}
	if s.NodeResources != nil {
		s.NodeResources.ClearTagged(tags)
	}
	if _, found := tags["nocmp"]; found {
		s.ObjId = ""
	}
	if _, found := tags["nocmp"]; found {
		s.CompatibilityVersion = 0
	}
}

func IgnoreAppFields(taglist string) cmp.Option {
	names := []string{}
	tags := make(map[string]struct{})
	for _, tag := range strings.Split(taglist, ",") {
		tags[tag] = struct{}{}
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "AuthPublicKey")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Revision")
	}
	if _, found := tags["timestamp"]; found {
		names = append(names, "CreatedAt")
	}
	if _, found := tags["timestamp"]; found {
		names = append(names, "UpdatedAt")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "ObjId")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "CompatibilityVersion")
	}
	return cmpopts.IgnoreFields(App{}, names...)
}

func (m *ServerlessConfig) Clone() *ServerlessConfig {
	cp := &ServerlessConfig{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *ServerlessConfig) CopyInFields(src *ServerlessConfig) int {
	changed := 0
	if m.Vcpus.Whole != src.Vcpus.Whole {
		m.Vcpus.Whole = src.Vcpus.Whole
		changed++
	}
	if m.Vcpus.Nanos != src.Vcpus.Nanos {
		m.Vcpus.Nanos = src.Vcpus.Nanos
		changed++
	}
	if m.Ram != src.Ram {
		m.Ram = src.Ram
		changed++
	}
	if m.MinReplicas != src.MinReplicas {
		m.MinReplicas = src.MinReplicas
		changed++
	}
	if m.GpuConfig.Type != src.GpuConfig.Type {
		m.GpuConfig.Type = src.GpuConfig.Type
		changed++
	}
	if m.GpuConfig.Model != src.GpuConfig.Model {
		m.GpuConfig.Model = src.GpuConfig.Model
		changed++
	}
	if m.GpuConfig.NumGpu != src.GpuConfig.NumGpu {
		m.GpuConfig.NumGpu = src.GpuConfig.NumGpu
		changed++
	}
	if m.GpuConfig.Ram != src.GpuConfig.Ram {
		m.GpuConfig.Ram = src.GpuConfig.Ram
		changed++
	}
	return changed
}

func (m *ServerlessConfig) DeepCopyIn(src *ServerlessConfig) {
	m.Vcpus.DeepCopyIn(&src.Vcpus)
	m.Ram = src.Ram
	m.MinReplicas = src.MinReplicas
	m.GpuConfig.DeepCopyIn(&src.GpuConfig)
}

// Helper method to check that enums have valid values
func (m *ServerlessConfig) ValidateEnums() error {
	if err := m.Vcpus.ValidateEnums(); err != nil {
		return err
	}
	if err := m.GpuConfig.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func (s *ServerlessConfig) ClearTagged(tags map[string]struct{}) {
	s.Vcpus.ClearTagged(tags)
	s.GpuConfig.ClearTagged(tags)
}

func (m *GpuConfig) Clone() *GpuConfig {
	cp := &GpuConfig{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *GpuConfig) CopyInFields(src *GpuConfig) int {
	changed := 0
	if m.Type != src.Type {
		m.Type = src.Type
		changed++
	}
	if m.Model != src.Model {
		m.Model = src.Model
		changed++
	}
	if m.NumGpu != src.NumGpu {
		m.NumGpu = src.NumGpu
		changed++
	}
	if m.Ram != src.Ram {
		m.Ram = src.Ram
		changed++
	}
	return changed
}

func (m *GpuConfig) DeepCopyIn(src *GpuConfig) {
	m.Type = src.Type
	m.Model = src.Model
	m.NumGpu = src.NumGpu
	m.Ram = src.Ram
}

// Helper method to check that enums have valid values
func (m *GpuConfig) ValidateEnums() error {
	if _, ok := GpuType_name[int32(m.Type)]; !ok {
		return errors.New("invalid Type")
	}
	return nil
}

func (s *GpuConfig) ClearTagged(tags map[string]struct{}) {
}

func (m *AppAutoProvPolicy) Clone() *AppAutoProvPolicy {
	cp := &AppAutoProvPolicy{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *AppAutoProvPolicy) CopyInFields(src *AppAutoProvPolicy) int {
	changed := 0
	if m.AppKey.Organization != src.AppKey.Organization {
		m.AppKey.Organization = src.AppKey.Organization
		changed++
	}
	if m.AppKey.Name != src.AppKey.Name {
		m.AppKey.Name = src.AppKey.Name
		changed++
	}
	if m.AppKey.Version != src.AppKey.Version {
		m.AppKey.Version = src.AppKey.Version
		changed++
	}
	if m.AutoProvPolicy != src.AutoProvPolicy {
		m.AutoProvPolicy = src.AutoProvPolicy
		changed++
	}
	return changed
}

func (m *AppAutoProvPolicy) DeepCopyIn(src *AppAutoProvPolicy) {
	m.AppKey.DeepCopyIn(&src.AppKey)
	m.AutoProvPolicy = src.AutoProvPolicy
}

// Helper method to check that enums have valid values
func (m *AppAutoProvPolicy) ValidateEnums() error {
	if err := m.AppKey.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func (s *AppAutoProvPolicy) ClearTagged(tags map[string]struct{}) {
	s.AppKey.ClearTagged(tags)
}

func (m *AppAlertPolicy) Clone() *AppAlertPolicy {
	cp := &AppAlertPolicy{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *AppAlertPolicy) CopyInFields(src *AppAlertPolicy) int {
	changed := 0
	if m.AppKey.Organization != src.AppKey.Organization {
		m.AppKey.Organization = src.AppKey.Organization
		changed++
	}
	if m.AppKey.Name != src.AppKey.Name {
		m.AppKey.Name = src.AppKey.Name
		changed++
	}
	if m.AppKey.Version != src.AppKey.Version {
		m.AppKey.Version = src.AppKey.Version
		changed++
	}
	if m.AlertPolicy != src.AlertPolicy {
		m.AlertPolicy = src.AlertPolicy
		changed++
	}
	return changed
}

func (m *AppAlertPolicy) DeepCopyIn(src *AppAlertPolicy) {
	m.AppKey.DeepCopyIn(&src.AppKey)
	m.AlertPolicy = src.AlertPolicy
}

// Helper method to check that enums have valid values
func (m *AppAlertPolicy) ValidateEnums() error {
	if err := m.AppKey.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func (s *AppAlertPolicy) ClearTagged(tags map[string]struct{}) {
	s.AppKey.ClearTagged(tags)
}

func (m *DeploymentZoneRequest) Clone() *DeploymentZoneRequest {
	cp := &DeploymentZoneRequest{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *DeploymentZoneRequest) AddAppConfigs(vals ...*ConfigFile) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.App.Configs {
		cur[v.String()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.String()]; found {
			continue // duplicate
		}
		m.App.Configs = append(m.App.Configs, v)
		changes++
	}
	return changes
}

func (m *DeploymentZoneRequest) RemoveAppConfigs(vals ...*ConfigFile) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.String()] = struct{}{}
	}
	for i := len(m.App.Configs); i >= 0; i-- {
		if _, found := remove[m.App.Configs[i].String()]; found {
			m.App.Configs = append(m.App.Configs[:i], m.App.Configs[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *DeploymentZoneRequest) AddAppAutoProvPolicies(vals ...string) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.App.AutoProvPolicies {
		cur[v] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v]; found {
			continue // duplicate
		}
		m.App.AutoProvPolicies = append(m.App.AutoProvPolicies, v)
		changes++
	}
	return changes
}

func (m *DeploymentZoneRequest) RemoveAppAutoProvPolicies(vals ...string) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v] = struct{}{}
	}
	for i := len(m.App.AutoProvPolicies); i >= 0; i-- {
		if _, found := remove[m.App.AutoProvPolicies[i]]; found {
			m.App.AutoProvPolicies = append(m.App.AutoProvPolicies[:i], m.App.AutoProvPolicies[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *DeploymentZoneRequest) AddAppRequiredOutboundConnections(vals ...SecurityRule) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.App.RequiredOutboundConnections {
		cur[v.String()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.String()]; found {
			continue // duplicate
		}
		m.App.RequiredOutboundConnections = append(m.App.RequiredOutboundConnections, v)
		changes++
	}
	return changes
}

func (m *DeploymentZoneRequest) RemoveAppRequiredOutboundConnections(vals ...SecurityRule) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.String()] = struct{}{}
	}
	for i := len(m.App.RequiredOutboundConnections); i >= 0; i-- {
		if _, found := remove[m.App.RequiredOutboundConnections[i].String()]; found {
			m.App.RequiredOutboundConnections = append(m.App.RequiredOutboundConnections[:i], m.App.RequiredOutboundConnections[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *DeploymentZoneRequest) AddAppAlertPolicies(vals ...string) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.App.AlertPolicies {
		cur[v] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v]; found {
			continue // duplicate
		}
		m.App.AlertPolicies = append(m.App.AlertPolicies, v)
		changes++
	}
	return changes
}

func (m *DeploymentZoneRequest) RemoveAppAlertPolicies(vals ...string) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v] = struct{}{}
	}
	for i := len(m.App.AlertPolicies); i >= 0; i-- {
		if _, found := remove[m.App.AlertPolicies[i]]; found {
			m.App.AlertPolicies = append(m.App.AlertPolicies[:i], m.App.AlertPolicies[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *DeploymentZoneRequest) AddAppCommandArgs(vals ...string) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.App.CommandArgs {
		cur[v] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v]; found {
			continue // duplicate
		}
		m.App.CommandArgs = append(m.App.CommandArgs, v)
		changes++
	}
	return changes
}

func (m *DeploymentZoneRequest) RemoveAppCommandArgs(vals ...string) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v] = struct{}{}
	}
	for i := len(m.App.CommandArgs); i >= 0; i-- {
		if _, found := remove[m.App.CommandArgs[i]]; found {
			m.App.CommandArgs = append(m.App.CommandArgs[:i], m.App.CommandArgs[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *DeploymentZoneRequest) AddAppKubernetesResourcesCpuPoolTopologyMinNodeGpus(vals ...*GPUResource) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.App.KubernetesResources.CpuPool.Topology.MinNodeGpus {
		cur[v.GetKey().GetKeyString()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.GetKey().GetKeyString()]; found {
			continue // duplicate
		}
		m.App.KubernetesResources.CpuPool.Topology.MinNodeGpus = append(m.App.KubernetesResources.CpuPool.Topology.MinNodeGpus, v)
		changes++
	}
	return changes
}

func (m *DeploymentZoneRequest) RemoveAppKubernetesResourcesCpuPoolTopologyMinNodeGpus(vals ...*GPUResource) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.GetKey().GetKeyString()] = struct{}{}
	}
	for i := len(m.App.KubernetesResources.CpuPool.Topology.MinNodeGpus); i >= 0; i-- {
		if _, found := remove[m.App.KubernetesResources.CpuPool.Topology.MinNodeGpus[i].GetKey().GetKeyString()]; found {
			m.App.KubernetesResources.CpuPool.Topology.MinNodeGpus = append(m.App.KubernetesResources.CpuPool.Topology.MinNodeGpus[:i], m.App.KubernetesResources.CpuPool.Topology.MinNodeGpus[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *DeploymentZoneRequest) AddAppKubernetesResourcesCpuPoolTotalGpus(vals ...*GPUResource) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.App.KubernetesResources.CpuPool.TotalGpus {
		cur[v.GetKey().GetKeyString()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.GetKey().GetKeyString()]; found {
			continue // duplicate
		}
		m.App.KubernetesResources.CpuPool.TotalGpus = append(m.App.KubernetesResources.CpuPool.TotalGpus, v)
		changes++
	}
	return changes
}

func (m *DeploymentZoneRequest) RemoveAppKubernetesResourcesCpuPoolTotalGpus(vals ...*GPUResource) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.GetKey().GetKeyString()] = struct{}{}
	}
	for i := len(m.App.KubernetesResources.CpuPool.TotalGpus); i >= 0; i-- {
		if _, found := remove[m.App.KubernetesResources.CpuPool.TotalGpus[i].GetKey().GetKeyString()]; found {
			m.App.KubernetesResources.CpuPool.TotalGpus = append(m.App.KubernetesResources.CpuPool.TotalGpus[:i], m.App.KubernetesResources.CpuPool.TotalGpus[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *DeploymentZoneRequest) AddAppKubernetesResourcesGpuPoolTopologyMinNodeGpus(vals ...*GPUResource) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.App.KubernetesResources.GpuPool.Topology.MinNodeGpus {
		cur[v.GetKey().GetKeyString()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.GetKey().GetKeyString()]; found {
			continue // duplicate
		}
		m.App.KubernetesResources.GpuPool.Topology.MinNodeGpus = append(m.App.KubernetesResources.GpuPool.Topology.MinNodeGpus, v)
		changes++
	}
	return changes
}

func (m *DeploymentZoneRequest) RemoveAppKubernetesResourcesGpuPoolTopologyMinNodeGpus(vals ...*GPUResource) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.GetKey().GetKeyString()] = struct{}{}
	}
	for i := len(m.App.KubernetesResources.GpuPool.Topology.MinNodeGpus); i >= 0; i-- {
		if _, found := remove[m.App.KubernetesResources.GpuPool.Topology.MinNodeGpus[i].GetKey().GetKeyString()]; found {
			m.App.KubernetesResources.GpuPool.Topology.MinNodeGpus = append(m.App.KubernetesResources.GpuPool.Topology.MinNodeGpus[:i], m.App.KubernetesResources.GpuPool.Topology.MinNodeGpus[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *DeploymentZoneRequest) AddAppKubernetesResourcesGpuPoolTotalGpus(vals ...*GPUResource) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.App.KubernetesResources.GpuPool.TotalGpus {
		cur[v.GetKey().GetKeyString()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.GetKey().GetKeyString()]; found {
			continue // duplicate
		}
		m.App.KubernetesResources.GpuPool.TotalGpus = append(m.App.KubernetesResources.GpuPool.TotalGpus, v)
		changes++
	}
	return changes
}

func (m *DeploymentZoneRequest) RemoveAppKubernetesResourcesGpuPoolTotalGpus(vals ...*GPUResource) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.GetKey().GetKeyString()] = struct{}{}
	}
	for i := len(m.App.KubernetesResources.GpuPool.TotalGpus); i >= 0; i-- {
		if _, found := remove[m.App.KubernetesResources.GpuPool.TotalGpus[i].GetKey().GetKeyString()]; found {
			m.App.KubernetesResources.GpuPool.TotalGpus = append(m.App.KubernetesResources.GpuPool.TotalGpus[:i], m.App.KubernetesResources.GpuPool.TotalGpus[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *DeploymentZoneRequest) AddAppNodeResourcesGpus(vals ...*GPUResource) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.App.NodeResources.Gpus {
		cur[v.GetKey().GetKeyString()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.GetKey().GetKeyString()]; found {
			continue // duplicate
		}
		m.App.NodeResources.Gpus = append(m.App.NodeResources.Gpus, v)
		changes++
	}
	return changes
}

func (m *DeploymentZoneRequest) RemoveAppNodeResourcesGpus(vals ...*GPUResource) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.GetKey().GetKeyString()] = struct{}{}
	}
	for i := len(m.App.NodeResources.Gpus); i >= 0; i-- {
		if _, found := remove[m.App.NodeResources.Gpus[i].GetKey().GetKeyString()]; found {
			m.App.NodeResources.Gpus = append(m.App.NodeResources.Gpus[:i], m.App.NodeResources.Gpus[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *DeploymentZoneRequest) CopyInFields(src *DeploymentZoneRequest) int {
	updateListAction := "replace"
	changed := 0
	if src.App != nil {
		if m.App == nil {
			m.App = &App{}
		}
		if m.App.Key.Organization != src.App.Key.Organization {
			m.App.Key.Organization = src.App.Key.Organization
			changed++
		}
		if m.App.Key.Name != src.App.Key.Name {
			m.App.Key.Name = src.App.Key.Name
			changed++
		}
		if m.App.Key.Version != src.App.Key.Version {
			m.App.Key.Version = src.App.Key.Version
			changed++
		}
		if m.App.ImagePath != src.App.ImagePath {
			m.App.ImagePath = src.App.ImagePath
			changed++
		}
		if m.App.ImageType != src.App.ImageType {
			m.App.ImageType = src.App.ImageType
			changed++
		}
		if m.App.AccessPorts != src.App.AccessPorts {
			m.App.AccessPorts = src.App.AccessPorts
			changed++
		}
		if m.App.DefaultFlavor.Name != src.App.DefaultFlavor.Name {
			m.App.DefaultFlavor.Name = src.App.DefaultFlavor.Name
			changed++
		}
		if m.App.AuthPublicKey != src.App.AuthPublicKey {
			m.App.AuthPublicKey = src.App.AuthPublicKey
			changed++
		}
		if m.App.Command != src.App.Command {
			m.App.Command = src.App.Command
			changed++
		}
		if m.App.Annotations != src.App.Annotations {
			m.App.Annotations = src.App.Annotations
			changed++
		}
		if m.App.Deployment != src.App.Deployment {
			m.App.Deployment = src.App.Deployment
			changed++
		}
		if m.App.DeploymentManifest != src.App.DeploymentManifest {
			m.App.DeploymentManifest = src.App.DeploymentManifest
			changed++
		}
		if m.App.DeploymentGenerator != src.App.DeploymentGenerator {
			m.App.DeploymentGenerator = src.App.DeploymentGenerator
			changed++
		}
		if m.App.AndroidPackageName != src.App.AndroidPackageName {
			m.App.AndroidPackageName = src.App.AndroidPackageName
			changed++
		}
		if m.App.DelOpt != src.App.DelOpt {
			m.App.DelOpt = src.App.DelOpt
			changed++
		}
		if src.App.Configs != nil {
			if updateListAction == "add" {
				changed += m.AddAppConfigs(src.App.Configs...)
			} else if updateListAction == "remove" {
				changed += m.RemoveAppConfigs(src.App.Configs...)
			} else {
				m.App.Configs = make([]*ConfigFile, 0)
				for k1, _ := range src.App.Configs {
					m.App.Configs = append(m.App.Configs, src.App.Configs[k1].Clone())
				}
				changed++
			}
		} else if m.App.Configs != nil {
			m.App.Configs = nil
			changed++
		}
		if m.App.ScaleWithCluster != src.App.ScaleWithCluster {
			m.App.ScaleWithCluster = src.App.ScaleWithCluster
			changed++
		}
		if m.App.InternalPorts != src.App.InternalPorts {
			m.App.InternalPorts = src.App.InternalPorts
			changed++
		}
		if m.App.Revision != src.App.Revision {
			m.App.Revision = src.App.Revision
			changed++
		}
		if m.App.OfficialFqdn != src.App.OfficialFqdn {
			m.App.OfficialFqdn = src.App.OfficialFqdn
			changed++
		}
		if m.App.Md5Sum != src.App.Md5Sum {
			m.App.Md5Sum = src.App.Md5Sum
			changed++
		}
		if m.App.AutoProvPolicy != src.App.AutoProvPolicy {
			m.App.AutoProvPolicy = src.App.AutoProvPolicy
			changed++
		}
		if m.App.AccessType != src.App.AccessType {
			m.App.AccessType = src.App.AccessType
			changed++
		}
		if m.App.DeletePrepare != src.App.DeletePrepare {
			m.App.DeletePrepare = src.App.DeletePrepare
			changed++
		}
		if src.App.AutoProvPolicies != nil {
			if updateListAction == "add" {
				changed += m.AddAppAutoProvPolicies(src.App.AutoProvPolicies...)
			} else if updateListAction == "remove" {
				changed += m.RemoveAppAutoProvPolicies(src.App.AutoProvPolicies...)
			} else {
				m.App.AutoProvPolicies = make([]string, 0)
				m.App.AutoProvPolicies = append(m.App.AutoProvPolicies, src.App.AutoProvPolicies...)
				changed++
			}
		} else if m.App.AutoProvPolicies != nil {
			m.App.AutoProvPolicies = nil
			changed++
		}
		if m.App.TemplateDelimiter != src.App.TemplateDelimiter {
			m.App.TemplateDelimiter = src.App.TemplateDelimiter
			changed++
		}
		if m.App.SkipHcPorts != src.App.SkipHcPorts {
			m.App.SkipHcPorts = src.App.SkipHcPorts
			changed++
		}
		if m.App.CreatedAt.Seconds != src.App.CreatedAt.Seconds {
			m.App.CreatedAt.Seconds = src.App.CreatedAt.Seconds
			changed++
		}
		if m.App.CreatedAt.Nanos != src.App.CreatedAt.Nanos {
			m.App.CreatedAt.Nanos = src.App.CreatedAt.Nanos
			changed++
		}
		if m.App.UpdatedAt.Seconds != src.App.UpdatedAt.Seconds {
			m.App.UpdatedAt.Seconds = src.App.UpdatedAt.Seconds
			changed++
		}
		if m.App.UpdatedAt.Nanos != src.App.UpdatedAt.Nanos {
			m.App.UpdatedAt.Nanos = src.App.UpdatedAt.Nanos
			changed++
		}
		if m.App.Trusted != src.App.Trusted {
			m.App.Trusted = src.App.Trusted
			changed++
		}
		if src.App.RequiredOutboundConnections != nil {
			if updateListAction == "add" {
				changed += m.AddAppRequiredOutboundConnections(src.App.RequiredOutboundConnections...)
			} else if updateListAction == "remove" {
				changed += m.RemoveAppRequiredOutboundConnections(src.App.RequiredOutboundConnections...)
			} else {
				m.App.RequiredOutboundConnections = make([]SecurityRule, 0)
				for k1, _ := range src.App.RequiredOutboundConnections {
					m.App.RequiredOutboundConnections = append(m.App.RequiredOutboundConnections, *src.App.RequiredOutboundConnections[k1].Clone())
				}
				changed++
			}
		} else if m.App.RequiredOutboundConnections != nil {
			m.App.RequiredOutboundConnections = nil
			changed++
		}
		if m.App.AllowServerless != src.App.AllowServerless {
			m.App.AllowServerless = src.App.AllowServerless
			changed++
		}
		if src.App.ServerlessConfig != nil {
			if m.App.ServerlessConfig == nil {
				m.App.ServerlessConfig = &ServerlessConfig{}
			}
			if m.App.ServerlessConfig.Vcpus.Whole != src.App.ServerlessConfig.Vcpus.Whole {
				m.App.ServerlessConfig.Vcpus.Whole = src.App.ServerlessConfig.Vcpus.Whole
				changed++
			}
			if m.App.ServerlessConfig.Vcpus.Nanos != src.App.ServerlessConfig.Vcpus.Nanos {
				m.App.ServerlessConfig.Vcpus.Nanos = src.App.ServerlessConfig.Vcpus.Nanos
				changed++
			}
			if m.App.ServerlessConfig.Ram != src.App.ServerlessConfig.Ram {
				m.App.ServerlessConfig.Ram = src.App.ServerlessConfig.Ram
				changed++
			}
			if m.App.ServerlessConfig.MinReplicas != src.App.ServerlessConfig.MinReplicas {
				m.App.ServerlessConfig.MinReplicas = src.App.ServerlessConfig.MinReplicas
				changed++
			}
			if m.App.ServerlessConfig.GpuConfig.Type != src.App.ServerlessConfig.GpuConfig.Type {
				m.App.ServerlessConfig.GpuConfig.Type = src.App.ServerlessConfig.GpuConfig.Type
				changed++
			}
			if m.App.ServerlessConfig.GpuConfig.Model != src.App.ServerlessConfig.GpuConfig.Model {
				m.App.ServerlessConfig.GpuConfig.Model = src.App.ServerlessConfig.GpuConfig.Model
				changed++
			}
			if m.App.ServerlessConfig.GpuConfig.NumGpu != src.App.ServerlessConfig.GpuConfig.NumGpu {
				m.App.ServerlessConfig.GpuConfig.NumGpu = src.App.ServerlessConfig.GpuConfig.NumGpu
				changed++
			}
			if m.App.ServerlessConfig.GpuConfig.Ram != src.App.ServerlessConfig.GpuConfig.Ram {
				m.App.ServerlessConfig.GpuConfig.Ram = src.App.ServerlessConfig.GpuConfig.Ram
				changed++
			}
		} else if m.App.ServerlessConfig != nil {
			m.App.ServerlessConfig = nil
			changed++
		}
		if m.App.VmAppOsType != src.App.VmAppOsType {
			m.App.VmAppOsType = src.App.VmAppOsType
			changed++
		}
		if src.App.AlertPolicies != nil {
			if updateListAction == "add" {
				changed += m.AddAppAlertPolicies(src.App.AlertPolicies...)
			} else if updateListAction == "remove" {
				changed += m.RemoveAppAlertPolicies(src.App.AlertPolicies...)
			} else {
				m.App.AlertPolicies = make([]string, 0)
				m.App.AlertPolicies = append(m.App.AlertPolicies, src.App.AlertPolicies...)
				changed++
			}
		} else if m.App.AlertPolicies != nil {
			m.App.AlertPolicies = nil
			changed++
		}
		if m.App.QosSessionProfile != src.App.QosSessionProfile {
			m.App.QosSessionProfile = src.App.QosSessionProfile
			changed++
		}
		if m.App.QosSessionDuration != src.App.QosSessionDuration {
			m.App.QosSessionDuration = src.App.QosSessionDuration
			changed++
		}
		if m.App.GlobalId != src.App.GlobalId {
			m.App.GlobalId = src.App.GlobalId
			changed++
		}
		if src.App.CommandArgs != nil {
			if updateListAction == "add" {
				changed += m.AddAppCommandArgs(src.App.CommandArgs...)
			} else if updateListAction == "remove" {
				changed += m.RemoveAppCommandArgs(src.App.CommandArgs...)
			} else {
				m.App.CommandArgs = make([]string, 0)
				m.App.CommandArgs = append(m.App.CommandArgs, src.App.CommandArgs...)
				changed++
			}
		} else if m.App.CommandArgs != nil {
			m.App.CommandArgs = nil
			changed++
		}
		if src.App.EnvVars != nil {
			if updateListAction == "add" {
				for k1, v := range src.App.EnvVars {
					m.App.EnvVars[k1] = v
					changed++
				}
			} else if updateListAction == "remove" {
				for k1, _ := range src.App.EnvVars {
					if _, ok := m.App.EnvVars[k1]; ok {
						delete(m.App.EnvVars, k1)
						changed++
					}
				}
			} else {
				m.App.EnvVars = make(map[string]string)
				for k1, v := range src.App.EnvVars {
					m.App.EnvVars[k1] = v
				}
				changed++
			}
		} else if m.App.EnvVars != nil {
			m.App.EnvVars = nil
			changed++
		}
		if src.App.SecretEnvVars != nil {
			if updateListAction == "add" {
				for k1, v := range src.App.SecretEnvVars {
					m.App.SecretEnvVars[k1] = v
					changed++
				}
			} else if updateListAction == "remove" {
				for k1, _ := range src.App.SecretEnvVars {
					if _, ok := m.App.SecretEnvVars[k1]; ok {
						delete(m.App.SecretEnvVars, k1)
						changed++
					}
				}
			} else {
				m.App.SecretEnvVars = make(map[string]string)
				for k1, v := range src.App.SecretEnvVars {
					m.App.SecretEnvVars[k1] = v
				}
				changed++
			}
		} else if m.App.SecretEnvVars != nil {
			m.App.SecretEnvVars = nil
			changed++
		}
		if m.App.UpdateListAction != src.App.UpdateListAction {
			m.App.UpdateListAction = src.App.UpdateListAction
			changed++
		}
		if src.App.KubernetesResources != nil {
			if m.App.KubernetesResources == nil {
				m.App.KubernetesResources = &KubernetesResources{}
			}
			if src.App.KubernetesResources.CpuPool != nil {
				if m.App.KubernetesResources.CpuPool == nil {
					m.App.KubernetesResources.CpuPool = &NodePoolResources{}
				}
				if m.App.KubernetesResources.CpuPool.TotalVcpus.Whole != src.App.KubernetesResources.CpuPool.TotalVcpus.Whole {
					m.App.KubernetesResources.CpuPool.TotalVcpus.Whole = src.App.KubernetesResources.CpuPool.TotalVcpus.Whole
					changed++
				}
				if m.App.KubernetesResources.CpuPool.TotalVcpus.Nanos != src.App.KubernetesResources.CpuPool.TotalVcpus.Nanos {
					m.App.KubernetesResources.CpuPool.TotalVcpus.Nanos = src.App.KubernetesResources.CpuPool.TotalVcpus.Nanos
					changed++
				}
				if m.App.KubernetesResources.CpuPool.TotalMemory != src.App.KubernetesResources.CpuPool.TotalMemory {
					m.App.KubernetesResources.CpuPool.TotalMemory = src.App.KubernetesResources.CpuPool.TotalMemory
					changed++
				}
				if m.App.KubernetesResources.CpuPool.TotalDisk != src.App.KubernetesResources.CpuPool.TotalDisk {
					m.App.KubernetesResources.CpuPool.TotalDisk = src.App.KubernetesResources.CpuPool.TotalDisk
					changed++
				}
				if src.App.KubernetesResources.CpuPool.TotalOptRes != nil {
					if updateListAction == "add" {
						for k3, v := range src.App.KubernetesResources.CpuPool.TotalOptRes {
							m.App.KubernetesResources.CpuPool.TotalOptRes[k3] = v
							changed++
						}
					} else if updateListAction == "remove" {
						for k3, _ := range src.App.KubernetesResources.CpuPool.TotalOptRes {
							if _, ok := m.App.KubernetesResources.CpuPool.TotalOptRes[k3]; ok {
								delete(m.App.KubernetesResources.CpuPool.TotalOptRes, k3)
								changed++
							}
						}
					} else {
						m.App.KubernetesResources.CpuPool.TotalOptRes = make(map[string]string)
						for k3, v := range src.App.KubernetesResources.CpuPool.TotalOptRes {
							m.App.KubernetesResources.CpuPool.TotalOptRes[k3] = v
						}
						changed++
					}
				} else if m.App.KubernetesResources.CpuPool.TotalOptRes != nil {
					m.App.KubernetesResources.CpuPool.TotalOptRes = nil
					changed++
				}
				if m.App.KubernetesResources.CpuPool.Topology.MinNodeVcpus != src.App.KubernetesResources.CpuPool.Topology.MinNodeVcpus {
					m.App.KubernetesResources.CpuPool.Topology.MinNodeVcpus = src.App.KubernetesResources.CpuPool.Topology.MinNodeVcpus
					changed++
				}
				if m.App.KubernetesResources.CpuPool.Topology.MinNodeMemory != src.App.KubernetesResources.CpuPool.Topology.MinNodeMemory {
					m.App.KubernetesResources.CpuPool.Topology.MinNodeMemory = src.App.KubernetesResources.CpuPool.Topology.MinNodeMemory
					changed++
				}
				if m.App.KubernetesResources.CpuPool.Topology.MinNodeDisk != src.App.KubernetesResources.CpuPool.Topology.MinNodeDisk {
					m.App.KubernetesResources.CpuPool.Topology.MinNodeDisk = src.App.KubernetesResources.CpuPool.Topology.MinNodeDisk
					changed++
				}
				if src.App.KubernetesResources.CpuPool.Topology.MinNodeOptRes != nil {
					if updateListAction == "add" {
						for k4, v := range src.App.KubernetesResources.CpuPool.Topology.MinNodeOptRes {
							m.App.KubernetesResources.CpuPool.Topology.MinNodeOptRes[k4] = v
							changed++
						}
					} else if updateListAction == "remove" {
						for k4, _ := range src.App.KubernetesResources.CpuPool.Topology.MinNodeOptRes {
							if _, ok := m.App.KubernetesResources.CpuPool.Topology.MinNodeOptRes[k4]; ok {
								delete(m.App.KubernetesResources.CpuPool.Topology.MinNodeOptRes, k4)
								changed++
							}
						}
					} else {
						m.App.KubernetesResources.CpuPool.Topology.MinNodeOptRes = make(map[string]string)
						for k4, v := range src.App.KubernetesResources.CpuPool.Topology.MinNodeOptRes {
							m.App.KubernetesResources.CpuPool.Topology.MinNodeOptRes[k4] = v
						}
						changed++
					}
				} else if m.App.KubernetesResources.CpuPool.Topology.MinNodeOptRes != nil {
					m.App.KubernetesResources.CpuPool.Topology.MinNodeOptRes = nil
					changed++
				}
				if m.App.KubernetesResources.CpuPool.Topology.MinNumberOfNodes != src.App.KubernetesResources.CpuPool.Topology.MinNumberOfNodes {
					m.App.KubernetesResources.CpuPool.Topology.MinNumberOfNodes = src.App.KubernetesResources.CpuPool.Topology.MinNumberOfNodes
					changed++
				}
				if src.App.KubernetesResources.CpuPool.Topology.MinNodeGpus != nil {
					if updateListAction == "add" {
						changed += m.AddAppKubernetesResourcesCpuPoolTopologyMinNodeGpus(src.App.KubernetesResources.CpuPool.Topology.MinNodeGpus...)
					} else if updateListAction == "remove" {
						changed += m.RemoveAppKubernetesResourcesCpuPoolTopologyMinNodeGpus(src.App.KubernetesResources.CpuPool.Topology.MinNodeGpus...)
					} else {
						m.App.KubernetesResources.CpuPool.Topology.MinNodeGpus = make([]*GPUResource, 0)
						for k4, _ := range src.App.KubernetesResources.CpuPool.Topology.MinNodeGpus {
							m.App.KubernetesResources.CpuPool.Topology.MinNodeGpus = append(m.App.KubernetesResources.CpuPool.Topology.MinNodeGpus, src.App.KubernetesResources.CpuPool.Topology.MinNodeGpus[k4].Clone())
						}
						changed++
					}
				} else if m.App.KubernetesResources.CpuPool.Topology.MinNodeGpus != nil {
					m.App.KubernetesResources.CpuPool.Topology.MinNodeGpus = nil
					changed++
				}
				if src.App.KubernetesResources.CpuPool.TotalGpus != nil {
					if updateListAction == "add" {
						changed += m.AddAppKubernetesResourcesCpuPoolTotalGpus(src.App.KubernetesResources.CpuPool.TotalGpus...)
					} else if updateListAction == "remove" {
						changed += m.RemoveAppKubernetesResourcesCpuPoolTotalGpus(src.App.KubernetesResources.CpuPool.TotalGpus...)
					} else {
						m.App.KubernetesResources.CpuPool.TotalGpus = make([]*GPUResource, 0)
						for k3, _ := range src.App.KubernetesResources.CpuPool.TotalGpus {
							m.App.KubernetesResources.CpuPool.TotalGpus = append(m.App.KubernetesResources.CpuPool.TotalGpus, src.App.KubernetesResources.CpuPool.TotalGpus[k3].Clone())
						}
						changed++
					}
				} else if m.App.KubernetesResources.CpuPool.TotalGpus != nil {
					m.App.KubernetesResources.CpuPool.TotalGpus = nil
					changed++
				}
			} else if m.App.KubernetesResources.CpuPool != nil {
				m.App.KubernetesResources.CpuPool = nil
				changed++
			}
			if src.App.KubernetesResources.GpuPool != nil {
				if m.App.KubernetesResources.GpuPool == nil {
					m.App.KubernetesResources.GpuPool = &NodePoolResources{}
				}
				if m.App.KubernetesResources.GpuPool.TotalVcpus.Whole != src.App.KubernetesResources.GpuPool.TotalVcpus.Whole {
					m.App.KubernetesResources.GpuPool.TotalVcpus.Whole = src.App.KubernetesResources.GpuPool.TotalVcpus.Whole
					changed++
				}
				if m.App.KubernetesResources.GpuPool.TotalVcpus.Nanos != src.App.KubernetesResources.GpuPool.TotalVcpus.Nanos {
					m.App.KubernetesResources.GpuPool.TotalVcpus.Nanos = src.App.KubernetesResources.GpuPool.TotalVcpus.Nanos
					changed++
				}
				if m.App.KubernetesResources.GpuPool.TotalMemory != src.App.KubernetesResources.GpuPool.TotalMemory {
					m.App.KubernetesResources.GpuPool.TotalMemory = src.App.KubernetesResources.GpuPool.TotalMemory
					changed++
				}
				if m.App.KubernetesResources.GpuPool.TotalDisk != src.App.KubernetesResources.GpuPool.TotalDisk {
					m.App.KubernetesResources.GpuPool.TotalDisk = src.App.KubernetesResources.GpuPool.TotalDisk
					changed++
				}
				if src.App.KubernetesResources.GpuPool.TotalOptRes != nil {
					if updateListAction == "add" {
						for k3, v := range src.App.KubernetesResources.GpuPool.TotalOptRes {
							m.App.KubernetesResources.GpuPool.TotalOptRes[k3] = v
							changed++
						}
					} else if updateListAction == "remove" {
						for k3, _ := range src.App.KubernetesResources.GpuPool.TotalOptRes {
							if _, ok := m.App.KubernetesResources.GpuPool.TotalOptRes[k3]; ok {
								delete(m.App.KubernetesResources.GpuPool.TotalOptRes, k3)
								changed++
							}
						}
					} else {
						m.App.KubernetesResources.GpuPool.TotalOptRes = make(map[string]string)
						for k3, v := range src.App.KubernetesResources.GpuPool.TotalOptRes {
							m.App.KubernetesResources.GpuPool.TotalOptRes[k3] = v
						}
						changed++
					}
				} else if m.App.KubernetesResources.GpuPool.TotalOptRes != nil {
					m.App.KubernetesResources.GpuPool.TotalOptRes = nil
					changed++
				}
				if m.App.KubernetesResources.GpuPool.Topology.MinNodeVcpus != src.App.KubernetesResources.GpuPool.Topology.MinNodeVcpus {
					m.App.KubernetesResources.GpuPool.Topology.MinNodeVcpus = src.App.KubernetesResources.GpuPool.Topology.MinNodeVcpus
					changed++
				}
				if m.App.KubernetesResources.GpuPool.Topology.MinNodeMemory != src.App.KubernetesResources.GpuPool.Topology.MinNodeMemory {
					m.App.KubernetesResources.GpuPool.Topology.MinNodeMemory = src.App.KubernetesResources.GpuPool.Topology.MinNodeMemory
					changed++
				}
				if m.App.KubernetesResources.GpuPool.Topology.MinNodeDisk != src.App.KubernetesResources.GpuPool.Topology.MinNodeDisk {
					m.App.KubernetesResources.GpuPool.Topology.MinNodeDisk = src.App.KubernetesResources.GpuPool.Topology.MinNodeDisk
					changed++
				}
				if src.App.KubernetesResources.GpuPool.Topology.MinNodeOptRes != nil {
					if updateListAction == "add" {
						for k4, v := range src.App.KubernetesResources.GpuPool.Topology.MinNodeOptRes {
							m.App.KubernetesResources.GpuPool.Topology.MinNodeOptRes[k4] = v
							changed++
						}
					} else if updateListAction == "remove" {
						for k4, _ := range src.App.KubernetesResources.GpuPool.Topology.MinNodeOptRes {
							if _, ok := m.App.KubernetesResources.GpuPool.Topology.MinNodeOptRes[k4]; ok {
								delete(m.App.KubernetesResources.GpuPool.Topology.MinNodeOptRes, k4)
								changed++
							}
						}
					} else {
						m.App.KubernetesResources.GpuPool.Topology.MinNodeOptRes = make(map[string]string)
						for k4, v := range src.App.KubernetesResources.GpuPool.Topology.MinNodeOptRes {
							m.App.KubernetesResources.GpuPool.Topology.MinNodeOptRes[k4] = v
						}
						changed++
					}
				} else if m.App.KubernetesResources.GpuPool.Topology.MinNodeOptRes != nil {
					m.App.KubernetesResources.GpuPool.Topology.MinNodeOptRes = nil
					changed++
				}
				if m.App.KubernetesResources.GpuPool.Topology.MinNumberOfNodes != src.App.KubernetesResources.GpuPool.Topology.MinNumberOfNodes {
					m.App.KubernetesResources.GpuPool.Topology.MinNumberOfNodes = src.App.KubernetesResources.GpuPool.Topology.MinNumberOfNodes
					changed++
				}
				if src.App.KubernetesResources.GpuPool.Topology.MinNodeGpus != nil {
					if updateListAction == "add" {
						changed += m.AddAppKubernetesResourcesGpuPoolTopologyMinNodeGpus(src.App.KubernetesResources.GpuPool.Topology.MinNodeGpus...)
					} else if updateListAction == "remove" {
						changed += m.RemoveAppKubernetesResourcesGpuPoolTopologyMinNodeGpus(src.App.KubernetesResources.GpuPool.Topology.MinNodeGpus...)
					} else {
						m.App.KubernetesResources.GpuPool.Topology.MinNodeGpus = make([]*GPUResource, 0)
						for k4, _ := range src.App.KubernetesResources.GpuPool.Topology.MinNodeGpus {
							m.App.KubernetesResources.GpuPool.Topology.MinNodeGpus = append(m.App.KubernetesResources.GpuPool.Topology.MinNodeGpus, src.App.KubernetesResources.GpuPool.Topology.MinNodeGpus[k4].Clone())
						}
						changed++
					}
				} else if m.App.KubernetesResources.GpuPool.Topology.MinNodeGpus != nil {
					m.App.KubernetesResources.GpuPool.Topology.MinNodeGpus = nil
					changed++
				}
				if src.App.KubernetesResources.GpuPool.TotalGpus != nil {
					if updateListAction == "add" {
						changed += m.AddAppKubernetesResourcesGpuPoolTotalGpus(src.App.KubernetesResources.GpuPool.TotalGpus...)
					} else if updateListAction == "remove" {
						changed += m.RemoveAppKubernetesResourcesGpuPoolTotalGpus(src.App.KubernetesResources.GpuPool.TotalGpus...)
					} else {
						m.App.KubernetesResources.GpuPool.TotalGpus = make([]*GPUResource, 0)
						for k3, _ := range src.App.KubernetesResources.GpuPool.TotalGpus {
							m.App.KubernetesResources.GpuPool.TotalGpus = append(m.App.KubernetesResources.GpuPool.TotalGpus, src.App.KubernetesResources.GpuPool.TotalGpus[k3].Clone())
						}
						changed++
					}
				} else if m.App.KubernetesResources.GpuPool.TotalGpus != nil {
					m.App.KubernetesResources.GpuPool.TotalGpus = nil
					changed++
				}
			} else if m.App.KubernetesResources.GpuPool != nil {
				m.App.KubernetesResources.GpuPool = nil
				changed++
			}
			if m.App.KubernetesResources.MinKubernetesVersion != src.App.KubernetesResources.MinKubernetesVersion {
				m.App.KubernetesResources.MinKubernetesVersion = src.App.KubernetesResources.MinKubernetesVersion
				changed++
			}
		} else if m.App.KubernetesResources != nil {
			m.App.KubernetesResources = nil
			changed++
		}
		if src.App.NodeResources != nil {
			if m.App.NodeResources == nil {
				m.App.NodeResources = &NodeResources{}
			}
			if m.App.NodeResources.Vcpus != src.App.NodeResources.Vcpus {
				m.App.NodeResources.Vcpus = src.App.NodeResources.Vcpus
				changed++
			}
			if m.App.NodeResources.Ram != src.App.NodeResources.Ram {
				m.App.NodeResources.Ram = src.App.NodeResources.Ram
				changed++
			}
			if m.App.NodeResources.Disk != src.App.NodeResources.Disk {
				m.App.NodeResources.Disk = src.App.NodeResources.Disk
				changed++
			}
			if src.App.NodeResources.OptResMap != nil {
				if updateListAction == "add" {
					for k2, v := range src.App.NodeResources.OptResMap {
						m.App.NodeResources.OptResMap[k2] = v
						changed++
					}
				} else if updateListAction == "remove" {
					for k2, _ := range src.App.NodeResources.OptResMap {
						if _, ok := m.App.NodeResources.OptResMap[k2]; ok {
							delete(m.App.NodeResources.OptResMap, k2)
							changed++
						}
					}
				} else {
					m.App.NodeResources.OptResMap = make(map[string]string)
					for k2, v := range src.App.NodeResources.OptResMap {
						m.App.NodeResources.OptResMap[k2] = v
					}
					changed++
				}
			} else if m.App.NodeResources.OptResMap != nil {
				m.App.NodeResources.OptResMap = nil
				changed++
			}
			if m.App.NodeResources.InfraNodeFlavor != src.App.NodeResources.InfraNodeFlavor {
				m.App.NodeResources.InfraNodeFlavor = src.App.NodeResources.InfraNodeFlavor
				changed++
			}
			if m.App.NodeResources.ExternalVolumeSize != src.App.NodeResources.ExternalVolumeSize {
				m.App.NodeResources.ExternalVolumeSize = src.App.NodeResources.ExternalVolumeSize
				changed++
			}
			if src.App.NodeResources.Gpus != nil {
				if updateListAction == "add" {
					changed += m.AddAppNodeResourcesGpus(src.App.NodeResources.Gpus...)
				} else if updateListAction == "remove" {
					changed += m.RemoveAppNodeResourcesGpus(src.App.NodeResources.Gpus...)
				} else {
					m.App.NodeResources.Gpus = make([]*GPUResource, 0)
					for k2, _ := range src.App.NodeResources.Gpus {
						m.App.NodeResources.Gpus = append(m.App.NodeResources.Gpus, src.App.NodeResources.Gpus[k2].Clone())
					}
					changed++
				}
			} else if m.App.NodeResources.Gpus != nil {
				m.App.NodeResources.Gpus = nil
				changed++
			}
		} else if m.App.NodeResources != nil {
			m.App.NodeResources = nil
			changed++
		}
		if m.App.ObjId != src.App.ObjId {
			m.App.ObjId = src.App.ObjId
			changed++
		}
		if src.App.AppAnnotations != nil {
			if updateListAction == "add" {
				for k1, v := range src.App.AppAnnotations {
					m.App.AppAnnotations[k1] = v
					changed++
				}
			} else if updateListAction == "remove" {
				for k1, _ := range src.App.AppAnnotations {
					if _, ok := m.App.AppAnnotations[k1]; ok {
						delete(m.App.AppAnnotations, k1)
						changed++
					}
				}
			} else {
				m.App.AppAnnotations = make(map[string]string)
				for k1, v := range src.App.AppAnnotations {
					m.App.AppAnnotations[k1] = v
				}
				changed++
			}
		} else if m.App.AppAnnotations != nil {
			m.App.AppAnnotations = nil
			changed++
		}
		if m.App.IsStandalone != src.App.IsStandalone {
			m.App.IsStandalone = src.App.IsStandalone
			changed++
		}
		if m.App.ManagesOwnNamespaces != src.App.ManagesOwnNamespaces {
			m.App.ManagesOwnNamespaces = src.App.ManagesOwnNamespaces
			changed++
		}
		if m.App.CompatibilityVersion != src.App.CompatibilityVersion {
			m.App.CompatibilityVersion = src.App.CompatibilityVersion
			changed++
		}
		if m.App.Username != src.App.Username {
			m.App.Username = src.App.Username
			changed++
		}
		if m.App.Credentials != src.App.Credentials {
			m.App.Credentials = src.App.Credentials
			changed++
		}
		if src.App.Tags != nil {
			if updateListAction == "add" {
				for k1, v := range src.App.Tags {
					m.App.Tags[k1] = v
					changed++
				}
			} else if updateListAction == "remove" {
				for k1, _ := range src.App.Tags {
					if _, ok := m.App.Tags[k1]; ok {
						delete(m.App.Tags, k1)
						changed++
					}
				}
			} else {
				m.App.Tags = make(map[string]string)
				for k1, v := range src.App.Tags {
					m.App.Tags[k1] = v
				}
				changed++
			}
		} else if m.App.Tags != nil {
			m.App.Tags = nil
			changed++
		}
	} else if m.App != nil {
		m.App = nil
		changed++
	}
	if m.DryRunDeploy != src.DryRunDeploy {
		m.DryRunDeploy = src.DryRunDeploy
		changed++
	}
	if m.NumNodes != src.NumNodes {
		m.NumNodes = src.NumNodes
		changed++
	}
	return changed
}

func (m *DeploymentZoneRequest) DeepCopyIn(src *DeploymentZoneRequest) {
	if src.App != nil {
		var tmp_App App
		tmp_App.DeepCopyIn(src.App)
		m.App = &tmp_App
	} else {
		m.App = nil
	}
	m.DryRunDeploy = src.DryRunDeploy
	m.NumNodes = src.NumNodes
}

// Helper method to check that enums have valid values
func (m *DeploymentZoneRequest) ValidateEnums() error {
	if m.App != nil {
		if err := m.App.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (s *DeploymentZoneRequest) ClearTagged(tags map[string]struct{}) {
	if s.App != nil {
		s.App.ClearTagged(tags)
	}
}

func IgnoreDeploymentZoneRequestFields(taglist string) cmp.Option {
	names := []string{}
	tags := make(map[string]struct{})
	for _, tag := range strings.Split(taglist, ",") {
		tags[tag] = struct{}{}
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "App.AuthPublicKey")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "App.Revision")
	}
	if _, found := tags["timestamp"]; found {
		names = append(names, "App.CreatedAt")
	}
	if _, found := tags["timestamp"]; found {
		names = append(names, "App.UpdatedAt")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "App.ObjId")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "App.CompatibilityVersion")
	}
	return cmpopts.IgnoreFields(DeploymentZoneRequest{}, names...)
}

var ImageTypeStrings = []string{
	"IMAGE_TYPE_UNKNOWN",
	"IMAGE_TYPE_DOCKER",
	"IMAGE_TYPE_QCOW",
	"IMAGE_TYPE_HELM",
	"IMAGE_TYPE_OVF",
	"IMAGE_TYPE_OVA",
}

const (
	ImageTypeIMAGE_TYPE_UNKNOWN uint64 = 1 << 0
	ImageTypeIMAGE_TYPE_DOCKER  uint64 = 1 << 1
	ImageTypeIMAGE_TYPE_QCOW    uint64 = 1 << 2
	ImageTypeIMAGE_TYPE_HELM    uint64 = 1 << 3
	ImageTypeIMAGE_TYPE_OVF     uint64 = 1 << 4
	ImageTypeIMAGE_TYPE_OVA     uint64 = 1 << 5
)

var ImageType_CamelName = map[int32]string{
	// IMAGE_TYPE_UNKNOWN -> ImageTypeUnknown
	0: "ImageTypeUnknown",
	// IMAGE_TYPE_DOCKER -> ImageTypeDocker
	1: "ImageTypeDocker",
	// IMAGE_TYPE_QCOW -> ImageTypeQcow
	2: "ImageTypeQcow",
	// IMAGE_TYPE_HELM -> ImageTypeHelm
	3: "ImageTypeHelm",
	// IMAGE_TYPE_OVF -> ImageTypeOvf
	4: "ImageTypeOvf",
	// IMAGE_TYPE_OVA -> ImageTypeOva
	5: "ImageTypeOva",
}
var ImageType_CamelValue = map[string]int32{
	"ImageTypeUnknown": 0,
	"ImageTypeDocker":  1,
	"ImageTypeQcow":    2,
	"ImageTypeHelm":    3,
	"ImageTypeOvf":     4,
	"ImageTypeOva":     5,
}

func ParseImageType(data interface{}) (ImageType, error) {
	if val, ok := data.(ImageType); ok {
		return val, nil
	} else if str, ok := data.(string); ok {
		val, ok := ImageType_CamelValue[util.CamelCase(str)]
		if !ok {
			// may have omitted common prefix
			val, ok = ImageType_CamelValue["ImageType"+util.CamelCase(str)]
		}
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = ImageType_CamelName[val]
			}
		}
		if !ok {
			return ImageType(0), fmt.Errorf("Invalid ImageType value %q", str)
		}
		return ImageType(val), nil
	} else if ival, ok := data.(int32); ok {
		if _, ok := ImageType_CamelName[ival]; ok {
			return ImageType(ival), nil
		} else {
			return ImageType(0), fmt.Errorf("Invalid ImageType value %d", ival)
		}
	}
	return ImageType(0), fmt.Errorf("Invalid ImageType value %v", data)
}

func (e *ImageType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, err := ParseImageType(str)
	if err != nil {
		return err
	}
	*e = val
	return nil
}

func (e ImageType) MarshalYAML() (interface{}, error) {
	str := proto.EnumName(ImageType_CamelName, int32(e))
	str = strings.TrimPrefix(str, "ImageType")
	return str, nil
}

// custom JSON encoding/decoding
func (e *ImageType) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, err := ParseImageType(str)
		if err != nil {
			return &json.UnmarshalTypeError{
				Value: "string " + str,
				Type:  reflect.TypeOf(ImageType(0)),
			}
		}
		*e = ImageType(val)
		return nil
	}
	var ival int32
	err = json.Unmarshal(b, &ival)
	if err == nil {
		val, err := ParseImageType(ival)
		if err == nil {
			*e = val
			return nil
		}
	}
	return &json.UnmarshalTypeError{
		Value: "value " + string(b),
		Type:  reflect.TypeOf(ImageType(0)),
	}
}

func (e ImageType) MarshalJSON() ([]byte, error) {
	str := proto.EnumName(ImageType_CamelName, int32(e))
	str = strings.TrimPrefix(str, "ImageType")
	return json.Marshal(str)
}

var ImageTypeCommonPrefix = "ImageType"

var QosSessionProfileStrings = []string{
	"QOS_NO_PRIORITY",
	"QOS_LOW_LATENCY",
	"QOS_THROUGHPUT_DOWN_S",
	"QOS_THROUGHPUT_DOWN_M",
	"QOS_THROUGHPUT_DOWN_L",
}

const (
	QosSessionProfileQOS_NO_PRIORITY       uint64 = 1 << 0
	QosSessionProfileQOS_LOW_LATENCY       uint64 = 1 << 1
	QosSessionProfileQOS_THROUGHPUT_DOWN_S uint64 = 1 << 2
	QosSessionProfileQOS_THROUGHPUT_DOWN_M uint64 = 1 << 3
	QosSessionProfileQOS_THROUGHPUT_DOWN_L uint64 = 1 << 4
)

var QosSessionProfile_CamelName = map[int32]string{
	// QOS_NO_PRIORITY -> QosNoPriority
	0: "QosNoPriority",
	// QOS_LOW_LATENCY -> QosLowLatency
	1: "QosLowLatency",
	// QOS_THROUGHPUT_DOWN_S -> QosThroughputDownS
	2: "QosThroughputDownS",
	// QOS_THROUGHPUT_DOWN_M -> QosThroughputDownM
	3: "QosThroughputDownM",
	// QOS_THROUGHPUT_DOWN_L -> QosThroughputDownL
	4: "QosThroughputDownL",
}
var QosSessionProfile_CamelValue = map[string]int32{
	"QosNoPriority":      0,
	"QosLowLatency":      1,
	"QosThroughputDownS": 2,
	"QosThroughputDownM": 3,
	"QosThroughputDownL": 4,
}

func ParseQosSessionProfile(data interface{}) (QosSessionProfile, error) {
	if val, ok := data.(QosSessionProfile); ok {
		return val, nil
	} else if str, ok := data.(string); ok {
		val, ok := QosSessionProfile_CamelValue[util.CamelCase(str)]
		if !ok {
			// may have omitted common prefix
			val, ok = QosSessionProfile_CamelValue["Qos"+util.CamelCase(str)]
		}
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = QosSessionProfile_CamelName[val]
			}
		}
		if !ok {
			return QosSessionProfile(0), fmt.Errorf("Invalid QosSessionProfile value %q", str)
		}
		return QosSessionProfile(val), nil
	} else if ival, ok := data.(int32); ok {
		if _, ok := QosSessionProfile_CamelName[ival]; ok {
			return QosSessionProfile(ival), nil
		} else {
			return QosSessionProfile(0), fmt.Errorf("Invalid QosSessionProfile value %d", ival)
		}
	}
	return QosSessionProfile(0), fmt.Errorf("Invalid QosSessionProfile value %v", data)
}

func (e *QosSessionProfile) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, err := ParseQosSessionProfile(str)
	if err != nil {
		return err
	}
	*e = val
	return nil
}

func (e QosSessionProfile) MarshalYAML() (interface{}, error) {
	str := proto.EnumName(QosSessionProfile_CamelName, int32(e))
	str = strings.TrimPrefix(str, "Qos")
	return str, nil
}

// custom JSON encoding/decoding
func (e *QosSessionProfile) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, err := ParseQosSessionProfile(str)
		if err != nil {
			return &json.UnmarshalTypeError{
				Value: "string " + str,
				Type:  reflect.TypeOf(QosSessionProfile(0)),
			}
		}
		*e = QosSessionProfile(val)
		return nil
	}
	var ival int32
	err = json.Unmarshal(b, &ival)
	if err == nil {
		val, err := ParseQosSessionProfile(ival)
		if err == nil {
			*e = val
			return nil
		}
	}
	return &json.UnmarshalTypeError{
		Value: "value " + string(b),
		Type:  reflect.TypeOf(QosSessionProfile(0)),
	}
}

func (e QosSessionProfile) MarshalJSON() ([]byte, error) {
	str := proto.EnumName(QosSessionProfile_CamelName, int32(e))
	str = strings.TrimPrefix(str, "Qos")
	return json.Marshal(str)
}

var QosSessionProfileCommonPrefix = "Qos"

var VmAppOsTypeStrings = []string{
	"VM_APP_OS_UNKNOWN",
	"VM_APP_OS_LINUX",
	"VM_APP_OS_WINDOWS_10",
	"VM_APP_OS_WINDOWS_2012",
	"VM_APP_OS_WINDOWS_2016",
	"VM_APP_OS_WINDOWS_2019",
}

const (
	VmAppOsTypeVM_APP_OS_UNKNOWN      uint64 = 1 << 0
	VmAppOsTypeVM_APP_OS_LINUX        uint64 = 1 << 1
	VmAppOsTypeVM_APP_OS_WINDOWS_10   uint64 = 1 << 2
	VmAppOsTypeVM_APP_OS_WINDOWS_2012 uint64 = 1 << 3
	VmAppOsTypeVM_APP_OS_WINDOWS_2016 uint64 = 1 << 4
	VmAppOsTypeVM_APP_OS_WINDOWS_2019 uint64 = 1 << 5
)

var VmAppOsType_CamelName = map[int32]string{
	// VM_APP_OS_UNKNOWN -> VmAppOsUnknown
	0: "VmAppOsUnknown",
	// VM_APP_OS_LINUX -> VmAppOsLinux
	1: "VmAppOsLinux",
	// VM_APP_OS_WINDOWS_10 -> VmAppOsWindows10
	2: "VmAppOsWindows10",
	// VM_APP_OS_WINDOWS_2012 -> VmAppOsWindows2012
	3: "VmAppOsWindows2012",
	// VM_APP_OS_WINDOWS_2016 -> VmAppOsWindows2016
	4: "VmAppOsWindows2016",
	// VM_APP_OS_WINDOWS_2019 -> VmAppOsWindows2019
	5: "VmAppOsWindows2019",
}
var VmAppOsType_CamelValue = map[string]int32{
	"VmAppOsUnknown":     0,
	"VmAppOsLinux":       1,
	"VmAppOsWindows10":   2,
	"VmAppOsWindows2012": 3,
	"VmAppOsWindows2016": 4,
	"VmAppOsWindows2019": 5,
}

func ParseVmAppOsType(data interface{}) (VmAppOsType, error) {
	if val, ok := data.(VmAppOsType); ok {
		return val, nil
	} else if str, ok := data.(string); ok {
		val, ok := VmAppOsType_CamelValue[util.CamelCase(str)]
		if !ok {
			// may have omitted common prefix
			val, ok = VmAppOsType_CamelValue["VmAppOs"+util.CamelCase(str)]
		}
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = VmAppOsType_CamelName[val]
			}
		}
		if !ok {
			return VmAppOsType(0), fmt.Errorf("Invalid VmAppOsType value %q", str)
		}
		return VmAppOsType(val), nil
	} else if ival, ok := data.(int32); ok {
		if _, ok := VmAppOsType_CamelName[ival]; ok {
			return VmAppOsType(ival), nil
		} else {
			return VmAppOsType(0), fmt.Errorf("Invalid VmAppOsType value %d", ival)
		}
	}
	return VmAppOsType(0), fmt.Errorf("Invalid VmAppOsType value %v", data)
}

func (e *VmAppOsType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, err := ParseVmAppOsType(str)
	if err != nil {
		return err
	}
	*e = val
	return nil
}

func (e VmAppOsType) MarshalYAML() (interface{}, error) {
	str := proto.EnumName(VmAppOsType_CamelName, int32(e))
	str = strings.TrimPrefix(str, "VmAppOs")
	return str, nil
}

// custom JSON encoding/decoding
func (e *VmAppOsType) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, err := ParseVmAppOsType(str)
		if err != nil {
			return &json.UnmarshalTypeError{
				Value: "string " + str,
				Type:  reflect.TypeOf(VmAppOsType(0)),
			}
		}
		*e = VmAppOsType(val)
		return nil
	}
	var ival int32
	err = json.Unmarshal(b, &ival)
	if err == nil {
		val, err := ParseVmAppOsType(ival)
		if err == nil {
			*e = val
			return nil
		}
	}
	return &json.UnmarshalTypeError{
		Value: "value " + string(b),
		Type:  reflect.TypeOf(VmAppOsType(0)),
	}
}

func (e VmAppOsType) MarshalJSON() ([]byte, error) {
	str := proto.EnumName(VmAppOsType_CamelName, int32(e))
	str = strings.TrimPrefix(str, "VmAppOs")
	return json.Marshal(str)
}

var VmAppOsTypeCommonPrefix = "VmAppOs"

var DeleteTypeStrings = []string{
	"NO_AUTO_DELETE",
	"AUTO_DELETE",
}

const (
	DeleteTypeNO_AUTO_DELETE uint64 = 1 << 0
	DeleteTypeAUTO_DELETE    uint64 = 1 << 1
)

var DeleteType_CamelName = map[int32]string{
	// NO_AUTO_DELETE -> NoAutoDelete
	0: "NoAutoDelete",
	// AUTO_DELETE -> AutoDelete
	1: "AutoDelete",
}
var DeleteType_CamelValue = map[string]int32{
	"NoAutoDelete": 0,
	"AutoDelete":   1,
}

func ParseDeleteType(data interface{}) (DeleteType, error) {
	if val, ok := data.(DeleteType); ok {
		return val, nil
	} else if str, ok := data.(string); ok {
		val, ok := DeleteType_CamelValue[util.CamelCase(str)]
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = DeleteType_CamelName[val]
			}
		}
		if !ok {
			return DeleteType(0), fmt.Errorf("Invalid DeleteType value %q", str)
		}
		return DeleteType(val), nil
	} else if ival, ok := data.(int32); ok {
		if _, ok := DeleteType_CamelName[ival]; ok {
			return DeleteType(ival), nil
		} else {
			return DeleteType(0), fmt.Errorf("Invalid DeleteType value %d", ival)
		}
	}
	return DeleteType(0), fmt.Errorf("Invalid DeleteType value %v", data)
}

func (e *DeleteType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, err := ParseDeleteType(str)
	if err != nil {
		return err
	}
	*e = val
	return nil
}

func (e DeleteType) MarshalYAML() (interface{}, error) {
	str := proto.EnumName(DeleteType_CamelName, int32(e))
	return str, nil
}

// custom JSON encoding/decoding
func (e *DeleteType) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, err := ParseDeleteType(str)
		if err != nil {
			return &json.UnmarshalTypeError{
				Value: "string " + str,
				Type:  reflect.TypeOf(DeleteType(0)),
			}
		}
		*e = DeleteType(val)
		return nil
	}
	var ival int32
	err = json.Unmarshal(b, &ival)
	if err == nil {
		val, err := ParseDeleteType(ival)
		if err == nil {
			*e = val
			return nil
		}
	}
	return &json.UnmarshalTypeError{
		Value: "value " + string(b),
		Type:  reflect.TypeOf(DeleteType(0)),
	}
}

func (e DeleteType) MarshalJSON() ([]byte, error) {
	str := proto.EnumName(DeleteType_CamelName, int32(e))
	return json.Marshal(str)
}

var AccessTypeStrings = []string{
	"ACCESS_TYPE_DEFAULT_FOR_DEPLOYMENT",
	"ACCESS_TYPE_DIRECT",
	"ACCESS_TYPE_LOAD_BALANCER",
}

const (
	AccessTypeACCESS_TYPE_DEFAULT_FOR_DEPLOYMENT uint64 = 1 << 0
	AccessTypeACCESS_TYPE_DIRECT                 uint64 = 1 << 1
	AccessTypeACCESS_TYPE_LOAD_BALANCER          uint64 = 1 << 2
)

var AccessType_CamelName = map[int32]string{
	// ACCESS_TYPE_DEFAULT_FOR_DEPLOYMENT -> AccessTypeDefaultForDeployment
	0: "AccessTypeDefaultForDeployment",
	// ACCESS_TYPE_DIRECT -> AccessTypeDirect
	1: "AccessTypeDirect",
	// ACCESS_TYPE_LOAD_BALANCER -> AccessTypeLoadBalancer
	2: "AccessTypeLoadBalancer",
}
var AccessType_CamelValue = map[string]int32{
	"AccessTypeDefaultForDeployment": 0,
	"AccessTypeDirect":               1,
	"AccessTypeLoadBalancer":         2,
}

func ParseAccessType(data interface{}) (AccessType, error) {
	if val, ok := data.(AccessType); ok {
		return val, nil
	} else if str, ok := data.(string); ok {
		val, ok := AccessType_CamelValue[util.CamelCase(str)]
		if !ok {
			// may have omitted common prefix
			val, ok = AccessType_CamelValue["AccessType"+util.CamelCase(str)]
		}
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = AccessType_CamelName[val]
			}
		}
		if !ok {
			return AccessType(0), fmt.Errorf("Invalid AccessType value %q", str)
		}
		return AccessType(val), nil
	} else if ival, ok := data.(int32); ok {
		if _, ok := AccessType_CamelName[ival]; ok {
			return AccessType(ival), nil
		} else {
			return AccessType(0), fmt.Errorf("Invalid AccessType value %d", ival)
		}
	}
	return AccessType(0), fmt.Errorf("Invalid AccessType value %v", data)
}

func (e *AccessType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, err := ParseAccessType(str)
	if err != nil {
		return err
	}
	*e = val
	return nil
}

func (e AccessType) MarshalYAML() (interface{}, error) {
	str := proto.EnumName(AccessType_CamelName, int32(e))
	str = strings.TrimPrefix(str, "AccessType")
	return str, nil
}

// custom JSON encoding/decoding
func (e *AccessType) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, err := ParseAccessType(str)
		if err != nil {
			return &json.UnmarshalTypeError{
				Value: "string " + str,
				Type:  reflect.TypeOf(AccessType(0)),
			}
		}
		*e = AccessType(val)
		return nil
	}
	var ival int32
	err = json.Unmarshal(b, &ival)
	if err == nil {
		val, err := ParseAccessType(ival)
		if err == nil {
			*e = val
			return nil
		}
	}
	return &json.UnmarshalTypeError{
		Value: "value " + string(b),
		Type:  reflect.TypeOf(AccessType(0)),
	}
}

func (e AccessType) MarshalJSON() ([]byte, error) {
	str := proto.EnumName(AccessType_CamelName, int32(e))
	str = strings.TrimPrefix(str, "AccessType")
	return json.Marshal(str)
}

var AccessTypeCommonPrefix = "AccessType"

var GpuTypeStrings = []string{
	"GPU_TYPE_NONE",
	"GPU_TYPE_ANY",
	"GPU_TYPE_VGPU",
	"GPU_TYPE_PCI",
}

const (
	GpuTypeGPU_TYPE_NONE uint64 = 1 << 0
	GpuTypeGPU_TYPE_ANY  uint64 = 1 << 1
	GpuTypeGPU_TYPE_VGPU uint64 = 1 << 2
	GpuTypeGPU_TYPE_PCI  uint64 = 1 << 3
)

var GpuType_CamelName = map[int32]string{
	// GPU_TYPE_NONE -> GpuTypeNone
	0: "GpuTypeNone",
	// GPU_TYPE_ANY -> GpuTypeAny
	1: "GpuTypeAny",
	// GPU_TYPE_VGPU -> GpuTypeVgpu
	2: "GpuTypeVgpu",
	// GPU_TYPE_PCI -> GpuTypePci
	3: "GpuTypePci",
}
var GpuType_CamelValue = map[string]int32{
	"GpuTypeNone": 0,
	"GpuTypeAny":  1,
	"GpuTypeVgpu": 2,
	"GpuTypePci":  3,
}

func ParseGpuType(data interface{}) (GpuType, error) {
	if val, ok := data.(GpuType); ok {
		return val, nil
	} else if str, ok := data.(string); ok {
		val, ok := GpuType_CamelValue[util.CamelCase(str)]
		if !ok {
			// may have omitted common prefix
			val, ok = GpuType_CamelValue["GpuType"+util.CamelCase(str)]
		}
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = GpuType_CamelName[val]
			}
		}
		if !ok {
			return GpuType(0), fmt.Errorf("Invalid GpuType value %q", str)
		}
		return GpuType(val), nil
	} else if ival, ok := data.(int32); ok {
		if _, ok := GpuType_CamelName[ival]; ok {
			return GpuType(ival), nil
		} else {
			return GpuType(0), fmt.Errorf("Invalid GpuType value %d", ival)
		}
	}
	return GpuType(0), fmt.Errorf("Invalid GpuType value %v", data)
}

func (e *GpuType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, err := ParseGpuType(str)
	if err != nil {
		return err
	}
	*e = val
	return nil
}

func (e GpuType) MarshalYAML() (interface{}, error) {
	str := proto.EnumName(GpuType_CamelName, int32(e))
	str = strings.TrimPrefix(str, "GpuType")
	return str, nil
}

// custom JSON encoding/decoding
func (e *GpuType) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, err := ParseGpuType(str)
		if err != nil {
			return &json.UnmarshalTypeError{
				Value: "string " + str,
				Type:  reflect.TypeOf(GpuType(0)),
			}
		}
		*e = GpuType(val)
		return nil
	}
	var ival int32
	err = json.Unmarshal(b, &ival)
	if err == nil {
		val, err := ParseGpuType(ival)
		if err == nil {
			*e = val
			return nil
		}
	}
	return &json.UnmarshalTypeError{
		Value: "value " + string(b),
		Type:  reflect.TypeOf(GpuType(0)),
	}
}

func (e GpuType) MarshalJSON() ([]byte, error) {
	str := proto.EnumName(GpuType_CamelName, int32(e))
	str = strings.TrimPrefix(str, "GpuType")
	return json.Marshal(str)
}

var GpuTypeCommonPrefix = "GpuType"

func (m *App) IsValidArgsForCreateApp() error {
	if m.DelOpt != 0 {
		return fmt.Errorf("Invalid field specified: DelOpt, this field is only for internal use")
	}
	if m.AutoProvPolicy != "" {
		return fmt.Errorf("Invalid field specified: AutoProvPolicy, this field is only for internal use")
	}
	if m.DeletePrepare != false {
		return fmt.Errorf("Invalid field specified: DeletePrepare, this field is only for internal use")
	}
	if m.CreatedAt.Seconds != 0 {
		return fmt.Errorf("Invalid field specified: CreatedAt.Seconds, this field is only for internal use")
	}
	if m.CreatedAt.Nanos != 0 {
		return fmt.Errorf("Invalid field specified: CreatedAt.Nanos, this field is only for internal use")
	}
	if m.UpdatedAt.Seconds != 0 {
		return fmt.Errorf("Invalid field specified: UpdatedAt.Seconds, this field is only for internal use")
	}
	if m.UpdatedAt.Nanos != 0 {
		return fmt.Errorf("Invalid field specified: UpdatedAt.Nanos, this field is only for internal use")
	}
	if m.UpdateListAction != "" {
		return fmt.Errorf("Invalid field specified: UpdateListAction, this field is only for internal use")
	}
	if m.CompatibilityVersion != 0 {
		return fmt.Errorf("Invalid field specified: CompatibilityVersion, this field is only for internal use")
	}
	return nil
}

func (m *App) IsValidArgsForDeleteApp() error {
	if m.DelOpt != 0 {
		return fmt.Errorf("Invalid field specified: DelOpt, this field is only for internal use")
	}
	if m.AutoProvPolicy != "" {
		return fmt.Errorf("Invalid field specified: AutoProvPolicy, this field is only for internal use")
	}
	if m.DeletePrepare != false {
		return fmt.Errorf("Invalid field specified: DeletePrepare, this field is only for internal use")
	}
	if m.CreatedAt.Seconds != 0 {
		return fmt.Errorf("Invalid field specified: CreatedAt.Seconds, this field is only for internal use")
	}
	if m.CreatedAt.Nanos != 0 {
		return fmt.Errorf("Invalid field specified: CreatedAt.Nanos, this field is only for internal use")
	}
	if m.UpdatedAt.Seconds != 0 {
		return fmt.Errorf("Invalid field specified: UpdatedAt.Seconds, this field is only for internal use")
	}
	if m.UpdatedAt.Nanos != 0 {
		return fmt.Errorf("Invalid field specified: UpdatedAt.Nanos, this field is only for internal use")
	}
	if m.UpdateListAction != "" {
		return fmt.Errorf("Invalid field specified: UpdateListAction, this field is only for internal use")
	}
	if m.CompatibilityVersion != 0 {
		return fmt.Errorf("Invalid field specified: CompatibilityVersion, this field is only for internal use")
	}
	return nil
}

func (m *App) IsValidArgsForUpdateApp() error {
	if m.DelOpt != 0 {
		return fmt.Errorf("Invalid field specified: DelOpt, this field is only for internal use")
	}
	if m.AutoProvPolicy != "" {
		return fmt.Errorf("Invalid field specified: AutoProvPolicy, this field is only for internal use")
	}
	if m.DeletePrepare != false {
		return fmt.Errorf("Invalid field specified: DeletePrepare, this field is only for internal use")
	}
	if m.CreatedAt.Seconds != 0 {
		return fmt.Errorf("Invalid field specified: CreatedAt.Seconds, this field is only for internal use")
	}
	if m.CreatedAt.Nanos != 0 {
		return fmt.Errorf("Invalid field specified: CreatedAt.Nanos, this field is only for internal use")
	}
	if m.UpdatedAt.Seconds != 0 {
		return fmt.Errorf("Invalid field specified: UpdatedAt.Seconds, this field is only for internal use")
	}
	if m.UpdatedAt.Nanos != 0 {
		return fmt.Errorf("Invalid field specified: UpdatedAt.Nanos, this field is only for internal use")
	}
	if m.CompatibilityVersion != 0 {
		return fmt.Errorf("Invalid field specified: CompatibilityVersion, this field is only for internal use")
	}
	return nil
}

func (m *AppAutoProvPolicy) IsValidArgsForAddAppAutoProvPolicy() error {
	return nil
}

func (m *AppAutoProvPolicy) IsValidArgsForRemoveAppAutoProvPolicy() error {
	return nil
}

func (m *AppAlertPolicy) IsValidArgsForAddAppAlertPolicy() error {
	return nil
}

func (m *AppAlertPolicy) IsValidArgsForRemoveAppAlertPolicy() error {
	return nil
}

func (m *App) IsValidArgsForShowPublicApp() error {
	if m.DelOpt != 0 {
		return fmt.Errorf("Invalid field specified: DelOpt, this field is only for internal use")
	}
	if m.AutoProvPolicy != "" {
		return fmt.Errorf("Invalid field specified: AutoProvPolicy, this field is only for internal use")
	}
	if m.DeletePrepare != false {
		return fmt.Errorf("Invalid field specified: DeletePrepare, this field is only for internal use")
	}
	if m.CreatedAt.Seconds != 0 {
		return fmt.Errorf("Invalid field specified: CreatedAt.Seconds, this field is only for internal use")
	}
	if m.CreatedAt.Nanos != 0 {
		return fmt.Errorf("Invalid field specified: CreatedAt.Nanos, this field is only for internal use")
	}
	if m.UpdatedAt.Seconds != 0 {
		return fmt.Errorf("Invalid field specified: UpdatedAt.Seconds, this field is only for internal use")
	}
	if m.UpdatedAt.Nanos != 0 {
		return fmt.Errorf("Invalid field specified: UpdatedAt.Nanos, this field is only for internal use")
	}
	if m.UpdateListAction != "" {
		return fmt.Errorf("Invalid field specified: UpdateListAction, this field is only for internal use")
	}
	if m.CompatibilityVersion != 0 {
		return fmt.Errorf("Invalid field specified: CompatibilityVersion, this field is only for internal use")
	}
	return nil
}

func (m *AppKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Organization)
	if l > 0 {
		n += 1 + l + sovApp(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApp(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovApp(uint64(l))
	}
	return n
}

func (m *ConfigFile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovApp(uint64(l))
	}
	l = len(m.Config)
	if l > 0 {
		n += 1 + l + sovApp(uint64(l))
	}
	return n
}

func (m *App) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovApp(uint64(l))
		}
	}
	l = m.Key.Size()
	n += 1 + l + sovApp(uint64(l))
	l = len(m.ImagePath)
	if l > 0 {
		n += 1 + l + sovApp(uint64(l))
	}
	if m.ImageType != 0 {
		n += 1 + sovApp(uint64(m.ImageType))
	}
	l = len(m.AccessPorts)
	if l > 0 {
		n += 1 + l + sovApp(uint64(l))
	}
	l = m.DefaultFlavor.Size()
	n += 1 + l + sovApp(uint64(l))
	l = len(m.AuthPublicKey)
	if l > 0 {
		n += 1 + l + sovApp(uint64(l))
	}
	l = len(m.Command)
	if l > 0 {
		n += 1 + l + sovApp(uint64(l))
	}
	l = len(m.Annotations)
	if l > 0 {
		n += 1 + l + sovApp(uint64(l))
	}
	l = len(m.Deployment)
	if l > 0 {
		n += 1 + l + sovApp(uint64(l))
	}
	l = len(m.DeploymentManifest)
	if l > 0 {
		n += 2 + l + sovApp(uint64(l))
	}
	l = len(m.DeploymentGenerator)
	if l > 0 {
		n += 2 + l + sovApp(uint64(l))
	}
	l = len(m.AndroidPackageName)
	if l > 0 {
		n += 2 + l + sovApp(uint64(l))
	}
	if m.DelOpt != 0 {
		n += 2 + sovApp(uint64(m.DelOpt))
	}
	if len(m.Configs) > 0 {
		for _, e := range m.Configs {
			l = e.Size()
			n += 2 + l + sovApp(uint64(l))
		}
	}
	if m.ScaleWithCluster {
		n += 3
	}
	if m.InternalPorts {
		n += 3
	}
	l = len(m.Revision)
	if l > 0 {
		n += 2 + l + sovApp(uint64(l))
	}
	l = len(m.OfficialFqdn)
	if l > 0 {
		n += 2 + l + sovApp(uint64(l))
	}
	l = len(m.Md5Sum)
	if l > 0 {
		n += 2 + l + sovApp(uint64(l))
	}
	l = len(m.AutoProvPolicy)
	if l > 0 {
		n += 2 + l + sovApp(uint64(l))
	}
	if m.AccessType != 0 {
		n += 2 + sovApp(uint64(m.AccessType))
	}
	if m.DeletePrepare {
		n += 3
	}
	if len(m.AutoProvPolicies) > 0 {
		for _, s := range m.AutoProvPolicies {
			l = len(s)
			n += 2 + l + sovApp(uint64(l))
		}
	}
	l = len(m.TemplateDelimiter)
	if l > 0 {
		n += 2 + l + sovApp(uint64(l))
	}
	l = len(m.SkipHcPorts)
	if l > 0 {
		n += 2 + l + sovApp(uint64(l))
	}
	l = m.CreatedAt.Size()
	n += 2 + l + sovApp(uint64(l))
	l = m.UpdatedAt.Size()
	n += 2 + l + sovApp(uint64(l))
	if m.Trusted {
		n += 3
	}
	if len(m.RequiredOutboundConnections) > 0 {
		for _, e := range m.RequiredOutboundConnections {
			l = e.Size()
			n += 2 + l + sovApp(uint64(l))
		}
	}
	if m.AllowServerless {
		n += 3
	}
	if m.ServerlessConfig != nil {
		l = m.ServerlessConfig.Size()
		n += 2 + l + sovApp(uint64(l))
	}
	if m.VmAppOsType != 0 {
		n += 2 + sovApp(uint64(m.VmAppOsType))
	}
	if len(m.AlertPolicies) > 0 {
		for _, s := range m.AlertPolicies {
			l = len(s)
			n += 2 + l + sovApp(uint64(l))
		}
	}
	if m.QosSessionProfile != 0 {
		n += 2 + sovApp(uint64(m.QosSessionProfile))
	}
	if m.QosSessionDuration != 0 {
		n += 2 + sovApp(uint64(m.QosSessionDuration))
	}
	l = len(m.GlobalId)
	if l > 0 {
		n += 2 + l + sovApp(uint64(l))
	}
	if len(m.CommandArgs) > 0 {
		for _, s := range m.CommandArgs {
			l = len(s)
			n += 2 + l + sovApp(uint64(l))
		}
	}
	if len(m.EnvVars) > 0 {
		for k, v := range m.EnvVars {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovApp(uint64(len(k))) + 1 + len(v) + sovApp(uint64(len(v)))
			n += mapEntrySize + 2 + sovApp(uint64(mapEntrySize))
		}
	}
	if len(m.SecretEnvVars) > 0 {
		for k, v := range m.SecretEnvVars {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovApp(uint64(len(k))) + 1 + len(v) + sovApp(uint64(len(v)))
			n += mapEntrySize + 2 + sovApp(uint64(mapEntrySize))
		}
	}
	l = len(m.UpdateListAction)
	if l > 0 {
		n += 2 + l + sovApp(uint64(l))
	}
	if m.KubernetesResources != nil {
		l = m.KubernetesResources.Size()
		n += 2 + l + sovApp(uint64(l))
	}
	if m.NodeResources != nil {
		l = m.NodeResources.Size()
		n += 2 + l + sovApp(uint64(l))
	}
	l = len(m.ObjId)
	if l > 0 {
		n += 2 + l + sovApp(uint64(l))
	}
	if len(m.AppAnnotations) > 0 {
		for k, v := range m.AppAnnotations {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovApp(uint64(len(k))) + 1 + len(v) + sovApp(uint64(len(v)))
			n += mapEntrySize + 2 + sovApp(uint64(mapEntrySize))
		}
	}
	if m.IsStandalone {
		n += 3
	}
	if m.ManagesOwnNamespaces {
		n += 3
	}
	if m.CompatibilityVersion != 0 {
		n += 2 + sovApp(uint64(m.CompatibilityVersion))
	}
	l = len(m.Username)
	if l > 0 {
		n += 2 + l + sovApp(uint64(l))
	}
	l = len(m.Credentials)
	if l > 0 {
		n += 2 + l + sovApp(uint64(l))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovApp(uint64(len(k))) + 1 + len(v) + sovApp(uint64(len(v)))
			n += mapEntrySize + 2 + sovApp(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ServerlessConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Vcpus.Size()
	n += 1 + l + sovApp(uint64(l))
	if m.Ram != 0 {
		n += 1 + sovApp(uint64(m.Ram))
	}
	if m.MinReplicas != 0 {
		n += 1 + sovApp(uint64(m.MinReplicas))
	}
	l = m.GpuConfig.Size()
	n += 1 + l + sovApp(uint64(l))
	return n
}

func (m *GpuConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovApp(uint64(m.Type))
	}
	l = len(m.Model)
	if l > 0 {
		n += 1 + l + sovApp(uint64(l))
	}
	if m.NumGpu != 0 {
		n += 1 + sovApp(uint64(m.NumGpu))
	}
	if m.Ram != 0 {
		n += 1 + sovApp(uint64(m.Ram))
	}
	return n
}

func (m *AppAutoProvPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.AppKey.Size()
	n += 1 + l + sovApp(uint64(l))
	l = len(m.AutoProvPolicy)
	if l > 0 {
		n += 1 + l + sovApp(uint64(l))
	}
	return n
}

func (m *AppAlertPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.AppKey.Size()
	n += 1 + l + sovApp(uint64(l))
	l = len(m.AlertPolicy)
	if l > 0 {
		n += 1 + l + sovApp(uint64(l))
	}
	return n
}

func (m *DeploymentZoneRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.App != nil {
		l = m.App.Size()
		n += 1 + l + sovApp(uint64(l))
	}
	if m.DryRunDeploy {
		n += 2
	}
	if m.NumNodes != 0 {
		n += 1 + sovApp(uint64(m.NumNodes))
	}
	return n
}

func sovApp(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozApp(x uint64) (n int) {
	return sovApp(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AppKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Organization", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Organization = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigFile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigFile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigFile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Config = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *App) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: App: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: App: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImagePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImagePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageType", wireType)
			}
			m.ImageType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ImageType |= ImageType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessPorts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessPorts = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultFlavor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DefaultFlavor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthPublicKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthPublicKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Command = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Annotations = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deployment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Deployment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentManifest", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeploymentManifest = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentGenerator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeploymentGenerator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AndroidPackageName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AndroidPackageName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelOpt", wireType)
			}
			m.DelOpt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DelOpt |= DeleteType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Configs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Configs = append(m.Configs, &ConfigFile{})
			if err := m.Configs[len(m.Configs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScaleWithCluster", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ScaleWithCluster = bool(v != 0)
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalPorts", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InternalPorts = bool(v != 0)
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Revision", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Revision = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OfficialFqdn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OfficialFqdn = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Md5Sum", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Md5Sum = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoProvPolicy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AutoProvPolicy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessType", wireType)
			}
			m.AccessType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessType |= AccessType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletePrepare", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DeletePrepare = bool(v != 0)
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoProvPolicies", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AutoProvPolicies = append(m.AutoProvPolicies, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TemplateDelimiter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TemplateDelimiter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipHcPorts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SkipHcPorts = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CreatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.UpdatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trusted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Trusted = bool(v != 0)
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequiredOutboundConnections", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequiredOutboundConnections = append(m.RequiredOutboundConnections, SecurityRule{})
			if err := m.RequiredOutboundConnections[len(m.RequiredOutboundConnections)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 39:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowServerless", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowServerless = bool(v != 0)
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerlessConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ServerlessConfig == nil {
				m.ServerlessConfig = &ServerlessConfig{}
			}
			if err := m.ServerlessConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VmAppOsType", wireType)
			}
			m.VmAppOsType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VmAppOsType |= VmAppOsType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlertPolicies", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AlertPolicies = append(m.AlertPolicies, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 43:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QosSessionProfile", wireType)
			}
			m.QosSessionProfile = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QosSessionProfile |= QosSessionProfile(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 44:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QosSessionDuration", wireType)
			}
			m.QosSessionDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QosSessionDuration |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GlobalId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 46:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandArgs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommandArgs = append(m.CommandArgs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 47:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnvVars", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EnvVars == nil {
				m.EnvVars = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApp
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthApp
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthApp
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApp
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthApp
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthApp
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApp(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthApp
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.EnvVars[mapkey] = mapvalue
			iNdEx = postIndex
		case 48:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecretEnvVars", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SecretEnvVars == nil {
				m.SecretEnvVars = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApp
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthApp
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthApp
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApp
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthApp
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthApp
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApp(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthApp
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.SecretEnvVars[mapkey] = mapvalue
			iNdEx = postIndex
		case 49:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateListAction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdateListAction = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KubernetesResources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KubernetesResources == nil {
				m.KubernetesResources = &KubernetesResources{}
			}
			if err := m.KubernetesResources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeResources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeResources == nil {
				m.NodeResources = &NodeResources{}
			}
			if err := m.NodeResources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 52:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 53:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppAnnotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AppAnnotations == nil {
				m.AppAnnotations = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApp
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthApp
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthApp
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApp
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthApp
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthApp
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApp(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthApp
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.AppAnnotations[mapkey] = mapvalue
			iNdEx = postIndex
		case 54:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsStandalone", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsStandalone = bool(v != 0)
		case 55:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManagesOwnNamespaces", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ManagesOwnNamespaces = bool(v != 0)
		case 56:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompatibilityVersion", wireType)
			}
			m.CompatibilityVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompatibilityVersion |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 57:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 58:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Credentials", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Credentials = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApp
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthApp
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthApp
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApp
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthApp
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthApp
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApp(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthApp
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServerlessConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServerlessConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServerlessConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vcpus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Vcpus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ram", wireType)
			}
			m.Ram = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ram |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinReplicas", wireType)
			}
			m.MinReplicas = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinReplicas |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpuConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GpuConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GpuConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GpuConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GpuConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= GpuType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Model = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumGpu", wireType)
			}
			m.NumGpu = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumGpu |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ram", wireType)
			}
			m.Ram = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ram |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppAutoProvPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppAutoProvPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppAutoProvPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AppKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoProvPolicy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AutoProvPolicy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppAlertPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppAlertPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppAlertPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AppKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlertPolicy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AlertPolicy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeploymentZoneRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeploymentZoneRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeploymentZoneRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field App", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.App == nil {
				m.App = &App{}
			}
			if err := m.App.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DryRunDeploy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DryRunDeploy = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumNodes", wireType)
			}
			m.NumNodes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumNodes |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipApp(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowApp
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApp
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApp
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthApp
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupApp
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthApp
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthApp        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowApp          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupApp = fmt.Errorf("proto: unexpected end of group")
)
