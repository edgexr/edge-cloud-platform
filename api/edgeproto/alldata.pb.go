// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: alldata.proto

package edgeproto

import (
	context "context"
	fmt "fmt"
	"github.com/edgexr/edge-cloud-platform/pkg/objstore"
	_ "github.com/edgexr/edge-cloud-platform/tools/protogen"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	io "io"
	math "math"
	math_bits "math/bits"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// AllData contains all data that may be used for declarative
// create/delete, or as input for e2e tests.
// The order of fields here is important, as objects will be
// created in the order they are specified here, and deleted
// in the opposite order. The field ID (number) doesn't matter.
type AllData struct {
	Flavors                    []Flavor                    `protobuf:"bytes,2,rep,name=flavors,proto3" json:"flavors"`
	Settings                   *Settings                   `protobuf:"bytes,1,opt,name=settings,proto3" json:"settings,omitempty"`
	OperatorCodes              []OperatorCode              `protobuf:"bytes,4,rep,name=operator_codes,json=operatorCodes,proto3" json:"operator_codes"`
	ResTagTables               []ResTagTable               `protobuf:"bytes,6,rep,name=res_tag_tables,json=resTagTables,proto3" json:"res_tag_tables"`
	TrustPolicies              []TrustPolicy               `protobuf:"bytes,14,rep,name=trust_policies,json=trustPolicies,proto3" json:"trust_policies"`
	GpuDrivers                 []GPUDriver                 `protobuf:"bytes,21,rep,name=gpu_drivers,json=gpuDrivers,proto3" json:"gpu_drivers"`
	PlatformFeatures           []PlatformFeatures          `protobuf:"bytes,28,rep,name=platform_features,json=platformFeatures,proto3" json:"platform_features"`
	Zones                      []Zone                      `protobuf:"bytes,29,rep,name=zones,proto3" json:"zones"`
	Cloudlets                  []Cloudlet                  `protobuf:"bytes,7,rep,name=cloudlets,proto3" json:"cloudlets"`
	CloudletInfos              []CloudletInfo              `protobuf:"bytes,8,rep,name=cloudlet_infos,json=cloudletInfos,proto3" json:"cloudlet_infos"`
	ZonePools                  []ZonePool                  `protobuf:"bytes,9,rep,name=zone_pools,json=zonePools,proto3" json:"zone_pools"`
	Nodes                      []Node                      `protobuf:"bytes,30,rep,name=nodes,proto3" json:"nodes"`
	CloudletNodeRefs           []CloudletNodeRefs          `protobuf:"bytes,31,rep,name=cloudlet_node_refs,json=cloudletNodeRefs,proto3" json:"cloudlet_node_refs"`
	Networks                   []Network                   `protobuf:"bytes,25,rep,name=networks,proto3" json:"networks"`
	AutoProvPolicies           []AutoProvPolicy            `protobuf:"bytes,11,rep,name=auto_prov_policies,json=autoProvPolicies,proto3" json:"auto_prov_policies"`
	AutoProvPolicyZones        []AutoProvPolicyZone        `protobuf:"bytes,12,rep,name=auto_prov_policy_zones,json=autoProvPolicyZones,proto3" json:"auto_prov_policy_zones"`
	AutoScalePolicies          []AutoScalePolicy           `protobuf:"bytes,13,rep,name=auto_scale_policies,json=autoScalePolicies,proto3" json:"auto_scale_policies"`
	IdleReservableClusterInsts *IdleReservableClusterInsts `protobuf:"bytes,20,opt,name=idle_reservable_cluster_insts,json=idleReservableClusterInsts,proto3" json:"idle_reservable_cluster_insts,omitempty"`
	ClusterInsts               []ClusterInst               `protobuf:"bytes,15,rep,name=cluster_insts,json=clusterInsts,proto3" json:"cluster_insts"`
	Apps                       []App                       `protobuf:"bytes,16,rep,name=apps,proto3" json:"apps"`
	AppInstances               []AppInst                   `protobuf:"bytes,17,rep,name=app_instances,json=appInstances,proto3" json:"app_instances"`
	AppInstRefs                []AppInstRefs               `protobuf:"bytes,18,rep,name=app_inst_refs,json=appInstRefs,proto3" json:"app_inst_refs"`
	ClusterRefs                []ClusterRefs               `protobuf:"bytes,27,rep,name=cluster_refs,json=clusterRefs,proto3" json:"cluster_refs"`
	VmPools                    []VMPool                    `protobuf:"bytes,19,rep,name=vm_pools,json=vmPools,proto3" json:"vm_pools"`
	AlertPolicies              []AlertPolicy               `protobuf:"bytes,22,rep,name=alert_policies,json=alertPolicies,proto3" json:"alert_policies"`
	FlowRateLimitSettings      []FlowRateLimitSettings     `protobuf:"bytes,23,rep,name=flow_rate_limit_settings,json=flowRateLimitSettings,proto3" json:"flow_rate_limit_settings"`
	MaxReqsRateLimitSettings   []MaxReqsRateLimitSettings  `protobuf:"bytes,24,rep,name=max_reqs_rate_limit_settings,json=maxReqsRateLimitSettings,proto3" json:"max_reqs_rate_limit_settings"`
	TrustPolicyExceptions      []TrustPolicyException      `protobuf:"bytes,26,rep,name=trust_policy_exceptions,json=trustPolicyExceptions,proto3" json:"trust_policy_exceptions"`
}

func (m *AllData) Reset()         { *m = AllData{} }
func (m *AllData) String() string { return proto.CompactTextString(m) }
func (*AllData) ProtoMessage()    {}
func (*AllData) Descriptor() ([]byte, []int) {
	return fileDescriptor_8eca40466c9a5f17, []int{0}
}
func (m *AllData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AllData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AllData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AllData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllData.Merge(m, src)
}
func (m *AllData) XXX_Size() int {
	return m.Size()
}
func (m *AllData) XXX_DiscardUnknown() {
	xxx_messageInfo_AllData.DiscardUnknown(m)
}

var xxx_messageInfo_AllData proto.InternalMessageInfo

func init() {
	proto.RegisterType((*AllData)(nil), "edgeproto.AllData")
}

func init() { proto.RegisterFile("alldata.proto", fileDescriptor_8eca40466c9a5f17) }

var fileDescriptor_8eca40466c9a5f17 = []byte{
	// 985 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x55, 0x4f, 0x6f, 0x23, 0x35,
	0x14, 0x4f, 0xa0, 0x6c, 0x53, 0xa7, 0x49, 0x1b, 0xf7, 0x9f, 0x37, 0xdb, 0xa6, 0x15, 0x08, 0xa9,
	0x12, 0x52, 0x2b, 0x0a, 0x12, 0x08, 0x84, 0xa0, 0x4d, 0x59, 0x54, 0x89, 0xee, 0x46, 0xd9, 0x82,
	0x10, 0x12, 0xb2, 0xbc, 0x13, 0x67, 0x18, 0xe1, 0x8c, 0xbd, 0xb6, 0x93, 0xb6, 0xfb, 0x29, 0x38,
	0x72, 0xe4, 0xc2, 0x77, 0xe9, 0x71, 0x8f, 0x9c, 0x10, 0xb4, 0xdf, 0x61, 0xcf, 0xc8, 0x1e, 0x7b,
	0xc6, 0xd3, 0x69, 0x6e, 0xf6, 0xef, 0xfd, 0xde, 0xef, 0x3d, 0xdb, 0xef, 0x3d, 0x83, 0x16, 0x61,
	0x6c, 0x44, 0x34, 0x39, 0x10, 0x92, 0x6b, 0x0e, 0x97, 0xe8, 0x28, 0xa6, 0x76, 0xd9, 0xdd, 0xd1,
	0x9c, 0x33, 0x75, 0x68, 0x37, 0x31, 0x4d, 0xf3, 0x45, 0xc6, 0xec, 0xb6, 0x15, 0xd5, 0x3a, 0x49,
	0x63, 0xe5, 0xf6, 0xcb, 0x63, 0x46, 0x66, 0x5c, 0xba, 0x1d, 0xe4, 0x82, 0x4a, 0xa2, 0xb9, 0x8c,
	0xf8, 0x88, 0x3a, 0xac, 0x23, 0xa9, 0xd2, 0x24, 0xd6, 0xe4, 0x25, 0xf3, 0x50, 0x3b, 0x62, 0x7c,
	0x3a, 0x62, 0x54, 0xbb, 0x3d, 0x78, 0xcd, 0xd3, 0xdc, 0x66, 0xd6, 0x82, 0x73, 0xe6, 0x03, 0xcc,
	0x26, 0xc1, 0x6e, 0x9d, 0x4c, 0x35, 0x17, 0x92, 0xcf, 0x04, 0x67, 0x49, 0x74, 0xed, 0xd0, 0x0d,
	0x83, 0xaa, 0x88, 0x30, 0x5a, 0x82, 0x3b, 0x5a, 0x4e, 0x95, 0x2e, 0x41, 0xdd, 0x00, 0xa2, 0x57,
	0x11, 0x15, 0x3a, 0xe1, 0xfe, 0x68, 0xad, 0x94, 0xea, 0x4b, 0x2e, 0x7f, 0xf3, 0xde, 0x11, 0x9b,
	0x2a, 0x4d, 0x65, 0x92, 0x2a, 0x9f, 0xe7, 0x12, 0x11, 0xc2, 0x93, 0x89, 0x10, 0x81, 0x05, 0x48,
	0x3a, 0xf6, 0x57, 0xd2, 0x21, 0x8c, 0xca, 0x72, 0xd8, 0x15, 0x49, 0x34, 0x65, 0xc9, 0x24, 0xf1,
	0xfc, 0xf5, 0x98, 0xc7, 0xdc, 0x2e, 0x0f, 0xcd, 0xca, 0xab, 0xa4, 0xf9, 0xb5, 0xbd, 0xff, 0xd7,
	0x0a, 0x58, 0x3c, 0x66, 0xec, 0x94, 0x68, 0x02, 0x3f, 0x06, 0x8b, 0xd9, 0x35, 0x2b, 0xf4, 0xce,
	0xde, 0xbb, 0xfb, 0xcd, 0xa3, 0xce, 0x41, 0xfe, 0x60, 0x07, 0x4f, 0xad, 0xe5, 0x64, 0xe1, 0xe6,
	0x9f, 0xdd, 0xda, 0xd0, 0xf3, 0xe0, 0x21, 0x68, 0xf8, 0x97, 0x42, 0xf5, 0xbd, 0xfa, 0x7e, 0xf3,
	0x68, 0x2d, 0xf0, 0x79, 0xe1, 0x4c, 0xc3, 0x9c, 0x04, 0x4f, 0x41, 0xdb, 0x3f, 0x1e, 0x36, 0xaf,
	0xa7, 0xd0, 0x82, 0x0d, 0xb5, 0x15, 0xb8, 0x3d, 0x77, 0x84, 0x3e, 0x1f, 0x51, 0x17, 0xb0, 0xc5,
	0x03, 0x4c, 0xc1, 0x13, 0xd0, 0x96, 0x54, 0x61, 0x4d, 0x62, 0x6c, 0x1f, 0x5c, 0xa1, 0x47, 0x56,
	0x65, 0x33, 0x50, 0x19, 0x52, 0x75, 0x41, 0xe2, 0x0b, 0x63, 0x76, 0x22, 0xcb, 0xb2, 0x80, 0x14,
	0xec, 0x83, 0xb6, 0x7d, 0x25, 0x6c, 0xaf, 0x30, 0xa1, 0x0a, 0xb5, 0x2b, 0x1a, 0x17, 0x86, 0x30,
	0xb0, 0x57, 0xec, 0x13, 0xd1, 0x39, 0x94, 0x50, 0x05, 0xbf, 0x04, 0xcd, 0x58, 0x4c, 0xf1, 0x48,
	0x26, 0x33, 0x2a, 0x15, 0xda, 0xb0, 0x0a, 0xeb, 0x81, 0xc2, 0x77, 0x83, 0x1f, 0x4e, 0xad, 0xd1,
	0xf9, 0x83, 0x58, 0x4c, 0x33, 0x40, 0xc1, 0x67, 0xa0, 0x23, 0x18, 0xd1, 0x63, 0x2e, 0x27, 0x78,
	0x4c, 0x89, 0x9e, 0x4a, 0xaa, 0xd0, 0xb6, 0x95, 0x78, 0x12, 0x48, 0x0c, 0x1c, 0xe7, 0xa9, 0xa3,
	0x38, 0xa5, 0x55, 0x71, 0x0f, 0x87, 0x1f, 0x81, 0xf7, 0x4c, 0x55, 0x2b, 0xb4, 0x63, 0x35, 0x56,
	0x02, 0x8d, 0x9f, 0x79, 0xea, 0x6f, 0x21, 0xe3, 0xc0, 0xcf, 0xc0, 0x92, 0x6f, 0x0f, 0x85, 0x16,
	0xad, 0x43, 0xf8, 0x74, 0x7d, 0x67, 0x73, 0x4e, 0x05, 0xd7, 0xbc, 0xa0, 0xdf, 0xe0, 0x24, 0x1d,
	0x73, 0x85, 0x1a, 0x95, 0x17, 0xf4, 0xde, 0x67, 0xe9, 0x98, 0xfb, 0x8b, 0x8b, 0x02, 0x4c, 0xc1,
	0xcf, 0x81, 0xed, 0x46, 0x6c, 0x9a, 0x4e, 0xa1, 0xa5, 0x4a, 0x7c, 0x93, 0xf0, 0x80, 0x73, 0xe6,
	0xe3, 0xbf, 0x76, 0x7b, 0x7b, 0xca, 0xd4, 0x16, 0x4e, 0xaf, 0x72, 0xca, 0x67, 0x45, 0xc1, 0x64,
	0x1c, 0xf8, 0x1c, 0xc0, 0x3c, 0x59, 0x83, 0x60, 0xd3, 0x40, 0x68, 0xb7, 0x72, 0xc7, 0x3e, 0x61,
	0xa3, 0x30, 0xa4, 0xe3, 0xfc, 0x8e, 0xa3, 0x7b, 0x38, 0xfc, 0x14, 0x34, 0x5c, 0xff, 0x2a, 0xf4,
	0xd8, 0xca, 0xc0, 0x30, 0x81, 0xcc, 0xe4, 0xbc, 0x73, 0x26, 0x3c, 0x07, 0xd0, 0xcc, 0x0e, 0x6c,
	0x46, 0x4a, 0x51, 0x6f, 0x4d, 0xeb, 0xff, 0x38, 0xf0, 0x3f, 0x9e, 0x6a, 0x3e, 0x90, 0x7c, 0x56,
	0x2a, 0xb9, 0x55, 0x12, 0xa2, 0xa6, 0xea, 0x7e, 0x02, 0x9b, 0xf7, 0xe4, 0xae, 0x71, 0xf6, 0xf2,
	0xcb, 0x56, 0x72, 0x67, 0xae, 0x64, 0x50, 0x07, 0x6b, 0xa4, 0x62, 0x51, 0x70, 0x00, 0x2c, 0x8c,
	0xed, 0x94, 0x2b, 0x32, 0x6d, 0x59, 0xd9, 0xee, 0x3d, 0xd9, 0x17, 0x86, 0x54, 0x4a, 0xb5, 0x43,
	0x4a, 0xb0, 0xc9, 0xf5, 0x57, 0xb0, 0x93, 0x8c, 0x98, 0xb9, 0x78, 0x45, 0xe5, 0xcc, 0xb4, 0x1e,
	0x76, 0x13, 0x0f, 0x9b, 0xc1, 0xa6, 0xd0, 0xba, 0x1d, 0x1b, 0x1f, 0x06, 0xda, 0x67, 0x23, 0x46,
	0x87, 0x39, 0xbd, 0x9f, 0xb1, 0xcf, 0x0c, 0x79, 0xd8, 0x4d, 0xe6, 0xda, 0xe0, 0x31, 0x68, 0x95,
	0x95, 0x57, 0x2a, 0xfd, 0x1c, 0xf0, 0xfd, 0x4c, 0x88, 0x42, 0x89, 0x7d, 0xb0, 0x40, 0x84, 0x50,
	0x68, 0xd5, 0x7a, 0xb6, 0xc3, 0xf3, 0x0a, 0xe1, 0x3c, 0x2c, 0x03, 0x7e, 0x05, 0xcc, 0x68, 0xb6,
	0x81, 0x48, 0x1a, 0x51, 0x85, 0x3a, 0x95, 0x62, 0x38, 0x16, 0x22, 0x0c, 0x44, 0xb2, 0xad, 0x65,
	0xc3, 0x6f, 0x0a, 0xf7, 0xac, 0x24, 0x61, 0x25, 0x57, 0xe7, 0x1e, 0x54, 0x63, 0x93, 0x14, 0x10,
	0xfc, 0x1a, 0xf8, 0xd4, 0x33, 0x81, 0x27, 0xf3, 0x0e, 0x1b, 0x0a, 0x44, 0x05, 0x04, 0x8f, 0x40,
	0x63, 0x36, 0x71, 0xfd, 0xb7, 0x56, 0x19, 0xf7, 0x3f, 0x9e, 0x07, 0xdd, 0xb7, 0x38, 0x9b, 0x64,
	0xbd, 0xd7, 0x07, 0x6d, 0xfb, 0xeb, 0x14, 0x95, 0xb1, 0x59, 0xcd, 0xdb, 0x10, 0xca, 0x33, 0x93,
	0xe4, 0x90, 0xa9, 0x08, 0x0c, 0xd0, 0x98, 0xf1, 0x4b, 0x6c, 0x3e, 0x2b, 0x6c, 0x7f, 0x2b, 0x9c,
	0xff, 0x21, 0x5b, 0x56, 0x6e, 0xaf, 0xf4, 0xef, 0xf0, 0xcb, 0x21, 0xd1, 0xf4, 0x7b, 0x43, 0xf4,
	0x1f, 0x8a, 0x13, 0xde, 0x18, 0x3f, 0x64, 0x84, 0x09, 0xd8, 0x9e, 0x90, 0x2b, 0x2c, 0xe9, 0x2b,
	0xf5, 0x60, 0x10, 0x64, 0x83, 0x7c, 0x10, 0x04, 0x39, 0x27, 0x57, 0x43, 0xfa, 0x4a, 0xcd, 0x8b,
	0x83, 0x26, 0x73, 0xec, 0xf0, 0x17, 0xb0, 0x15, 0x7c, 0x22, 0xd7, 0x38, 0xff, 0xec, 0x15, 0xea,
	0xda, 0x28, 0xbb, 0x0f, 0xff, 0x26, 0xdf, 0x7a, 0x9e, 0x3f, 0x89, 0x7e, 0xc0, 0xa6, 0xbe, 0x68,
	0xfc, 0xf1, 0x16, 0xd5, 0xff, 0x7c, 0x8b, 0x6a, 0x27, 0xdb, 0x37, 0xff, 0xf5, 0x6a, 0x37, 0xb7,
	0xbd, 0xfa, 0x9b, 0xdb, 0x5e, 0xfd, 0xdf, 0xdb, 0x5e, 0xfd, 0xf7, 0xbb, 0x5e, 0xed, 0xcd, 0x5d,
	0xaf, 0xf6, 0xf7, 0x5d, 0xaf, 0xf6, 0xf2, 0x91, 0x0d, 0xf0, 0xc9, 0xff, 0x01, 0x00, 0x00, 0xff,
	0xff, 0xaf, 0x93, 0x46, 0x6f, 0x70, 0x09, 0x00, 0x00,
}

func (m *AllData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AllData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CloudletNodeRefs) > 0 {
		for iNdEx := len(m.CloudletNodeRefs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CloudletNodeRefs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAlldata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xfa
		}
	}
	if len(m.Nodes) > 0 {
		for iNdEx := len(m.Nodes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Nodes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAlldata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xf2
		}
	}
	if len(m.Zones) > 0 {
		for iNdEx := len(m.Zones) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Zones[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAlldata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xea
		}
	}
	if len(m.PlatformFeatures) > 0 {
		for iNdEx := len(m.PlatformFeatures) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PlatformFeatures[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAlldata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xe2
		}
	}
	if len(m.ClusterRefs) > 0 {
		for iNdEx := len(m.ClusterRefs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ClusterRefs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAlldata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xda
		}
	}
	if len(m.TrustPolicyExceptions) > 0 {
		for iNdEx := len(m.TrustPolicyExceptions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TrustPolicyExceptions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAlldata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xd2
		}
	}
	if len(m.Networks) > 0 {
		for iNdEx := len(m.Networks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Networks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAlldata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xca
		}
	}
	if len(m.MaxReqsRateLimitSettings) > 0 {
		for iNdEx := len(m.MaxReqsRateLimitSettings) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MaxReqsRateLimitSettings[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAlldata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xc2
		}
	}
	if len(m.FlowRateLimitSettings) > 0 {
		for iNdEx := len(m.FlowRateLimitSettings) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FlowRateLimitSettings[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAlldata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xba
		}
	}
	if len(m.AlertPolicies) > 0 {
		for iNdEx := len(m.AlertPolicies) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AlertPolicies[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAlldata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xb2
		}
	}
	if len(m.GpuDrivers) > 0 {
		for iNdEx := len(m.GpuDrivers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.GpuDrivers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAlldata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xaa
		}
	}
	if m.IdleReservableClusterInsts != nil {
		{
			size, err := m.IdleReservableClusterInsts.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAlldata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if len(m.VmPools) > 0 {
		for iNdEx := len(m.VmPools) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.VmPools[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAlldata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x9a
		}
	}
	if len(m.AppInstRefs) > 0 {
		for iNdEx := len(m.AppInstRefs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AppInstRefs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAlldata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x92
		}
	}
	if len(m.AppInstances) > 0 {
		for iNdEx := len(m.AppInstances) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AppInstances[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAlldata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x8a
		}
	}
	if len(m.Apps) > 0 {
		for iNdEx := len(m.Apps) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Apps[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAlldata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if len(m.ClusterInsts) > 0 {
		for iNdEx := len(m.ClusterInsts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ClusterInsts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAlldata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x7a
		}
	}
	if len(m.TrustPolicies) > 0 {
		for iNdEx := len(m.TrustPolicies) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TrustPolicies[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAlldata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x72
		}
	}
	if len(m.AutoScalePolicies) > 0 {
		for iNdEx := len(m.AutoScalePolicies) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AutoScalePolicies[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAlldata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6a
		}
	}
	if len(m.AutoProvPolicyZones) > 0 {
		for iNdEx := len(m.AutoProvPolicyZones) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AutoProvPolicyZones[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAlldata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.AutoProvPolicies) > 0 {
		for iNdEx := len(m.AutoProvPolicies) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AutoProvPolicies[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAlldata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.ZonePools) > 0 {
		for iNdEx := len(m.ZonePools) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ZonePools[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAlldata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.CloudletInfos) > 0 {
		for iNdEx := len(m.CloudletInfos) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CloudletInfos[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAlldata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.Cloudlets) > 0 {
		for iNdEx := len(m.Cloudlets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Cloudlets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAlldata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.ResTagTables) > 0 {
		for iNdEx := len(m.ResTagTables) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ResTagTables[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAlldata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.OperatorCodes) > 0 {
		for iNdEx := len(m.OperatorCodes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OperatorCodes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAlldata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Flavors) > 0 {
		for iNdEx := len(m.Flavors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Flavors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAlldata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Settings != nil {
		{
			size, err := m.Settings.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAlldata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintAlldata(dAtA []byte, offset int, v uint64) int {
	offset -= sovAlldata(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *AllData) Clone() *AllData {
	cp := &AllData{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *AllData) AddSettingsEdgeEventsMetricsContinuousQueriesCollectionIntervals(vals ...*CollectionInterval) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.Settings.EdgeEventsMetricsContinuousQueriesCollectionIntervals {
		cur[v.String()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.String()]; found {
			continue // duplicate
		}
		m.Settings.EdgeEventsMetricsContinuousQueriesCollectionIntervals = append(m.Settings.EdgeEventsMetricsContinuousQueriesCollectionIntervals, v)
		changes++
	}
	return changes
}

func (m *AllData) RemoveSettingsEdgeEventsMetricsContinuousQueriesCollectionIntervals(vals ...*CollectionInterval) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.String()] = struct{}{}
	}
	for i := len(m.Settings.EdgeEventsMetricsContinuousQueriesCollectionIntervals); i >= 0; i-- {
		if _, found := remove[m.Settings.EdgeEventsMetricsContinuousQueriesCollectionIntervals[i].String()]; found {
			m.Settings.EdgeEventsMetricsContinuousQueriesCollectionIntervals = append(m.Settings.EdgeEventsMetricsContinuousQueriesCollectionIntervals[:i], m.Settings.EdgeEventsMetricsContinuousQueriesCollectionIntervals[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *AllData) AddFlavors(vals ...Flavor) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.Flavors {
		cur[v.GetKey().GetKeyString()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.GetKey().GetKeyString()]; found {
			continue // duplicate
		}
		m.Flavors = append(m.Flavors, v)
		changes++
	}
	return changes
}

func (m *AllData) RemoveFlavors(vals ...Flavor) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.GetKey().GetKeyString()] = struct{}{}
	}
	for i := len(m.Flavors); i >= 0; i-- {
		if _, found := remove[m.Flavors[i].GetKey().GetKeyString()]; found {
			m.Flavors = append(m.Flavors[:i], m.Flavors[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *AllData) AddOperatorCodes(vals ...OperatorCode) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.OperatorCodes {
		cur[v.String()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.String()]; found {
			continue // duplicate
		}
		m.OperatorCodes = append(m.OperatorCodes, v)
		changes++
	}
	return changes
}

func (m *AllData) RemoveOperatorCodes(vals ...OperatorCode) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.String()] = struct{}{}
	}
	for i := len(m.OperatorCodes); i >= 0; i-- {
		if _, found := remove[m.OperatorCodes[i].String()]; found {
			m.OperatorCodes = append(m.OperatorCodes[:i], m.OperatorCodes[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *AllData) AddResTagTables(vals ...ResTagTable) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.ResTagTables {
		cur[v.GetKey().GetKeyString()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.GetKey().GetKeyString()]; found {
			continue // duplicate
		}
		m.ResTagTables = append(m.ResTagTables, v)
		changes++
	}
	return changes
}

func (m *AllData) RemoveResTagTables(vals ...ResTagTable) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.GetKey().GetKeyString()] = struct{}{}
	}
	for i := len(m.ResTagTables); i >= 0; i-- {
		if _, found := remove[m.ResTagTables[i].GetKey().GetKeyString()]; found {
			m.ResTagTables = append(m.ResTagTables[:i], m.ResTagTables[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *AllData) AddCloudlets(vals ...Cloudlet) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.Cloudlets {
		cur[v.GetKey().GetKeyString()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.GetKey().GetKeyString()]; found {
			continue // duplicate
		}
		m.Cloudlets = append(m.Cloudlets, v)
		changes++
	}
	return changes
}

func (m *AllData) RemoveCloudlets(vals ...Cloudlet) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.GetKey().GetKeyString()] = struct{}{}
	}
	for i := len(m.Cloudlets); i >= 0; i-- {
		if _, found := remove[m.Cloudlets[i].GetKey().GetKeyString()]; found {
			m.Cloudlets = append(m.Cloudlets[:i], m.Cloudlets[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *AllData) AddCloudletInfos(vals ...CloudletInfo) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.CloudletInfos {
		cur[v.GetKey().GetKeyString()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.GetKey().GetKeyString()]; found {
			continue // duplicate
		}
		m.CloudletInfos = append(m.CloudletInfos, v)
		changes++
	}
	return changes
}

func (m *AllData) RemoveCloudletInfos(vals ...CloudletInfo) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.GetKey().GetKeyString()] = struct{}{}
	}
	for i := len(m.CloudletInfos); i >= 0; i-- {
		if _, found := remove[m.CloudletInfos[i].GetKey().GetKeyString()]; found {
			m.CloudletInfos = append(m.CloudletInfos[:i], m.CloudletInfos[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *AllData) AddZonePools(vals ...ZonePool) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.ZonePools {
		cur[v.GetKey().GetKeyString()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.GetKey().GetKeyString()]; found {
			continue // duplicate
		}
		m.ZonePools = append(m.ZonePools, v)
		changes++
	}
	return changes
}

func (m *AllData) RemoveZonePools(vals ...ZonePool) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.GetKey().GetKeyString()] = struct{}{}
	}
	for i := len(m.ZonePools); i >= 0; i-- {
		if _, found := remove[m.ZonePools[i].GetKey().GetKeyString()]; found {
			m.ZonePools = append(m.ZonePools[:i], m.ZonePools[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *AllData) AddAutoProvPolicies(vals ...AutoProvPolicy) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.AutoProvPolicies {
		cur[v.GetKey().GetKeyString()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.GetKey().GetKeyString()]; found {
			continue // duplicate
		}
		m.AutoProvPolicies = append(m.AutoProvPolicies, v)
		changes++
	}
	return changes
}

func (m *AllData) RemoveAutoProvPolicies(vals ...AutoProvPolicy) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.GetKey().GetKeyString()] = struct{}{}
	}
	for i := len(m.AutoProvPolicies); i >= 0; i-- {
		if _, found := remove[m.AutoProvPolicies[i].GetKey().GetKeyString()]; found {
			m.AutoProvPolicies = append(m.AutoProvPolicies[:i], m.AutoProvPolicies[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *AllData) AddAutoProvPolicyZones(vals ...AutoProvPolicyZone) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.AutoProvPolicyZones {
		cur[v.GetKey().GetKeyString()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.GetKey().GetKeyString()]; found {
			continue // duplicate
		}
		m.AutoProvPolicyZones = append(m.AutoProvPolicyZones, v)
		changes++
	}
	return changes
}

func (m *AllData) RemoveAutoProvPolicyZones(vals ...AutoProvPolicyZone) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.GetKey().GetKeyString()] = struct{}{}
	}
	for i := len(m.AutoProvPolicyZones); i >= 0; i-- {
		if _, found := remove[m.AutoProvPolicyZones[i].GetKey().GetKeyString()]; found {
			m.AutoProvPolicyZones = append(m.AutoProvPolicyZones[:i], m.AutoProvPolicyZones[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *AllData) AddAutoScalePolicies(vals ...AutoScalePolicy) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.AutoScalePolicies {
		cur[v.GetKey().GetKeyString()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.GetKey().GetKeyString()]; found {
			continue // duplicate
		}
		m.AutoScalePolicies = append(m.AutoScalePolicies, v)
		changes++
	}
	return changes
}

func (m *AllData) RemoveAutoScalePolicies(vals ...AutoScalePolicy) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.GetKey().GetKeyString()] = struct{}{}
	}
	for i := len(m.AutoScalePolicies); i >= 0; i-- {
		if _, found := remove[m.AutoScalePolicies[i].GetKey().GetKeyString()]; found {
			m.AutoScalePolicies = append(m.AutoScalePolicies[:i], m.AutoScalePolicies[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *AllData) AddTrustPolicies(vals ...TrustPolicy) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.TrustPolicies {
		cur[v.GetKey().GetKeyString()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.GetKey().GetKeyString()]; found {
			continue // duplicate
		}
		m.TrustPolicies = append(m.TrustPolicies, v)
		changes++
	}
	return changes
}

func (m *AllData) RemoveTrustPolicies(vals ...TrustPolicy) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.GetKey().GetKeyString()] = struct{}{}
	}
	for i := len(m.TrustPolicies); i >= 0; i-- {
		if _, found := remove[m.TrustPolicies[i].GetKey().GetKeyString()]; found {
			m.TrustPolicies = append(m.TrustPolicies[:i], m.TrustPolicies[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *AllData) AddClusterInsts(vals ...ClusterInst) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.ClusterInsts {
		cur[v.GetKey().GetKeyString()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.GetKey().GetKeyString()]; found {
			continue // duplicate
		}
		m.ClusterInsts = append(m.ClusterInsts, v)
		changes++
	}
	return changes
}

func (m *AllData) RemoveClusterInsts(vals ...ClusterInst) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.GetKey().GetKeyString()] = struct{}{}
	}
	for i := len(m.ClusterInsts); i >= 0; i-- {
		if _, found := remove[m.ClusterInsts[i].GetKey().GetKeyString()]; found {
			m.ClusterInsts = append(m.ClusterInsts[:i], m.ClusterInsts[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *AllData) AddApps(vals ...App) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.Apps {
		cur[v.GetKey().GetKeyString()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.GetKey().GetKeyString()]; found {
			continue // duplicate
		}
		m.Apps = append(m.Apps, v)
		changes++
	}
	return changes
}

func (m *AllData) RemoveApps(vals ...App) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.GetKey().GetKeyString()] = struct{}{}
	}
	for i := len(m.Apps); i >= 0; i-- {
		if _, found := remove[m.Apps[i].GetKey().GetKeyString()]; found {
			m.Apps = append(m.Apps[:i], m.Apps[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *AllData) AddAppInstances(vals ...AppInst) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.AppInstances {
		cur[v.GetKey().GetKeyString()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.GetKey().GetKeyString()]; found {
			continue // duplicate
		}
		m.AppInstances = append(m.AppInstances, v)
		changes++
	}
	return changes
}

func (m *AllData) RemoveAppInstances(vals ...AppInst) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.GetKey().GetKeyString()] = struct{}{}
	}
	for i := len(m.AppInstances); i >= 0; i-- {
		if _, found := remove[m.AppInstances[i].GetKey().GetKeyString()]; found {
			m.AppInstances = append(m.AppInstances[:i], m.AppInstances[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *AllData) AddAppInstRefs(vals ...AppInstRefs) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.AppInstRefs {
		cur[v.GetKey().GetKeyString()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.GetKey().GetKeyString()]; found {
			continue // duplicate
		}
		m.AppInstRefs = append(m.AppInstRefs, v)
		changes++
	}
	return changes
}

func (m *AllData) RemoveAppInstRefs(vals ...AppInstRefs) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.GetKey().GetKeyString()] = struct{}{}
	}
	for i := len(m.AppInstRefs); i >= 0; i-- {
		if _, found := remove[m.AppInstRefs[i].GetKey().GetKeyString()]; found {
			m.AppInstRefs = append(m.AppInstRefs[:i], m.AppInstRefs[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *AllData) AddVmPools(vals ...VMPool) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.VmPools {
		cur[v.GetKey().GetKeyString()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.GetKey().GetKeyString()]; found {
			continue // duplicate
		}
		m.VmPools = append(m.VmPools, v)
		changes++
	}
	return changes
}

func (m *AllData) RemoveVmPools(vals ...VMPool) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.GetKey().GetKeyString()] = struct{}{}
	}
	for i := len(m.VmPools); i >= 0; i-- {
		if _, found := remove[m.VmPools[i].GetKey().GetKeyString()]; found {
			m.VmPools = append(m.VmPools[:i], m.VmPools[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *AllData) AddGpuDrivers(vals ...GPUDriver) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.GpuDrivers {
		cur[v.GetKey().GetKeyString()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.GetKey().GetKeyString()]; found {
			continue // duplicate
		}
		m.GpuDrivers = append(m.GpuDrivers, v)
		changes++
	}
	return changes
}

func (m *AllData) RemoveGpuDrivers(vals ...GPUDriver) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.GetKey().GetKeyString()] = struct{}{}
	}
	for i := len(m.GpuDrivers); i >= 0; i-- {
		if _, found := remove[m.GpuDrivers[i].GetKey().GetKeyString()]; found {
			m.GpuDrivers = append(m.GpuDrivers[:i], m.GpuDrivers[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *AllData) AddAlertPolicies(vals ...AlertPolicy) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.AlertPolicies {
		cur[v.GetKey().GetKeyString()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.GetKey().GetKeyString()]; found {
			continue // duplicate
		}
		m.AlertPolicies = append(m.AlertPolicies, v)
		changes++
	}
	return changes
}

func (m *AllData) RemoveAlertPolicies(vals ...AlertPolicy) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.GetKey().GetKeyString()] = struct{}{}
	}
	for i := len(m.AlertPolicies); i >= 0; i-- {
		if _, found := remove[m.AlertPolicies[i].GetKey().GetKeyString()]; found {
			m.AlertPolicies = append(m.AlertPolicies[:i], m.AlertPolicies[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *AllData) AddFlowRateLimitSettings(vals ...FlowRateLimitSettings) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.FlowRateLimitSettings {
		cur[v.GetKey().GetKeyString()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.GetKey().GetKeyString()]; found {
			continue // duplicate
		}
		m.FlowRateLimitSettings = append(m.FlowRateLimitSettings, v)
		changes++
	}
	return changes
}

func (m *AllData) RemoveFlowRateLimitSettings(vals ...FlowRateLimitSettings) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.GetKey().GetKeyString()] = struct{}{}
	}
	for i := len(m.FlowRateLimitSettings); i >= 0; i-- {
		if _, found := remove[m.FlowRateLimitSettings[i].GetKey().GetKeyString()]; found {
			m.FlowRateLimitSettings = append(m.FlowRateLimitSettings[:i], m.FlowRateLimitSettings[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *AllData) AddMaxReqsRateLimitSettings(vals ...MaxReqsRateLimitSettings) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.MaxReqsRateLimitSettings {
		cur[v.GetKey().GetKeyString()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.GetKey().GetKeyString()]; found {
			continue // duplicate
		}
		m.MaxReqsRateLimitSettings = append(m.MaxReqsRateLimitSettings, v)
		changes++
	}
	return changes
}

func (m *AllData) RemoveMaxReqsRateLimitSettings(vals ...MaxReqsRateLimitSettings) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.GetKey().GetKeyString()] = struct{}{}
	}
	for i := len(m.MaxReqsRateLimitSettings); i >= 0; i-- {
		if _, found := remove[m.MaxReqsRateLimitSettings[i].GetKey().GetKeyString()]; found {
			m.MaxReqsRateLimitSettings = append(m.MaxReqsRateLimitSettings[:i], m.MaxReqsRateLimitSettings[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *AllData) AddNetworks(vals ...Network) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.Networks {
		cur[v.GetKey().GetKeyString()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.GetKey().GetKeyString()]; found {
			continue // duplicate
		}
		m.Networks = append(m.Networks, v)
		changes++
	}
	return changes
}

func (m *AllData) RemoveNetworks(vals ...Network) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.GetKey().GetKeyString()] = struct{}{}
	}
	for i := len(m.Networks); i >= 0; i-- {
		if _, found := remove[m.Networks[i].GetKey().GetKeyString()]; found {
			m.Networks = append(m.Networks[:i], m.Networks[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *AllData) AddTrustPolicyExceptions(vals ...TrustPolicyException) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.TrustPolicyExceptions {
		cur[v.GetKey().GetKeyString()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.GetKey().GetKeyString()]; found {
			continue // duplicate
		}
		m.TrustPolicyExceptions = append(m.TrustPolicyExceptions, v)
		changes++
	}
	return changes
}

func (m *AllData) RemoveTrustPolicyExceptions(vals ...TrustPolicyException) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.GetKey().GetKeyString()] = struct{}{}
	}
	for i := len(m.TrustPolicyExceptions); i >= 0; i-- {
		if _, found := remove[m.TrustPolicyExceptions[i].GetKey().GetKeyString()]; found {
			m.TrustPolicyExceptions = append(m.TrustPolicyExceptions[:i], m.TrustPolicyExceptions[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *AllData) AddClusterRefs(vals ...ClusterRefs) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.ClusterRefs {
		cur[v.GetKey().GetKeyString()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.GetKey().GetKeyString()]; found {
			continue // duplicate
		}
		m.ClusterRefs = append(m.ClusterRefs, v)
		changes++
	}
	return changes
}

func (m *AllData) RemoveClusterRefs(vals ...ClusterRefs) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.GetKey().GetKeyString()] = struct{}{}
	}
	for i := len(m.ClusterRefs); i >= 0; i-- {
		if _, found := remove[m.ClusterRefs[i].GetKey().GetKeyString()]; found {
			m.ClusterRefs = append(m.ClusterRefs[:i], m.ClusterRefs[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *AllData) AddPlatformFeatures(vals ...PlatformFeatures) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.PlatformFeatures {
		cur[v.GetKey().GetKeyString()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.GetKey().GetKeyString()]; found {
			continue // duplicate
		}
		m.PlatformFeatures = append(m.PlatformFeatures, v)
		changes++
	}
	return changes
}

func (m *AllData) RemovePlatformFeatures(vals ...PlatformFeatures) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.GetKey().GetKeyString()] = struct{}{}
	}
	for i := len(m.PlatformFeatures); i >= 0; i-- {
		if _, found := remove[m.PlatformFeatures[i].GetKey().GetKeyString()]; found {
			m.PlatformFeatures = append(m.PlatformFeatures[:i], m.PlatformFeatures[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *AllData) AddZones(vals ...Zone) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.Zones {
		cur[v.GetKey().GetKeyString()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.GetKey().GetKeyString()]; found {
			continue // duplicate
		}
		m.Zones = append(m.Zones, v)
		changes++
	}
	return changes
}

func (m *AllData) RemoveZones(vals ...Zone) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.GetKey().GetKeyString()] = struct{}{}
	}
	for i := len(m.Zones); i >= 0; i-- {
		if _, found := remove[m.Zones[i].GetKey().GetKeyString()]; found {
			m.Zones = append(m.Zones[:i], m.Zones[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *AllData) AddNodes(vals ...Node) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.Nodes {
		cur[v.GetKey().GetKeyString()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.GetKey().GetKeyString()]; found {
			continue // duplicate
		}
		m.Nodes = append(m.Nodes, v)
		changes++
	}
	return changes
}

func (m *AllData) RemoveNodes(vals ...Node) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.GetKey().GetKeyString()] = struct{}{}
	}
	for i := len(m.Nodes); i >= 0; i-- {
		if _, found := remove[m.Nodes[i].GetKey().GetKeyString()]; found {
			m.Nodes = append(m.Nodes[:i], m.Nodes[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *AllData) AddCloudletNodeRefs(vals ...CloudletNodeRefs) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.CloudletNodeRefs {
		cur[v.GetKey().GetKeyString()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.GetKey().GetKeyString()]; found {
			continue // duplicate
		}
		m.CloudletNodeRefs = append(m.CloudletNodeRefs, v)
		changes++
	}
	return changes
}

func (m *AllData) RemoveCloudletNodeRefs(vals ...CloudletNodeRefs) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.GetKey().GetKeyString()] = struct{}{}
	}
	for i := len(m.CloudletNodeRefs); i >= 0; i-- {
		if _, found := remove[m.CloudletNodeRefs[i].GetKey().GetKeyString()]; found {
			m.CloudletNodeRefs = append(m.CloudletNodeRefs[:i], m.CloudletNodeRefs[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *AllData) DeepCopyIn(src *AllData) {
	if src.Settings != nil {
		var tmp_Settings Settings
		tmp_Settings.DeepCopyIn(src.Settings)
		m.Settings = &tmp_Settings
	} else {
		m.Settings = nil
	}
	if src.Flavors != nil {
		m.Flavors = make([]Flavor, len(src.Flavors), len(src.Flavors))
		for ii, s := range src.Flavors {
			m.Flavors[ii].DeepCopyIn(&s)
		}
	} else {
		m.Flavors = nil
	}
	if src.OperatorCodes != nil {
		m.OperatorCodes = make([]OperatorCode, len(src.OperatorCodes), len(src.OperatorCodes))
		for ii, s := range src.OperatorCodes {
			m.OperatorCodes[ii].DeepCopyIn(&s)
		}
	} else {
		m.OperatorCodes = nil
	}
	if src.ResTagTables != nil {
		m.ResTagTables = make([]ResTagTable, len(src.ResTagTables), len(src.ResTagTables))
		for ii, s := range src.ResTagTables {
			m.ResTagTables[ii].DeepCopyIn(&s)
		}
	} else {
		m.ResTagTables = nil
	}
	if src.Cloudlets != nil {
		m.Cloudlets = make([]Cloudlet, len(src.Cloudlets), len(src.Cloudlets))
		for ii, s := range src.Cloudlets {
			m.Cloudlets[ii].DeepCopyIn(&s)
		}
	} else {
		m.Cloudlets = nil
	}
	if src.CloudletInfos != nil {
		m.CloudletInfos = make([]CloudletInfo, len(src.CloudletInfos), len(src.CloudletInfos))
		for ii, s := range src.CloudletInfos {
			m.CloudletInfos[ii].DeepCopyIn(&s)
		}
	} else {
		m.CloudletInfos = nil
	}
	if src.ZonePools != nil {
		m.ZonePools = make([]ZonePool, len(src.ZonePools), len(src.ZonePools))
		for ii, s := range src.ZonePools {
			m.ZonePools[ii].DeepCopyIn(&s)
		}
	} else {
		m.ZonePools = nil
	}
	if src.AutoProvPolicies != nil {
		m.AutoProvPolicies = make([]AutoProvPolicy, len(src.AutoProvPolicies), len(src.AutoProvPolicies))
		for ii, s := range src.AutoProvPolicies {
			m.AutoProvPolicies[ii].DeepCopyIn(&s)
		}
	} else {
		m.AutoProvPolicies = nil
	}
	if src.AutoProvPolicyZones != nil {
		m.AutoProvPolicyZones = make([]AutoProvPolicyZone, len(src.AutoProvPolicyZones), len(src.AutoProvPolicyZones))
		for ii, s := range src.AutoProvPolicyZones {
			m.AutoProvPolicyZones[ii].DeepCopyIn(&s)
		}
	} else {
		m.AutoProvPolicyZones = nil
	}
	if src.AutoScalePolicies != nil {
		m.AutoScalePolicies = make([]AutoScalePolicy, len(src.AutoScalePolicies), len(src.AutoScalePolicies))
		for ii, s := range src.AutoScalePolicies {
			m.AutoScalePolicies[ii].DeepCopyIn(&s)
		}
	} else {
		m.AutoScalePolicies = nil
	}
	if src.TrustPolicies != nil {
		m.TrustPolicies = make([]TrustPolicy, len(src.TrustPolicies), len(src.TrustPolicies))
		for ii, s := range src.TrustPolicies {
			m.TrustPolicies[ii].DeepCopyIn(&s)
		}
	} else {
		m.TrustPolicies = nil
	}
	if src.ClusterInsts != nil {
		m.ClusterInsts = make([]ClusterInst, len(src.ClusterInsts), len(src.ClusterInsts))
		for ii, s := range src.ClusterInsts {
			m.ClusterInsts[ii].DeepCopyIn(&s)
		}
	} else {
		m.ClusterInsts = nil
	}
	if src.Apps != nil {
		m.Apps = make([]App, len(src.Apps), len(src.Apps))
		for ii, s := range src.Apps {
			m.Apps[ii].DeepCopyIn(&s)
		}
	} else {
		m.Apps = nil
	}
	if src.AppInstances != nil {
		m.AppInstances = make([]AppInst, len(src.AppInstances), len(src.AppInstances))
		for ii, s := range src.AppInstances {
			m.AppInstances[ii].DeepCopyIn(&s)
		}
	} else {
		m.AppInstances = nil
	}
	if src.AppInstRefs != nil {
		m.AppInstRefs = make([]AppInstRefs, len(src.AppInstRefs), len(src.AppInstRefs))
		for ii, s := range src.AppInstRefs {
			m.AppInstRefs[ii].DeepCopyIn(&s)
		}
	} else {
		m.AppInstRefs = nil
	}
	if src.VmPools != nil {
		m.VmPools = make([]VMPool, len(src.VmPools), len(src.VmPools))
		for ii, s := range src.VmPools {
			m.VmPools[ii].DeepCopyIn(&s)
		}
	} else {
		m.VmPools = nil
	}
	if src.IdleReservableClusterInsts != nil {
		var tmp_IdleReservableClusterInsts IdleReservableClusterInsts
		tmp_IdleReservableClusterInsts.DeepCopyIn(src.IdleReservableClusterInsts)
		m.IdleReservableClusterInsts = &tmp_IdleReservableClusterInsts
	} else {
		m.IdleReservableClusterInsts = nil
	}
	if src.GpuDrivers != nil {
		m.GpuDrivers = make([]GPUDriver, len(src.GpuDrivers), len(src.GpuDrivers))
		for ii, s := range src.GpuDrivers {
			m.GpuDrivers[ii].DeepCopyIn(&s)
		}
	} else {
		m.GpuDrivers = nil
	}
	if src.AlertPolicies != nil {
		m.AlertPolicies = make([]AlertPolicy, len(src.AlertPolicies), len(src.AlertPolicies))
		for ii, s := range src.AlertPolicies {
			m.AlertPolicies[ii].DeepCopyIn(&s)
		}
	} else {
		m.AlertPolicies = nil
	}
	if src.FlowRateLimitSettings != nil {
		m.FlowRateLimitSettings = make([]FlowRateLimitSettings, len(src.FlowRateLimitSettings), len(src.FlowRateLimitSettings))
		for ii, s := range src.FlowRateLimitSettings {
			m.FlowRateLimitSettings[ii].DeepCopyIn(&s)
		}
	} else {
		m.FlowRateLimitSettings = nil
	}
	if src.MaxReqsRateLimitSettings != nil {
		m.MaxReqsRateLimitSettings = make([]MaxReqsRateLimitSettings, len(src.MaxReqsRateLimitSettings), len(src.MaxReqsRateLimitSettings))
		for ii, s := range src.MaxReqsRateLimitSettings {
			m.MaxReqsRateLimitSettings[ii].DeepCopyIn(&s)
		}
	} else {
		m.MaxReqsRateLimitSettings = nil
	}
	if src.Networks != nil {
		m.Networks = make([]Network, len(src.Networks), len(src.Networks))
		for ii, s := range src.Networks {
			m.Networks[ii].DeepCopyIn(&s)
		}
	} else {
		m.Networks = nil
	}
	if src.TrustPolicyExceptions != nil {
		m.TrustPolicyExceptions = make([]TrustPolicyException, len(src.TrustPolicyExceptions), len(src.TrustPolicyExceptions))
		for ii, s := range src.TrustPolicyExceptions {
			m.TrustPolicyExceptions[ii].DeepCopyIn(&s)
		}
	} else {
		m.TrustPolicyExceptions = nil
	}
	if src.ClusterRefs != nil {
		m.ClusterRefs = make([]ClusterRefs, len(src.ClusterRefs), len(src.ClusterRefs))
		for ii, s := range src.ClusterRefs {
			m.ClusterRefs[ii].DeepCopyIn(&s)
		}
	} else {
		m.ClusterRefs = nil
	}
	if src.PlatformFeatures != nil {
		m.PlatformFeatures = make([]PlatformFeatures, len(src.PlatformFeatures), len(src.PlatformFeatures))
		for ii, s := range src.PlatformFeatures {
			m.PlatformFeatures[ii].DeepCopyIn(&s)
		}
	} else {
		m.PlatformFeatures = nil
	}
	if src.Zones != nil {
		m.Zones = make([]Zone, len(src.Zones), len(src.Zones))
		for ii, s := range src.Zones {
			m.Zones[ii].DeepCopyIn(&s)
		}
	} else {
		m.Zones = nil
	}
	if src.Nodes != nil {
		m.Nodes = make([]Node, len(src.Nodes), len(src.Nodes))
		for ii, s := range src.Nodes {
			m.Nodes[ii].DeepCopyIn(&s)
		}
	} else {
		m.Nodes = nil
	}
	if src.CloudletNodeRefs != nil {
		m.CloudletNodeRefs = make([]CloudletNodeRefs, len(src.CloudletNodeRefs), len(src.CloudletNodeRefs))
		for ii, s := range src.CloudletNodeRefs {
			m.CloudletNodeRefs[ii].DeepCopyIn(&s)
		}
	} else {
		m.CloudletNodeRefs = nil
	}
}

// Helper method to check that enums have valid values
func (m *AllData) ValidateEnums() error {
	if m.Settings != nil {
		if err := m.Settings.ValidateEnums(); err != nil {
			return err
		}
	}
	for _, e := range m.Flavors {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	for _, e := range m.OperatorCodes {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	for _, e := range m.ResTagTables {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	for _, e := range m.Cloudlets {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	for _, e := range m.CloudletInfos {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	for _, e := range m.ZonePools {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	for _, e := range m.AutoProvPolicies {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	for _, e := range m.AutoProvPolicyZones {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	for _, e := range m.AutoScalePolicies {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	for _, e := range m.TrustPolicies {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	for _, e := range m.ClusterInsts {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	for _, e := range m.Apps {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	for _, e := range m.AppInstances {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	for _, e := range m.AppInstRefs {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	for _, e := range m.VmPools {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	if m.IdleReservableClusterInsts != nil {
		if err := m.IdleReservableClusterInsts.ValidateEnums(); err != nil {
			return err
		}
	}
	for _, e := range m.GpuDrivers {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	for _, e := range m.AlertPolicies {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	for _, e := range m.FlowRateLimitSettings {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	for _, e := range m.MaxReqsRateLimitSettings {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	for _, e := range m.Networks {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	for _, e := range m.TrustPolicyExceptions {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	for _, e := range m.ClusterRefs {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	for _, e := range m.PlatformFeatures {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	for _, e := range m.Zones {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	for _, e := range m.Nodes {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	for _, e := range m.CloudletNodeRefs {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (s *AllData) ClearTagged(tags map[string]struct{}) {
	if s.Settings != nil {
		s.Settings.ClearTagged(tags)
	}
	if s.Flavors != nil {
		for ii := 0; ii < len(s.Flavors); ii++ {
			s.Flavors[ii].ClearTagged(tags)
		}
	}
	if s.OperatorCodes != nil {
		for ii := 0; ii < len(s.OperatorCodes); ii++ {
			s.OperatorCodes[ii].ClearTagged(tags)
		}
	}
	if s.ResTagTables != nil {
		for ii := 0; ii < len(s.ResTagTables); ii++ {
			s.ResTagTables[ii].ClearTagged(tags)
		}
	}
	if s.Cloudlets != nil {
		for ii := 0; ii < len(s.Cloudlets); ii++ {
			s.Cloudlets[ii].ClearTagged(tags)
		}
	}
	if s.CloudletInfos != nil {
		for ii := 0; ii < len(s.CloudletInfos); ii++ {
			s.CloudletInfos[ii].ClearTagged(tags)
		}
	}
	if s.ZonePools != nil {
		for ii := 0; ii < len(s.ZonePools); ii++ {
			s.ZonePools[ii].ClearTagged(tags)
		}
	}
	if s.AutoProvPolicies != nil {
		for ii := 0; ii < len(s.AutoProvPolicies); ii++ {
			s.AutoProvPolicies[ii].ClearTagged(tags)
		}
	}
	if s.AutoProvPolicyZones != nil {
		for ii := 0; ii < len(s.AutoProvPolicyZones); ii++ {
			s.AutoProvPolicyZones[ii].ClearTagged(tags)
		}
	}
	if s.AutoScalePolicies != nil {
		for ii := 0; ii < len(s.AutoScalePolicies); ii++ {
			s.AutoScalePolicies[ii].ClearTagged(tags)
		}
	}
	if s.TrustPolicies != nil {
		for ii := 0; ii < len(s.TrustPolicies); ii++ {
			s.TrustPolicies[ii].ClearTagged(tags)
		}
	}
	if s.ClusterInsts != nil {
		for ii := 0; ii < len(s.ClusterInsts); ii++ {
			s.ClusterInsts[ii].ClearTagged(tags)
		}
	}
	if s.Apps != nil {
		for ii := 0; ii < len(s.Apps); ii++ {
			s.Apps[ii].ClearTagged(tags)
		}
	}
	if s.AppInstances != nil {
		for ii := 0; ii < len(s.AppInstances); ii++ {
			s.AppInstances[ii].ClearTagged(tags)
		}
	}
	if s.AppInstRefs != nil {
		for ii := 0; ii < len(s.AppInstRefs); ii++ {
			s.AppInstRefs[ii].ClearTagged(tags)
		}
	}
	if s.VmPools != nil {
		for ii := 0; ii < len(s.VmPools); ii++ {
			s.VmPools[ii].ClearTagged(tags)
		}
	}
	if s.IdleReservableClusterInsts != nil {
		s.IdleReservableClusterInsts.ClearTagged(tags)
	}
	if s.GpuDrivers != nil {
		for ii := 0; ii < len(s.GpuDrivers); ii++ {
			s.GpuDrivers[ii].ClearTagged(tags)
		}
	}
	if s.AlertPolicies != nil {
		for ii := 0; ii < len(s.AlertPolicies); ii++ {
			s.AlertPolicies[ii].ClearTagged(tags)
		}
	}
	if s.FlowRateLimitSettings != nil {
		for ii := 0; ii < len(s.FlowRateLimitSettings); ii++ {
			s.FlowRateLimitSettings[ii].ClearTagged(tags)
		}
	}
	if s.MaxReqsRateLimitSettings != nil {
		for ii := 0; ii < len(s.MaxReqsRateLimitSettings); ii++ {
			s.MaxReqsRateLimitSettings[ii].ClearTagged(tags)
		}
	}
	if s.Networks != nil {
		for ii := 0; ii < len(s.Networks); ii++ {
			s.Networks[ii].ClearTagged(tags)
		}
	}
	if s.TrustPolicyExceptions != nil {
		for ii := 0; ii < len(s.TrustPolicyExceptions); ii++ {
			s.TrustPolicyExceptions[ii].ClearTagged(tags)
		}
	}
	if s.ClusterRefs != nil {
		for ii := 0; ii < len(s.ClusterRefs); ii++ {
			s.ClusterRefs[ii].ClearTagged(tags)
		}
	}
	if s.PlatformFeatures != nil {
		for ii := 0; ii < len(s.PlatformFeatures); ii++ {
			s.PlatformFeatures[ii].ClearTagged(tags)
		}
	}
	if s.Zones != nil {
		for ii := 0; ii < len(s.Zones); ii++ {
			s.Zones[ii].ClearTagged(tags)
		}
	}
	if s.Nodes != nil {
		for ii := 0; ii < len(s.Nodes); ii++ {
			s.Nodes[ii].ClearTagged(tags)
		}
	}
	if s.CloudletNodeRefs != nil {
		for ii := 0; ii < len(s.CloudletNodeRefs); ii++ {
			s.CloudletNodeRefs[ii].ClearTagged(tags)
		}
	}
}

func IgnoreAllDataFields(taglist string) cmp.Option {
	names := []string{}
	tags := make(map[string]struct{})
	for _, tag := range strings.Split(taglist, ",") {
		tags[tag] = struct{}{}
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Cloudlets.Errors")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Cloudlets.NotifySrvAddr")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Cloudlets.Config.NotifyCtrlAddrs")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Cloudlets.Config.PlatformTag")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Cloudlets.Config.Span")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Cloudlets.Config.CrmAccessPrivateKey")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Cloudlets.Config.AccessApiAddr")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Cloudlets.Config.SecondaryCrmAccessPrivateKey")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Cloudlets.AccessVars")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Cloudlets.CrmAccessPublicKey")
	}
	if _, found := tags["timestamp"]; found {
		names = append(names, "Cloudlets.CreatedAt")
	}
	if _, found := tags["timestamp"]; found {
		names = append(names, "Cloudlets.UpdatedAt")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Cloudlets.HostController")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Cloudlets.SecondaryCrmAccessPublicKey")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Cloudlets.SecondaryNotifySrvAddr")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Cloudlets.ObjId")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Cloudlets.DbModelId")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "CloudletInfos.NotifyId")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "CloudletInfos.Controller")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "CloudletInfos.Status")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "CloudletInfos.CompatibilityVersion")
	}
	if _, found := tags["timestamp"]; found {
		names = append(names, "ZonePools.CreatedAt")
	}
	if _, found := tags["timestamp"]; found {
		names = append(names, "ZonePools.UpdatedAt")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "ClusterInsts.Errors")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "ClusterInsts.AllocatedIp")
	}
	if _, found := tags["timestamp"]; found {
		names = append(names, "ClusterInsts.CreatedAt")
	}
	if _, found := tags["timestamp"]; found {
		names = append(names, "ClusterInsts.UpdatedAt")
	}
	if _, found := tags["timestamp"]; found {
		names = append(names, "ClusterInsts.ReservationEndedAt")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "ClusterInsts.ObjId")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "ClusterInsts.CompatibilityVersion")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "ClusterInsts.DbModelId")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "ClusterInsts.InfraAnnotations")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Apps.AuthPublicKey")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Apps.Revision")
	}
	if _, found := tags["timestamp"]; found {
		names = append(names, "Apps.CreatedAt")
	}
	if _, found := tags["timestamp"]; found {
		names = append(names, "Apps.UpdatedAt")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Apps.ObjId")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Apps.CompatibilityVersion")
	}
	if _, found := tags["timestamp"]; found {
		names = append(names, "AppInstances.CreatedAt")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "AppInstances.Revision")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "AppInstances.ForceUpdate")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "AppInstances.UpdateMultiple")
	}
	if _, found := tags["timestamp"]; found {
		names = append(names, "AppInstances.UpdatedAt")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "AppInstances.CompatibilityVersion")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "AppInstances.VirtualClusterKey")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "AppInstances.ObjId")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "AppInstances.DbModelId")
	}
	if _, found := tags["timestamp"]; found {
		names = append(names, "VmPools.Vms.UpdatedAt")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "VmPools.Errors")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "AlertPolicies.DeletePrepare")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Zones.ObjId")
	}
	if _, found := tags["timestamp"]; found {
		names = append(names, "Zones.CreatedAt")
	}
	if _, found := tags["timestamp"]; found {
		names = append(names, "Zones.UpdatedAt")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Nodes.ObjId")
	}
	return cmpopts.IgnoreFields(AllData{}, names...)
}

func (m *AllData) IsEmpty() bool {
	if m.Settings != nil {
		return false
	}
	if m.Flavors != nil {
		return false
	}
	if m.OperatorCodes != nil {
		return false
	}
	if m.ResTagTables != nil {
		return false
	}
	if m.Cloudlets != nil {
		return false
	}
	if m.CloudletInfos != nil {
		return false
	}
	if m.ZonePools != nil {
		return false
	}
	if m.AutoProvPolicies != nil {
		return false
	}
	if m.AutoProvPolicyZones != nil {
		return false
	}
	if m.AutoScalePolicies != nil {
		return false
	}
	if m.TrustPolicies != nil {
		return false
	}
	if m.ClusterInsts != nil {
		return false
	}
	if m.Apps != nil {
		return false
	}
	if m.AppInstances != nil {
		return false
	}
	if m.AppInstRefs != nil {
		return false
	}
	if m.VmPools != nil {
		return false
	}
	if m.IdleReservableClusterInsts != nil {
		return false
	}
	if m.GpuDrivers != nil {
		return false
	}
	if m.AlertPolicies != nil {
		return false
	}
	if m.FlowRateLimitSettings != nil {
		return false
	}
	if m.MaxReqsRateLimitSettings != nil {
		return false
	}
	if m.Networks != nil {
		return false
	}
	if m.TrustPolicyExceptions != nil {
		return false
	}
	if m.ClusterRefs != nil {
		return false
	}
	if m.PlatformFeatures != nil {
		return false
	}
	if m.Zones != nil {
		return false
	}
	if m.Nodes != nil {
		return false
	}
	if m.CloudletNodeRefs != nil {
		return false
	}
	return true
}

func (m *AllData) StoreRead(ctx context.Context, kvstore objstore.KVStore) error {
	settings, err := StoreListSettings(ctx, kvstore)
	if err != nil {
		return err
	}
	if len(settings) > 0 {
		m.Settings = &settings[0]
	}
	flavors, err := StoreListFlavor(ctx, kvstore)
	if err != nil {
		return err
	}
	m.Flavors = flavors
	operator_codes, err := StoreListOperatorCode(ctx, kvstore)
	if err != nil {
		return err
	}
	m.OperatorCodes = operator_codes
	res_tag_tables, err := StoreListResTagTable(ctx, kvstore)
	if err != nil {
		return err
	}
	m.ResTagTables = res_tag_tables
	cloudlets, err := StoreListCloudlet(ctx, kvstore)
	if err != nil {
		return err
	}
	m.Cloudlets = cloudlets
	cloudlet_infos, err := StoreListCloudletInfo(ctx, kvstore)
	if err != nil {
		return err
	}
	m.CloudletInfos = cloudlet_infos
	zone_pools, err := StoreListZonePool(ctx, kvstore)
	if err != nil {
		return err
	}
	m.ZonePools = zone_pools
	auto_prov_policies, err := StoreListAutoProvPolicy(ctx, kvstore)
	if err != nil {
		return err
	}
	m.AutoProvPolicies = auto_prov_policies
	auto_scale_policies, err := StoreListAutoScalePolicy(ctx, kvstore)
	if err != nil {
		return err
	}
	m.AutoScalePolicies = auto_scale_policies
	trust_policies, err := StoreListTrustPolicy(ctx, kvstore)
	if err != nil {
		return err
	}
	m.TrustPolicies = trust_policies
	cluster_insts, err := StoreListClusterInst(ctx, kvstore)
	if err != nil {
		return err
	}
	m.ClusterInsts = cluster_insts
	apps, err := StoreListApp(ctx, kvstore)
	if err != nil {
		return err
	}
	m.Apps = apps
	app_instances, err := StoreListAppInst(ctx, kvstore)
	if err != nil {
		return err
	}
	m.AppInstances = app_instances
	app_inst_refs, err := StoreListAppInstRefs(ctx, kvstore)
	if err != nil {
		return err
	}
	m.AppInstRefs = app_inst_refs
	vm_pools, err := StoreListVMPool(ctx, kvstore)
	if err != nil {
		return err
	}
	m.VmPools = vm_pools
	gpu_drivers, err := StoreListGPUDriver(ctx, kvstore)
	if err != nil {
		return err
	}
	m.GpuDrivers = gpu_drivers
	alert_policies, err := StoreListAlertPolicy(ctx, kvstore)
	if err != nil {
		return err
	}
	m.AlertPolicies = alert_policies
	flow_rate_limit_settings, err := StoreListFlowRateLimitSettings(ctx, kvstore)
	if err != nil {
		return err
	}
	m.FlowRateLimitSettings = flow_rate_limit_settings
	max_reqs_rate_limit_settings, err := StoreListMaxReqsRateLimitSettings(ctx, kvstore)
	if err != nil {
		return err
	}
	m.MaxReqsRateLimitSettings = max_reqs_rate_limit_settings
	networks, err := StoreListNetwork(ctx, kvstore)
	if err != nil {
		return err
	}
	m.Networks = networks
	trust_policy_exceptions, err := StoreListTrustPolicyException(ctx, kvstore)
	if err != nil {
		return err
	}
	m.TrustPolicyExceptions = trust_policy_exceptions
	cluster_refs, err := StoreListClusterRefs(ctx, kvstore)
	if err != nil {
		return err
	}
	m.ClusterRefs = cluster_refs
	platform_features, err := StoreListPlatformFeatures(ctx, kvstore)
	if err != nil {
		return err
	}
	m.PlatformFeatures = platform_features
	zones, err := StoreListZone(ctx, kvstore)
	if err != nil {
		return err
	}
	m.Zones = zones
	nodes, err := StoreListNode(ctx, kvstore)
	if err != nil {
		return err
	}
	m.Nodes = nodes
	cloudlet_node_refs, err := StoreListCloudletNodeRefs(ctx, kvstore)
	if err != nil {
		return err
	}
	m.CloudletNodeRefs = cloudlet_node_refs
	return nil
}

func (m *AllData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Settings != nil {
		l = m.Settings.Size()
		n += 1 + l + sovAlldata(uint64(l))
	}
	if len(m.Flavors) > 0 {
		for _, e := range m.Flavors {
			l = e.Size()
			n += 1 + l + sovAlldata(uint64(l))
		}
	}
	if len(m.OperatorCodes) > 0 {
		for _, e := range m.OperatorCodes {
			l = e.Size()
			n += 1 + l + sovAlldata(uint64(l))
		}
	}
	if len(m.ResTagTables) > 0 {
		for _, e := range m.ResTagTables {
			l = e.Size()
			n += 1 + l + sovAlldata(uint64(l))
		}
	}
	if len(m.Cloudlets) > 0 {
		for _, e := range m.Cloudlets {
			l = e.Size()
			n += 1 + l + sovAlldata(uint64(l))
		}
	}
	if len(m.CloudletInfos) > 0 {
		for _, e := range m.CloudletInfos {
			l = e.Size()
			n += 1 + l + sovAlldata(uint64(l))
		}
	}
	if len(m.ZonePools) > 0 {
		for _, e := range m.ZonePools {
			l = e.Size()
			n += 1 + l + sovAlldata(uint64(l))
		}
	}
	if len(m.AutoProvPolicies) > 0 {
		for _, e := range m.AutoProvPolicies {
			l = e.Size()
			n += 1 + l + sovAlldata(uint64(l))
		}
	}
	if len(m.AutoProvPolicyZones) > 0 {
		for _, e := range m.AutoProvPolicyZones {
			l = e.Size()
			n += 1 + l + sovAlldata(uint64(l))
		}
	}
	if len(m.AutoScalePolicies) > 0 {
		for _, e := range m.AutoScalePolicies {
			l = e.Size()
			n += 1 + l + sovAlldata(uint64(l))
		}
	}
	if len(m.TrustPolicies) > 0 {
		for _, e := range m.TrustPolicies {
			l = e.Size()
			n += 1 + l + sovAlldata(uint64(l))
		}
	}
	if len(m.ClusterInsts) > 0 {
		for _, e := range m.ClusterInsts {
			l = e.Size()
			n += 1 + l + sovAlldata(uint64(l))
		}
	}
	if len(m.Apps) > 0 {
		for _, e := range m.Apps {
			l = e.Size()
			n += 2 + l + sovAlldata(uint64(l))
		}
	}
	if len(m.AppInstances) > 0 {
		for _, e := range m.AppInstances {
			l = e.Size()
			n += 2 + l + sovAlldata(uint64(l))
		}
	}
	if len(m.AppInstRefs) > 0 {
		for _, e := range m.AppInstRefs {
			l = e.Size()
			n += 2 + l + sovAlldata(uint64(l))
		}
	}
	if len(m.VmPools) > 0 {
		for _, e := range m.VmPools {
			l = e.Size()
			n += 2 + l + sovAlldata(uint64(l))
		}
	}
	if m.IdleReservableClusterInsts != nil {
		l = m.IdleReservableClusterInsts.Size()
		n += 2 + l + sovAlldata(uint64(l))
	}
	if len(m.GpuDrivers) > 0 {
		for _, e := range m.GpuDrivers {
			l = e.Size()
			n += 2 + l + sovAlldata(uint64(l))
		}
	}
	if len(m.AlertPolicies) > 0 {
		for _, e := range m.AlertPolicies {
			l = e.Size()
			n += 2 + l + sovAlldata(uint64(l))
		}
	}
	if len(m.FlowRateLimitSettings) > 0 {
		for _, e := range m.FlowRateLimitSettings {
			l = e.Size()
			n += 2 + l + sovAlldata(uint64(l))
		}
	}
	if len(m.MaxReqsRateLimitSettings) > 0 {
		for _, e := range m.MaxReqsRateLimitSettings {
			l = e.Size()
			n += 2 + l + sovAlldata(uint64(l))
		}
	}
	if len(m.Networks) > 0 {
		for _, e := range m.Networks {
			l = e.Size()
			n += 2 + l + sovAlldata(uint64(l))
		}
	}
	if len(m.TrustPolicyExceptions) > 0 {
		for _, e := range m.TrustPolicyExceptions {
			l = e.Size()
			n += 2 + l + sovAlldata(uint64(l))
		}
	}
	if len(m.ClusterRefs) > 0 {
		for _, e := range m.ClusterRefs {
			l = e.Size()
			n += 2 + l + sovAlldata(uint64(l))
		}
	}
	if len(m.PlatformFeatures) > 0 {
		for _, e := range m.PlatformFeatures {
			l = e.Size()
			n += 2 + l + sovAlldata(uint64(l))
		}
	}
	if len(m.Zones) > 0 {
		for _, e := range m.Zones {
			l = e.Size()
			n += 2 + l + sovAlldata(uint64(l))
		}
	}
	if len(m.Nodes) > 0 {
		for _, e := range m.Nodes {
			l = e.Size()
			n += 2 + l + sovAlldata(uint64(l))
		}
	}
	if len(m.CloudletNodeRefs) > 0 {
		for _, e := range m.CloudletNodeRefs {
			l = e.Size()
			n += 2 + l + sovAlldata(uint64(l))
		}
	}
	return n
}

func sovAlldata(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozAlldata(x uint64) (n int) {
	return sovAlldata(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AllData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlldata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Settings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlldata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlldata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlldata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Settings == nil {
				m.Settings = &Settings{}
			}
			if err := m.Settings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flavors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlldata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlldata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlldata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Flavors = append(m.Flavors, Flavor{})
			if err := m.Flavors[len(m.Flavors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatorCodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlldata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlldata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlldata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperatorCodes = append(m.OperatorCodes, OperatorCode{})
			if err := m.OperatorCodes[len(m.OperatorCodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResTagTables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlldata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlldata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlldata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResTagTables = append(m.ResTagTables, ResTagTable{})
			if err := m.ResTagTables[len(m.ResTagTables)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cloudlets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlldata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlldata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlldata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cloudlets = append(m.Cloudlets, Cloudlet{})
			if err := m.Cloudlets[len(m.Cloudlets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudletInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlldata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlldata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlldata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CloudletInfos = append(m.CloudletInfos, CloudletInfo{})
			if err := m.CloudletInfos[len(m.CloudletInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZonePools", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlldata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlldata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlldata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ZonePools = append(m.ZonePools, ZonePool{})
			if err := m.ZonePools[len(m.ZonePools)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoProvPolicies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlldata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlldata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlldata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AutoProvPolicies = append(m.AutoProvPolicies, AutoProvPolicy{})
			if err := m.AutoProvPolicies[len(m.AutoProvPolicies)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoProvPolicyZones", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlldata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlldata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlldata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AutoProvPolicyZones = append(m.AutoProvPolicyZones, AutoProvPolicyZone{})
			if err := m.AutoProvPolicyZones[len(m.AutoProvPolicyZones)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoScalePolicies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlldata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlldata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlldata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AutoScalePolicies = append(m.AutoScalePolicies, AutoScalePolicy{})
			if err := m.AutoScalePolicies[len(m.AutoScalePolicies)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustPolicies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlldata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlldata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlldata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrustPolicies = append(m.TrustPolicies, TrustPolicy{})
			if err := m.TrustPolicies[len(m.TrustPolicies)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterInsts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlldata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlldata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlldata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterInsts = append(m.ClusterInsts, ClusterInst{})
			if err := m.ClusterInsts[len(m.ClusterInsts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Apps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlldata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlldata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlldata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Apps = append(m.Apps, App{})
			if err := m.Apps[len(m.Apps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppInstances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlldata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlldata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlldata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppInstances = append(m.AppInstances, AppInst{})
			if err := m.AppInstances[len(m.AppInstances)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppInstRefs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlldata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlldata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlldata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppInstRefs = append(m.AppInstRefs, AppInstRefs{})
			if err := m.AppInstRefs[len(m.AppInstRefs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VmPools", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlldata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlldata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlldata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VmPools = append(m.VmPools, VMPool{})
			if err := m.VmPools[len(m.VmPools)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdleReservableClusterInsts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlldata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlldata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlldata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdleReservableClusterInsts == nil {
				m.IdleReservableClusterInsts = &IdleReservableClusterInsts{}
			}
			if err := m.IdleReservableClusterInsts.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpuDrivers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlldata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlldata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlldata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GpuDrivers = append(m.GpuDrivers, GPUDriver{})
			if err := m.GpuDrivers[len(m.GpuDrivers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlertPolicies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlldata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlldata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlldata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AlertPolicies = append(m.AlertPolicies, AlertPolicy{})
			if err := m.AlertPolicies[len(m.AlertPolicies)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowRateLimitSettings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlldata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlldata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlldata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FlowRateLimitSettings = append(m.FlowRateLimitSettings, FlowRateLimitSettings{})
			if err := m.FlowRateLimitSettings[len(m.FlowRateLimitSettings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxReqsRateLimitSettings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlldata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlldata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlldata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MaxReqsRateLimitSettings = append(m.MaxReqsRateLimitSettings, MaxReqsRateLimitSettings{})
			if err := m.MaxReqsRateLimitSettings[len(m.MaxReqsRateLimitSettings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Networks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlldata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlldata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlldata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Networks = append(m.Networks, Network{})
			if err := m.Networks[len(m.Networks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustPolicyExceptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlldata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlldata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlldata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrustPolicyExceptions = append(m.TrustPolicyExceptions, TrustPolicyException{})
			if err := m.TrustPolicyExceptions[len(m.TrustPolicyExceptions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterRefs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlldata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlldata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlldata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterRefs = append(m.ClusterRefs, ClusterRefs{})
			if err := m.ClusterRefs[len(m.ClusterRefs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlatformFeatures", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlldata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlldata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlldata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlatformFeatures = append(m.PlatformFeatures, PlatformFeatures{})
			if err := m.PlatformFeatures[len(m.PlatformFeatures)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Zones", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlldata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlldata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlldata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Zones = append(m.Zones, Zone{})
			if err := m.Zones[len(m.Zones)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlldata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlldata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlldata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodes = append(m.Nodes, Node{})
			if err := m.Nodes[len(m.Nodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudletNodeRefs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlldata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlldata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlldata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CloudletNodeRefs = append(m.CloudletNodeRefs, CloudletNodeRefs{})
			if err := m.CloudletNodeRefs[len(m.CloudletNodeRefs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlldata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAlldata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAlldata(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAlldata
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAlldata
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAlldata
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAlldata
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupAlldata
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthAlldata
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthAlldata        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAlldata          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupAlldata = fmt.Errorf("proto: unexpected end of group")
)
