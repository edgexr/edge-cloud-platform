// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: alldata.proto

package edgeproto

import (
	fmt "fmt"
	_ "github.com/edgexr/edge-cloud-platform/tools/protogen"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	io "io"
	math "math"
	math_bits "math/bits"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// AllData contains all data that may be used for declarative
// create/delete, or as input for e2e tests.
// The order of fields here is important, as objects will be
// created in the order they are specified here, and deleted
// in the opposite order. The field ID (number) doesn't matter.
type AllData struct {
	Flavors                    []Flavor                    `protobuf:"bytes,2,rep,name=flavors,proto3" json:"flavors"`
	Settings                   *Settings                   `protobuf:"bytes,1,opt,name=settings,proto3" json:"settings,omitempty"`
	OperatorCodes              []OperatorCode              `protobuf:"bytes,4,rep,name=operator_codes,json=operatorCodes,proto3" json:"operator_codes"`
	ResTagTables               []ResTagTable               `protobuf:"bytes,6,rep,name=res_tag_tables,json=resTagTables,proto3" json:"res_tag_tables"`
	TrustPolicies              []TrustPolicy               `protobuf:"bytes,14,rep,name=trust_policies,json=trustPolicies,proto3" json:"trust_policies"`
	GpuDrivers                 []GPUDriver                 `protobuf:"bytes,21,rep,name=gpu_drivers,json=gpuDrivers,proto3" json:"gpu_drivers"`
	PlatformFeatures           []PlatformFeatures          `protobuf:"bytes,28,rep,name=platform_features,json=platformFeatures,proto3" json:"platform_features"`
	Cloudlets                  []Cloudlet                  `protobuf:"bytes,7,rep,name=cloudlets,proto3" json:"cloudlets"`
	CloudletInfos              []CloudletInfo              `protobuf:"bytes,8,rep,name=cloudlet_infos,json=cloudletInfos,proto3" json:"cloudlet_infos"`
	CloudletPools              []CloudletPool              `protobuf:"bytes,9,rep,name=cloudlet_pools,json=cloudletPools,proto3" json:"cloudlet_pools"`
	Networks                   []Network                   `protobuf:"bytes,25,rep,name=networks,proto3" json:"networks"`
	AutoProvPolicies           []AutoProvPolicy            `protobuf:"bytes,11,rep,name=auto_prov_policies,json=autoProvPolicies,proto3" json:"auto_prov_policies"`
	AutoProvPolicyCloudlets    []AutoProvPolicyCloudlet    `protobuf:"bytes,12,rep,name=auto_prov_policy_cloudlets,json=autoProvPolicyCloudlets,proto3" json:"auto_prov_policy_cloudlets"`
	AutoScalePolicies          []AutoScalePolicy           `protobuf:"bytes,13,rep,name=auto_scale_policies,json=autoScalePolicies,proto3" json:"auto_scale_policies"`
	IdleReservableClusterInsts *IdleReservableClusterInsts `protobuf:"bytes,20,opt,name=idle_reservable_cluster_insts,json=idleReservableClusterInsts,proto3" json:"idle_reservable_cluster_insts,omitempty"`
	ClusterInsts               []ClusterInst               `protobuf:"bytes,15,rep,name=cluster_insts,json=clusterInsts,proto3" json:"cluster_insts"`
	Apps                       []App                       `protobuf:"bytes,16,rep,name=apps,proto3" json:"apps"`
	AppInstances               []AppInst                   `protobuf:"bytes,17,rep,name=app_instances,json=appInstances,proto3" json:"app_instances"`
	AppInstRefs                []AppInstRefs               `protobuf:"bytes,18,rep,name=app_inst_refs,json=appInstRefs,proto3" json:"app_inst_refs"`
	ClusterRefs                []ClusterRefs               `protobuf:"bytes,27,rep,name=cluster_refs,json=clusterRefs,proto3" json:"cluster_refs"`
	VmPools                    []VMPool                    `protobuf:"bytes,19,rep,name=vm_pools,json=vmPools,proto3" json:"vm_pools"`
	AlertPolicies              []AlertPolicy               `protobuf:"bytes,22,rep,name=alert_policies,json=alertPolicies,proto3" json:"alert_policies"`
	FlowRateLimitSettings      []FlowRateLimitSettings     `protobuf:"bytes,23,rep,name=flow_rate_limit_settings,json=flowRateLimitSettings,proto3" json:"flow_rate_limit_settings"`
	MaxReqsRateLimitSettings   []MaxReqsRateLimitSettings  `protobuf:"bytes,24,rep,name=max_reqs_rate_limit_settings,json=maxReqsRateLimitSettings,proto3" json:"max_reqs_rate_limit_settings"`
	TrustPolicyExceptions      []TrustPolicyException      `protobuf:"bytes,26,rep,name=trust_policy_exceptions,json=trustPolicyExceptions,proto3" json:"trust_policy_exceptions"`
}

func (m *AllData) Reset()         { *m = AllData{} }
func (m *AllData) String() string { return proto.CompactTextString(m) }
func (*AllData) ProtoMessage()    {}
func (*AllData) Descriptor() ([]byte, []int) {
	return fileDescriptor_8eca40466c9a5f17, []int{0}
}
func (m *AllData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AllData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AllData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AllData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllData.Merge(m, src)
}
func (m *AllData) XXX_Size() int {
	return m.Size()
}
func (m *AllData) XXX_DiscardUnknown() {
	xxx_messageInfo_AllData.DiscardUnknown(m)
}

var xxx_messageInfo_AllData proto.InternalMessageInfo

func init() {
	proto.RegisterType((*AllData)(nil), "edgeproto.AllData")
}

func init() { proto.RegisterFile("alldata.proto", fileDescriptor_8eca40466c9a5f17) }

var fileDescriptor_8eca40466c9a5f17 = []byte{
	// 917 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x55, 0x4f, 0x6f, 0x23, 0xb5,
	0x1b, 0x4e, 0x7e, 0xbf, 0x6a, 0x9b, 0x3a, 0xcd, 0x6c, 0xe3, 0xb6, 0x5b, 0x6f, 0xb6, 0x9b, 0x2d,
	0x20, 0xa4, 0x9e, 0x5a, 0x51, 0x90, 0x90, 0x40, 0x08, 0xda, 0x94, 0x45, 0x95, 0xe8, 0x12, 0x65,
	0x0b, 0x37, 0x64, 0x79, 0x67, 0x3c, 0xc3, 0x08, 0x27, 0xf6, 0xda, 0x4e, 0xda, 0x7e, 0x0b, 0xc4,
	0x89, 0x23, 0x1f, 0xa7, 0xc7, 0x3d, 0x72, 0x42, 0xd0, 0x7e, 0x87, 0x3d, 0x23, 0x7b, 0xec, 0x19,
	0x4f, 0xfe, 0xdc, 0xc6, 0xcf, 0xfb, 0x3c, 0xcf, 0x6b, 0xfb, 0xf5, 0xfb, 0x0e, 0xe8, 0x10, 0xc6,
	0x12, 0xa2, 0xc9, 0x91, 0x90, 0x5c, 0x73, 0xb8, 0x41, 0x93, 0x8c, 0xda, 0xcf, 0xde, 0x73, 0xcd,
	0x39, 0x53, 0xc7, 0x76, 0x91, 0xd1, 0x49, 0xf9, 0x51, 0x30, 0x7b, 0x91, 0xa2, 0x5a, 0xe7, 0x93,
	0x4c, 0xb9, 0xf5, 0x66, 0xca, 0xc8, 0x8c, 0x4b, 0xb7, 0x82, 0x5c, 0x50, 0x49, 0x34, 0x97, 0x31,
	0x4f, 0xa8, 0xc3, 0xba, 0x92, 0x2a, 0x4d, 0x32, 0x4d, 0xde, 0x30, 0x0f, 0x45, 0x31, 0xe3, 0xd3,
	0x84, 0x51, 0xed, 0x65, 0x7e, 0x2d, 0x38, 0x67, 0xde, 0x78, 0x36, 0x0e, 0x56, 0x3b, 0x64, 0xaa,
	0xb9, 0x90, 0x7c, 0x26, 0x38, 0xcb, 0xe3, 0x5b, 0x87, 0xee, 0x1a, 0x54, 0xc5, 0x84, 0xd1, 0x1a,
	0xdc, 0xd5, 0x72, 0xaa, 0x74, 0x0d, 0xea, 0x05, 0x10, 0xbd, 0x89, 0xa9, 0xd0, 0x39, 0xf7, 0x47,
	0xea, 0x4c, 0xa8, 0xbe, 0xe6, 0xf2, 0x57, 0xaf, 0x8e, 0xd9, 0x54, 0x69, 0x2a, 0xf3, 0x89, 0xf2,
	0xfb, 0xdb, 0x20, 0x42, 0x78, 0x32, 0x11, 0x22, 0x88, 0x00, 0x49, 0x53, 0x7f, 0x15, 0x5d, 0xc2,
	0xa8, 0xac, 0xa7, 0x7d, 0x2c, 0x89, 0xa6, 0x2c, 0x1f, 0xe7, 0x9e, 0xbf, 0x93, 0xf1, 0x8c, 0xdb,
	0xcf, 0x63, 0xf3, 0x55, 0xa0, 0x1f, 0xfe, 0x1e, 0x81, 0xf5, 0x53, 0xc6, 0xce, 0x89, 0x26, 0xf0,
	0x13, 0xb0, 0x5e, 0x5c, 0xa9, 0x42, 0xff, 0x3b, 0xf8, 0xff, 0x61, 0xfb, 0xa4, 0x7b, 0x54, 0x16,
	0xe7, 0xe8, 0xa5, 0x8d, 0x9c, 0xad, 0xdd, 0xfd, 0xfd, 0xa2, 0x31, 0xf2, 0x3c, 0x78, 0x0c, 0x5a,
	0xbe, 0x2a, 0xa8, 0x79, 0xd0, 0x3c, 0x6c, 0x9f, 0x6c, 0x07, 0x9a, 0xd7, 0x2e, 0x34, 0x2a, 0x49,
	0xf0, 0x1c, 0x44, 0xbe, 0x50, 0xd8, 0x54, 0x4a, 0xa1, 0x35, 0x9b, 0x6a, 0x2f, 0x90, 0xfd, 0xe0,
	0x08, 0x03, 0x9e, 0x50, 0x97, 0xb0, 0xc3, 0x03, 0x4c, 0xc1, 0x33, 0x10, 0x49, 0xaa, 0xb0, 0x26,
	0x19, 0xb6, 0xc5, 0x55, 0xe8, 0x91, 0x75, 0x79, 0x12, 0xb8, 0x8c, 0xa8, 0xba, 0x22, 0xd9, 0x95,
	0x09, 0x3b, 0x93, 0x4d, 0x59, 0x41, 0x0a, 0x0e, 0x40, 0x64, 0x2b, 0x83, 0xed, 0xb5, 0xe5, 0x54,
	0xa1, 0x68, 0xc1, 0xe3, 0xca, 0x10, 0x86, 0xf6, 0x5a, 0xfd, 0x46, 0x74, 0x09, 0xe5, 0x54, 0xc1,
	0x2f, 0x41, 0x3b, 0x13, 0x53, 0x9c, 0xc8, 0x7c, 0x46, 0xa5, 0x42, 0xbb, 0xd6, 0x61, 0x27, 0x70,
	0xf8, 0x6e, 0xf8, 0xe3, 0xb9, 0x0d, 0x3a, 0x3d, 0xc8, 0xc4, 0xb4, 0x00, 0x14, 0x7c, 0x05, 0xba,
	0x82, 0x11, 0x9d, 0x72, 0x39, 0xc6, 0x29, 0x25, 0x7a, 0x2a, 0xa9, 0x42, 0xfb, 0xd6, 0xe2, 0x59,
	0x60, 0x31, 0x74, 0x9c, 0x97, 0x8e, 0xe2, 0x9c, 0xb6, 0xc4, 0x1c, 0x0e, 0x3f, 0x07, 0x1b, 0xfe,
	0x35, 0x2b, 0xb4, 0x6e, 0x7d, 0xc2, 0x6a, 0x0c, 0x5c, 0xcc, 0xe9, 0x2b, 0xae, 0x29, 0x8a, 0x5f,
	0xe0, 0x7c, 0x92, 0x72, 0x85, 0x5a, 0x0b, 0x45, 0xf1, 0xea, 0x8b, 0x49, 0xca, 0xfd, 0x5d, 0xc4,
	0x01, 0x56, 0x77, 0x31, 0xfd, 0xa3, 0xd0, 0xc6, 0x4a, 0x97, 0x21, 0xe7, 0x6c, 0xde, 0xc5, 0x60,
	0x0a, 0x7e, 0x06, 0x5a, 0xae, 0x29, 0x14, 0x7a, 0x6a, 0xf5, 0x30, 0xd0, 0xbf, 0x2a, 0x42, 0x4e,
	0x5a, 0x32, 0xe1, 0x25, 0x80, 0xa6, 0x21, 0xb1, 0xe9, 0xd3, 0xaa, 0xa0, 0x6d, 0xab, 0x7f, 0x1a,
	0xe8, 0x4f, 0xa7, 0x9a, 0x0f, 0x25, 0x9f, 0xd5, 0x6a, 0xba, 0x45, 0x42, 0xd4, 0x94, 0x35, 0x01,
	0xbd, 0x39, 0xbb, 0x5b, 0x5c, 0x5d, 0xed, 0xa6, 0xb5, 0xfd, 0x60, 0xa5, 0xed, 0xdc, 0x45, 0xef,
	0x91, 0xa5, 0x51, 0x05, 0x87, 0x60, 0xdb, 0x66, 0xb1, 0x63, 0xa4, 0xda, 0x75, 0xc7, 0xda, 0xf7,
	0xe6, 0xec, 0x5f, 0x1b, 0x52, 0x6d, 0xdb, 0x5d, 0x52, 0x83, 0xcd, 0xbe, 0x7f, 0x01, 0xcf, 0xf3,
	0x84, 0x51, 0x2c, 0xa9, 0xa2, 0x72, 0x66, 0xde, 0x39, 0x76, 0x23, 0x05, 0x9b, 0xc9, 0xa1, 0xd0,
	0x8e, 0xed, 0xd1, 0x8f, 0x03, 0xef, 0x8b, 0x84, 0xd1, 0x51, 0x49, 0x1f, 0x14, 0xec, 0x0b, 0x43,
	0x1e, 0xf5, 0xf2, 0x95, 0x31, 0x78, 0x0a, 0x3a, 0x75, 0xe7, 0xc7, 0x0b, 0xcd, 0x13, 0xf0, 0x7d,
	0x03, 0xc6, 0xa1, 0xc5, 0x21, 0x58, 0x23, 0x42, 0x28, 0xb4, 0x65, 0x95, 0x51, 0x78, 0x5e, 0x21,
	0x9c, 0xc2, 0x32, 0xe0, 0x57, 0xc0, 0xcc, 0x3e, 0x9b, 0x88, 0x4c, 0x62, 0xaa, 0x50, 0x77, 0xe1,
	0x61, 0x9c, 0x0a, 0x11, 0x26, 0x22, 0xc5, 0xd2, 0xb2, 0xe1, 0x37, 0x95, 0x1c, 0x9b, 0xa1, 0x89,
	0xe0, 0xc2, 0x5e, 0x9d, 0x7c, 0x44, 0x53, 0xdf, 0x5e, 0x6d, 0x52, 0x41, 0xf0, 0x6b, 0xe0, 0xb7,
	0x5e, 0x18, 0x3c, 0x5b, 0x75, 0xd8, 0xd0, 0x20, 0xae, 0x20, 0x78, 0x02, 0x5a, 0xb3, 0xb1, 0xeb,
	0x8a, 0xed, 0x85, 0xd9, 0xfa, 0xd3, 0x65, 0xd0, 0x0f, 0xeb, 0xb3, 0x71, 0xd1, 0x09, 0x03, 0x10,
	0xd9, 0xb1, 0x5e, 0xbd, 0x8c, 0x27, 0x8b, 0xfb, 0x36, 0x84, 0xfa, 0x80, 0x22, 0x25, 0x64, 0x5e,
	0x04, 0x06, 0x28, 0x65, 0xfc, 0x1a, 0x9b, 0xbf, 0x01, 0xb6, 0xbf, 0x03, 0x5c, 0x0e, 0xec, 0x3d,
	0x6b, 0x77, 0x50, 0x1b, 0xf2, 0xfc, 0x7a, 0x44, 0x34, 0xfd, 0xde, 0x10, 0xfd, 0xf4, 0x76, 0xc6,
	0xbb, 0xe9, 0xb2, 0x20, 0xcc, 0xc1, 0xfe, 0x98, 0xdc, 0x60, 0x49, 0xdf, 0xaa, 0xa5, 0x49, 0x90,
	0x4d, 0xf2, 0x51, 0x90, 0xe4, 0x92, 0xdc, 0x8c, 0xe8, 0x5b, 0xb5, 0x2a, 0x0f, 0x1a, 0xaf, 0x88,
	0xc3, 0x9f, 0xc1, 0x5e, 0x30, 0xb1, 0x6f, 0x71, 0xf9, 0x37, 0x55, 0xa8, 0x67, 0xb3, 0xbc, 0x58,
	0x3e, 0xba, 0xbf, 0xf5, 0x3c, 0x7f, 0x12, 0xbd, 0x24, 0xa6, 0xbe, 0x68, 0xfd, 0xf1, 0x1e, 0x35,
	0xff, 0x7c, 0x8f, 0x1a, 0x67, 0xfb, 0x77, 0xff, 0xf6, 0x1b, 0x77, 0xf7, 0xfd, 0xe6, 0xbb, 0xfb,
	0x7e, 0xf3, 0x9f, 0xfb, 0x7e, 0xf3, 0xb7, 0x87, 0x7e, 0xe3, 0xdd, 0x43, 0xbf, 0xf1, 0xd7, 0x43,
	0xbf, 0xf1, 0xe6, 0x91, 0x4d, 0xf0, 0xe9, 0x7f, 0x01, 0x00, 0x00, 0xff, 0xff, 0xf0, 0x23, 0xc2,
	0xb0, 0xc9, 0x08, 0x00, 0x00,
}

func (m *AllData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AllData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PlatformFeatures) > 0 {
		for iNdEx := len(m.PlatformFeatures) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PlatformFeatures[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAlldata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xe2
		}
	}
	if len(m.ClusterRefs) > 0 {
		for iNdEx := len(m.ClusterRefs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ClusterRefs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAlldata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xda
		}
	}
	if len(m.TrustPolicyExceptions) > 0 {
		for iNdEx := len(m.TrustPolicyExceptions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TrustPolicyExceptions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAlldata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xd2
		}
	}
	if len(m.Networks) > 0 {
		for iNdEx := len(m.Networks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Networks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAlldata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xca
		}
	}
	if len(m.MaxReqsRateLimitSettings) > 0 {
		for iNdEx := len(m.MaxReqsRateLimitSettings) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MaxReqsRateLimitSettings[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAlldata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xc2
		}
	}
	if len(m.FlowRateLimitSettings) > 0 {
		for iNdEx := len(m.FlowRateLimitSettings) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FlowRateLimitSettings[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAlldata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xba
		}
	}
	if len(m.AlertPolicies) > 0 {
		for iNdEx := len(m.AlertPolicies) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AlertPolicies[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAlldata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xb2
		}
	}
	if len(m.GpuDrivers) > 0 {
		for iNdEx := len(m.GpuDrivers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.GpuDrivers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAlldata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xaa
		}
	}
	if m.IdleReservableClusterInsts != nil {
		{
			size, err := m.IdleReservableClusterInsts.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAlldata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if len(m.VmPools) > 0 {
		for iNdEx := len(m.VmPools) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.VmPools[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAlldata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x9a
		}
	}
	if len(m.AppInstRefs) > 0 {
		for iNdEx := len(m.AppInstRefs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AppInstRefs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAlldata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x92
		}
	}
	if len(m.AppInstances) > 0 {
		for iNdEx := len(m.AppInstances) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AppInstances[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAlldata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x8a
		}
	}
	if len(m.Apps) > 0 {
		for iNdEx := len(m.Apps) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Apps[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAlldata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if len(m.ClusterInsts) > 0 {
		for iNdEx := len(m.ClusterInsts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ClusterInsts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAlldata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x7a
		}
	}
	if len(m.TrustPolicies) > 0 {
		for iNdEx := len(m.TrustPolicies) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TrustPolicies[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAlldata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x72
		}
	}
	if len(m.AutoScalePolicies) > 0 {
		for iNdEx := len(m.AutoScalePolicies) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AutoScalePolicies[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAlldata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6a
		}
	}
	if len(m.AutoProvPolicyCloudlets) > 0 {
		for iNdEx := len(m.AutoProvPolicyCloudlets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AutoProvPolicyCloudlets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAlldata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.AutoProvPolicies) > 0 {
		for iNdEx := len(m.AutoProvPolicies) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AutoProvPolicies[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAlldata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.CloudletPools) > 0 {
		for iNdEx := len(m.CloudletPools) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CloudletPools[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAlldata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.CloudletInfos) > 0 {
		for iNdEx := len(m.CloudletInfos) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CloudletInfos[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAlldata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.Cloudlets) > 0 {
		for iNdEx := len(m.Cloudlets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Cloudlets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAlldata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.ResTagTables) > 0 {
		for iNdEx := len(m.ResTagTables) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ResTagTables[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAlldata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.OperatorCodes) > 0 {
		for iNdEx := len(m.OperatorCodes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OperatorCodes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAlldata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Flavors) > 0 {
		for iNdEx := len(m.Flavors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Flavors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAlldata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Settings != nil {
		{
			size, err := m.Settings.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAlldata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintAlldata(dAtA []byte, offset int, v uint64) int {
	offset -= sovAlldata(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *AllData) Clone() *AllData {
	cp := &AllData{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *AllData) AddSettingsEdgeEventsMetricsContinuousQueriesCollectionIntervals(vals ...*CollectionInterval) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.Settings.EdgeEventsMetricsContinuousQueriesCollectionIntervals {
		cur[v.String()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.String()]; found {
			continue // duplicate
		}
		m.Settings.EdgeEventsMetricsContinuousQueriesCollectionIntervals = append(m.Settings.EdgeEventsMetricsContinuousQueriesCollectionIntervals, v)
		changes++
	}
	return changes
}

func (m *AllData) RemoveSettingsEdgeEventsMetricsContinuousQueriesCollectionIntervals(vals ...*CollectionInterval) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.String()] = struct{}{}
	}
	for i := len(m.Settings.EdgeEventsMetricsContinuousQueriesCollectionIntervals); i >= 0; i-- {
		if _, found := remove[m.Settings.EdgeEventsMetricsContinuousQueriesCollectionIntervals[i].String()]; found {
			m.Settings.EdgeEventsMetricsContinuousQueriesCollectionIntervals = append(m.Settings.EdgeEventsMetricsContinuousQueriesCollectionIntervals[:i], m.Settings.EdgeEventsMetricsContinuousQueriesCollectionIntervals[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *AllData) AddFlavors(vals ...Flavor) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.Flavors {
		cur[v.GetKey().GetKeyString()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.GetKey().GetKeyString()]; found {
			continue // duplicate
		}
		m.Flavors = append(m.Flavors, v)
		changes++
	}
	return changes
}

func (m *AllData) RemoveFlavors(vals ...Flavor) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.GetKey().GetKeyString()] = struct{}{}
	}
	for i := len(m.Flavors); i >= 0; i-- {
		if _, found := remove[m.Flavors[i].GetKey().GetKeyString()]; found {
			m.Flavors = append(m.Flavors[:i], m.Flavors[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *AllData) AddOperatorCodes(vals ...OperatorCode) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.OperatorCodes {
		cur[v.String()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.String()]; found {
			continue // duplicate
		}
		m.OperatorCodes = append(m.OperatorCodes, v)
		changes++
	}
	return changes
}

func (m *AllData) RemoveOperatorCodes(vals ...OperatorCode) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.String()] = struct{}{}
	}
	for i := len(m.OperatorCodes); i >= 0; i-- {
		if _, found := remove[m.OperatorCodes[i].String()]; found {
			m.OperatorCodes = append(m.OperatorCodes[:i], m.OperatorCodes[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *AllData) AddResTagTables(vals ...ResTagTable) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.ResTagTables {
		cur[v.GetKey().GetKeyString()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.GetKey().GetKeyString()]; found {
			continue // duplicate
		}
		m.ResTagTables = append(m.ResTagTables, v)
		changes++
	}
	return changes
}

func (m *AllData) RemoveResTagTables(vals ...ResTagTable) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.GetKey().GetKeyString()] = struct{}{}
	}
	for i := len(m.ResTagTables); i >= 0; i-- {
		if _, found := remove[m.ResTagTables[i].GetKey().GetKeyString()]; found {
			m.ResTagTables = append(m.ResTagTables[:i], m.ResTagTables[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *AllData) AddCloudlets(vals ...Cloudlet) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.Cloudlets {
		cur[v.GetKey().GetKeyString()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.GetKey().GetKeyString()]; found {
			continue // duplicate
		}
		m.Cloudlets = append(m.Cloudlets, v)
		changes++
	}
	return changes
}

func (m *AllData) RemoveCloudlets(vals ...Cloudlet) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.GetKey().GetKeyString()] = struct{}{}
	}
	for i := len(m.Cloudlets); i >= 0; i-- {
		if _, found := remove[m.Cloudlets[i].GetKey().GetKeyString()]; found {
			m.Cloudlets = append(m.Cloudlets[:i], m.Cloudlets[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *AllData) AddCloudletInfos(vals ...CloudletInfo) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.CloudletInfos {
		cur[v.GetKey().GetKeyString()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.GetKey().GetKeyString()]; found {
			continue // duplicate
		}
		m.CloudletInfos = append(m.CloudletInfos, v)
		changes++
	}
	return changes
}

func (m *AllData) RemoveCloudletInfos(vals ...CloudletInfo) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.GetKey().GetKeyString()] = struct{}{}
	}
	for i := len(m.CloudletInfos); i >= 0; i-- {
		if _, found := remove[m.CloudletInfos[i].GetKey().GetKeyString()]; found {
			m.CloudletInfos = append(m.CloudletInfos[:i], m.CloudletInfos[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *AllData) AddCloudletPools(vals ...CloudletPool) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.CloudletPools {
		cur[v.GetKey().GetKeyString()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.GetKey().GetKeyString()]; found {
			continue // duplicate
		}
		m.CloudletPools = append(m.CloudletPools, v)
		changes++
	}
	return changes
}

func (m *AllData) RemoveCloudletPools(vals ...CloudletPool) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.GetKey().GetKeyString()] = struct{}{}
	}
	for i := len(m.CloudletPools); i >= 0; i-- {
		if _, found := remove[m.CloudletPools[i].GetKey().GetKeyString()]; found {
			m.CloudletPools = append(m.CloudletPools[:i], m.CloudletPools[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *AllData) AddAutoProvPolicies(vals ...AutoProvPolicy) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.AutoProvPolicies {
		cur[v.GetKey().GetKeyString()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.GetKey().GetKeyString()]; found {
			continue // duplicate
		}
		m.AutoProvPolicies = append(m.AutoProvPolicies, v)
		changes++
	}
	return changes
}

func (m *AllData) RemoveAutoProvPolicies(vals ...AutoProvPolicy) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.GetKey().GetKeyString()] = struct{}{}
	}
	for i := len(m.AutoProvPolicies); i >= 0; i-- {
		if _, found := remove[m.AutoProvPolicies[i].GetKey().GetKeyString()]; found {
			m.AutoProvPolicies = append(m.AutoProvPolicies[:i], m.AutoProvPolicies[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *AllData) AddAutoProvPolicyCloudlets(vals ...AutoProvPolicyCloudlet) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.AutoProvPolicyCloudlets {
		cur[v.GetKey().GetKeyString()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.GetKey().GetKeyString()]; found {
			continue // duplicate
		}
		m.AutoProvPolicyCloudlets = append(m.AutoProvPolicyCloudlets, v)
		changes++
	}
	return changes
}

func (m *AllData) RemoveAutoProvPolicyCloudlets(vals ...AutoProvPolicyCloudlet) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.GetKey().GetKeyString()] = struct{}{}
	}
	for i := len(m.AutoProvPolicyCloudlets); i >= 0; i-- {
		if _, found := remove[m.AutoProvPolicyCloudlets[i].GetKey().GetKeyString()]; found {
			m.AutoProvPolicyCloudlets = append(m.AutoProvPolicyCloudlets[:i], m.AutoProvPolicyCloudlets[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *AllData) AddAutoScalePolicies(vals ...AutoScalePolicy) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.AutoScalePolicies {
		cur[v.GetKey().GetKeyString()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.GetKey().GetKeyString()]; found {
			continue // duplicate
		}
		m.AutoScalePolicies = append(m.AutoScalePolicies, v)
		changes++
	}
	return changes
}

func (m *AllData) RemoveAutoScalePolicies(vals ...AutoScalePolicy) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.GetKey().GetKeyString()] = struct{}{}
	}
	for i := len(m.AutoScalePolicies); i >= 0; i-- {
		if _, found := remove[m.AutoScalePolicies[i].GetKey().GetKeyString()]; found {
			m.AutoScalePolicies = append(m.AutoScalePolicies[:i], m.AutoScalePolicies[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *AllData) AddTrustPolicies(vals ...TrustPolicy) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.TrustPolicies {
		cur[v.GetKey().GetKeyString()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.GetKey().GetKeyString()]; found {
			continue // duplicate
		}
		m.TrustPolicies = append(m.TrustPolicies, v)
		changes++
	}
	return changes
}

func (m *AllData) RemoveTrustPolicies(vals ...TrustPolicy) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.GetKey().GetKeyString()] = struct{}{}
	}
	for i := len(m.TrustPolicies); i >= 0; i-- {
		if _, found := remove[m.TrustPolicies[i].GetKey().GetKeyString()]; found {
			m.TrustPolicies = append(m.TrustPolicies[:i], m.TrustPolicies[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *AllData) AddClusterInsts(vals ...ClusterInst) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.ClusterInsts {
		cur[v.GetKey().GetKeyString()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.GetKey().GetKeyString()]; found {
			continue // duplicate
		}
		m.ClusterInsts = append(m.ClusterInsts, v)
		changes++
	}
	return changes
}

func (m *AllData) RemoveClusterInsts(vals ...ClusterInst) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.GetKey().GetKeyString()] = struct{}{}
	}
	for i := len(m.ClusterInsts); i >= 0; i-- {
		if _, found := remove[m.ClusterInsts[i].GetKey().GetKeyString()]; found {
			m.ClusterInsts = append(m.ClusterInsts[:i], m.ClusterInsts[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *AllData) AddApps(vals ...App) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.Apps {
		cur[v.GetKey().GetKeyString()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.GetKey().GetKeyString()]; found {
			continue // duplicate
		}
		m.Apps = append(m.Apps, v)
		changes++
	}
	return changes
}

func (m *AllData) RemoveApps(vals ...App) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.GetKey().GetKeyString()] = struct{}{}
	}
	for i := len(m.Apps); i >= 0; i-- {
		if _, found := remove[m.Apps[i].GetKey().GetKeyString()]; found {
			m.Apps = append(m.Apps[:i], m.Apps[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *AllData) AddAppInstances(vals ...AppInst) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.AppInstances {
		cur[v.GetKey().GetKeyString()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.GetKey().GetKeyString()]; found {
			continue // duplicate
		}
		m.AppInstances = append(m.AppInstances, v)
		changes++
	}
	return changes
}

func (m *AllData) RemoveAppInstances(vals ...AppInst) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.GetKey().GetKeyString()] = struct{}{}
	}
	for i := len(m.AppInstances); i >= 0; i-- {
		if _, found := remove[m.AppInstances[i].GetKey().GetKeyString()]; found {
			m.AppInstances = append(m.AppInstances[:i], m.AppInstances[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *AllData) AddAppInstRefs(vals ...AppInstRefs) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.AppInstRefs {
		cur[v.GetKey().GetKeyString()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.GetKey().GetKeyString()]; found {
			continue // duplicate
		}
		m.AppInstRefs = append(m.AppInstRefs, v)
		changes++
	}
	return changes
}

func (m *AllData) RemoveAppInstRefs(vals ...AppInstRefs) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.GetKey().GetKeyString()] = struct{}{}
	}
	for i := len(m.AppInstRefs); i >= 0; i-- {
		if _, found := remove[m.AppInstRefs[i].GetKey().GetKeyString()]; found {
			m.AppInstRefs = append(m.AppInstRefs[:i], m.AppInstRefs[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *AllData) AddVmPools(vals ...VMPool) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.VmPools {
		cur[v.GetKey().GetKeyString()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.GetKey().GetKeyString()]; found {
			continue // duplicate
		}
		m.VmPools = append(m.VmPools, v)
		changes++
	}
	return changes
}

func (m *AllData) RemoveVmPools(vals ...VMPool) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.GetKey().GetKeyString()] = struct{}{}
	}
	for i := len(m.VmPools); i >= 0; i-- {
		if _, found := remove[m.VmPools[i].GetKey().GetKeyString()]; found {
			m.VmPools = append(m.VmPools[:i], m.VmPools[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *AllData) AddGpuDrivers(vals ...GPUDriver) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.GpuDrivers {
		cur[v.GetKey().GetKeyString()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.GetKey().GetKeyString()]; found {
			continue // duplicate
		}
		m.GpuDrivers = append(m.GpuDrivers, v)
		changes++
	}
	return changes
}

func (m *AllData) RemoveGpuDrivers(vals ...GPUDriver) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.GetKey().GetKeyString()] = struct{}{}
	}
	for i := len(m.GpuDrivers); i >= 0; i-- {
		if _, found := remove[m.GpuDrivers[i].GetKey().GetKeyString()]; found {
			m.GpuDrivers = append(m.GpuDrivers[:i], m.GpuDrivers[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *AllData) AddAlertPolicies(vals ...AlertPolicy) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.AlertPolicies {
		cur[v.GetKey().GetKeyString()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.GetKey().GetKeyString()]; found {
			continue // duplicate
		}
		m.AlertPolicies = append(m.AlertPolicies, v)
		changes++
	}
	return changes
}

func (m *AllData) RemoveAlertPolicies(vals ...AlertPolicy) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.GetKey().GetKeyString()] = struct{}{}
	}
	for i := len(m.AlertPolicies); i >= 0; i-- {
		if _, found := remove[m.AlertPolicies[i].GetKey().GetKeyString()]; found {
			m.AlertPolicies = append(m.AlertPolicies[:i], m.AlertPolicies[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *AllData) AddFlowRateLimitSettings(vals ...FlowRateLimitSettings) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.FlowRateLimitSettings {
		cur[v.GetKey().GetKeyString()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.GetKey().GetKeyString()]; found {
			continue // duplicate
		}
		m.FlowRateLimitSettings = append(m.FlowRateLimitSettings, v)
		changes++
	}
	return changes
}

func (m *AllData) RemoveFlowRateLimitSettings(vals ...FlowRateLimitSettings) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.GetKey().GetKeyString()] = struct{}{}
	}
	for i := len(m.FlowRateLimitSettings); i >= 0; i-- {
		if _, found := remove[m.FlowRateLimitSettings[i].GetKey().GetKeyString()]; found {
			m.FlowRateLimitSettings = append(m.FlowRateLimitSettings[:i], m.FlowRateLimitSettings[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *AllData) AddMaxReqsRateLimitSettings(vals ...MaxReqsRateLimitSettings) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.MaxReqsRateLimitSettings {
		cur[v.GetKey().GetKeyString()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.GetKey().GetKeyString()]; found {
			continue // duplicate
		}
		m.MaxReqsRateLimitSettings = append(m.MaxReqsRateLimitSettings, v)
		changes++
	}
	return changes
}

func (m *AllData) RemoveMaxReqsRateLimitSettings(vals ...MaxReqsRateLimitSettings) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.GetKey().GetKeyString()] = struct{}{}
	}
	for i := len(m.MaxReqsRateLimitSettings); i >= 0; i-- {
		if _, found := remove[m.MaxReqsRateLimitSettings[i].GetKey().GetKeyString()]; found {
			m.MaxReqsRateLimitSettings = append(m.MaxReqsRateLimitSettings[:i], m.MaxReqsRateLimitSettings[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *AllData) AddNetworks(vals ...Network) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.Networks {
		cur[v.GetKey().GetKeyString()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.GetKey().GetKeyString()]; found {
			continue // duplicate
		}
		m.Networks = append(m.Networks, v)
		changes++
	}
	return changes
}

func (m *AllData) RemoveNetworks(vals ...Network) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.GetKey().GetKeyString()] = struct{}{}
	}
	for i := len(m.Networks); i >= 0; i-- {
		if _, found := remove[m.Networks[i].GetKey().GetKeyString()]; found {
			m.Networks = append(m.Networks[:i], m.Networks[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *AllData) AddTrustPolicyExceptions(vals ...TrustPolicyException) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.TrustPolicyExceptions {
		cur[v.GetKey().GetKeyString()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.GetKey().GetKeyString()]; found {
			continue // duplicate
		}
		m.TrustPolicyExceptions = append(m.TrustPolicyExceptions, v)
		changes++
	}
	return changes
}

func (m *AllData) RemoveTrustPolicyExceptions(vals ...TrustPolicyException) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.GetKey().GetKeyString()] = struct{}{}
	}
	for i := len(m.TrustPolicyExceptions); i >= 0; i-- {
		if _, found := remove[m.TrustPolicyExceptions[i].GetKey().GetKeyString()]; found {
			m.TrustPolicyExceptions = append(m.TrustPolicyExceptions[:i], m.TrustPolicyExceptions[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *AllData) AddClusterRefs(vals ...ClusterRefs) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.ClusterRefs {
		cur[v.GetKey().GetKeyString()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.GetKey().GetKeyString()]; found {
			continue // duplicate
		}
		m.ClusterRefs = append(m.ClusterRefs, v)
		changes++
	}
	return changes
}

func (m *AllData) RemoveClusterRefs(vals ...ClusterRefs) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.GetKey().GetKeyString()] = struct{}{}
	}
	for i := len(m.ClusterRefs); i >= 0; i-- {
		if _, found := remove[m.ClusterRefs[i].GetKey().GetKeyString()]; found {
			m.ClusterRefs = append(m.ClusterRefs[:i], m.ClusterRefs[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *AllData) AddPlatformFeatures(vals ...PlatformFeatures) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.PlatformFeatures {
		cur[v.GetKey().GetKeyString()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.GetKey().GetKeyString()]; found {
			continue // duplicate
		}
		m.PlatformFeatures = append(m.PlatformFeatures, v)
		changes++
	}
	return changes
}

func (m *AllData) RemovePlatformFeatures(vals ...PlatformFeatures) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.GetKey().GetKeyString()] = struct{}{}
	}
	for i := len(m.PlatformFeatures); i >= 0; i-- {
		if _, found := remove[m.PlatformFeatures[i].GetKey().GetKeyString()]; found {
			m.PlatformFeatures = append(m.PlatformFeatures[:i], m.PlatformFeatures[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *AllData) DeepCopyIn(src *AllData) {
	if src.Settings != nil {
		var tmp_Settings Settings
		tmp_Settings.DeepCopyIn(src.Settings)
		m.Settings = &tmp_Settings
	} else {
		m.Settings = nil
	}
	if src.Flavors != nil {
		m.Flavors = make([]Flavor, len(src.Flavors), len(src.Flavors))
		for ii, s := range src.Flavors {
			m.Flavors[ii].DeepCopyIn(&s)
		}
	} else {
		m.Flavors = nil
	}
	if src.OperatorCodes != nil {
		m.OperatorCodes = make([]OperatorCode, len(src.OperatorCodes), len(src.OperatorCodes))
		for ii, s := range src.OperatorCodes {
			m.OperatorCodes[ii].DeepCopyIn(&s)
		}
	} else {
		m.OperatorCodes = nil
	}
	if src.ResTagTables != nil {
		m.ResTagTables = make([]ResTagTable, len(src.ResTagTables), len(src.ResTagTables))
		for ii, s := range src.ResTagTables {
			m.ResTagTables[ii].DeepCopyIn(&s)
		}
	} else {
		m.ResTagTables = nil
	}
	if src.Cloudlets != nil {
		m.Cloudlets = make([]Cloudlet, len(src.Cloudlets), len(src.Cloudlets))
		for ii, s := range src.Cloudlets {
			m.Cloudlets[ii].DeepCopyIn(&s)
		}
	} else {
		m.Cloudlets = nil
	}
	if src.CloudletInfos != nil {
		m.CloudletInfos = make([]CloudletInfo, len(src.CloudletInfos), len(src.CloudletInfos))
		for ii, s := range src.CloudletInfos {
			m.CloudletInfos[ii].DeepCopyIn(&s)
		}
	} else {
		m.CloudletInfos = nil
	}
	if src.CloudletPools != nil {
		m.CloudletPools = make([]CloudletPool, len(src.CloudletPools), len(src.CloudletPools))
		for ii, s := range src.CloudletPools {
			m.CloudletPools[ii].DeepCopyIn(&s)
		}
	} else {
		m.CloudletPools = nil
	}
	if src.AutoProvPolicies != nil {
		m.AutoProvPolicies = make([]AutoProvPolicy, len(src.AutoProvPolicies), len(src.AutoProvPolicies))
		for ii, s := range src.AutoProvPolicies {
			m.AutoProvPolicies[ii].DeepCopyIn(&s)
		}
	} else {
		m.AutoProvPolicies = nil
	}
	if src.AutoProvPolicyCloudlets != nil {
		m.AutoProvPolicyCloudlets = make([]AutoProvPolicyCloudlet, len(src.AutoProvPolicyCloudlets), len(src.AutoProvPolicyCloudlets))
		for ii, s := range src.AutoProvPolicyCloudlets {
			m.AutoProvPolicyCloudlets[ii].DeepCopyIn(&s)
		}
	} else {
		m.AutoProvPolicyCloudlets = nil
	}
	if src.AutoScalePolicies != nil {
		m.AutoScalePolicies = make([]AutoScalePolicy, len(src.AutoScalePolicies), len(src.AutoScalePolicies))
		for ii, s := range src.AutoScalePolicies {
			m.AutoScalePolicies[ii].DeepCopyIn(&s)
		}
	} else {
		m.AutoScalePolicies = nil
	}
	if src.TrustPolicies != nil {
		m.TrustPolicies = make([]TrustPolicy, len(src.TrustPolicies), len(src.TrustPolicies))
		for ii, s := range src.TrustPolicies {
			m.TrustPolicies[ii].DeepCopyIn(&s)
		}
	} else {
		m.TrustPolicies = nil
	}
	if src.ClusterInsts != nil {
		m.ClusterInsts = make([]ClusterInst, len(src.ClusterInsts), len(src.ClusterInsts))
		for ii, s := range src.ClusterInsts {
			m.ClusterInsts[ii].DeepCopyIn(&s)
		}
	} else {
		m.ClusterInsts = nil
	}
	if src.Apps != nil {
		m.Apps = make([]App, len(src.Apps), len(src.Apps))
		for ii, s := range src.Apps {
			m.Apps[ii].DeepCopyIn(&s)
		}
	} else {
		m.Apps = nil
	}
	if src.AppInstances != nil {
		m.AppInstances = make([]AppInst, len(src.AppInstances), len(src.AppInstances))
		for ii, s := range src.AppInstances {
			m.AppInstances[ii].DeepCopyIn(&s)
		}
	} else {
		m.AppInstances = nil
	}
	if src.AppInstRefs != nil {
		m.AppInstRefs = make([]AppInstRefs, len(src.AppInstRefs), len(src.AppInstRefs))
		for ii, s := range src.AppInstRefs {
			m.AppInstRefs[ii].DeepCopyIn(&s)
		}
	} else {
		m.AppInstRefs = nil
	}
	if src.VmPools != nil {
		m.VmPools = make([]VMPool, len(src.VmPools), len(src.VmPools))
		for ii, s := range src.VmPools {
			m.VmPools[ii].DeepCopyIn(&s)
		}
	} else {
		m.VmPools = nil
	}
	if src.IdleReservableClusterInsts != nil {
		var tmp_IdleReservableClusterInsts IdleReservableClusterInsts
		tmp_IdleReservableClusterInsts.DeepCopyIn(src.IdleReservableClusterInsts)
		m.IdleReservableClusterInsts = &tmp_IdleReservableClusterInsts
	} else {
		m.IdleReservableClusterInsts = nil
	}
	if src.GpuDrivers != nil {
		m.GpuDrivers = make([]GPUDriver, len(src.GpuDrivers), len(src.GpuDrivers))
		for ii, s := range src.GpuDrivers {
			m.GpuDrivers[ii].DeepCopyIn(&s)
		}
	} else {
		m.GpuDrivers = nil
	}
	if src.AlertPolicies != nil {
		m.AlertPolicies = make([]AlertPolicy, len(src.AlertPolicies), len(src.AlertPolicies))
		for ii, s := range src.AlertPolicies {
			m.AlertPolicies[ii].DeepCopyIn(&s)
		}
	} else {
		m.AlertPolicies = nil
	}
	if src.FlowRateLimitSettings != nil {
		m.FlowRateLimitSettings = make([]FlowRateLimitSettings, len(src.FlowRateLimitSettings), len(src.FlowRateLimitSettings))
		for ii, s := range src.FlowRateLimitSettings {
			m.FlowRateLimitSettings[ii].DeepCopyIn(&s)
		}
	} else {
		m.FlowRateLimitSettings = nil
	}
	if src.MaxReqsRateLimitSettings != nil {
		m.MaxReqsRateLimitSettings = make([]MaxReqsRateLimitSettings, len(src.MaxReqsRateLimitSettings), len(src.MaxReqsRateLimitSettings))
		for ii, s := range src.MaxReqsRateLimitSettings {
			m.MaxReqsRateLimitSettings[ii].DeepCopyIn(&s)
		}
	} else {
		m.MaxReqsRateLimitSettings = nil
	}
	if src.Networks != nil {
		m.Networks = make([]Network, len(src.Networks), len(src.Networks))
		for ii, s := range src.Networks {
			m.Networks[ii].DeepCopyIn(&s)
		}
	} else {
		m.Networks = nil
	}
	if src.TrustPolicyExceptions != nil {
		m.TrustPolicyExceptions = make([]TrustPolicyException, len(src.TrustPolicyExceptions), len(src.TrustPolicyExceptions))
		for ii, s := range src.TrustPolicyExceptions {
			m.TrustPolicyExceptions[ii].DeepCopyIn(&s)
		}
	} else {
		m.TrustPolicyExceptions = nil
	}
	if src.ClusterRefs != nil {
		m.ClusterRefs = make([]ClusterRefs, len(src.ClusterRefs), len(src.ClusterRefs))
		for ii, s := range src.ClusterRefs {
			m.ClusterRefs[ii].DeepCopyIn(&s)
		}
	} else {
		m.ClusterRefs = nil
	}
	if src.PlatformFeatures != nil {
		m.PlatformFeatures = make([]PlatformFeatures, len(src.PlatformFeatures), len(src.PlatformFeatures))
		for ii, s := range src.PlatformFeatures {
			m.PlatformFeatures[ii].DeepCopyIn(&s)
		}
	} else {
		m.PlatformFeatures = nil
	}
}

// Helper method to check that enums have valid values
func (m *AllData) ValidateEnums() error {
	if m.Settings != nil {
		if err := m.Settings.ValidateEnums(); err != nil {
			return err
		}
	}
	for _, e := range m.Flavors {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	for _, e := range m.OperatorCodes {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	for _, e := range m.ResTagTables {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	for _, e := range m.Cloudlets {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	for _, e := range m.CloudletInfos {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	for _, e := range m.CloudletPools {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	for _, e := range m.AutoProvPolicies {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	for _, e := range m.AutoProvPolicyCloudlets {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	for _, e := range m.AutoScalePolicies {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	for _, e := range m.TrustPolicies {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	for _, e := range m.ClusterInsts {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	for _, e := range m.Apps {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	for _, e := range m.AppInstances {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	for _, e := range m.AppInstRefs {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	for _, e := range m.VmPools {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	if m.IdleReservableClusterInsts != nil {
		if err := m.IdleReservableClusterInsts.ValidateEnums(); err != nil {
			return err
		}
	}
	for _, e := range m.GpuDrivers {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	for _, e := range m.AlertPolicies {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	for _, e := range m.FlowRateLimitSettings {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	for _, e := range m.MaxReqsRateLimitSettings {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	for _, e := range m.Networks {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	for _, e := range m.TrustPolicyExceptions {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	for _, e := range m.ClusterRefs {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	for _, e := range m.PlatformFeatures {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (s *AllData) ClearTagged(tags map[string]struct{}) {
	if s.Settings != nil {
		s.Settings.ClearTagged(tags)
	}
	if s.Flavors != nil {
		for ii := 0; ii < len(s.Flavors); ii++ {
			s.Flavors[ii].ClearTagged(tags)
		}
	}
	if s.OperatorCodes != nil {
		for ii := 0; ii < len(s.OperatorCodes); ii++ {
			s.OperatorCodes[ii].ClearTagged(tags)
		}
	}
	if s.ResTagTables != nil {
		for ii := 0; ii < len(s.ResTagTables); ii++ {
			s.ResTagTables[ii].ClearTagged(tags)
		}
	}
	if s.Cloudlets != nil {
		for ii := 0; ii < len(s.Cloudlets); ii++ {
			s.Cloudlets[ii].ClearTagged(tags)
		}
	}
	if s.CloudletInfos != nil {
		for ii := 0; ii < len(s.CloudletInfos); ii++ {
			s.CloudletInfos[ii].ClearTagged(tags)
		}
	}
	if s.CloudletPools != nil {
		for ii := 0; ii < len(s.CloudletPools); ii++ {
			s.CloudletPools[ii].ClearTagged(tags)
		}
	}
	if s.AutoProvPolicies != nil {
		for ii := 0; ii < len(s.AutoProvPolicies); ii++ {
			s.AutoProvPolicies[ii].ClearTagged(tags)
		}
	}
	if s.AutoProvPolicyCloudlets != nil {
		for ii := 0; ii < len(s.AutoProvPolicyCloudlets); ii++ {
			s.AutoProvPolicyCloudlets[ii].ClearTagged(tags)
		}
	}
	if s.AutoScalePolicies != nil {
		for ii := 0; ii < len(s.AutoScalePolicies); ii++ {
			s.AutoScalePolicies[ii].ClearTagged(tags)
		}
	}
	if s.TrustPolicies != nil {
		for ii := 0; ii < len(s.TrustPolicies); ii++ {
			s.TrustPolicies[ii].ClearTagged(tags)
		}
	}
	if s.ClusterInsts != nil {
		for ii := 0; ii < len(s.ClusterInsts); ii++ {
			s.ClusterInsts[ii].ClearTagged(tags)
		}
	}
	if s.Apps != nil {
		for ii := 0; ii < len(s.Apps); ii++ {
			s.Apps[ii].ClearTagged(tags)
		}
	}
	if s.AppInstances != nil {
		for ii := 0; ii < len(s.AppInstances); ii++ {
			s.AppInstances[ii].ClearTagged(tags)
		}
	}
	if s.AppInstRefs != nil {
		for ii := 0; ii < len(s.AppInstRefs); ii++ {
			s.AppInstRefs[ii].ClearTagged(tags)
		}
	}
	if s.VmPools != nil {
		for ii := 0; ii < len(s.VmPools); ii++ {
			s.VmPools[ii].ClearTagged(tags)
		}
	}
	if s.IdleReservableClusterInsts != nil {
		s.IdleReservableClusterInsts.ClearTagged(tags)
	}
	if s.GpuDrivers != nil {
		for ii := 0; ii < len(s.GpuDrivers); ii++ {
			s.GpuDrivers[ii].ClearTagged(tags)
		}
	}
	if s.AlertPolicies != nil {
		for ii := 0; ii < len(s.AlertPolicies); ii++ {
			s.AlertPolicies[ii].ClearTagged(tags)
		}
	}
	if s.FlowRateLimitSettings != nil {
		for ii := 0; ii < len(s.FlowRateLimitSettings); ii++ {
			s.FlowRateLimitSettings[ii].ClearTagged(tags)
		}
	}
	if s.MaxReqsRateLimitSettings != nil {
		for ii := 0; ii < len(s.MaxReqsRateLimitSettings); ii++ {
			s.MaxReqsRateLimitSettings[ii].ClearTagged(tags)
		}
	}
	if s.Networks != nil {
		for ii := 0; ii < len(s.Networks); ii++ {
			s.Networks[ii].ClearTagged(tags)
		}
	}
	if s.TrustPolicyExceptions != nil {
		for ii := 0; ii < len(s.TrustPolicyExceptions); ii++ {
			s.TrustPolicyExceptions[ii].ClearTagged(tags)
		}
	}
	if s.ClusterRefs != nil {
		for ii := 0; ii < len(s.ClusterRefs); ii++ {
			s.ClusterRefs[ii].ClearTagged(tags)
		}
	}
	if s.PlatformFeatures != nil {
		for ii := 0; ii < len(s.PlatformFeatures); ii++ {
			s.PlatformFeatures[ii].ClearTagged(tags)
		}
	}
}

func IgnoreAllDataFields(taglist string) cmp.Option {
	names := []string{}
	tags := make(map[string]struct{})
	for _, tag := range strings.Split(taglist, ",") {
		tags[tag] = struct{}{}
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Cloudlets.Errors")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Cloudlets.NotifySrvAddr")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Cloudlets.Config.NotifyCtrlAddrs")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Cloudlets.Config.PlatformTag")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Cloudlets.Config.Span")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Cloudlets.Config.CrmAccessPrivateKey")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Cloudlets.Config.AccessApiAddr")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Cloudlets.Config.SecondaryCrmAccessPrivateKey")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Cloudlets.CrmAccessPublicKey")
	}
	if _, found := tags["timestamp"]; found {
		names = append(names, "Cloudlets.CreatedAt")
	}
	if _, found := tags["timestamp"]; found {
		names = append(names, "Cloudlets.UpdatedAt")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Cloudlets.HostController")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Cloudlets.SecondaryCrmAccessPublicKey")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Cloudlets.SecondaryNotifySrvAddr")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "CloudletInfos.NotifyId")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "CloudletInfos.Controller")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "CloudletInfos.Status")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "CloudletInfos.CompatibilityVersion")
	}
	if _, found := tags["timestamp"]; found {
		names = append(names, "CloudletPools.CreatedAt")
	}
	if _, found := tags["timestamp"]; found {
		names = append(names, "CloudletPools.UpdatedAt")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "ClusterInsts.Errors")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "ClusterInsts.AllocatedIp")
	}
	if _, found := tags["timestamp"]; found {
		names = append(names, "ClusterInsts.CreatedAt")
	}
	if _, found := tags["timestamp"]; found {
		names = append(names, "ClusterInsts.UpdatedAt")
	}
	if _, found := tags["timestamp"]; found {
		names = append(names, "ClusterInsts.ReservationEndedAt")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Apps.AuthPublicKey")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Apps.Revision")
	}
	if _, found := tags["timestamp"]; found {
		names = append(names, "Apps.CreatedAt")
	}
	if _, found := tags["timestamp"]; found {
		names = append(names, "Apps.UpdatedAt")
	}
	if _, found := tags["timestamp"]; found {
		names = append(names, "AppInstances.CreatedAt")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "AppInstances.Revision")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "AppInstances.ForceUpdate")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "AppInstances.UpdateMultiple")
	}
	if _, found := tags["timestamp"]; found {
		names = append(names, "AppInstances.UpdatedAt")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "AppInstances.CompatibilityVersion")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "AppInstances.VirtualClusterKey")
	}
	if _, found := tags["timestamp"]; found {
		names = append(names, "VmPools.Vms.UpdatedAt")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "VmPools.Errors")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "AlertPolicies.DeletePrepare")
	}
	return cmpopts.IgnoreFields(AllData{}, names...)
}

func (m *AllData) IsEmpty() bool {
	if m.Settings != nil {
		return false
	}
	if m.Flavors != nil {
		return false
	}
	if m.OperatorCodes != nil {
		return false
	}
	if m.ResTagTables != nil {
		return false
	}
	if m.Cloudlets != nil {
		return false
	}
	if m.CloudletInfos != nil {
		return false
	}
	if m.CloudletPools != nil {
		return false
	}
	if m.AutoProvPolicies != nil {
		return false
	}
	if m.AutoProvPolicyCloudlets != nil {
		return false
	}
	if m.AutoScalePolicies != nil {
		return false
	}
	if m.TrustPolicies != nil {
		return false
	}
	if m.ClusterInsts != nil {
		return false
	}
	if m.Apps != nil {
		return false
	}
	if m.AppInstances != nil {
		return false
	}
	if m.AppInstRefs != nil {
		return false
	}
	if m.VmPools != nil {
		return false
	}
	if m.IdleReservableClusterInsts != nil {
		return false
	}
	if m.GpuDrivers != nil {
		return false
	}
	if m.AlertPolicies != nil {
		return false
	}
	if m.FlowRateLimitSettings != nil {
		return false
	}
	if m.MaxReqsRateLimitSettings != nil {
		return false
	}
	if m.Networks != nil {
		return false
	}
	if m.TrustPolicyExceptions != nil {
		return false
	}
	if m.ClusterRefs != nil {
		return false
	}
	if m.PlatformFeatures != nil {
		return false
	}
	return true
}

func (m *AllData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Settings != nil {
		l = m.Settings.Size()
		n += 1 + l + sovAlldata(uint64(l))
	}
	if len(m.Flavors) > 0 {
		for _, e := range m.Flavors {
			l = e.Size()
			n += 1 + l + sovAlldata(uint64(l))
		}
	}
	if len(m.OperatorCodes) > 0 {
		for _, e := range m.OperatorCodes {
			l = e.Size()
			n += 1 + l + sovAlldata(uint64(l))
		}
	}
	if len(m.ResTagTables) > 0 {
		for _, e := range m.ResTagTables {
			l = e.Size()
			n += 1 + l + sovAlldata(uint64(l))
		}
	}
	if len(m.Cloudlets) > 0 {
		for _, e := range m.Cloudlets {
			l = e.Size()
			n += 1 + l + sovAlldata(uint64(l))
		}
	}
	if len(m.CloudletInfos) > 0 {
		for _, e := range m.CloudletInfos {
			l = e.Size()
			n += 1 + l + sovAlldata(uint64(l))
		}
	}
	if len(m.CloudletPools) > 0 {
		for _, e := range m.CloudletPools {
			l = e.Size()
			n += 1 + l + sovAlldata(uint64(l))
		}
	}
	if len(m.AutoProvPolicies) > 0 {
		for _, e := range m.AutoProvPolicies {
			l = e.Size()
			n += 1 + l + sovAlldata(uint64(l))
		}
	}
	if len(m.AutoProvPolicyCloudlets) > 0 {
		for _, e := range m.AutoProvPolicyCloudlets {
			l = e.Size()
			n += 1 + l + sovAlldata(uint64(l))
		}
	}
	if len(m.AutoScalePolicies) > 0 {
		for _, e := range m.AutoScalePolicies {
			l = e.Size()
			n += 1 + l + sovAlldata(uint64(l))
		}
	}
	if len(m.TrustPolicies) > 0 {
		for _, e := range m.TrustPolicies {
			l = e.Size()
			n += 1 + l + sovAlldata(uint64(l))
		}
	}
	if len(m.ClusterInsts) > 0 {
		for _, e := range m.ClusterInsts {
			l = e.Size()
			n += 1 + l + sovAlldata(uint64(l))
		}
	}
	if len(m.Apps) > 0 {
		for _, e := range m.Apps {
			l = e.Size()
			n += 2 + l + sovAlldata(uint64(l))
		}
	}
	if len(m.AppInstances) > 0 {
		for _, e := range m.AppInstances {
			l = e.Size()
			n += 2 + l + sovAlldata(uint64(l))
		}
	}
	if len(m.AppInstRefs) > 0 {
		for _, e := range m.AppInstRefs {
			l = e.Size()
			n += 2 + l + sovAlldata(uint64(l))
		}
	}
	if len(m.VmPools) > 0 {
		for _, e := range m.VmPools {
			l = e.Size()
			n += 2 + l + sovAlldata(uint64(l))
		}
	}
	if m.IdleReservableClusterInsts != nil {
		l = m.IdleReservableClusterInsts.Size()
		n += 2 + l + sovAlldata(uint64(l))
	}
	if len(m.GpuDrivers) > 0 {
		for _, e := range m.GpuDrivers {
			l = e.Size()
			n += 2 + l + sovAlldata(uint64(l))
		}
	}
	if len(m.AlertPolicies) > 0 {
		for _, e := range m.AlertPolicies {
			l = e.Size()
			n += 2 + l + sovAlldata(uint64(l))
		}
	}
	if len(m.FlowRateLimitSettings) > 0 {
		for _, e := range m.FlowRateLimitSettings {
			l = e.Size()
			n += 2 + l + sovAlldata(uint64(l))
		}
	}
	if len(m.MaxReqsRateLimitSettings) > 0 {
		for _, e := range m.MaxReqsRateLimitSettings {
			l = e.Size()
			n += 2 + l + sovAlldata(uint64(l))
		}
	}
	if len(m.Networks) > 0 {
		for _, e := range m.Networks {
			l = e.Size()
			n += 2 + l + sovAlldata(uint64(l))
		}
	}
	if len(m.TrustPolicyExceptions) > 0 {
		for _, e := range m.TrustPolicyExceptions {
			l = e.Size()
			n += 2 + l + sovAlldata(uint64(l))
		}
	}
	if len(m.ClusterRefs) > 0 {
		for _, e := range m.ClusterRefs {
			l = e.Size()
			n += 2 + l + sovAlldata(uint64(l))
		}
	}
	if len(m.PlatformFeatures) > 0 {
		for _, e := range m.PlatformFeatures {
			l = e.Size()
			n += 2 + l + sovAlldata(uint64(l))
		}
	}
	return n
}

func sovAlldata(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozAlldata(x uint64) (n int) {
	return sovAlldata(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AllData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlldata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Settings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlldata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlldata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlldata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Settings == nil {
				m.Settings = &Settings{}
			}
			if err := m.Settings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flavors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlldata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlldata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlldata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Flavors = append(m.Flavors, Flavor{})
			if err := m.Flavors[len(m.Flavors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatorCodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlldata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlldata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlldata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperatorCodes = append(m.OperatorCodes, OperatorCode{})
			if err := m.OperatorCodes[len(m.OperatorCodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResTagTables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlldata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlldata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlldata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResTagTables = append(m.ResTagTables, ResTagTable{})
			if err := m.ResTagTables[len(m.ResTagTables)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cloudlets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlldata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlldata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlldata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cloudlets = append(m.Cloudlets, Cloudlet{})
			if err := m.Cloudlets[len(m.Cloudlets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudletInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlldata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlldata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlldata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CloudletInfos = append(m.CloudletInfos, CloudletInfo{})
			if err := m.CloudletInfos[len(m.CloudletInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudletPools", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlldata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlldata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlldata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CloudletPools = append(m.CloudletPools, CloudletPool{})
			if err := m.CloudletPools[len(m.CloudletPools)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoProvPolicies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlldata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlldata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlldata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AutoProvPolicies = append(m.AutoProvPolicies, AutoProvPolicy{})
			if err := m.AutoProvPolicies[len(m.AutoProvPolicies)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoProvPolicyCloudlets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlldata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlldata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlldata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AutoProvPolicyCloudlets = append(m.AutoProvPolicyCloudlets, AutoProvPolicyCloudlet{})
			if err := m.AutoProvPolicyCloudlets[len(m.AutoProvPolicyCloudlets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoScalePolicies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlldata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlldata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlldata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AutoScalePolicies = append(m.AutoScalePolicies, AutoScalePolicy{})
			if err := m.AutoScalePolicies[len(m.AutoScalePolicies)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustPolicies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlldata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlldata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlldata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrustPolicies = append(m.TrustPolicies, TrustPolicy{})
			if err := m.TrustPolicies[len(m.TrustPolicies)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterInsts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlldata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlldata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlldata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterInsts = append(m.ClusterInsts, ClusterInst{})
			if err := m.ClusterInsts[len(m.ClusterInsts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Apps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlldata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlldata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlldata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Apps = append(m.Apps, App{})
			if err := m.Apps[len(m.Apps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppInstances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlldata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlldata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlldata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppInstances = append(m.AppInstances, AppInst{})
			if err := m.AppInstances[len(m.AppInstances)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppInstRefs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlldata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlldata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlldata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppInstRefs = append(m.AppInstRefs, AppInstRefs{})
			if err := m.AppInstRefs[len(m.AppInstRefs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VmPools", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlldata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlldata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlldata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VmPools = append(m.VmPools, VMPool{})
			if err := m.VmPools[len(m.VmPools)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdleReservableClusterInsts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlldata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlldata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlldata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdleReservableClusterInsts == nil {
				m.IdleReservableClusterInsts = &IdleReservableClusterInsts{}
			}
			if err := m.IdleReservableClusterInsts.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpuDrivers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlldata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlldata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlldata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GpuDrivers = append(m.GpuDrivers, GPUDriver{})
			if err := m.GpuDrivers[len(m.GpuDrivers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlertPolicies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlldata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlldata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlldata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AlertPolicies = append(m.AlertPolicies, AlertPolicy{})
			if err := m.AlertPolicies[len(m.AlertPolicies)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowRateLimitSettings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlldata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlldata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlldata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FlowRateLimitSettings = append(m.FlowRateLimitSettings, FlowRateLimitSettings{})
			if err := m.FlowRateLimitSettings[len(m.FlowRateLimitSettings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxReqsRateLimitSettings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlldata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlldata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlldata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MaxReqsRateLimitSettings = append(m.MaxReqsRateLimitSettings, MaxReqsRateLimitSettings{})
			if err := m.MaxReqsRateLimitSettings[len(m.MaxReqsRateLimitSettings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Networks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlldata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlldata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlldata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Networks = append(m.Networks, Network{})
			if err := m.Networks[len(m.Networks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustPolicyExceptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlldata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlldata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlldata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrustPolicyExceptions = append(m.TrustPolicyExceptions, TrustPolicyException{})
			if err := m.TrustPolicyExceptions[len(m.TrustPolicyExceptions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterRefs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlldata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlldata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlldata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterRefs = append(m.ClusterRefs, ClusterRefs{})
			if err := m.ClusterRefs[len(m.ClusterRefs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlatformFeatures", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlldata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlldata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlldata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlatformFeatures = append(m.PlatformFeatures, PlatformFeatures{})
			if err := m.PlatformFeatures[len(m.PlatformFeatures)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlldata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAlldata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAlldata(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAlldata
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAlldata
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAlldata
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAlldata
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupAlldata
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthAlldata
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthAlldata        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAlldata          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupAlldata = fmt.Errorf("proto: unexpected end of group")
)
