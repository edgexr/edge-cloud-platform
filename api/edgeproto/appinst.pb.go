// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: appinst.proto

package edgeproto

import (
	context "context"
	"encoding/json"
	"errors"
	fmt "fmt"
	distributed_match_engine "github.com/edgexr/edge-cloud-platform/api/distributed_match_engine"
	"github.com/edgexr/edge-cloud-platform/pkg/log"
	"github.com/edgexr/edge-cloud-platform/pkg/objstore"
	"github.com/edgexr/edge-cloud-platform/pkg/util"
	_ "github.com/edgexr/edge-cloud-platform/tools/protogen"
	_ "github.com/gogo/googleapis/google/api"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"go.etcd.io/etcd/client/v3/concurrency"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	"strconv"
	strings "strings"
	"sync"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Power State
//
// # Power State of the AppInst
//
// 0: `POWER_STATE_UNKNOWN`
// 1: `POWER_ON_REQUESTED`
// 2: `POWERING_ON`
// 3: `POWER_ON`
// 4: `POWER_OFF_REQUESTED`
// 5: `POWERING_OFF`
// 6: `POWER_OFF`
// 7: `REBOOT_REQUESTED`
// 8: `REBOOTING`
// 9: `REBOOT`
// 10: `POWER_STATE_ERROR`
type PowerState int32

const (
	// Unknown
	PowerState_POWER_STATE_UNKNOWN PowerState = 0
	// Power On Requested
	PowerState_POWER_ON_REQUESTED PowerState = 1
	// Powering On
	PowerState_POWERING_ON PowerState = 2
	// Power On
	PowerState_POWER_ON PowerState = 3
	// Power Off Requested
	PowerState_POWER_OFF_REQUESTED PowerState = 4
	// Powering Off
	PowerState_POWERING_OFF PowerState = 5
	// Power Off
	PowerState_POWER_OFF PowerState = 6
	// Reboot Requested
	PowerState_REBOOT_REQUESTED PowerState = 7
	// Rebooting
	PowerState_REBOOTING PowerState = 8
	// Reboot
	PowerState_REBOOT PowerState = 9
	// Error
	PowerState_POWER_STATE_ERROR PowerState = 10
)

var PowerState_name = map[int32]string{
	0:  "POWER_STATE_UNKNOWN",
	1:  "POWER_ON_REQUESTED",
	2:  "POWERING_ON",
	3:  "POWER_ON",
	4:  "POWER_OFF_REQUESTED",
	5:  "POWERING_OFF",
	6:  "POWER_OFF",
	7:  "REBOOT_REQUESTED",
	8:  "REBOOTING",
	9:  "REBOOT",
	10: "POWER_STATE_ERROR",
}

var PowerState_value = map[string]int32{
	"POWER_STATE_UNKNOWN": 0,
	"POWER_ON_REQUESTED":  1,
	"POWERING_ON":         2,
	"POWER_ON":            3,
	"POWER_OFF_REQUESTED": 4,
	"POWERING_OFF":        5,
	"POWER_OFF":           6,
	"REBOOT_REQUESTED":    7,
	"REBOOTING":           8,
	"REBOOT":              9,
	"POWER_STATE_ERROR":   10,
}

func (x PowerState) String() string {
	return proto.EnumName(PowerState_name, int32(x))
}

func (PowerState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_94c89dd623ab567d, []int{0}
}

// Virtual ClusterInstKey
type VirtualClusterInstKeyV1 struct {
	// Name of Cluster
	ClusterKey ClusterKeyV1 `protobuf:"bytes,1,opt,name=cluster_key,json=clusterKey,proto3" json:"cluster_key"`
	// Name of Cloudlet on which the Cluster is instantiated
	CloudletKey CloudletKey `protobuf:"bytes,2,opt,name=cloudlet_key,json=cloudletKey,proto3" json:"cloudlet_key"`
	// Name of Developer organization that this cluster belongs to
	Organization string `protobuf:"bytes,3,opt,name=organization,proto3" json:"organization,omitempty"`
}

func (m *VirtualClusterInstKeyV1) Reset()         { *m = VirtualClusterInstKeyV1{} }
func (m *VirtualClusterInstKeyV1) String() string { return proto.CompactTextString(m) }
func (*VirtualClusterInstKeyV1) ProtoMessage()    {}
func (*VirtualClusterInstKeyV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_94c89dd623ab567d, []int{0}
}
func (m *VirtualClusterInstKeyV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VirtualClusterInstKeyV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VirtualClusterInstKeyV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VirtualClusterInstKeyV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VirtualClusterInstKeyV1.Merge(m, src)
}
func (m *VirtualClusterInstKeyV1) XXX_Size() int {
	return m.Size()
}
func (m *VirtualClusterInstKeyV1) XXX_DiscardUnknown() {
	xxx_messageInfo_VirtualClusterInstKeyV1.DiscardUnknown(m)
}

var xxx_messageInfo_VirtualClusterInstKeyV1 proto.InternalMessageInfo

// (_deprecated_) App Instance Unique Key V1
//
// AppInstKey uniquely identifies an Application Instance (AppInst) or Application Instance state (AppInstInfo).
type AppInstKeyV1 struct {
	// App key
	AppKey AppKey `protobuf:"bytes,1,opt,name=app_key,json=appKey,proto3" json:"app_key"`
	// Cluster instance on which this is instantiated
	ClusterInstKey VirtualClusterInstKeyV1 `protobuf:"bytes,4,opt,name=cluster_inst_key,json=clusterInstKey,proto3" json:"cluster_inst_key"`
}

func (m *AppInstKeyV1) Reset()         { *m = AppInstKeyV1{} }
func (m *AppInstKeyV1) String() string { return proto.CompactTextString(m) }
func (*AppInstKeyV1) ProtoMessage()    {}
func (*AppInstKeyV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_94c89dd623ab567d, []int{1}
}
func (m *AppInstKeyV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppInstKeyV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppInstKeyV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppInstKeyV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppInstKeyV1.Merge(m, src)
}
func (m *AppInstKeyV1) XXX_Size() int {
	return m.Size()
}
func (m *AppInstKeyV1) XXX_DiscardUnknown() {
	xxx_messageInfo_AppInstKeyV1.DiscardUnknown(m)
}

var xxx_messageInfo_AppInstKeyV1 proto.InternalMessageInfo

// (_deprecated_) App Instance Unique Key V2
//
// AppInstKey uniquely identifies an Application Instance (AppInst) or Application Instance state (AppInstInfo).
type AppInstKeyV2 struct {
	// App Instance name
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// App Instance organization
	Organization string `protobuf:"bytes,2,opt,name=organization,proto3" json:"organization,omitempty"`
	// Name of Cloudlet on which to deploy the App Instance
	CloudletKey CloudletKey `protobuf:"bytes,3,opt,name=cloudlet_key,json=cloudletKey,proto3" json:"cloudlet_key"`
}

func (m *AppInstKeyV2) Reset()         { *m = AppInstKeyV2{} }
func (m *AppInstKeyV2) String() string { return proto.CompactTextString(m) }
func (*AppInstKeyV2) ProtoMessage()    {}
func (*AppInstKeyV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_94c89dd623ab567d, []int{2}
}
func (m *AppInstKeyV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppInstKeyV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppInstKeyV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppInstKeyV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppInstKeyV2.Merge(m, src)
}
func (m *AppInstKeyV2) XXX_Size() int {
	return m.Size()
}
func (m *AppInstKeyV2) XXX_DiscardUnknown() {
	xxx_messageInfo_AppInstKeyV2.DiscardUnknown(m)
}

var xxx_messageInfo_AppInstKeyV2 proto.InternalMessageInfo

// App Instance Unique Key
//
// AppInstKey uniquely identifies an Application Instance (AppInst) or Application Instance state (AppInstInfo).
type AppInstKey struct {
	// App Instance name
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// App Instance organization
	Organization string `protobuf:"bytes,2,opt,name=organization,proto3" json:"organization,omitempty"`
}

func (m *AppInstKey) Reset()         { *m = AppInstKey{} }
func (m *AppInstKey) String() string { return proto.CompactTextString(m) }
func (*AppInstKey) ProtoMessage()    {}
func (*AppInstKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_94c89dd623ab567d, []int{3}
}
func (m *AppInstKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppInstKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppInstKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppInstKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppInstKey.Merge(m, src)
}
func (m *AppInstKey) XXX_Size() int {
	return m.Size()
}
func (m *AppInstKey) XXX_DiscardUnknown() {
	xxx_messageInfo_AppInstKey.DiscardUnknown(m)
}

var xxx_messageInfo_AppInstKey proto.InternalMessageInfo

// Application Instance
//
// AppInst is an instance of an App on a Cloudlet where it is defined by an App plus a ClusterInst key.
// Many of the fields here are inherited from the App definition.
type AppInst struct {
	// Fields are used for the Update API to specify which fields to apply
	Fields []string `protobuf:"bytes,1,rep,name=fields,proto3" json:"fields,omitempty"`
	// Unique identifier key
	// required: true
	Key AppInstKey `protobuf:"bytes,2,opt,name=key,proto3" json:"key"`
	// App key
	AppKey AppKey `protobuf:"bytes,44,opt,name=app_key,json=appKey,proto3" json:"app_key"`
	// Cluster on which to deploy App Instance, may be left blank for auto-placement
	ClusterKey ClusterKey `protobuf:"bytes,45,opt,name=cluster_key,json=clusterKey,proto3" json:"cluster_key"`
	// Cloudlet on which the instance is deployed
	CloudletKey CloudletKey `protobuf:"bytes,51,opt,name=cloudlet_key,json=cloudletKey,proto3" json:"cloudlet_key"`
	// Cached location of the cloudlet
	CloudletLoc distributed_match_engine.Loc `protobuf:"bytes,3,opt,name=cloudlet_loc,json=cloudletLoc,proto3" json:"cloudlet_loc"`
	// Base FQDN (not really URI) for the App. See Service FQDN for endpoint access.
	Uri string `protobuf:"bytes,4,opt,name=uri,proto3" json:"uri,omitempty"`
	// Static startup FQDN gets set when the object is created and cannot be changed
	StaticUri string `protobuf:"bytes,50,opt,name=static_uri,json=staticUri,proto3" json:"static_uri,omitempty"`
	// Liveness of instance (see Liveness)
	Liveness Liveness `protobuf:"varint,6,opt,name=liveness,proto3,enum=edgeproto.Liveness" json:"liveness,omitempty"`
	// For instances accessible via a shared load balancer, defines the external
	// ports on the shared load balancer that map to the internal ports
	// External ports should be appended to the Uri for L4 access.
	MappedPorts []distributed_match_engine.AppPort `protobuf:"bytes,9,rep,name=mapped_ports,json=mappedPorts,proto3" json:"mapped_ports"`
	// Flavor defining resource requirements
	Flavor FlavorKey `protobuf:"bytes,12,opt,name=flavor,proto3" json:"flavor"`
	// Cloudlet-specific flavor instead of regional flavor
	CloudletFlavor string `protobuf:"bytes,42,opt,name=cloudlet_flavor,json=cloudletFlavor,proto3" json:"cloudlet_flavor,omitempty"`
	// Current state of the AppInst on the Cloudlet
	State TrackedState `protobuf:"varint,14,opt,name=state,proto3,enum=edgeproto.TrackedState" json:"state,omitempty"`
	// Any errors trying to create, update, or delete the AppInst on the Cloudlet
	Errors []string `protobuf:"bytes,15,rep,name=errors,proto3" json:"errors,omitempty"`
	// Override actions to CRM
	CrmOverride CRMOverride `protobuf:"varint,16,opt,name=crm_override,json=crmOverride,proto3,enum=edgeproto.CRMOverride" json:"crm_override,omitempty"`
	// AppInst runtime information
	RuntimeInfo AppInstRuntime `protobuf:"bytes,17,opt,name=runtime_info,json=runtimeInfo,proto3" json:"runtime_info"`
	// Created at time
	CreatedAt distributed_match_engine.Timestamp `protobuf:"bytes,21,opt,name=created_at,json=createdAt,proto3" json:"created_at"`
	// (Deprecated) IpAccess for auto-clusters. Ignored otherwise.
	AutoClusterIpAccess IpAccess `protobuf:"varint,22,opt,name=auto_cluster_ip_access,json=autoClusterIpAccess,proto3,enum=edgeproto.IpAccess" json:"auto_cluster_ip_access,omitempty"`
	// Revision changes each time the App is updated.  Refreshing the App Instance will sync the revision with that of the App
	Revision string `protobuf:"bytes,24,opt,name=revision,proto3" json:"revision,omitempty"`
	// Force Appinst refresh even if revision number matches App revision number.
	ForceUpdate bool `protobuf:"varint,25,opt,name=force_update,json=forceUpdate,proto3" json:"force_update,omitempty"`
	// Allow multiple instances to be updated at once
	UpdateMultiple bool `protobuf:"varint,26,opt,name=update_multiple,json=updateMultiple,proto3" json:"update_multiple,omitempty"`
	// Customization files passed through to implementing services
	Configs []*ConfigFile `protobuf:"bytes,27,rep,name=configs,proto3" json:"configs,omitempty"`
	// Health Check status
	HealthCheck distributed_match_engine.HealthCheck `protobuf:"varint,29,opt,name=health_check,json=healthCheck,proto3,enum=distributed_match_engine.HealthCheck" json:"health_check,omitempty"`
	// Power State of the AppInst
	PowerState PowerState `protobuf:"varint,31,opt,name=power_state,json=powerState,proto3,enum=edgeproto.PowerState" json:"power_state,omitempty"`
	// Size of external volume to be attached to nodes.  This is for the root partition
	ExternalVolumeSize uint64 `protobuf:"varint,32,opt,name=external_volume_size,json=externalVolumeSize,proto3" json:"external_volume_size,omitempty"`
	// Optional Availability Zone if any
	AvailabilityZone string `protobuf:"bytes,33,opt,name=availability_zone,json=availabilityZone,proto3" json:"availability_zone,omitempty"`
	// OS node flavor to use
	VmFlavor string `protobuf:"bytes,34,opt,name=vm_flavor,json=vmFlavor,proto3" json:"vm_flavor,omitempty"`
	// Optional Resources required by OS flavor if any
	OptRes string `protobuf:"bytes,35,opt,name=opt_res,json=optRes,proto3" json:"opt_res,omitempty"`
	// Updated at time
	UpdatedAt distributed_match_engine.Timestamp `protobuf:"bytes,36,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at"`
	// (_deprecated_) Real ClusterInst name
	RealClusterName string `protobuf:"bytes,37,opt,name=real_cluster_name,json=realClusterName,proto3" json:"real_cluster_name,omitempty"`
	// mapping of ports to load balancer IPs
	InternalPortToLbIp map[string]string `protobuf:"bytes,38,rep,name=internal_port_to_lb_ip,json=internalPortToLbIp,proto3" json:"internal_port_to_lb_ip,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Dedicated IP assigns an IP for this AppInst but requires platform support
	DedicatedIp bool `protobuf:"varint,39,opt,name=dedicated_ip,json=dedicatedIp,proto3" json:"dedicated_ip,omitempty"`
	// A unique id for the AppInst within the region to be used by platforms
	UniqueId string `protobuf:"bytes,40,opt,name=unique_id,json=uniqueId,proto3" json:"unique_id,omitempty"`
	// DNS label that is unique within the cloudlet and among other AppInsts/ClusterInsts
	DnsLabel string `protobuf:"bytes,41,opt,name=dns_label,json=dnsLabel,proto3" json:"dns_label,omitempty"`
	// Federated ID if federated AppInst
	FedKey FedAppInstKey `protobuf:"bytes,43,opt,name=fed_key,json=fedKey,proto3" json:"fed_key"`
	// Internal compatibility version
	CompatibilityVersion uint32 `protobuf:"varint,46,opt,name=compatibility_version,json=compatibilityVersion,proto3" json:"compatibility_version,omitempty"`
	// Older deprecated virtual cluster
	VirtualClusterKey ClusterKey `protobuf:"bytes,47,opt,name=virtual_cluster_key,json=virtualClusterKey,proto3" json:"virtual_cluster_key"`
	// Enable IPv6 addressing, requires platform and cloudlet support, defaults to platform setting for VM Apps and auto-clusters, otherwise defaults to target cluster instance setting.
	EnableIpv6 bool `protobuf:"varint,48,opt,name=enable_ipv6,json=enableIpv6,proto3" json:"enable_ipv6,omitempty"`
	// Universally unique object ID
	ObjId string `protobuf:"bytes,49,opt,name=obj_id,json=objId,proto3" json:"obj_id,omitempty"`
	// Annotations
	Annotations map[string]string `protobuf:"bytes,52,rep,name=annotations,proto3" json:"annotations,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *AppInst) Reset()         { *m = AppInst{} }
func (m *AppInst) String() string { return proto.CompactTextString(m) }
func (*AppInst) ProtoMessage()    {}
func (*AppInst) Descriptor() ([]byte, []int) {
	return fileDescriptor_94c89dd623ab567d, []int{4}
}
func (m *AppInst) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppInst) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppInst.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppInst) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppInst.Merge(m, src)
}
func (m *AppInst) XXX_Size() int {
	return m.Size()
}
func (m *AppInst) XXX_DiscardUnknown() {
	xxx_messageInfo_AppInst.DiscardUnknown(m)
}

var xxx_messageInfo_AppInst proto.InternalMessageInfo

// AppInst Runtime Info
//
// Runtime information of active AppInsts
type AppInstRuntime struct {
	// List of container names
	ContainerIds []string `protobuf:"bytes,1,rep,name=container_ids,json=containerIds,proto3" json:"container_ids,omitempty"`
}

func (m *AppInstRuntime) Reset()         { *m = AppInstRuntime{} }
func (m *AppInstRuntime) String() string { return proto.CompactTextString(m) }
func (*AppInstRuntime) ProtoMessage()    {}
func (*AppInstRuntime) Descriptor() ([]byte, []int) {
	return fileDescriptor_94c89dd623ab567d, []int{5}
}
func (m *AppInstRuntime) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppInstRuntime) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppInstRuntime.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppInstRuntime) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppInstRuntime.Merge(m, src)
}
func (m *AppInstRuntime) XXX_Size() int {
	return m.Size()
}
func (m *AppInstRuntime) XXX_DiscardUnknown() {
	xxx_messageInfo_AppInstRuntime.DiscardUnknown(m)
}

var xxx_messageInfo_AppInstRuntime proto.InternalMessageInfo

// AppInstInfo provides information from the Cloudlet Resource Manager about the state of the AppInst on the Cloudlet. Whereas the AppInst defines the intent of instantiating an App on a Cloudlet, the AppInstInfo defines the current state of trying to apply that intent on the physical resources of the Cloudlet.
type AppInstInfo struct {
	// Fields are used for the Update API to specify which fields to apply
	Fields []string `protobuf:"bytes,1,rep,name=fields,proto3" json:"fields,omitempty"`
	// Unique identifier key
	Key AppInstKey `protobuf:"bytes,2,opt,name=key,proto3" json:"key"`
	// Id of client assigned by server (internal use only)
	NotifyId int64 `protobuf:"varint,3,opt,name=notify_id,json=notifyId,proto3" json:"notify_id,omitempty"`
	// Current state of the AppInst on the Cloudlet
	State TrackedState `protobuf:"varint,4,opt,name=state,proto3,enum=edgeproto.TrackedState" json:"state,omitempty"`
	// Any errors trying to create, update, or delete the AppInst on the Cloudlet
	Errors []string `protobuf:"bytes,5,rep,name=errors,proto3" json:"errors,omitempty"`
	// AppInst runtime information
	RuntimeInfo AppInstRuntime `protobuf:"bytes,6,opt,name=runtime_info,json=runtimeInfo,proto3" json:"runtime_info"`
	// status is used to reflect progress of creation or other events
	Status StatusInfo `protobuf:"bytes,7,opt,name=status,proto3" json:"status"`
	// Power State of the AppInst
	PowerState PowerState `protobuf:"varint,8,opt,name=power_state,json=powerState,proto3,enum=edgeproto.PowerState" json:"power_state,omitempty"`
	// Base FQDN for the App based on the cloudlet platform
	Uri string `protobuf:"bytes,9,opt,name=uri,proto3" json:"uri,omitempty"`
	// Federation AppInst Key, if any
	FedKey FedAppInstKey `protobuf:"bytes,10,opt,name=fed_key,json=fedKey,proto3" json:"fed_key"`
	// Federation Port info if any
	FedPorts []distributed_match_engine.AppPort `protobuf:"bytes,11,rep,name=fed_ports,json=fedPorts,proto3" json:"fed_ports"`
}

func (m *AppInstInfo) Reset()         { *m = AppInstInfo{} }
func (m *AppInstInfo) String() string { return proto.CompactTextString(m) }
func (*AppInstInfo) ProtoMessage()    {}
func (*AppInstInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_94c89dd623ab567d, []int{6}
}
func (m *AppInstInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppInstInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppInstInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppInstInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppInstInfo.Merge(m, src)
}
func (m *AppInstInfo) XXX_Size() int {
	return m.Size()
}
func (m *AppInstInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_AppInstInfo.DiscardUnknown(m)
}

var xxx_messageInfo_AppInstInfo proto.InternalMessageInfo

// (TODO) AppInstMetrics provide metrics collected about the application instance on the Cloudlet. They are sent to a metrics collector for analytics. They are not stored in the persistent distributed database, but are stored as a time series in some other database or files.
type AppInstMetrics struct {
	// what goes here?
	// Note that metrics for grpc calls can be done by a prometheus
	// interceptor in grpc, so adding call metrics here may be
	// redundant unless they're needed for billing.
	Something uint64 `protobuf:"varint,5,opt,name=something,proto3" json:"something,omitempty"`
}

func (m *AppInstMetrics) Reset()         { *m = AppInstMetrics{} }
func (m *AppInstMetrics) String() string { return proto.CompactTextString(m) }
func (*AppInstMetrics) ProtoMessage()    {}
func (*AppInstMetrics) Descriptor() ([]byte, []int) {
	return fileDescriptor_94c89dd623ab567d, []int{7}
}
func (m *AppInstMetrics) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppInstMetrics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppInstMetrics.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppInstMetrics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppInstMetrics.Merge(m, src)
}
func (m *AppInstMetrics) XXX_Size() int {
	return m.Size()
}
func (m *AppInstMetrics) XXX_DiscardUnknown() {
	xxx_messageInfo_AppInstMetrics.DiscardUnknown(m)
}

var xxx_messageInfo_AppInstMetrics proto.InternalMessageInfo

// AppInstLookup is used to generate reverse lookup caches
type AppInstLookup struct {
	// unique key
	Key AppInstKey `protobuf:"bytes,1,opt,name=key,proto3" json:"key"`
	// lookup by AutoProvPolicy
	PolicyKey PolicyKey `protobuf:"bytes,2,opt,name=policy_key,json=policyKey,proto3" json:"policy_key"`
}

func (m *AppInstLookup) Reset()         { *m = AppInstLookup{} }
func (m *AppInstLookup) String() string { return proto.CompactTextString(m) }
func (*AppInstLookup) ProtoMessage()    {}
func (*AppInstLookup) Descriptor() ([]byte, []int) {
	return fileDescriptor_94c89dd623ab567d, []int{8}
}
func (m *AppInstLookup) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppInstLookup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppInstLookup.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppInstLookup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppInstLookup.Merge(m, src)
}
func (m *AppInstLookup) XXX_Size() int {
	return m.Size()
}
func (m *AppInstLookup) XXX_DiscardUnknown() {
	xxx_messageInfo_AppInstLookup.DiscardUnknown(m)
}

var xxx_messageInfo_AppInstLookup proto.InternalMessageInfo

// AppInstLookup2 is used to generate reverse lookup caches
type AppInstLookup2 struct {
	// unique key
	Key AppInstKey `protobuf:"bytes,1,opt,name=key,proto3" json:"key"`
	// lookup by AutoProvPolicy
	CloudletKey CloudletKey `protobuf:"bytes,2,opt,name=cloudlet_key,json=cloudletKey,proto3" json:"cloudlet_key"`
}

func (m *AppInstLookup2) Reset()         { *m = AppInstLookup2{} }
func (m *AppInstLookup2) String() string { return proto.CompactTextString(m) }
func (*AppInstLookup2) ProtoMessage()    {}
func (*AppInstLookup2) Descriptor() ([]byte, []int) {
	return fileDescriptor_94c89dd623ab567d, []int{9}
}
func (m *AppInstLookup2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppInstLookup2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppInstLookup2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppInstLookup2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppInstLookup2.Merge(m, src)
}
func (m *AppInstLookup2) XXX_Size() int {
	return m.Size()
}
func (m *AppInstLookup2) XXX_DiscardUnknown() {
	xxx_messageInfo_AppInstLookup2.DiscardUnknown(m)
}

var xxx_messageInfo_AppInstLookup2 proto.InternalMessageInfo

type AppInstLatency struct {
	// Unique identifier key
	Key AppInstKey `protobuf:"bytes,1,opt,name=key,proto3" json:"key"`
}

func (m *AppInstLatency) Reset()         { *m = AppInstLatency{} }
func (m *AppInstLatency) String() string { return proto.CompactTextString(m) }
func (*AppInstLatency) ProtoMessage()    {}
func (*AppInstLatency) Descriptor() ([]byte, []int) {
	return fileDescriptor_94c89dd623ab567d, []int{10}
}
func (m *AppInstLatency) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppInstLatency) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppInstLatency.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppInstLatency) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppInstLatency.Merge(m, src)
}
func (m *AppInstLatency) XXX_Size() int {
	return m.Size()
}
func (m *AppInstLatency) XXX_DiscardUnknown() {
	xxx_messageInfo_AppInstLatency.DiscardUnknown(m)
}

var xxx_messageInfo_AppInstLatency proto.InternalMessageInfo

// Federation AppInst Key
type FedAppInstKey struct {
	// Federation name
	FederationName string `protobuf:"bytes,1,opt,name=federation_name,json=federationName,proto3" json:"federation_name,omitempty"`
	// Federated AppInst ID
	AppInstId string `protobuf:"bytes,2,opt,name=app_inst_id,json=appInstId,proto3" json:"app_inst_id,omitempty"`
}

func (m *FedAppInstKey) Reset()         { *m = FedAppInstKey{} }
func (m *FedAppInstKey) String() string { return proto.CompactTextString(m) }
func (*FedAppInstKey) ProtoMessage()    {}
func (*FedAppInstKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_94c89dd623ab567d, []int{11}
}
func (m *FedAppInstKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FedAppInstKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FedAppInstKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FedAppInstKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FedAppInstKey.Merge(m, src)
}
func (m *FedAppInstKey) XXX_Size() int {
	return m.Size()
}
func (m *FedAppInstKey) XXX_DiscardUnknown() {
	xxx_messageInfo_FedAppInstKey.DiscardUnknown(m)
}

var xxx_messageInfo_FedAppInstKey proto.InternalMessageInfo

// FedAppInst associates a Federated AppInst Id with the AppInst Key
type FedAppInst struct {
	// FedAppInst Key
	Key FedAppInstKey `protobuf:"bytes,1,opt,name=key,proto3" json:"key"`
	// AppInst Key
	AppInstKey AppInstKey `protobuf:"bytes,2,opt,name=app_inst_key,json=appInstKey,proto3" json:"app_inst_key"`
}

func (m *FedAppInst) Reset()         { *m = FedAppInst{} }
func (m *FedAppInst) String() string { return proto.CompactTextString(m) }
func (*FedAppInst) ProtoMessage()    {}
func (*FedAppInst) Descriptor() ([]byte, []int) {
	return fileDescriptor_94c89dd623ab567d, []int{12}
}
func (m *FedAppInst) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FedAppInst) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FedAppInst.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FedAppInst) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FedAppInst.Merge(m, src)
}
func (m *FedAppInst) XXX_Size() int {
	return m.Size()
}
func (m *FedAppInst) XXX_DiscardUnknown() {
	xxx_messageInfo_FedAppInst.DiscardUnknown(m)
}

var xxx_messageInfo_FedAppInst proto.InternalMessageInfo

// FedAppInstEvent is received from a partner Federation
type FedAppInstEvent struct {
	// FedAppInst Key
	Key FedAppInstKey `protobuf:"bytes,1,opt,name=key,proto3" json:"key"`
	// Updated State if any
	State TrackedState `protobuf:"varint,2,opt,name=state,proto3,enum=edgeproto.TrackedState" json:"state,omitempty"`
	// Event message or error message
	Message string `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
	// Port info if any
	Ports []distributed_match_engine.AppPort `protobuf:"bytes,4,rep,name=ports,proto3" json:"ports"`
	// Unique Id, matches AppInst.UniqueId
	UniqueId string `protobuf:"bytes,5,opt,name=unique_id,json=uniqueId,proto3" json:"unique_id,omitempty"`
}

func (m *FedAppInstEvent) Reset()         { *m = FedAppInstEvent{} }
func (m *FedAppInstEvent) String() string { return proto.CompactTextString(m) }
func (*FedAppInstEvent) ProtoMessage()    {}
func (*FedAppInstEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_94c89dd623ab567d, []int{13}
}
func (m *FedAppInstEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FedAppInstEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FedAppInstEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FedAppInstEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FedAppInstEvent.Merge(m, src)
}
func (m *FedAppInstEvent) XXX_Size() int {
	return m.Size()
}
func (m *FedAppInstEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_FedAppInstEvent.DiscardUnknown(m)
}

var xxx_messageInfo_FedAppInstEvent proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("edgeproto.PowerState", PowerState_name, PowerState_value)
	proto.RegisterType((*VirtualClusterInstKeyV1)(nil), "edgeproto.VirtualClusterInstKeyV1")
	proto.RegisterType((*AppInstKeyV1)(nil), "edgeproto.AppInstKeyV1")
	proto.RegisterType((*AppInstKeyV2)(nil), "edgeproto.AppInstKeyV2")
	proto.RegisterType((*AppInstKey)(nil), "edgeproto.AppInstKey")
	proto.RegisterType((*AppInst)(nil), "edgeproto.AppInst")
	proto.RegisterMapType((map[string]string)(nil), "edgeproto.AppInst.AnnotationsEntry")
	proto.RegisterMapType((map[string]string)(nil), "edgeproto.AppInst.InternalPortToLbIpEntry")
	proto.RegisterType((*AppInstRuntime)(nil), "edgeproto.AppInstRuntime")
	proto.RegisterType((*AppInstInfo)(nil), "edgeproto.AppInstInfo")
	proto.RegisterType((*AppInstMetrics)(nil), "edgeproto.AppInstMetrics")
	proto.RegisterType((*AppInstLookup)(nil), "edgeproto.AppInstLookup")
	proto.RegisterType((*AppInstLookup2)(nil), "edgeproto.AppInstLookup2")
	proto.RegisterType((*AppInstLatency)(nil), "edgeproto.AppInstLatency")
	proto.RegisterType((*FedAppInstKey)(nil), "edgeproto.FedAppInstKey")
	proto.RegisterType((*FedAppInst)(nil), "edgeproto.FedAppInst")
	proto.RegisterType((*FedAppInstEvent)(nil), "edgeproto.FedAppInstEvent")
}

func init() { proto.RegisterFile("appinst.proto", fileDescriptor_94c89dd623ab567d) }

var fileDescriptor_94c89dd623ab567d = []byte{
	// 2809 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x19, 0x4d, 0x6c, 0x1c, 0x57,
	0x39, 0x63, 0xaf, 0xd7, 0xde, 0xb7, 0xbb, 0xf6, 0xfa, 0xc5, 0x76, 0x5e, 0x5c, 0xc7, 0x71, 0x36,
	0x4d, 0xeb, 0x86, 0x89, 0x9d, 0xb8, 0x25, 0xa5, 0xae, 0xdc, 0x62, 0x27, 0x76, 0xeb, 0xc6, 0xb1,
	0xcb, 0xf8, 0xa7, 0xc0, 0x65, 0x34, 0x9e, 0x79, 0xbb, 0x9e, 0x66, 0x76, 0xde, 0x74, 0x66, 0x76,
	0x83, 0x23, 0x21, 0xa1, 0x4a, 0x48, 0x3d, 0xa1, 0x52, 0x0e, 0x45, 0x85, 0x43, 0x0f, 0x1c, 0x8a,
	0x84, 0x50, 0x1b, 0x09, 0x21, 0xe5, 0x80, 0x10, 0xa7, 0xaa, 0x12, 0x52, 0x24, 0x38, 0x54, 0x3d,
	0x40, 0x69, 0x39, 0xa0, 0x1c, 0x50, 0xa5, 0xd8, 0x5b, 0xc4, 0x09, 0xbd, 0x9f, 0x99, 0x79, 0xb3,
	0xbb, 0xb6, 0xe2, 0x84, 0xdb, 0xce, 0xf7, 0xff, 0xff, 0xbe, 0xf7, 0x16, 0x14, 0x0d, 0xcf, 0xb3,
	0xdd, 0x20, 0x9c, 0xf2, 0x7c, 0x12, 0x12, 0x98, 0xc3, 0x56, 0x15, 0xb3, 0x9f, 0xa3, 0x63, 0x55,
	0x42, 0xaa, 0x0e, 0x9e, 0x36, 0x3c, 0x7b, 0xda, 0x70, 0x5d, 0x12, 0x1a, 0xa1, 0x4d, 0xdc, 0x80,
	0x13, 0x8e, 0x16, 0x7c, 0x1c, 0xd4, 0x1d, 0xc1, 0x36, 0x7a, 0x2a, 0x24, 0xc4, 0x09, 0xa6, 0xd9,
	0x47, 0x15, 0xbb, 0xf1, 0x0f, 0x81, 0xce, 0x19, 0x9e, 0x17, 0xf1, 0x55, 0x1c, 0xa3, 0x41, 0xfc,
	0xe8, 0xcb, 0x24, 0xb5, 0x1a, 0x89, 0xc8, 0x06, 0x4d, 0x87, 0xd4, 0x2d, 0x07, 0x87, 0x37, 0xf0,
	0xae, 0x00, 0x0d, 0x1b, 0xf5, 0x90, 0x04, 0xa6, 0xe1, 0x60, 0x8f, 0x38, 0xb6, 0x19, 0x81, 0x8b,
	0xa6, 0x53, 0x0f, 0x42, 0x1c, 0x89, 0x29, 0x5a, 0x35, 0x3c, 0xed, 0x10, 0x53, 0x7c, 0x1e, 0xa7,
	0x9f, 0x86, 0xe7, 0xa5, 0x84, 0x0f, 0x55, 0x49, 0x95, 0xb0, 0x9f, 0xd3, 0xf4, 0x97, 0x80, 0xc2,
	0xd8, 0xdf, 0xd8, 0xda, 0xf2, 0xe7, 0x0a, 0x38, 0xb1, 0x65, 0xfb, 0x61, 0xdd, 0x70, 0xae, 0x70,
	0x35, 0xcb, 0x6e, 0x10, 0x5e, 0xc3, 0xbb, 0x5b, 0x97, 0xe0, 0x0b, 0x20, 0x2f, 0x54, 0xeb, 0x37,
	0xf0, 0x2e, 0x52, 0x26, 0x94, 0xc9, 0xfc, 0xcc, 0x89, 0xa9, 0x58, 0xca, 0x94, 0xe0, 0x60, 0xd4,
	0x0b, 0x99, 0x8f, 0xff, 0x76, 0xfa, 0x98, 0x06, 0xcc, 0x18, 0x06, 0x5f, 0x04, 0x85, 0xc8, 0x49,
	0x26, 0xa0, 0x8b, 0x09, 0x18, 0x49, 0x09, 0xe0, 0xe8, 0x6b, 0x78, 0x57, 0xf0, 0xe7, 0xcd, 0x04,
	0x04, 0x2f, 0x83, 0x02, 0xf1, 0xab, 0x86, 0x6b, 0xdf, 0x62, 0xe9, 0x40, 0xdd, 0x13, 0xca, 0x64,
	0x6e, 0x01, 0xde, 0x69, 0xa2, 0x48, 0x0d, 0xf1, 0xab, 0x77, 0x9b, 0x48, 0xd1, 0x52, 0x74, 0xb3,
	0x85, 0x7f, 0xdd, 0x47, 0xca, 0x7f, 0xee, 0x23, 0xe5, 0xc3, 0xf7, 0x4f, 0x2b, 0xe5, 0xdf, 0x29,
	0xa0, 0x30, 0xef, 0x79, 0x89, 0x5f, 0x17, 0x41, 0xaf, 0xe1, 0x79, 0x92, 0x4f, 0x83, 0x92, 0x49,
	0xf3, 0x9e, 0x97, 0x58, 0x93, 0x35, 0xd8, 0x17, 0xc4, 0xa0, 0x14, 0x45, 0x82, 0xd6, 0x0f, 0x63,
	0xcd, 0x30, 0xd6, 0xb2, 0xc4, 0x7a, 0x40, 0x1c, 0x17, 0x4e, 0x7c, 0xb0, 0x87, 0x94, 0x7b, 0x4d,
	0x94, 0x97, 0x30, 0x4c, 0x7c, 0xbf, 0x99, 0x22, 0x6d, 0xb1, 0xfb, 0x4f, 0x69, 0xbb, 0x67, 0xe0,
	0x19, 0x90, 0x71, 0x8d, 0x1a, 0x66, 0x46, 0xe7, 0x16, 0x8a, 0x77, 0x9a, 0x28, 0x27, 0x0a, 0xba,
	0x31, 0xa3, 0x31, 0x14, 0x7c, 0xa6, 0x25, 0x62, 0x5d, 0x8c, 0xb4, 0x74, 0xa7, 0x89, 0x0a, 0x31,
	0x29, 0xf1, 0xab, 0xe9, 0x78, 0xc1, 0x6b, 0x2d, 0x89, 0xea, 0x3e, 0x34, 0x51, 0xa5, 0x7b, 0x4d,
	0xd4, 0x17, 0x01, 0xda, 0x92, 0xd6, 0xe2, 0x04, 0x01, 0x20, 0xf1, 0x01, 0x9e, 0x4e, 0x79, 0x90,
	0xbf, 0xd3, 0x44, 0xbd, 0xc2, 0x2c, 0x61, 0xff, 0x4c, 0x47, 0xfb, 0xfb, 0x69, 0xc6, 0x05, 0x61,
	0x9b, 0xf5, 0x2d, 0x0a, 0x7f, 0x8b, 0x40, 0xaf, 0xd0, 0x08, 0x47, 0x40, 0xb6, 0x62, 0x63, 0xc7,
	0x0a, 0x90, 0x32, 0xd1, 0x3d, 0x99, 0xd3, 0xc4, 0x17, 0xbc, 0x00, 0xba, 0x93, 0x7a, 0x1c, 0x4e,
	0x27, 0x5f, 0x98, 0x2a, 0x0a, 0x80, 0xd2, 0xc1, 0x67, 0x93, 0x7a, 0x51, 0x0f, 0xaa, 0x97, 0xfc,
	0xbd, 0x26, 0xea, 0x9e, 0xf7, 0xbc, 0x54, 0xd9, 0x5c, 0x4b, 0x37, 0xd0, 0x85, 0x36, 0x7d, 0x49,
	0x03, 0x2d, 0x1c, 0xef, 0x54, 0x20, 0x72, 0x37, 0xb5, 0x26, 0xe9, 0xe9, 0x47, 0x48, 0x12, 0x5c,
	0x92, 0x84, 0x39, 0xc4, 0x14, 0x19, 0x3f, 0x35, 0x65, 0xd9, 0x41, 0xe8, 0xdb, 0xdb, 0xf5, 0x10,
	0x5b, 0x7a, 0xcd, 0x08, 0xcd, 0x1d, 0x1d, 0xbb, 0x55, 0xdb, 0xc5, 0x53, 0x2b, 0xc4, 0x6c, 0xed,
	0xd0, 0x15, 0x62, 0xc2, 0x11, 0xd0, 0x5d, 0xf7, 0x6d, 0xd6, 0x0b, 0xb9, 0x85, 0x0c, 0xad, 0x73,
	0x8d, 0x02, 0xe0, 0x59, 0x00, 0x02, 0x3a, 0x43, 0x4d, 0x9d, 0xa2, 0x67, 0x24, 0x74, 0x8e, 0xc3,
	0x37, 0x7d, 0x1b, 0x7e, 0x13, 0xf4, 0x39, 0x76, 0x03, 0xbb, 0x38, 0x08, 0x50, 0x76, 0x42, 0x99,
	0xec, 0x9f, 0x39, 0x2e, 0x79, 0xb3, 0x22, 0x50, 0x82, 0x2f, 0x26, 0x85, 0xab, 0xa0, 0x50, 0x33,
	0x3c, 0x0f, 0x5b, 0xba, 0x47, 0xfc, 0x30, 0x40, 0xb9, 0x89, 0xee, 0xc9, 0xfc, 0xcc, 0x99, 0x83,
	0x6d, 0x9f, 0xf7, 0xbc, 0x57, 0x89, 0x1f, 0x2e, 0xf4, 0x51, 0x41, 0xdc, 0x07, 0x2e, 0x80, 0x42,
	0x03, 0xf8, 0x6d, 0x90, 0xe5, 0x73, 0x1a, 0x15, 0x58, 0x14, 0x86, 0x24, 0x23, 0x96, 0x18, 0x82,
	0x06, 0x14, 0x8a, 0x26, 0xce, 0x72, 0x10, 0xcf, 0x33, 0xe7, 0x83, 0x4f, 0x82, 0x81, 0x38, 0x9a,
	0x42, 0xd4, 0x79, 0xea, 0x32, 0x6d, 0x70, 0x0e, 0xe6, 0x4c, 0xf0, 0x69, 0xd0, 0x43, 0xdd, 0xc7,
	0xa8, 0x9f, 0xb9, 0x2b, 0xcf, 0xd2, 0x0d, 0xdf, 0x30, 0x6f, 0x60, 0x6b, 0x9d, 0xa2, 0x85, 0xcb,
	0x9c, 0x16, 0x8e, 0x81, 0x2c, 0xf6, 0x7d, 0xe2, 0x07, 0x68, 0x80, 0x56, 0xb1, 0x40, 0x0a, 0x18,
	0x7c, 0x0e, 0x14, 0x4c, 0xbf, 0xa6, 0x93, 0x06, 0xf6, 0x7d, 0xdb, 0xc2, 0xa8, 0xc4, 0x24, 0xa7,
	0xca, 0x42, 0xbb, 0xbe, 0x26, 0xb0, 0x5a, 0xde, 0xf4, 0x6b, 0xd1, 0x07, 0x5c, 0x00, 0x05, 0xbf,
	0xee, 0x86, 0x76, 0x0d, 0xeb, 0xb6, 0x5b, 0x21, 0x68, 0x90, 0xb9, 0x7f, 0xb2, 0xbd, 0x1f, 0x34,
	0x4e, 0x15, 0x15, 0x80, 0x60, 0x5a, 0x76, 0x2b, 0x04, 0x7e, 0x0f, 0x00, 0xd3, 0xc7, 0x06, 0x8d,
	0xb9, 0x11, 0xa2, 0x61, 0x26, 0xe1, 0xec, 0xc1, 0xa9, 0xd8, 0xb0, 0x6b, 0x38, 0x08, 0x8d, 0x9a,
	0xb7, 0x30, 0x4c, 0xbd, 0x78, 0xe7, 0xf6, 0xc9, 0x5c, 0x18, 0x81, 0x98, 0xf0, 0x9c, 0x90, 0x36,
	0x1f, 0xc2, 0x55, 0x30, 0x42, 0x0f, 0x44, 0x3d, 0x9e, 0xbc, 0x9e, 0x6e, 0x98, 0x26, 0x2d, 0x96,
	0x91, 0xb6, 0x62, 0x59, 0xf6, 0xe6, 0x19, 0x4a, 0x04, 0xe7, 0x38, 0x65, 0x8c, 0x9a, 0x49, 0xa0,
	0xe0, 0x39, 0xd0, 0xe7, 0xe3, 0x86, 0x1d, 0xd0, 0xb9, 0x82, 0x58, 0x45, 0xe6, 0xde, 0xb9, 0x7d,
	0xb2, 0xc7, 0x25, 0x66, 0xcd, 0xd3, 0x62, 0x14, 0x54, 0x41, 0xa1, 0x42, 0x7c, 0x13, 0xeb, 0x75,
	0xcf, 0xa2, 0xa9, 0x3a, 0x39, 0xa1, 0x4c, 0xf6, 0xc9, 0xa4, 0x79, 0x86, 0xde, 0x64, 0x58, 0x38,
	0x03, 0x06, 0x38, 0x9d, 0x5e, 0xab, 0x3b, 0xa1, 0xed, 0x39, 0x18, 0x8d, 0xb6, 0x32, 0xf4, 0x73,
	0x8a, 0xeb, 0x82, 0x00, 0x4e, 0x83, 0x5e, 0x93, 0xb8, 0x15, 0xbb, 0x1a, 0xa0, 0xc7, 0x58, 0xed,
	0xa6, 0x46, 0x02, 0xc3, 0x2c, 0xd9, 0x0e, 0xd6, 0x22, 0x2a, 0x5a, 0xf1, 0x3b, 0xd8, 0x70, 0xc2,
	0x1d, 0xdd, 0xdc, 0xc1, 0xe6, 0x0d, 0x74, 0x8a, 0xf9, 0x7f, 0xee, 0xe0, 0x30, 0xbf, 0xcc, 0xa8,
	0xaf, 0x50, 0x62, 0x11, 0x91, 0xfc, 0x4e, 0x02, 0x82, 0x97, 0x41, 0xde, 0x23, 0x37, 0xb1, 0xaf,
	0xf3, 0x62, 0x3c, 0xcd, 0xc4, 0xc9, 0x46, 0xbc, 0x4a, 0xb1, 0xac, 0x14, 0x35, 0xe0, 0xc5, 0xbf,
	0xe1, 0x65, 0x30, 0x84, 0x7f, 0x10, 0x62, 0xdf, 0x35, 0x1c, 0xbd, 0x41, 0x9c, 0x7a, 0x0d, 0xeb,
	0x81, 0x7d, 0x0b, 0xa3, 0x89, 0x09, 0x65, 0x32, 0x23, 0x14, 0xc1, 0x88, 0x62, 0x8b, 0x11, 0xac,
	0xdb, 0xb7, 0x30, 0xbc, 0x04, 0x06, 0x8d, 0x86, 0x61, 0x3b, 0xc6, 0xb6, 0xed, 0xd8, 0xe1, 0xae,
	0x7e, 0x8b, 0xb8, 0x18, 0x9d, 0x91, 0x86, 0x42, 0x49, 0x46, 0x7f, 0x9f, 0xb8, 0x18, 0x9e, 0x01,
	0xb9, 0x46, 0x2d, 0x6a, 0xa6, 0xb2, 0x44, 0xda, 0xd7, 0xa8, 0x89, 0x66, 0x3a, 0x05, 0x7a, 0x89,
	0x17, 0xea, 0x3e, 0x0e, 0xd0, 0x59, 0x89, 0x20, 0x4b, 0xbc, 0x50, 0xc3, 0x01, 0xad, 0x4c, 0x1e,
	0x77, 0x56, 0x99, 0x8f, 0x3f, 0x7a, 0x65, 0x0a, 0x69, 0xf3, 0x21, 0xbc, 0x08, 0x06, 0x7d, 0x6c,
	0x38, 0x71, 0x65, 0xb2, 0x33, 0xed, 0x9c, 0x64, 0xc3, 0x00, 0x45, 0x8b, 0xfa, 0x5b, 0xa5, 0xe7,
	0x9a, 0x05, 0x46, 0x6c, 0x57, 0x44, 0x8e, 0x4e, 0x2d, 0x3d, 0x24, 0xba, 0xb3, 0xad, 0xdb, 0x1e,
	0x7a, 0x82, 0x55, 0xc0, 0xf9, 0xf6, 0xa6, 0x9b, 0x5a, 0x16, 0x0c, 0x74, 0x4a, 0x6d, 0x90, 0x95,
	0xed, 0x65, 0x6f, 0xd1, 0x0d, 0xfd, 0xdd, 0x28, 0xce, 0x76, 0x1b, 0x1a, 0x9e, 0x01, 0x05, 0x0b,
	0x5b, 0xb6, 0xc9, 0x9c, 0xb6, 0x3d, 0xf4, 0x24, 0xad, 0x44, 0x2d, 0x1f, 0xc3, 0x18, 0x49, 0xae,
	0xee, 0xda, 0x6f, 0xd4, 0xb1, 0x6e, 0x5b, 0x68, 0x52, 0x8e, 0x2b, 0x07, 0x2f, 0x5b, 0x94, 0xc4,
	0x72, 0x03, 0xdd, 0x31, 0xb6, 0xb1, 0x83, 0x9e, 0x92, 0x49, 0x2c, 0x37, 0x58, 0xa1, 0x50, 0xf8,
	0x3c, 0xe8, 0xad, 0x60, 0x8b, 0x1d, 0x43, 0xdf, 0x60, 0x81, 0x45, 0xf2, 0xcc, 0xc4, 0x96, 0x74,
	0x8e, 0x26, 0x43, 0x37, 0x5b, 0xc1, 0x16, 0x3d, 0x7b, 0x16, 0xc0, 0xb0, 0x49, 0x6a, 0x9e, 0x11,
	0xda, 0xa2, 0x1c, 0x1a, 0xd8, 0x67, 0x4d, 0x39, 0x35, 0xa1, 0x4c, 0x16, 0x17, 0x8a, 0x22, 0xfc,
	0xa2, 0x79, 0x86, 0x52, 0xb4, 0x5b, 0x9c, 0x14, 0x7e, 0x17, 0x1c, 0x6f, 0xf0, 0x6d, 0x4b, 0x97,
	0x4f, 0xd8, 0xe9, 0xc3, 0x4e, 0xd8, 0xc1, 0x94, 0x60, 0x66, 0xd2, 0x60, 0x23, 0xb5, 0xb2, 0xf1,
	0x15, 0x25, 0x8f, 0x5d, 0x63, 0xdb, 0xc1, 0xba, 0xed, 0x35, 0x2e, 0xa3, 0x8b, 0x2c, 0x84, 0x80,
	0x83, 0x96, 0xbd, 0xc6, 0x65, 0xf8, 0x38, 0xc8, 0x92, 0xed, 0xd7, 0x69, 0xf8, 0x2e, 0xf1, 0x3d,
	0x2c, 0x6d, 0x6f, 0x0f, 0xd9, 0x7e, 0x7d, 0xd9, 0x82, 0x8b, 0x20, 0x2f, 0xdd, 0x23, 0xd0, 0x33,
	0x2c, 0xcb, 0x67, 0x3b, 0x64, 0x79, 0x3e, 0xa1, 0x62, 0xe9, 0xd5, 0x64, 0xbe, 0xd1, 0x45, 0x70,
	0xe2, 0x80, 0x32, 0x80, 0x25, 0xbe, 0xc4, 0xb0, 0x55, 0x8a, 0xef, 0x29, 0x43, 0xa0, 0xa7, 0x61,
	0x38, 0x75, 0xcc, 0xb7, 0x26, 0x8d, 0x7f, 0xcc, 0x76, 0x7d, 0x4b, 0x19, 0x7d, 0x01, 0x94, 0x5a,
	0xf5, 0x1c, 0x85, 0x7f, 0xf6, 0xd7, 0x3d, 0x74, 0xc7, 0xfa, 0xea, 0x3e, 0x52, 0x7e, 0xb4, 0x87,
	0x94, 0xb7, 0xf7, 0x90, 0xf2, 0xf3, 0x3d, 0xa4, 0x7c, 0x48, 0x33, 0xbb, 0x87, 0x94, 0x4f, 0x69,
	0x00, 0xf6, 0xd1, 0xaf, 0xba, 0xae, 0x24, 0x9b, 0x81, 0xba, 0xe9, 0xdb, 0xea, 0x7a, 0x74, 0xd4,
	0xab, 0xd7, 0x93, 0xf3, 0x56, 0x8d, 0x0e, 0x76, 0xf5, 0x4a, 0x34, 0xea, 0x55, 0x4d, 0x0c, 0x5f,
	0x75, 0x91, 0x1d, 0x6a, 0xaa, 0x96, 0x9c, 0x30, 0xea, 0x96, 0xe8, 0x77, 0x75, 0xb1, 0x6d, 0xb0,
	0xa8, 0xf3, 0x2d, 0x63, 0x83, 0x69, 0xc4, 0xea, 0x66, 0xd4, 0xa9, 0xea, 0x1a, 0x9b, 0x05, 0xea,
	0xfa, 0x8e, 0xe1, 0x63, 0x4b, 0x66, 0x6c, 0x3f, 0x1f, 0xd4, 0xf6, 0x40, 0xab, 0x9b, 0xa2, 0x27,
	0xd4, 0xab, 0xa2, 0xf2, 0xd5, 0x25, 0x56, 0xc3, 0x2a, 0xdf, 0xfa, 0xa6, 0xd6, 0xa4, 0x3d, 0x54,
	0xbd, 0xd2, 0xa1, 0x50, 0xd5, 0xad, 0xd6, 0x02, 0x7b, 0x6f, 0x1f, 0xbd, 0xdb, 0x25, 0x76, 0x59,
	0x3a, 0x37, 0xe6, 0xa8, 0x1c, 0x3a, 0x23, 0xd4, 0x64, 0xc1, 0x9d, 0x6b, 0x93, 0x6d, 0x78, 0x1e,
	0x23, 0x16, 0x7a, 0x23, 0x7a, 0xda, 0x39, 0x11, 0x2c, 0xd2, 0x18, 0xad, 0x1c, 0x73, 0xd2, 0x3a,
	0xc8, 0x19, 0x22, 0x0c, 0xd5, 0x20, 0x23, 0x53, 0x9a, 0x2a, 0xd8, 0xc2, 0x3e, 0x8d, 0x5e, 0x2b,
	0xd5, 0x52, 0x84, 0x48, 0x91, 0x8b, 0xee, 0x9b, 0x4b, 0x1c, 0x8c, 0x74, 0x45, 0xf7, 0x33, 0x19,
	0x95, 0xd6, 0xc4, 0xd2, 0x3a, 0xc7, 0xb3, 0xcb, 0xb8, 0x3e, 0xdb, 0xa7, 0x2b, 0x70, 0xac, 0xf2,
	0x76, 0x13, 0x5d, 0xb8, 0x81, 0x77, 0xe7, 0x52, 0x5c, 0x0d, 0xc3, 0x39, 0xd0, 0xf8, 0xf7, 0xbf,
	0x46, 0xca, 0x2b, 0x99, 0xbe, 0xb1, 0xd2, 0xa9, 0x57, 0x32, 0x7d, 0xe3, 0xa5, 0xd3, 0x1a, 0x0c,
	0x58, 0xe2, 0xe5, 0xc3, 0x4a, 0xeb, 0xf7, 0x7c, 0xbb, 0x61, 0x98, 0xbb, 0x3a, 0xbf, 0x64, 0x97,
	0x9f, 0x07, 0xfd, 0xe9, 0x35, 0x07, 0x3e, 0x05, 0x8a, 0x26, 0x71, 0x43, 0xc3, 0x76, 0xe9, 0xd6,
	0x11, 0xdd, 0x1e, 0xc4, 0x10, 0x2c, 0xc4, 0xa8, 0x65, 0x2b, 0x28, 0xff, 0x35, 0x03, 0xf2, 0x82,
	0x9b, 0xad, 0x43, 0xff, 0xa7, 0x1b, 0xc7, 0x13, 0x20, 0xe7, 0x92, 0xd0, 0xae, 0xec, 0xd2, 0x31,
	0x43, 0x77, 0xf3, 0xee, 0xd4, 0xae, 0xc2, 0x71, 0xcb, 0x16, 0xbc, 0x10, 0xed, 0x93, 0x99, 0x43,
	0xf7, 0xc9, 0x68, 0x93, 0x1c, 0x89, 0x37, 0xc9, 0x1e, 0x6e, 0x9d, 0xd8, 0x21, 0x5b, 0x17, 0xc1,
	0xec, 0x43, 0x2c, 0x82, 0xcf, 0x82, 0x2c, 0x55, 0x52, 0x0f, 0x50, 0x6f, 0x9b, 0x93, 0xeb, 0x0c,
	0x41, 0xc9, 0xe4, 0xe3, 0x80, 0x93, 0xb7, 0x2e, 0x23, 0x7d, 0x0f, 0xba, 0x8c, 0x88, 0xab, 0x47,
	0xae, 0xf5, 0xea, 0x21, 0x9d, 0x4d, 0xe0, 0xc8, 0x67, 0xd3, 0x55, 0x90, 0xab, 0xc4, 0x17, 0x8b,
	0xfc, 0x83, 0x5e, 0x2c, 0x78, 0x38, 0xfa, 0x2a, 0x62, 0xc2, 0xcd, 0xbe, 0xd8, 0x3a, 0x2d, 0xdf,
	0xdf, 0x43, 0xca, 0x9d, 0x3d, 0x54, 0x90, 0x93, 0xf2, 0xf9, 0x1e, 0x52, 0x6e, 0x37, 0x51, 0xc6,
	0x25, 0x2e, 0xfe, 0xaa, 0x89, 0x94, 0xdb, 0x5f, 0xa3, 0xe8, 0xe2, 0x5a, 0x9e, 0x8a, 0x6b, 0xf2,
	0x3a, 0x0e, 0x7d, 0xdb, 0x0c, 0xe0, 0x18, 0xc8, 0x05, 0xa4, 0x86, 0xc3, 0x1d, 0xdb, 0xad, 0xa2,
	0x1e, 0xba, 0x6f, 0x69, 0x09, 0xa0, 0xfc, 0x96, 0x02, 0x8a, 0x82, 0x61, 0x85, 0x90, 0x1b, 0x75,
	0x2f, 0x2a, 0x38, 0xe5, 0x01, 0x0b, 0xee, 0x39, 0x00, 0x78, 0x3b, 0x48, 0x0f, 0x35, 0x43, 0xa9,
	0x1c, 0x50, 0x64, 0xc2, 0x94, 0xf3, 0x22, 0xc0, 0x6c, 0xf1, 0x93, 0x26, 0xca, 0xc5, 0xf8, 0xf2,
	0x4f, 0x95, 0xd8, 0x76, 0x6e, 0xca, 0xcc, 0x51, 0x6d, 0x79, 0xd4, 0x67, 0xa3, 0xd9, 0x81, 0x4f,
	0x9a, 0xa9, 0x39, 0x52, 0xbe, 0x2f, 0xd9, 0x64, 0x84, 0xd8, 0x35, 0x77, 0x8f, 0x68, 0xd3, 0xec,
	0x47, 0xca, 0x7b, 0xfb, 0xe8, 0x37, 0xca, 0x91, 0xe7, 0x76, 0x3c, 0x8c, 0x29, 0xe6, 0xd0, 0x81,
	0xdc, 0x4a, 0xd0, 0x51, 0x4c, 0x85, 0x8f, 0xe5, 0x56, 0xda, 0x8e, 0xa3, 0x99, 0x66, 0xa2, 0x98,
	0xaa, 0x77, 0xf8, 0x22, 0x18, 0x10, 0xe3, 0xdd, 0x26, 0xae, 0x2e, 0xbd, 0xc4, 0x8c, 0xdc, 0x69,
	0xa2, 0xfe, 0x04, 0x45, 0x31, 0xec, 0x59, 0x4d, 0x82, 0xb1, 0x35, 0xf6, 0x12, 0xc8, 0x1b, 0x9e,
	0xc7, 0xdf, 0xc0, 0x6c, 0x4b, 0xbc, 0xce, 0x0c, 0x4a, 0x0f, 0x51, 0xb6, 0xc5, 0xf8, 0xe8, 0x27,
	0x9b, 0x89, 0x56, 0xcb, 0xeb, 0xcc, 0xbb, 0x0a, 0x00, 0x89, 0x4d, 0xf0, 0xa2, 0x9c, 0x85, 0x83,
	0xfb, 0x54, 0x2a, 0x8e, 0x39, 0x50, 0x88, 0x2d, 0x78, 0xc0, 0x89, 0x0a, 0x8c, 0x18, 0x32, 0x8b,
	0xe4, 0xce, 0x94, 0xbb, 0xaf, 0xfc, 0x6f, 0x05, 0x0c, 0x24, 0x5a, 0x17, 0x1b, 0xd8, 0x7d, 0x18,
	0xf3, 0xe2, 0x81, 0xdc, 0xf5, 0x40, 0x03, 0x19, 0x81, 0xde, 0x1a, 0x0e, 0x02, 0xa3, 0x8a, 0xf9,
	0xdb, 0xa6, 0x16, 0x7d, 0xc2, 0x39, 0xd0, 0xc3, 0x87, 0x50, 0xe6, 0x68, 0x43, 0x88, 0x73, 0xc1,
	0xc7, 0xe4, 0x35, 0xbf, 0x87, 0x89, 0x8e, 0x17, 0xfc, 0xd9, 0xcc, 0x1f, 0xf7, 0x90, 0x72, 0xfe,
	0x27, 0x5d, 0x00, 0x24, 0xa3, 0x15, 0x9e, 0x02, 0xc7, 0x5f, 0x5d, 0x7b, 0x6d, 0x51, 0xd3, 0xd7,
	0x37, 0xe6, 0x37, 0x16, 0xf5, 0xcd, 0xd5, 0x6b, 0xab, 0x6b, 0xaf, 0xad, 0x96, 0x8e, 0x8d, 0x66,
	0xde, 0x6e, 0x22, 0x05, 0x8e, 0x01, 0xc8, 0xd1, 0x6b, 0xab, 0xba, 0xb6, 0xf8, 0x9d, 0xcd, 0xc5,
	0xf5, 0x8d, 0xc5, 0xab, 0x25, 0x45, 0x60, 0x87, 0x41, 0x9e, 0x61, 0x97, 0x57, 0x5f, 0xd2, 0xd7,
	0x56, 0x4b, 0x5d, 0x02, 0x5c, 0x00, 0x7d, 0x11, 0x53, 0xa9, 0x3b, 0xd1, 0xb0, 0xb6, 0xb4, 0x24,
	0xc9, 0xc8, 0x08, 0xe2, 0x11, 0x50, 0x48, 0x64, 0x2c, 0x2d, 0x95, 0x7a, 0x04, 0xbc, 0x08, 0x72,
	0x31, 0x5b, 0x29, 0x0b, 0x47, 0x41, 0x49, 0x5b, 0x5c, 0x58, 0x5b, 0xdb, 0x90, 0x44, 0xf4, 0x0a,
	0xd2, 0xe3, 0x20, 0xc7, 0x71, 0xcb, 0xab, 0x2f, 0x95, 0xfa, 0x04, 0x10, 0x80, 0x2c, 0x07, 0x96,
	0x72, 0xf0, 0x31, 0x30, 0x28, 0x3b, 0xb9, 0xa8, 0x69, 0x6b, 0x5a, 0x09, 0x70, 0xc2, 0x99, 0xbf,
	0xf7, 0xc5, 0x6f, 0x95, 0xf3, 0x9e, 0x0d, 0x7f, 0xaf, 0x80, 0x22, 0xdf, 0x50, 0xa3, 0x6a, 0x85,
	0xed, 0x55, 0x36, 0x2a, 0x3f, 0x05, 0x6a, 0xec, 0x5f, 0x82, 0xf2, 0x0f, 0xef, 0xed, 0x21, 0xfa,
	0x9b, 0xd4, 0x7d, 0x33, 0xe2, 0x0d, 0xd4, 0x79, 0x93, 0x76, 0xd1, 0x75, 0xc3, 0x35, 0xaa, 0x58,
	0x6d, 0x6d, 0xf0, 0x0f, 0xf6, 0x91, 0x72, 0x77, 0x1f, 0x29, 0x9f, 0xed, 0xa3, 0x73, 0x9b, 0xa9,
	0xc7, 0x02, 0x75, 0x29, 0x79, 0x6c, 0x50, 0x93, 0x74, 0xbd, 0xf9, 0x97, 0x7f, 0xfe, 0xac, 0x6b,
	0xa8, 0x3c, 0x30, 0xcd, 0x9f, 0x4b, 0xa6, 0x45, 0xfb, 0xcd, 0x2a, 0xe7, 0x2f, 0x2a, 0xf0, 0x97,
	0x0a, 0x28, 0x5e, 0xc5, 0x0e, 0x3e, 0xb2, 0xe5, 0xdb, 0x8f, 0x64, 0x39, 0xe8, 0x60, 0x9e, 0xc5,
	0xcc, 0x48, 0x9b, 0xf7, 0x5f, 0x05, 0xf4, 0x6b, 0xb8, 0xe2, 0xe3, 0x60, 0xe7, 0x88, 0xf6, 0xfd,
	0x41, 0x79, 0x38, 0x03, 0x3f, 0xdb, 0x47, 0xeb, 0xe2, 0x12, 0xd1, 0x69, 0xf1, 0xe7, 0x4f, 0x2e,
	0x81, 0x14, 0x5e, 0x55, 0x7a, 0x40, 0x69, 0xbf, 0x3c, 0x44, 0x37, 0x92, 0x7b, 0xfb, 0x08, 0xf2,
	0x51, 0x2c, 0xbf, 0xe2, 0x33, 0xdf, 0x87, 0xcb, 0xa5, 0x69, 0x9f, 0xfb, 0x98, 0x76, 0xfe, 0xad,
	0x2e, 0x50, 0xe4, 0xd9, 0x3c, 0xa2, 0xef, 0x7f, 0x7e, 0x78, 0xdf, 0x77, 0x0f, 0xf1, 0xfd, 0x90,
	0x6a, 0x7b, 0xa0, 0x18, 0x88, 0x9b, 0x90, 0x9a, 0x2c, 0xf9, 0xaa, 0x74, 0x32, 0xc5, 0x75, 0xc0,
	0xdf, 0x4e, 0xd2, 0xa1, 0xf8, 0xb1, 0x02, 0xf2, 0xeb, 0x3b, 0xe4, 0xe6, 0x61, 0x81, 0xe8, 0x00,
	0x2b, 0xaf, 0xdc, 0xdb, 0x43, 0xea, 0x01, 0x81, 0xd8, 0xb2, 0xf1, 0xcd, 0xb6, 0x30, 0xd0, 0xfa,
	0x64, 0x96, 0xc0, 0x72, 0x71, 0x3a, 0xd8, 0x21, 0x37, 0xd3, 0x76, 0xec, 0x80, 0xe1, 0x97, 0x0d,
	0xd7, 0x72, 0x70, 0xeb, 0xf8, 0x1f, 0xed, 0x38, 0xf1, 0x19, 0xae, 0x53, 0x86, 0x26, 0x98, 0x8e,
	0xd1, 0xf2, 0xf0, 0x34, 0x3d, 0x35, 0x29, 0x55, 0xa4, 0x87, 0x2e, 0xd5, 0xb3, 0xca, 0xf9, 0x99,
	0x20, 0x5e, 0x43, 0xe8, 0x2e, 0x4c, 0x87, 0x8c, 0x01, 0x06, 0xa4, 0x10, 0xf0, 0x2b, 0x44, 0xbb,
	0xcb, 0x14, 0x3e, 0x7a, 0x00, 0xbc, 0x3c, 0xc6, 0xd4, 0x8e, 0x94, 0x07, 0x53, 0xae, 0x09, 0x95,
	0x17, 0x95, 0x99, 0x37, 0x15, 0x30, 0x98, 0x5e, 0x26, 0xa9, 0xe2, 0x1a, 0x80, 0x92, 0xe2, 0x68,
	0xcb, 0xec, 0xb0, 0xf2, 0x0b, 0xd4, 0xe8, 0xc1, 0xa8, 0xf2, 0x69, 0x66, 0xc1, 0xc9, 0xf2, 0x50,
	0xca, 0x82, 0x1a, 0xc7, 0x72, 0x23, 0x3e, 0x4a, 0x8c, 0x10, 0x1b, 0x18, 0x35, 0xe2, 0x17, 0x0a,
	0x18, 0xd6, 0xf0, 0x1b, 0x75, 0x4c, 0x27, 0x6e, 0x6a, 0x3d, 0xeb, 0xa0, 0x4d, 0xa0, 0x3a, 0x45,
	0x7e, 0xe3, 0xe8, 0xad, 0xc1, 0x4c, 0x1e, 0x2b, 0x9f, 0x98, 0xf6, 0xb9, 0xfe, 0xc8, 0x6a, 0x87,
	0x6b, 0x99, 0x55, 0xce, 0x2f, 0x8c, 0x7d, 0xfc, 0x8f, 0xf1, 0x63, 0x1f, 0x7f, 0x31, 0xae, 0xdc,
	0xfd, 0x62, 0x5c, 0xf9, 0xfc, 0x8b, 0x71, 0xe5, 0xed, 0x2f, 0xc7, 0x8f, 0xdd, 0xfd, 0x72, 0xfc,
	0xd8, 0xa7, 0x5f, 0x8e, 0x1f, 0xdb, 0xce, 0x32, 0x0b, 0x9e, 0xfe, 0x5f, 0x00, 0x00, 0x00, 0xff,
	0xff, 0x8e, 0x92, 0x20, 0xea, 0x54, 0x1e, 0x00, 0x00,
}

func (this *VirtualClusterInstKeyV1) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&edgeproto.VirtualClusterInstKeyV1{")
	s = append(s, "ClusterKey: "+strings.Replace(this.ClusterKey.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "CloudletKey: "+strings.Replace(this.CloudletKey.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "Organization: "+fmt.Sprintf("%#v", this.Organization)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AppInstKeyV1) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&edgeproto.AppInstKeyV1{")
	s = append(s, "AppKey: "+strings.Replace(this.AppKey.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "ClusterInstKey: "+strings.Replace(this.ClusterInstKey.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AppInstKeyV2) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&edgeproto.AppInstKeyV2{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Organization: "+fmt.Sprintf("%#v", this.Organization)+",\n")
	s = append(s, "CloudletKey: "+strings.Replace(this.CloudletKey.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AppInstKey) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&edgeproto.AppInstKey{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Organization: "+fmt.Sprintf("%#v", this.Organization)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FedAppInstKey) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&edgeproto.FedAppInstKey{")
	s = append(s, "FederationName: "+fmt.Sprintf("%#v", this.FederationName)+",\n")
	s = append(s, "AppInstId: "+fmt.Sprintf("%#v", this.AppInstId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringAppinst(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// AppInstApiClient is the client API for AppInstApi service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AppInstApiClient interface {
	// Create Application Instance. Creates an instance of an App on a Cloudlet where it is
	// defined by an App plus a ClusterInst key. Many of the fields here are inherited from
	// the App definition.
	CreateAppInst(ctx context.Context, in *AppInst, opts ...grpc.CallOption) (AppInstApi_CreateAppInstClient, error)
	// Delete Application Instance. Deletes an instance of the App from the Cloudlet.
	DeleteAppInst(ctx context.Context, in *AppInst, opts ...grpc.CallOption) (AppInstApi_DeleteAppInstClient, error)
	// Refresh Application Instance. Restarts an App instance with new App settings or image.
	RefreshAppInst(ctx context.Context, in *AppInst, opts ...grpc.CallOption) (AppInstApi_RefreshAppInstClient, error)
	// Update Application Instance. Updates an Application instance and then refreshes it.
	UpdateAppInst(ctx context.Context, in *AppInst, opts ...grpc.CallOption) (AppInstApi_UpdateAppInstClient, error)
	// Show Application Instances. Lists all the Application instances managed by the Edge Controller.
	// Any fields specified will be used to filter results.
	ShowAppInst(ctx context.Context, in *AppInst, opts ...grpc.CallOption) (AppInstApi_ShowAppInstClient, error)
	HandleFedAppInstEvent(ctx context.Context, in *FedAppInstEvent, opts ...grpc.CallOption) (*Result, error)
}

type appInstApiClient struct {
	cc *grpc.ClientConn
}

func NewAppInstApiClient(cc *grpc.ClientConn) AppInstApiClient {
	return &appInstApiClient{cc}
}

func (c *appInstApiClient) CreateAppInst(ctx context.Context, in *AppInst, opts ...grpc.CallOption) (AppInstApi_CreateAppInstClient, error) {
	stream, err := c.cc.NewStream(ctx, &_AppInstApi_serviceDesc.Streams[0], "/edgeproto.AppInstApi/CreateAppInst", opts...)
	if err != nil {
		return nil, err
	}
	x := &appInstApiCreateAppInstClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AppInstApi_CreateAppInstClient interface {
	Recv() (*Result, error)
	grpc.ClientStream
}

type appInstApiCreateAppInstClient struct {
	grpc.ClientStream
}

func (x *appInstApiCreateAppInstClient) Recv() (*Result, error) {
	m := new(Result)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *appInstApiClient) DeleteAppInst(ctx context.Context, in *AppInst, opts ...grpc.CallOption) (AppInstApi_DeleteAppInstClient, error) {
	stream, err := c.cc.NewStream(ctx, &_AppInstApi_serviceDesc.Streams[1], "/edgeproto.AppInstApi/DeleteAppInst", opts...)
	if err != nil {
		return nil, err
	}
	x := &appInstApiDeleteAppInstClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AppInstApi_DeleteAppInstClient interface {
	Recv() (*Result, error)
	grpc.ClientStream
}

type appInstApiDeleteAppInstClient struct {
	grpc.ClientStream
}

func (x *appInstApiDeleteAppInstClient) Recv() (*Result, error) {
	m := new(Result)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *appInstApiClient) RefreshAppInst(ctx context.Context, in *AppInst, opts ...grpc.CallOption) (AppInstApi_RefreshAppInstClient, error) {
	stream, err := c.cc.NewStream(ctx, &_AppInstApi_serviceDesc.Streams[2], "/edgeproto.AppInstApi/RefreshAppInst", opts...)
	if err != nil {
		return nil, err
	}
	x := &appInstApiRefreshAppInstClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AppInstApi_RefreshAppInstClient interface {
	Recv() (*Result, error)
	grpc.ClientStream
}

type appInstApiRefreshAppInstClient struct {
	grpc.ClientStream
}

func (x *appInstApiRefreshAppInstClient) Recv() (*Result, error) {
	m := new(Result)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *appInstApiClient) UpdateAppInst(ctx context.Context, in *AppInst, opts ...grpc.CallOption) (AppInstApi_UpdateAppInstClient, error) {
	stream, err := c.cc.NewStream(ctx, &_AppInstApi_serviceDesc.Streams[3], "/edgeproto.AppInstApi/UpdateAppInst", opts...)
	if err != nil {
		return nil, err
	}
	x := &appInstApiUpdateAppInstClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AppInstApi_UpdateAppInstClient interface {
	Recv() (*Result, error)
	grpc.ClientStream
}

type appInstApiUpdateAppInstClient struct {
	grpc.ClientStream
}

func (x *appInstApiUpdateAppInstClient) Recv() (*Result, error) {
	m := new(Result)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *appInstApiClient) ShowAppInst(ctx context.Context, in *AppInst, opts ...grpc.CallOption) (AppInstApi_ShowAppInstClient, error) {
	stream, err := c.cc.NewStream(ctx, &_AppInstApi_serviceDesc.Streams[4], "/edgeproto.AppInstApi/ShowAppInst", opts...)
	if err != nil {
		return nil, err
	}
	x := &appInstApiShowAppInstClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AppInstApi_ShowAppInstClient interface {
	Recv() (*AppInst, error)
	grpc.ClientStream
}

type appInstApiShowAppInstClient struct {
	grpc.ClientStream
}

func (x *appInstApiShowAppInstClient) Recv() (*AppInst, error) {
	m := new(AppInst)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *appInstApiClient) HandleFedAppInstEvent(ctx context.Context, in *FedAppInstEvent, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/edgeproto.AppInstApi/HandleFedAppInstEvent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AppInstApiServer is the server API for AppInstApi service.
type AppInstApiServer interface {
	// Create Application Instance. Creates an instance of an App on a Cloudlet where it is
	// defined by an App plus a ClusterInst key. Many of the fields here are inherited from
	// the App definition.
	CreateAppInst(*AppInst, AppInstApi_CreateAppInstServer) error
	// Delete Application Instance. Deletes an instance of the App from the Cloudlet.
	DeleteAppInst(*AppInst, AppInstApi_DeleteAppInstServer) error
	// Refresh Application Instance. Restarts an App instance with new App settings or image.
	RefreshAppInst(*AppInst, AppInstApi_RefreshAppInstServer) error
	// Update Application Instance. Updates an Application instance and then refreshes it.
	UpdateAppInst(*AppInst, AppInstApi_UpdateAppInstServer) error
	// Show Application Instances. Lists all the Application instances managed by the Edge Controller.
	// Any fields specified will be used to filter results.
	ShowAppInst(*AppInst, AppInstApi_ShowAppInstServer) error
	HandleFedAppInstEvent(context.Context, *FedAppInstEvent) (*Result, error)
}

// UnimplementedAppInstApiServer can be embedded to have forward compatible implementations.
type UnimplementedAppInstApiServer struct {
}

func (*UnimplementedAppInstApiServer) CreateAppInst(req *AppInst, srv AppInstApi_CreateAppInstServer) error {
	return status.Errorf(codes.Unimplemented, "method CreateAppInst not implemented")
}
func (*UnimplementedAppInstApiServer) DeleteAppInst(req *AppInst, srv AppInstApi_DeleteAppInstServer) error {
	return status.Errorf(codes.Unimplemented, "method DeleteAppInst not implemented")
}
func (*UnimplementedAppInstApiServer) RefreshAppInst(req *AppInst, srv AppInstApi_RefreshAppInstServer) error {
	return status.Errorf(codes.Unimplemented, "method RefreshAppInst not implemented")
}
func (*UnimplementedAppInstApiServer) UpdateAppInst(req *AppInst, srv AppInstApi_UpdateAppInstServer) error {
	return status.Errorf(codes.Unimplemented, "method UpdateAppInst not implemented")
}
func (*UnimplementedAppInstApiServer) ShowAppInst(req *AppInst, srv AppInstApi_ShowAppInstServer) error {
	return status.Errorf(codes.Unimplemented, "method ShowAppInst not implemented")
}
func (*UnimplementedAppInstApiServer) HandleFedAppInstEvent(ctx context.Context, req *FedAppInstEvent) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HandleFedAppInstEvent not implemented")
}

func RegisterAppInstApiServer(s *grpc.Server, srv AppInstApiServer) {
	s.RegisterService(&_AppInstApi_serviceDesc, srv)
}

func _AppInstApi_CreateAppInst_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AppInst)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AppInstApiServer).CreateAppInst(m, &appInstApiCreateAppInstServer{stream})
}

type AppInstApi_CreateAppInstServer interface {
	Send(*Result) error
	grpc.ServerStream
}

type appInstApiCreateAppInstServer struct {
	grpc.ServerStream
}

func (x *appInstApiCreateAppInstServer) Send(m *Result) error {
	return x.ServerStream.SendMsg(m)
}

func _AppInstApi_DeleteAppInst_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AppInst)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AppInstApiServer).DeleteAppInst(m, &appInstApiDeleteAppInstServer{stream})
}

type AppInstApi_DeleteAppInstServer interface {
	Send(*Result) error
	grpc.ServerStream
}

type appInstApiDeleteAppInstServer struct {
	grpc.ServerStream
}

func (x *appInstApiDeleteAppInstServer) Send(m *Result) error {
	return x.ServerStream.SendMsg(m)
}

func _AppInstApi_RefreshAppInst_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AppInst)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AppInstApiServer).RefreshAppInst(m, &appInstApiRefreshAppInstServer{stream})
}

type AppInstApi_RefreshAppInstServer interface {
	Send(*Result) error
	grpc.ServerStream
}

type appInstApiRefreshAppInstServer struct {
	grpc.ServerStream
}

func (x *appInstApiRefreshAppInstServer) Send(m *Result) error {
	return x.ServerStream.SendMsg(m)
}

func _AppInstApi_UpdateAppInst_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AppInst)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AppInstApiServer).UpdateAppInst(m, &appInstApiUpdateAppInstServer{stream})
}

type AppInstApi_UpdateAppInstServer interface {
	Send(*Result) error
	grpc.ServerStream
}

type appInstApiUpdateAppInstServer struct {
	grpc.ServerStream
}

func (x *appInstApiUpdateAppInstServer) Send(m *Result) error {
	return x.ServerStream.SendMsg(m)
}

func _AppInstApi_ShowAppInst_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AppInst)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AppInstApiServer).ShowAppInst(m, &appInstApiShowAppInstServer{stream})
}

type AppInstApi_ShowAppInstServer interface {
	Send(*AppInst) error
	grpc.ServerStream
}

type appInstApiShowAppInstServer struct {
	grpc.ServerStream
}

func (x *appInstApiShowAppInstServer) Send(m *AppInst) error {
	return x.ServerStream.SendMsg(m)
}

func _AppInstApi_HandleFedAppInstEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FedAppInstEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppInstApiServer).HandleFedAppInstEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.AppInstApi/HandleFedAppInstEvent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppInstApiServer).HandleFedAppInstEvent(ctx, req.(*FedAppInstEvent))
	}
	return interceptor(ctx, in, info, handler)
}

var _AppInstApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "edgeproto.AppInstApi",
	HandlerType: (*AppInstApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "HandleFedAppInstEvent",
			Handler:    _AppInstApi_HandleFedAppInstEvent_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "CreateAppInst",
			Handler:       _AppInstApi_CreateAppInst_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "DeleteAppInst",
			Handler:       _AppInstApi_DeleteAppInst_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "RefreshAppInst",
			Handler:       _AppInstApi_RefreshAppInst_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "UpdateAppInst",
			Handler:       _AppInstApi_UpdateAppInst_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ShowAppInst",
			Handler:       _AppInstApi_ShowAppInst_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "appinst.proto",
}

// AppInstInfoApiClient is the client API for AppInstInfoApi service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AppInstInfoApiClient interface {
	// Show application instances state.
	ShowAppInstInfo(ctx context.Context, in *AppInstInfo, opts ...grpc.CallOption) (AppInstInfoApi_ShowAppInstInfoClient, error)
}

type appInstInfoApiClient struct {
	cc *grpc.ClientConn
}

func NewAppInstInfoApiClient(cc *grpc.ClientConn) AppInstInfoApiClient {
	return &appInstInfoApiClient{cc}
}

func (c *appInstInfoApiClient) ShowAppInstInfo(ctx context.Context, in *AppInstInfo, opts ...grpc.CallOption) (AppInstInfoApi_ShowAppInstInfoClient, error) {
	stream, err := c.cc.NewStream(ctx, &_AppInstInfoApi_serviceDesc.Streams[0], "/edgeproto.AppInstInfoApi/ShowAppInstInfo", opts...)
	if err != nil {
		return nil, err
	}
	x := &appInstInfoApiShowAppInstInfoClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AppInstInfoApi_ShowAppInstInfoClient interface {
	Recv() (*AppInstInfo, error)
	grpc.ClientStream
}

type appInstInfoApiShowAppInstInfoClient struct {
	grpc.ClientStream
}

func (x *appInstInfoApiShowAppInstInfoClient) Recv() (*AppInstInfo, error) {
	m := new(AppInstInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// AppInstInfoApiServer is the server API for AppInstInfoApi service.
type AppInstInfoApiServer interface {
	// Show application instances state.
	ShowAppInstInfo(*AppInstInfo, AppInstInfoApi_ShowAppInstInfoServer) error
}

// UnimplementedAppInstInfoApiServer can be embedded to have forward compatible implementations.
type UnimplementedAppInstInfoApiServer struct {
}

func (*UnimplementedAppInstInfoApiServer) ShowAppInstInfo(req *AppInstInfo, srv AppInstInfoApi_ShowAppInstInfoServer) error {
	return status.Errorf(codes.Unimplemented, "method ShowAppInstInfo not implemented")
}

func RegisterAppInstInfoApiServer(s *grpc.Server, srv AppInstInfoApiServer) {
	s.RegisterService(&_AppInstInfoApi_serviceDesc, srv)
}

func _AppInstInfoApi_ShowAppInstInfo_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AppInstInfo)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AppInstInfoApiServer).ShowAppInstInfo(m, &appInstInfoApiShowAppInstInfoServer{stream})
}

type AppInstInfoApi_ShowAppInstInfoServer interface {
	Send(*AppInstInfo) error
	grpc.ServerStream
}

type appInstInfoApiShowAppInstInfoServer struct {
	grpc.ServerStream
}

func (x *appInstInfoApiShowAppInstInfoServer) Send(m *AppInstInfo) error {
	return x.ServerStream.SendMsg(m)
}

var _AppInstInfoApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "edgeproto.AppInstInfoApi",
	HandlerType: (*AppInstInfoApiServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ShowAppInstInfo",
			Handler:       _AppInstInfoApi_ShowAppInstInfo_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "appinst.proto",
}

// AppInstMetricsApiClient is the client API for AppInstMetricsApi service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AppInstMetricsApiClient interface {
	// Show application instance metrics.
	ShowAppInstMetrics(ctx context.Context, in *AppInstMetrics, opts ...grpc.CallOption) (AppInstMetricsApi_ShowAppInstMetricsClient, error)
}

type appInstMetricsApiClient struct {
	cc *grpc.ClientConn
}

func NewAppInstMetricsApiClient(cc *grpc.ClientConn) AppInstMetricsApiClient {
	return &appInstMetricsApiClient{cc}
}

func (c *appInstMetricsApiClient) ShowAppInstMetrics(ctx context.Context, in *AppInstMetrics, opts ...grpc.CallOption) (AppInstMetricsApi_ShowAppInstMetricsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_AppInstMetricsApi_serviceDesc.Streams[0], "/edgeproto.AppInstMetricsApi/ShowAppInstMetrics", opts...)
	if err != nil {
		return nil, err
	}
	x := &appInstMetricsApiShowAppInstMetricsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AppInstMetricsApi_ShowAppInstMetricsClient interface {
	Recv() (*AppInstMetrics, error)
	grpc.ClientStream
}

type appInstMetricsApiShowAppInstMetricsClient struct {
	grpc.ClientStream
}

func (x *appInstMetricsApiShowAppInstMetricsClient) Recv() (*AppInstMetrics, error) {
	m := new(AppInstMetrics)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// AppInstMetricsApiServer is the server API for AppInstMetricsApi service.
type AppInstMetricsApiServer interface {
	// Show application instance metrics.
	ShowAppInstMetrics(*AppInstMetrics, AppInstMetricsApi_ShowAppInstMetricsServer) error
}

// UnimplementedAppInstMetricsApiServer can be embedded to have forward compatible implementations.
type UnimplementedAppInstMetricsApiServer struct {
}

func (*UnimplementedAppInstMetricsApiServer) ShowAppInstMetrics(req *AppInstMetrics, srv AppInstMetricsApi_ShowAppInstMetricsServer) error {
	return status.Errorf(codes.Unimplemented, "method ShowAppInstMetrics not implemented")
}

func RegisterAppInstMetricsApiServer(s *grpc.Server, srv AppInstMetricsApiServer) {
	s.RegisterService(&_AppInstMetricsApi_serviceDesc, srv)
}

func _AppInstMetricsApi_ShowAppInstMetrics_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AppInstMetrics)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AppInstMetricsApiServer).ShowAppInstMetrics(m, &appInstMetricsApiShowAppInstMetricsServer{stream})
}

type AppInstMetricsApi_ShowAppInstMetricsServer interface {
	Send(*AppInstMetrics) error
	grpc.ServerStream
}

type appInstMetricsApiShowAppInstMetricsServer struct {
	grpc.ServerStream
}

func (x *appInstMetricsApiShowAppInstMetricsServer) Send(m *AppInstMetrics) error {
	return x.ServerStream.SendMsg(m)
}

var _AppInstMetricsApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "edgeproto.AppInstMetricsApi",
	HandlerType: (*AppInstMetricsApiServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ShowAppInstMetrics",
			Handler:       _AppInstMetricsApi_ShowAppInstMetrics_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "appinst.proto",
}

// AppInstLatencyApiClient is the client API for AppInstLatencyApi service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AppInstLatencyApiClient interface {
	// Request Latency measurements for clients connected to AppInst
	RequestAppInstLatency(ctx context.Context, in *AppInstLatency, opts ...grpc.CallOption) (*Result, error)
}

type appInstLatencyApiClient struct {
	cc *grpc.ClientConn
}

func NewAppInstLatencyApiClient(cc *grpc.ClientConn) AppInstLatencyApiClient {
	return &appInstLatencyApiClient{cc}
}

func (c *appInstLatencyApiClient) RequestAppInstLatency(ctx context.Context, in *AppInstLatency, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/edgeproto.AppInstLatencyApi/RequestAppInstLatency", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AppInstLatencyApiServer is the server API for AppInstLatencyApi service.
type AppInstLatencyApiServer interface {
	// Request Latency measurements for clients connected to AppInst
	RequestAppInstLatency(context.Context, *AppInstLatency) (*Result, error)
}

// UnimplementedAppInstLatencyApiServer can be embedded to have forward compatible implementations.
type UnimplementedAppInstLatencyApiServer struct {
}

func (*UnimplementedAppInstLatencyApiServer) RequestAppInstLatency(ctx context.Context, req *AppInstLatency) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequestAppInstLatency not implemented")
}

func RegisterAppInstLatencyApiServer(s *grpc.Server, srv AppInstLatencyApiServer) {
	s.RegisterService(&_AppInstLatencyApi_serviceDesc, srv)
}

func _AppInstLatencyApi_RequestAppInstLatency_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppInstLatency)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppInstLatencyApiServer).RequestAppInstLatency(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.AppInstLatencyApi/RequestAppInstLatency",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppInstLatencyApiServer).RequestAppInstLatency(ctx, req.(*AppInstLatency))
	}
	return interceptor(ctx, in, info, handler)
}

var _AppInstLatencyApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "edgeproto.AppInstLatencyApi",
	HandlerType: (*AppInstLatencyApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RequestAppInstLatency",
			Handler:    _AppInstLatencyApi_RequestAppInstLatency_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "appinst.proto",
}

func (m *VirtualClusterInstKeyV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VirtualClusterInstKeyV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VirtualClusterInstKeyV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Organization) > 0 {
		i -= len(m.Organization)
		copy(dAtA[i:], m.Organization)
		i = encodeVarintAppinst(dAtA, i, uint64(len(m.Organization)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.CloudletKey.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppinst(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ClusterKey.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppinst(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AppInstKeyV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppInstKeyV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppInstKeyV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ClusterInstKey.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppinst(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.AppKey.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppinst(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AppInstKeyV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppInstKeyV2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppInstKeyV2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.CloudletKey.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppinst(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Organization) > 0 {
		i -= len(m.Organization)
		copy(dAtA[i:], m.Organization)
		i = encodeVarintAppinst(dAtA, i, uint64(len(m.Organization)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintAppinst(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AppInstKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppInstKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppInstKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Organization) > 0 {
		i -= len(m.Organization)
		copy(dAtA[i:], m.Organization)
		i = encodeVarintAppinst(dAtA, i, uint64(len(m.Organization)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintAppinst(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AppInst) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppInst) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppInst) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Annotations) > 0 {
		for k := range m.Annotations {
			v := m.Annotations[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAppinst(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAppinst(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAppinst(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xa2
		}
	}
	{
		size, err := m.CloudletKey.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppinst(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3
	i--
	dAtA[i] = 0x9a
	if len(m.StaticUri) > 0 {
		i -= len(m.StaticUri)
		copy(dAtA[i:], m.StaticUri)
		i = encodeVarintAppinst(dAtA, i, uint64(len(m.StaticUri)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x92
	}
	if len(m.ObjId) > 0 {
		i -= len(m.ObjId)
		copy(dAtA[i:], m.ObjId)
		i = encodeVarintAppinst(dAtA, i, uint64(len(m.ObjId)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x8a
	}
	if m.EnableIpv6 {
		i--
		if m.EnableIpv6 {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x80
	}
	{
		size, err := m.VirtualClusterKey.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppinst(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0xfa
	if m.CompatibilityVersion != 0 {
		i = encodeVarintAppinst(dAtA, i, uint64(m.CompatibilityVersion))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf0
	}
	{
		size, err := m.ClusterKey.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppinst(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0xea
	{
		size, err := m.AppKey.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppinst(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0xe2
	{
		size, err := m.FedKey.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppinst(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0xda
	if len(m.CloudletFlavor) > 0 {
		i -= len(m.CloudletFlavor)
		copy(dAtA[i:], m.CloudletFlavor)
		i = encodeVarintAppinst(dAtA, i, uint64(len(m.CloudletFlavor)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd2
	}
	if len(m.DnsLabel) > 0 {
		i -= len(m.DnsLabel)
		copy(dAtA[i:], m.DnsLabel)
		i = encodeVarintAppinst(dAtA, i, uint64(len(m.DnsLabel)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xca
	}
	if len(m.UniqueId) > 0 {
		i -= len(m.UniqueId)
		copy(dAtA[i:], m.UniqueId)
		i = encodeVarintAppinst(dAtA, i, uint64(len(m.UniqueId)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc2
	}
	if m.DedicatedIp {
		i--
		if m.DedicatedIp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb8
	}
	if len(m.InternalPortToLbIp) > 0 {
		for k := range m.InternalPortToLbIp {
			v := m.InternalPortToLbIp[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAppinst(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAppinst(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAppinst(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xb2
		}
	}
	if len(m.RealClusterName) > 0 {
		i -= len(m.RealClusterName)
		copy(dAtA[i:], m.RealClusterName)
		i = encodeVarintAppinst(dAtA, i, uint64(len(m.RealClusterName)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xaa
	}
	{
		size, err := m.UpdatedAt.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppinst(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0xa2
	if len(m.OptRes) > 0 {
		i -= len(m.OptRes)
		copy(dAtA[i:], m.OptRes)
		i = encodeVarintAppinst(dAtA, i, uint64(len(m.OptRes)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x9a
	}
	if len(m.VmFlavor) > 0 {
		i -= len(m.VmFlavor)
		copy(dAtA[i:], m.VmFlavor)
		i = encodeVarintAppinst(dAtA, i, uint64(len(m.VmFlavor)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x92
	}
	if len(m.AvailabilityZone) > 0 {
		i -= len(m.AvailabilityZone)
		copy(dAtA[i:], m.AvailabilityZone)
		i = encodeVarintAppinst(dAtA, i, uint64(len(m.AvailabilityZone)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x8a
	}
	if m.ExternalVolumeSize != 0 {
		i = encodeVarintAppinst(dAtA, i, uint64(m.ExternalVolumeSize))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x80
	}
	if m.PowerState != 0 {
		i = encodeVarintAppinst(dAtA, i, uint64(m.PowerState))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if m.HealthCheck != 0 {
		i = encodeVarintAppinst(dAtA, i, uint64(m.HealthCheck))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe8
	}
	if len(m.Configs) > 0 {
		for iNdEx := len(m.Configs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Configs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAppinst(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xda
		}
	}
	if m.UpdateMultiple {
		i--
		if m.UpdateMultiple {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if m.ForceUpdate {
		i--
		if m.ForceUpdate {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if len(m.Revision) > 0 {
		i -= len(m.Revision)
		copy(dAtA[i:], m.Revision)
		i = encodeVarintAppinst(dAtA, i, uint64(len(m.Revision)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.AutoClusterIpAccess != 0 {
		i = encodeVarintAppinst(dAtA, i, uint64(m.AutoClusterIpAccess))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	{
		size, err := m.CreatedAt.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppinst(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xaa
	{
		size, err := m.RuntimeInfo.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppinst(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x8a
	if m.CrmOverride != 0 {
		i = encodeVarintAppinst(dAtA, i, uint64(m.CrmOverride))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if len(m.Errors) > 0 {
		for iNdEx := len(m.Errors) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Errors[iNdEx])
			copy(dAtA[i:], m.Errors[iNdEx])
			i = encodeVarintAppinst(dAtA, i, uint64(len(m.Errors[iNdEx])))
			i--
			dAtA[i] = 0x7a
		}
	}
	if m.State != 0 {
		i = encodeVarintAppinst(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x70
	}
	{
		size, err := m.Flavor.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppinst(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x62
	if len(m.MappedPorts) > 0 {
		for iNdEx := len(m.MappedPorts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MappedPorts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAppinst(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.Liveness != 0 {
		i = encodeVarintAppinst(dAtA, i, uint64(m.Liveness))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Uri) > 0 {
		i -= len(m.Uri)
		copy(dAtA[i:], m.Uri)
		i = encodeVarintAppinst(dAtA, i, uint64(len(m.Uri)))
		i--
		dAtA[i] = 0x22
	}
	{
		size, err := m.CloudletLoc.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppinst(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppinst(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Fields) > 0 {
		for iNdEx := len(m.Fields) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Fields[iNdEx])
			copy(dAtA[i:], m.Fields[iNdEx])
			i = encodeVarintAppinst(dAtA, i, uint64(len(m.Fields[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AppInstRuntime) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppInstRuntime) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppInstRuntime) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ContainerIds) > 0 {
		for iNdEx := len(m.ContainerIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ContainerIds[iNdEx])
			copy(dAtA[i:], m.ContainerIds[iNdEx])
			i = encodeVarintAppinst(dAtA, i, uint64(len(m.ContainerIds[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AppInstInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppInstInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppInstInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FedPorts) > 0 {
		for iNdEx := len(m.FedPorts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FedPorts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAppinst(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	{
		size, err := m.FedKey.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppinst(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	if len(m.Uri) > 0 {
		i -= len(m.Uri)
		copy(dAtA[i:], m.Uri)
		i = encodeVarintAppinst(dAtA, i, uint64(len(m.Uri)))
		i--
		dAtA[i] = 0x4a
	}
	if m.PowerState != 0 {
		i = encodeVarintAppinst(dAtA, i, uint64(m.PowerState))
		i--
		dAtA[i] = 0x40
	}
	{
		size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppinst(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size, err := m.RuntimeInfo.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppinst(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if len(m.Errors) > 0 {
		for iNdEx := len(m.Errors) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Errors[iNdEx])
			copy(dAtA[i:], m.Errors[iNdEx])
			i = encodeVarintAppinst(dAtA, i, uint64(len(m.Errors[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.State != 0 {
		i = encodeVarintAppinst(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x20
	}
	if m.NotifyId != 0 {
		i = encodeVarintAppinst(dAtA, i, uint64(m.NotifyId))
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppinst(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Fields) > 0 {
		for iNdEx := len(m.Fields) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Fields[iNdEx])
			copy(dAtA[i:], m.Fields[iNdEx])
			i = encodeVarintAppinst(dAtA, i, uint64(len(m.Fields[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AppInstMetrics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppInstMetrics) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppInstMetrics) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Something != 0 {
		i = encodeVarintAppinst(dAtA, i, uint64(m.Something))
		i--
		dAtA[i] = 0x28
	}
	return len(dAtA) - i, nil
}

func (m *AppInstLookup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppInstLookup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppInstLookup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.PolicyKey.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppinst(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppinst(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AppInstLookup2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppInstLookup2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppInstLookup2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.CloudletKey.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppinst(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppinst(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AppInstLatency) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppInstLatency) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppInstLatency) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppinst(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *FedAppInstKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FedAppInstKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FedAppInstKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AppInstId) > 0 {
		i -= len(m.AppInstId)
		copy(dAtA[i:], m.AppInstId)
		i = encodeVarintAppinst(dAtA, i, uint64(len(m.AppInstId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.FederationName) > 0 {
		i -= len(m.FederationName)
		copy(dAtA[i:], m.FederationName)
		i = encodeVarintAppinst(dAtA, i, uint64(len(m.FederationName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FedAppInst) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FedAppInst) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FedAppInst) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.AppInstKey.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppinst(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppinst(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *FedAppInstEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FedAppInstEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FedAppInstEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UniqueId) > 0 {
		i -= len(m.UniqueId)
		copy(dAtA[i:], m.UniqueId)
		i = encodeVarintAppinst(dAtA, i, uint64(len(m.UniqueId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Ports) > 0 {
		for iNdEx := len(m.Ports) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ports[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAppinst(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintAppinst(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x1a
	}
	if m.State != 0 {
		i = encodeVarintAppinst(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppinst(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintAppinst(dAtA []byte, offset int, v uint64) int {
	offset -= sovAppinst(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *VirtualClusterInstKeyV1) Matches(o *VirtualClusterInstKeyV1, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !m.ClusterKey.Matches(&o.ClusterKey, fopts...) {
		return false
	}
	if !m.CloudletKey.Matches(&o.CloudletKey, fopts...) {
		return false
	}
	if !opts.Filter || o.Organization != "" {
		if o.Organization != m.Organization {
			return false
		}
	}
	return true
}

func (m *VirtualClusterInstKeyV1) Clone() *VirtualClusterInstKeyV1 {
	cp := &VirtualClusterInstKeyV1{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *VirtualClusterInstKeyV1) CopyInFields(src *VirtualClusterInstKeyV1) int {
	changed := 0
	if m.ClusterKey.Name != src.ClusterKey.Name {
		m.ClusterKey.Name = src.ClusterKey.Name
		changed++
	}
	if m.CloudletKey.Organization != src.CloudletKey.Organization {
		m.CloudletKey.Organization = src.CloudletKey.Organization
		changed++
	}
	if m.CloudletKey.Name != src.CloudletKey.Name {
		m.CloudletKey.Name = src.CloudletKey.Name
		changed++
	}
	if m.CloudletKey.FederatedOrganization != src.CloudletKey.FederatedOrganization {
		m.CloudletKey.FederatedOrganization = src.CloudletKey.FederatedOrganization
		changed++
	}
	if m.Organization != src.Organization {
		m.Organization = src.Organization
		changed++
	}
	return changed
}

func (m *VirtualClusterInstKeyV1) DeepCopyIn(src *VirtualClusterInstKeyV1) {
	m.ClusterKey.DeepCopyIn(&src.ClusterKey)
	m.CloudletKey.DeepCopyIn(&src.CloudletKey)
	m.Organization = src.Organization
}

func (m *VirtualClusterInstKeyV1) GetKeyString() string {
	key, err := json.Marshal(m)
	if err != nil {
		log.FatalLog("Failed to marshal VirtualClusterInstKeyV1 key string", "obj", m)
	}
	return string(key)
}

func VirtualClusterInstKeyV1StringParse(str string, key *VirtualClusterInstKeyV1) {
	err := json.Unmarshal([]byte(str), key)
	if err != nil {
		log.FatalLog("Failed to unmarshal VirtualClusterInstKeyV1 key string", "str", str)
	}
}

func (m *VirtualClusterInstKeyV1) NotFoundError() error {
	return fmt.Errorf("VirtualClusterInstKeyV1 key %s not found", m.GetKeyString())
}

func (m *VirtualClusterInstKeyV1) ExistsError() error {
	return fmt.Errorf("VirtualClusterInstKeyV1 key %s already exists", m.GetKeyString())
}

func (m *VirtualClusterInstKeyV1) BeingDeletedError() error {
	return fmt.Errorf("VirtualClusterInstKeyV1 %s is being deleted", m.GetKeyString())
}

var VirtualClusterInstKeyV1TagOrganization = "clusterorg"

func (m *VirtualClusterInstKeyV1) GetTags() map[string]string {
	tags := make(map[string]string)
	m.AddTags(tags)
	return tags
}

func (m *VirtualClusterInstKeyV1) AddTagsByFunc(addTag AddTagFunc) {
	addTag("cluster", m.ClusterKey.Name)
	addTag("cloudletorg", m.CloudletKey.Organization)
	addTag("cloudlet", m.CloudletKey.Name)
	addTag("cloudletfedorg", m.CloudletKey.FederatedOrganization)
	addTag("clusterorg", m.Organization)
}

func (m *VirtualClusterInstKeyV1) AddTags(tags map[string]string) {
	tagMap := TagMap(tags)
	m.AddTagsByFunc(tagMap.AddTag)
}

// Helper method to check that enums have valid values
func (m *VirtualClusterInstKeyV1) ValidateEnums() error {
	if err := m.ClusterKey.ValidateEnums(); err != nil {
		return err
	}
	if err := m.CloudletKey.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func (s *VirtualClusterInstKeyV1) ClearTagged(tags map[string]struct{}) {
	s.ClusterKey.ClearTagged(tags)
	s.CloudletKey.ClearTagged(tags)
}

func (m *AppInstKeyV1) Matches(o *AppInstKeyV1, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !m.AppKey.Matches(&o.AppKey, fopts...) {
		return false
	}
	if !opts.IgnoreBackend {
		if !m.ClusterInstKey.Matches(&o.ClusterInstKey, fopts...) {
			return false
		}
	}
	return true
}

func (m *AppInstKeyV1) Clone() *AppInstKeyV1 {
	cp := &AppInstKeyV1{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *AppInstKeyV1) CopyInFields(src *AppInstKeyV1) int {
	changed := 0
	if m.AppKey.Organization != src.AppKey.Organization {
		m.AppKey.Organization = src.AppKey.Organization
		changed++
	}
	if m.AppKey.Name != src.AppKey.Name {
		m.AppKey.Name = src.AppKey.Name
		changed++
	}
	if m.AppKey.Version != src.AppKey.Version {
		m.AppKey.Version = src.AppKey.Version
		changed++
	}
	if m.ClusterInstKey.ClusterKey.Name != src.ClusterInstKey.ClusterKey.Name {
		m.ClusterInstKey.ClusterKey.Name = src.ClusterInstKey.ClusterKey.Name
		changed++
	}
	if m.ClusterInstKey.CloudletKey.Organization != src.ClusterInstKey.CloudletKey.Organization {
		m.ClusterInstKey.CloudletKey.Organization = src.ClusterInstKey.CloudletKey.Organization
		changed++
	}
	if m.ClusterInstKey.CloudletKey.Name != src.ClusterInstKey.CloudletKey.Name {
		m.ClusterInstKey.CloudletKey.Name = src.ClusterInstKey.CloudletKey.Name
		changed++
	}
	if m.ClusterInstKey.CloudletKey.FederatedOrganization != src.ClusterInstKey.CloudletKey.FederatedOrganization {
		m.ClusterInstKey.CloudletKey.FederatedOrganization = src.ClusterInstKey.CloudletKey.FederatedOrganization
		changed++
	}
	if m.ClusterInstKey.Organization != src.ClusterInstKey.Organization {
		m.ClusterInstKey.Organization = src.ClusterInstKey.Organization
		changed++
	}
	return changed
}

func (m *AppInstKeyV1) DeepCopyIn(src *AppInstKeyV1) {
	m.AppKey.DeepCopyIn(&src.AppKey)
	m.ClusterInstKey.DeepCopyIn(&src.ClusterInstKey)
}

func (m *AppInstKeyV1) GetKeyString() string {
	key, err := json.Marshal(m)
	if err != nil {
		log.FatalLog("Failed to marshal AppInstKeyV1 key string", "obj", m)
	}
	return string(key)
}

func AppInstKeyV1StringParse(str string, key *AppInstKeyV1) {
	err := json.Unmarshal([]byte(str), key)
	if err != nil {
		log.FatalLog("Failed to unmarshal AppInstKeyV1 key string", "str", str)
	}
}

func (m *AppInstKeyV1) NotFoundError() error {
	return fmt.Errorf("AppInstKeyV1 key %s not found", m.GetKeyString())
}

func (m *AppInstKeyV1) ExistsError() error {
	return fmt.Errorf("AppInstKeyV1 key %s already exists", m.GetKeyString())
}

func (m *AppInstKeyV1) BeingDeletedError() error {
	return fmt.Errorf("AppInstKeyV1 %s is being deleted", m.GetKeyString())
}

func (m *AppInstKeyV1) GetTags() map[string]string {
	tags := make(map[string]string)
	m.AddTags(tags)
	return tags
}

func (m *AppInstKeyV1) AddTagsByFunc(addTag AddTagFunc) {
	addTag("apporg", m.AppKey.Organization)
	addTag("app", m.AppKey.Name)
	addTag("appver", m.AppKey.Version)
	addTag("cluster", m.ClusterInstKey.ClusterKey.Name)
	addTag("cloudletorg", m.ClusterInstKey.CloudletKey.Organization)
	addTag("cloudlet", m.ClusterInstKey.CloudletKey.Name)
	addTag("cloudletfedorg", m.ClusterInstKey.CloudletKey.FederatedOrganization)
	addTag("clusterorg", m.ClusterInstKey.Organization)
}

func (m *AppInstKeyV1) AddTags(tags map[string]string) {
	tagMap := TagMap(tags)
	m.AddTagsByFunc(tagMap.AddTag)
}

// Helper method to check that enums have valid values
func (m *AppInstKeyV1) ValidateEnums() error {
	if err := m.AppKey.ValidateEnums(); err != nil {
		return err
	}
	if err := m.ClusterInstKey.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func (s *AppInstKeyV1) ClearTagged(tags map[string]struct{}) {
	s.AppKey.ClearTagged(tags)
	s.ClusterInstKey.ClearTagged(tags)
}

func (m *AppInstKeyV2) Matches(o *AppInstKeyV2, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !opts.Filter || o.Name != "" {
		if o.Name != m.Name {
			return false
		}
	}
	if !opts.Filter || o.Organization != "" {
		if o.Organization != m.Organization {
			return false
		}
	}
	if !m.CloudletKey.Matches(&o.CloudletKey, fopts...) {
		return false
	}
	return true
}

func (m *AppInstKeyV2) Clone() *AppInstKeyV2 {
	cp := &AppInstKeyV2{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *AppInstKeyV2) CopyInFields(src *AppInstKeyV2) int {
	changed := 0
	if m.Name != src.Name {
		m.Name = src.Name
		changed++
	}
	if m.Organization != src.Organization {
		m.Organization = src.Organization
		changed++
	}
	if m.CloudletKey.Organization != src.CloudletKey.Organization {
		m.CloudletKey.Organization = src.CloudletKey.Organization
		changed++
	}
	if m.CloudletKey.Name != src.CloudletKey.Name {
		m.CloudletKey.Name = src.CloudletKey.Name
		changed++
	}
	if m.CloudletKey.FederatedOrganization != src.CloudletKey.FederatedOrganization {
		m.CloudletKey.FederatedOrganization = src.CloudletKey.FederatedOrganization
		changed++
	}
	return changed
}

func (m *AppInstKeyV2) DeepCopyIn(src *AppInstKeyV2) {
	m.Name = src.Name
	m.Organization = src.Organization
	m.CloudletKey.DeepCopyIn(&src.CloudletKey)
}

func (m *AppInstKeyV2) GetKeyString() string {
	key, err := json.Marshal(m)
	if err != nil {
		log.FatalLog("Failed to marshal AppInstKeyV2 key string", "obj", m)
	}
	return string(key)
}

func AppInstKeyV2StringParse(str string, key *AppInstKeyV2) {
	err := json.Unmarshal([]byte(str), key)
	if err != nil {
		log.FatalLog("Failed to unmarshal AppInstKeyV2 key string", "str", str)
	}
}

func (m *AppInstKeyV2) NotFoundError() error {
	return fmt.Errorf("AppInstKeyV2 key %s not found", m.GetKeyString())
}

func (m *AppInstKeyV2) ExistsError() error {
	return fmt.Errorf("AppInstKeyV2 key %s already exists", m.GetKeyString())
}

func (m *AppInstKeyV2) BeingDeletedError() error {
	return fmt.Errorf("AppInstKeyV2 %s is being deleted", m.GetKeyString())
}

var AppInstKeyV2TagName = "appinstv2"
var AppInstKeyV2TagOrganization = "appinstv2org"

func (m *AppInstKeyV2) GetTags() map[string]string {
	tags := make(map[string]string)
	m.AddTags(tags)
	return tags
}

func (m *AppInstKeyV2) AddTagsByFunc(addTag AddTagFunc) {
	addTag("appinstv2", m.Name)
	addTag("appinstv2org", m.Organization)
	addTag("cloudletorg", m.CloudletKey.Organization)
	addTag("cloudlet", m.CloudletKey.Name)
	addTag("cloudletfedorg", m.CloudletKey.FederatedOrganization)
}

func (m *AppInstKeyV2) AddTags(tags map[string]string) {
	tagMap := TagMap(tags)
	m.AddTagsByFunc(tagMap.AddTag)
}

// Helper method to check that enums have valid values
func (m *AppInstKeyV2) ValidateEnums() error {
	if err := m.CloudletKey.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func (s *AppInstKeyV2) ClearTagged(tags map[string]struct{}) {
	s.CloudletKey.ClearTagged(tags)
}

func (m *AppInstKey) Matches(o *AppInstKey, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !opts.Filter || o.Name != "" {
		if o.Name != m.Name {
			return false
		}
	}
	if !opts.Filter || o.Organization != "" {
		if o.Organization != m.Organization {
			return false
		}
	}
	return true
}

func (m *AppInstKey) Clone() *AppInstKey {
	cp := &AppInstKey{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *AppInstKey) CopyInFields(src *AppInstKey) int {
	changed := 0
	if m.Name != src.Name {
		m.Name = src.Name
		changed++
	}
	if m.Organization != src.Organization {
		m.Organization = src.Organization
		changed++
	}
	return changed
}

func (m *AppInstKey) DeepCopyIn(src *AppInstKey) {
	m.Name = src.Name
	m.Organization = src.Organization
}

func (m *AppInstKey) GetKeyString() string {
	key, err := json.Marshal(m)
	if err != nil {
		log.FatalLog("Failed to marshal AppInstKey key string", "obj", m)
	}
	return string(key)
}

func AppInstKeyStringParse(str string, key *AppInstKey) {
	err := json.Unmarshal([]byte(str), key)
	if err != nil {
		log.FatalLog("Failed to unmarshal AppInstKey key string", "str", str)
	}
}

func (m *AppInstKey) NotFoundError() error {
	return fmt.Errorf("AppInst key %s not found", m.GetKeyString())
}

func (m *AppInstKey) ExistsError() error {
	return fmt.Errorf("AppInst key %s already exists", m.GetKeyString())
}

func (m *AppInstKey) BeingDeletedError() error {
	return fmt.Errorf("AppInst %s is being deleted", m.GetKeyString())
}

var AppInstKeyTagName = "appinst"
var AppInstKeyTagOrganization = "appinstorg"

func (m *AppInstKey) GetTags() map[string]string {
	tags := make(map[string]string)
	m.AddTags(tags)
	return tags
}

func (m *AppInstKey) AddTagsByFunc(addTag AddTagFunc) {
	addTag("appinst", m.Name)
	addTag("appinstorg", m.Organization)
}

func (m *AppInstKey) AddTags(tags map[string]string) {
	tagMap := TagMap(tags)
	m.AddTagsByFunc(tagMap.AddTag)
}

// Helper method to check that enums have valid values
func (m *AppInstKey) ValidateEnums() error {
	return nil
}

func (s *AppInstKey) ClearTagged(tags map[string]struct{}) {
}

func (m *AppInst) Matches(o *AppInst, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !m.Key.Matches(&o.Key, fopts...) {
		return false
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.Uri != "" {
			if o.Uri != m.Uri {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.Liveness != 0 {
			if o.Liveness != m.Liveness {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.MappedPorts != nil {
			if len(m.MappedPorts) == 0 && len(o.MappedPorts) > 0 || len(m.MappedPorts) > 0 && len(o.MappedPorts) == 0 {
				return false
			} else if m.MappedPorts != nil && o.MappedPorts != nil {
				if !opts.Filter && len(m.MappedPorts) != len(o.MappedPorts) {
					return false
				}
			}
		}
	}
	if !opts.IgnoreBackend {
		if !m.Flavor.Matches(&o.Flavor, fopts...) {
			return false
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.State != 0 {
			if o.State != m.State {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.Errors != nil {
			if len(m.Errors) == 0 && len(o.Errors) > 0 || len(m.Errors) > 0 && len(o.Errors) == 0 {
				return false
			} else if m.Errors != nil && o.Errors != nil {
				if !opts.Filter && len(m.Errors) != len(o.Errors) {
					return false
				}
				found := 0
				for oIndex, _ := range o.Errors {
					for mIndex, _ := range m.Errors {
						if o.Errors[oIndex] == m.Errors[mIndex] {
							found++
							break
						}
					}
				}
				if found != len(o.Errors) {
					return false
				}
			}
		}
	}
	if !opts.Filter || o.CrmOverride != 0 {
		if o.CrmOverride != m.CrmOverride {
			return false
		}
	}
	if !opts.IgnoreBackend {
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.AutoClusterIpAccess != 0 {
			if o.AutoClusterIpAccess != m.AutoClusterIpAccess {
				return false
			}
		}
	}
	if !opts.Filter || o.Revision != "" {
		if o.Revision != m.Revision {
			return false
		}
	}
	if !opts.Filter || o.ForceUpdate != false {
		if o.ForceUpdate != m.ForceUpdate {
			return false
		}
	}
	if !opts.Filter || o.UpdateMultiple != false {
		if o.UpdateMultiple != m.UpdateMultiple {
			return false
		}
	}
	if !opts.Filter || o.Configs != nil {
		if len(m.Configs) == 0 && len(o.Configs) > 0 || len(m.Configs) > 0 && len(o.Configs) == 0 {
			return false
		} else if m.Configs != nil && o.Configs != nil {
			if !opts.Filter && len(m.Configs) != len(o.Configs) {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.HealthCheck != 0 {
			if o.HealthCheck != m.HealthCheck {
				return false
			}
		}
	}
	if !opts.Filter || o.PowerState != 0 {
		if o.PowerState != m.PowerState {
			return false
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.ExternalVolumeSize != 0 {
			if o.ExternalVolumeSize != m.ExternalVolumeSize {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.AvailabilityZone != "" {
			if o.AvailabilityZone != m.AvailabilityZone {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.VmFlavor != "" {
			if o.VmFlavor != m.VmFlavor {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.OptRes != "" {
			if o.OptRes != m.OptRes {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.RealClusterName != "" {
			if o.RealClusterName != m.RealClusterName {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.InternalPortToLbIp != nil {
			if len(m.InternalPortToLbIp) == 0 && len(o.InternalPortToLbIp) > 0 || len(m.InternalPortToLbIp) > 0 && len(o.InternalPortToLbIp) == 0 {
				return false
			} else if m.InternalPortToLbIp != nil && o.InternalPortToLbIp != nil {
				if !opts.Filter && len(m.InternalPortToLbIp) != len(o.InternalPortToLbIp) {
					return false
				}
				for k, _ := range o.InternalPortToLbIp {
					_, ok := m.InternalPortToLbIp[k]
					if !ok {
						return false
					}
					if o.InternalPortToLbIp[k] != m.InternalPortToLbIp[k] {
						return false
					}
				}
			}
		}
	}
	if !opts.Filter || o.DedicatedIp != false {
		if o.DedicatedIp != m.DedicatedIp {
			return false
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.UniqueId != "" {
			if o.UniqueId != m.UniqueId {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.DnsLabel != "" {
			if o.DnsLabel != m.DnsLabel {
				return false
			}
		}
	}
	if !opts.Filter || o.CloudletFlavor != "" {
		if o.CloudletFlavor != m.CloudletFlavor {
			return false
		}
	}
	if !opts.IgnoreBackend {
		if !m.FedKey.Matches(&o.FedKey, fopts...) {
			return false
		}
	}
	if !m.AppKey.Matches(&o.AppKey, fopts...) {
		return false
	}
	if !m.ClusterKey.Matches(&o.ClusterKey, fopts...) {
		return false
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.CompatibilityVersion != 0 {
			if o.CompatibilityVersion != m.CompatibilityVersion {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !m.VirtualClusterKey.Matches(&o.VirtualClusterKey, fopts...) {
			return false
		}
	}
	if !opts.Filter || o.EnableIpv6 != false {
		if o.EnableIpv6 != m.EnableIpv6 {
			return false
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.ObjId != "" {
			if o.ObjId != m.ObjId {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.StaticUri != "" {
			if o.StaticUri != m.StaticUri {
				return false
			}
		}
	}
	if !m.CloudletKey.Matches(&o.CloudletKey, fopts...) {
		return false
	}
	if !opts.Filter || o.Annotations != nil {
		if len(m.Annotations) == 0 && len(o.Annotations) > 0 || len(m.Annotations) > 0 && len(o.Annotations) == 0 {
			return false
		} else if m.Annotations != nil && o.Annotations != nil {
			if !opts.Filter && len(m.Annotations) != len(o.Annotations) {
				return false
			}
			for k, _ := range o.Annotations {
				_, ok := m.Annotations[k]
				if !ok {
					return false
				}
				if o.Annotations[k] != m.Annotations[k] {
					return false
				}
			}
		}
	}
	return true
}

const AppInstFieldKey = "2"
const AppInstFieldKeyName = "2.1"
const AppInstFieldKeyOrganization = "2.2"
const AppInstFieldCloudletLoc = "3"
const AppInstFieldCloudletLocLatitude = "3.1"
const AppInstFieldCloudletLocLongitude = "3.2"
const AppInstFieldCloudletLocHorizontalAccuracy = "3.3"
const AppInstFieldCloudletLocVerticalAccuracy = "3.4"
const AppInstFieldCloudletLocAltitude = "3.5"
const AppInstFieldCloudletLocCourse = "3.6"
const AppInstFieldCloudletLocSpeed = "3.7"
const AppInstFieldCloudletLocTimestamp = "3.8"
const AppInstFieldCloudletLocTimestampSeconds = "3.8.1"
const AppInstFieldCloudletLocTimestampNanos = "3.8.2"
const AppInstFieldUri = "4"
const AppInstFieldLiveness = "6"
const AppInstFieldMappedPorts = "9"
const AppInstFieldMappedPortsProto = "9.1"
const AppInstFieldMappedPortsInternalPort = "9.2"
const AppInstFieldMappedPortsPublicPort = "9.3"
const AppInstFieldMappedPortsFqdnPrefix = "9.5"
const AppInstFieldMappedPortsEndPort = "9.6"
const AppInstFieldMappedPortsTls = "9.7"
const AppInstFieldMappedPortsNginx = "9.8"
const AppInstFieldMappedPortsMaxPktSize = "9.9"
const AppInstFieldFlavor = "12"
const AppInstFieldFlavorName = "12.1"
const AppInstFieldState = "14"
const AppInstFieldErrors = "15"
const AppInstFieldCrmOverride = "16"
const AppInstFieldRuntimeInfo = "17"
const AppInstFieldRuntimeInfoContainerIds = "17.1"
const AppInstFieldCreatedAt = "21"
const AppInstFieldCreatedAtSeconds = "21.1"
const AppInstFieldCreatedAtNanos = "21.2"
const AppInstFieldAutoClusterIpAccess = "22"
const AppInstFieldRevision = "24"
const AppInstFieldForceUpdate = "25"
const AppInstFieldUpdateMultiple = "26"
const AppInstFieldConfigs = "27"
const AppInstFieldConfigsKind = "27.1"
const AppInstFieldConfigsConfig = "27.2"
const AppInstFieldHealthCheck = "29"
const AppInstFieldPowerState = "31"
const AppInstFieldExternalVolumeSize = "32"
const AppInstFieldAvailabilityZone = "33"
const AppInstFieldVmFlavor = "34"
const AppInstFieldOptRes = "35"
const AppInstFieldUpdatedAt = "36"
const AppInstFieldUpdatedAtSeconds = "36.1"
const AppInstFieldUpdatedAtNanos = "36.2"
const AppInstFieldRealClusterName = "37"
const AppInstFieldInternalPortToLbIp = "38"
const AppInstFieldInternalPortToLbIpKey = "38.1"
const AppInstFieldInternalPortToLbIpValue = "38.2"
const AppInstFieldDedicatedIp = "39"
const AppInstFieldUniqueId = "40"
const AppInstFieldDnsLabel = "41"
const AppInstFieldCloudletFlavor = "42"
const AppInstFieldFedKey = "43"
const AppInstFieldFedKeyFederationName = "43.1"
const AppInstFieldFedKeyAppInstId = "43.2"
const AppInstFieldAppKey = "44"
const AppInstFieldAppKeyOrganization = "44.1"
const AppInstFieldAppKeyName = "44.2"
const AppInstFieldAppKeyVersion = "44.3"
const AppInstFieldClusterKey = "45"
const AppInstFieldClusterKeyName = "45.1"
const AppInstFieldClusterKeyOrganization = "45.2"
const AppInstFieldCompatibilityVersion = "46"
const AppInstFieldVirtualClusterKey = "47"
const AppInstFieldVirtualClusterKeyName = "47.1"
const AppInstFieldVirtualClusterKeyOrganization = "47.2"
const AppInstFieldEnableIpv6 = "48"
const AppInstFieldObjId = "49"
const AppInstFieldStaticUri = "50"
const AppInstFieldCloudletKey = "51"
const AppInstFieldCloudletKeyOrganization = "51.1"
const AppInstFieldCloudletKeyName = "51.2"
const AppInstFieldCloudletKeyFederatedOrganization = "51.3"
const AppInstFieldAnnotations = "52"
const AppInstFieldAnnotationsKey = "52.1"
const AppInstFieldAnnotationsValue = "52.2"

var AppInstAllFields = []string{
	AppInstFieldKeyName,
	AppInstFieldKeyOrganization,
	AppInstFieldCloudletLocLatitude,
	AppInstFieldCloudletLocLongitude,
	AppInstFieldCloudletLocHorizontalAccuracy,
	AppInstFieldCloudletLocVerticalAccuracy,
	AppInstFieldCloudletLocAltitude,
	AppInstFieldCloudletLocCourse,
	AppInstFieldCloudletLocSpeed,
	AppInstFieldCloudletLocTimestampSeconds,
	AppInstFieldCloudletLocTimestampNanos,
	AppInstFieldUri,
	AppInstFieldLiveness,
	AppInstFieldMappedPortsProto,
	AppInstFieldMappedPortsInternalPort,
	AppInstFieldMappedPortsPublicPort,
	AppInstFieldMappedPortsFqdnPrefix,
	AppInstFieldMappedPortsEndPort,
	AppInstFieldMappedPortsTls,
	AppInstFieldMappedPortsNginx,
	AppInstFieldMappedPortsMaxPktSize,
	AppInstFieldFlavorName,
	AppInstFieldState,
	AppInstFieldErrors,
	AppInstFieldCrmOverride,
	AppInstFieldRuntimeInfoContainerIds,
	AppInstFieldCreatedAtSeconds,
	AppInstFieldCreatedAtNanos,
	AppInstFieldAutoClusterIpAccess,
	AppInstFieldRevision,
	AppInstFieldForceUpdate,
	AppInstFieldUpdateMultiple,
	AppInstFieldConfigsKind,
	AppInstFieldConfigsConfig,
	AppInstFieldHealthCheck,
	AppInstFieldPowerState,
	AppInstFieldExternalVolumeSize,
	AppInstFieldAvailabilityZone,
	AppInstFieldVmFlavor,
	AppInstFieldOptRes,
	AppInstFieldUpdatedAtSeconds,
	AppInstFieldUpdatedAtNanos,
	AppInstFieldRealClusterName,
	AppInstFieldInternalPortToLbIpKey,
	AppInstFieldInternalPortToLbIpValue,
	AppInstFieldDedicatedIp,
	AppInstFieldUniqueId,
	AppInstFieldDnsLabel,
	AppInstFieldCloudletFlavor,
	AppInstFieldFedKeyFederationName,
	AppInstFieldFedKeyAppInstId,
	AppInstFieldAppKeyOrganization,
	AppInstFieldAppKeyName,
	AppInstFieldAppKeyVersion,
	AppInstFieldClusterKeyName,
	AppInstFieldClusterKeyOrganization,
	AppInstFieldCompatibilityVersion,
	AppInstFieldVirtualClusterKeyName,
	AppInstFieldVirtualClusterKeyOrganization,
	AppInstFieldEnableIpv6,
	AppInstFieldObjId,
	AppInstFieldStaticUri,
	AppInstFieldCloudletKeyOrganization,
	AppInstFieldCloudletKeyName,
	AppInstFieldCloudletKeyFederatedOrganization,
	AppInstFieldAnnotationsKey,
	AppInstFieldAnnotationsValue,
}

var AppInstAllFieldsMap = NewFieldMap(map[string]struct{}{
	AppInstFieldKeyName:                          struct{}{},
	AppInstFieldKeyOrganization:                  struct{}{},
	AppInstFieldCloudletLocLatitude:              struct{}{},
	AppInstFieldCloudletLocLongitude:             struct{}{},
	AppInstFieldCloudletLocHorizontalAccuracy:    struct{}{},
	AppInstFieldCloudletLocVerticalAccuracy:      struct{}{},
	AppInstFieldCloudletLocAltitude:              struct{}{},
	AppInstFieldCloudletLocCourse:                struct{}{},
	AppInstFieldCloudletLocSpeed:                 struct{}{},
	AppInstFieldCloudletLocTimestampSeconds:      struct{}{},
	AppInstFieldCloudletLocTimestampNanos:        struct{}{},
	AppInstFieldUri:                              struct{}{},
	AppInstFieldLiveness:                         struct{}{},
	AppInstFieldMappedPortsProto:                 struct{}{},
	AppInstFieldMappedPortsInternalPort:          struct{}{},
	AppInstFieldMappedPortsPublicPort:            struct{}{},
	AppInstFieldMappedPortsFqdnPrefix:            struct{}{},
	AppInstFieldMappedPortsEndPort:               struct{}{},
	AppInstFieldMappedPortsTls:                   struct{}{},
	AppInstFieldMappedPortsNginx:                 struct{}{},
	AppInstFieldMappedPortsMaxPktSize:            struct{}{},
	AppInstFieldFlavorName:                       struct{}{},
	AppInstFieldState:                            struct{}{},
	AppInstFieldErrors:                           struct{}{},
	AppInstFieldCrmOverride:                      struct{}{},
	AppInstFieldRuntimeInfoContainerIds:          struct{}{},
	AppInstFieldCreatedAtSeconds:                 struct{}{},
	AppInstFieldCreatedAtNanos:                   struct{}{},
	AppInstFieldAutoClusterIpAccess:              struct{}{},
	AppInstFieldRevision:                         struct{}{},
	AppInstFieldForceUpdate:                      struct{}{},
	AppInstFieldUpdateMultiple:                   struct{}{},
	AppInstFieldConfigsKind:                      struct{}{},
	AppInstFieldConfigsConfig:                    struct{}{},
	AppInstFieldHealthCheck:                      struct{}{},
	AppInstFieldPowerState:                       struct{}{},
	AppInstFieldExternalVolumeSize:               struct{}{},
	AppInstFieldAvailabilityZone:                 struct{}{},
	AppInstFieldVmFlavor:                         struct{}{},
	AppInstFieldOptRes:                           struct{}{},
	AppInstFieldUpdatedAtSeconds:                 struct{}{},
	AppInstFieldUpdatedAtNanos:                   struct{}{},
	AppInstFieldRealClusterName:                  struct{}{},
	AppInstFieldInternalPortToLbIpKey:            struct{}{},
	AppInstFieldInternalPortToLbIpValue:          struct{}{},
	AppInstFieldDedicatedIp:                      struct{}{},
	AppInstFieldUniqueId:                         struct{}{},
	AppInstFieldDnsLabel:                         struct{}{},
	AppInstFieldCloudletFlavor:                   struct{}{},
	AppInstFieldFedKeyFederationName:             struct{}{},
	AppInstFieldFedKeyAppInstId:                  struct{}{},
	AppInstFieldAppKeyOrganization:               struct{}{},
	AppInstFieldAppKeyName:                       struct{}{},
	AppInstFieldAppKeyVersion:                    struct{}{},
	AppInstFieldClusterKeyName:                   struct{}{},
	AppInstFieldClusterKeyOrganization:           struct{}{},
	AppInstFieldCompatibilityVersion:             struct{}{},
	AppInstFieldVirtualClusterKeyName:            struct{}{},
	AppInstFieldVirtualClusterKeyOrganization:    struct{}{},
	AppInstFieldEnableIpv6:                       struct{}{},
	AppInstFieldObjId:                            struct{}{},
	AppInstFieldStaticUri:                        struct{}{},
	AppInstFieldCloudletKeyOrganization:          struct{}{},
	AppInstFieldCloudletKeyName:                  struct{}{},
	AppInstFieldCloudletKeyFederatedOrganization: struct{}{},
	AppInstFieldAnnotationsKey:                   struct{}{},
	AppInstFieldAnnotationsValue:                 struct{}{},
})

var AppInstAllFieldsStringMap = map[string]string{
	AppInstFieldKeyName:                          "Key Name",
	AppInstFieldKeyOrganization:                  "Key Organization",
	AppInstFieldCloudletLocLatitude:              "Cloudlet Loc Latitude",
	AppInstFieldCloudletLocLongitude:             "Cloudlet Loc Longitude",
	AppInstFieldCloudletLocHorizontalAccuracy:    "Cloudlet Loc Horizontal Accuracy",
	AppInstFieldCloudletLocVerticalAccuracy:      "Cloudlet Loc Vertical Accuracy",
	AppInstFieldCloudletLocAltitude:              "Cloudlet Loc Altitude",
	AppInstFieldCloudletLocCourse:                "Cloudlet Loc Course",
	AppInstFieldCloudletLocSpeed:                 "Cloudlet Loc Speed",
	AppInstFieldCloudletLocTimestampSeconds:      "Cloudlet Loc Timestamp Seconds",
	AppInstFieldCloudletLocTimestampNanos:        "Cloudlet Loc Timestamp Nanos",
	AppInstFieldUri:                              "Uri",
	AppInstFieldLiveness:                         "Liveness",
	AppInstFieldMappedPortsProto:                 "Mapped Ports Proto",
	AppInstFieldMappedPortsInternalPort:          "Mapped Ports Internal Port",
	AppInstFieldMappedPortsPublicPort:            "Mapped Ports Public Port",
	AppInstFieldMappedPortsFqdnPrefix:            "Mapped Ports Fqdn Prefix",
	AppInstFieldMappedPortsEndPort:               "Mapped Ports End Port",
	AppInstFieldMappedPortsTls:                   "Mapped Ports Tls",
	AppInstFieldMappedPortsNginx:                 "Mapped Ports Nginx",
	AppInstFieldMappedPortsMaxPktSize:            "Mapped Ports Max Pkt Size",
	AppInstFieldFlavorName:                       "Flavor Name",
	AppInstFieldState:                            "State",
	AppInstFieldErrors:                           "Errors",
	AppInstFieldCrmOverride:                      "Crm Override",
	AppInstFieldRuntimeInfoContainerIds:          "Runtime Info Container Ids",
	AppInstFieldCreatedAtSeconds:                 "Created At Seconds",
	AppInstFieldCreatedAtNanos:                   "Created At Nanos",
	AppInstFieldAutoClusterIpAccess:              "Auto Cluster Ip Access",
	AppInstFieldRevision:                         "Revision",
	AppInstFieldForceUpdate:                      "Force Update",
	AppInstFieldUpdateMultiple:                   "Update Multiple",
	AppInstFieldConfigsKind:                      "Configs Kind",
	AppInstFieldConfigsConfig:                    "Configs Config",
	AppInstFieldHealthCheck:                      "Health Check",
	AppInstFieldPowerState:                       "Power State",
	AppInstFieldExternalVolumeSize:               "External Volume Size",
	AppInstFieldAvailabilityZone:                 "Availability Zone",
	AppInstFieldVmFlavor:                         "Vm Flavor",
	AppInstFieldOptRes:                           "Opt Res",
	AppInstFieldUpdatedAtSeconds:                 "Updated At Seconds",
	AppInstFieldUpdatedAtNanos:                   "Updated At Nanos",
	AppInstFieldRealClusterName:                  "Real Cluster Name",
	AppInstFieldInternalPortToLbIpKey:            "Internal Port To Lb Ip Key",
	AppInstFieldInternalPortToLbIpValue:          "Internal Port To Lb Ip Value",
	AppInstFieldDedicatedIp:                      "Dedicated Ip",
	AppInstFieldUniqueId:                         "Unique Id",
	AppInstFieldDnsLabel:                         "Dns Label",
	AppInstFieldCloudletFlavor:                   "Cloudlet Flavor",
	AppInstFieldFedKeyFederationName:             "Fed Key Federation Name",
	AppInstFieldFedKeyAppInstId:                  "Fed Key App Inst Id",
	AppInstFieldAppKeyOrganization:               "App Key Organization",
	AppInstFieldAppKeyName:                       "App Key Name",
	AppInstFieldAppKeyVersion:                    "App Key Version",
	AppInstFieldClusterKeyName:                   "Cluster Key Name",
	AppInstFieldClusterKeyOrganization:           "Cluster Key Organization",
	AppInstFieldCompatibilityVersion:             "Compatibility Version",
	AppInstFieldVirtualClusterKeyName:            "Virtual Cluster Key Name",
	AppInstFieldVirtualClusterKeyOrganization:    "Virtual Cluster Key Organization",
	AppInstFieldEnableIpv6:                       "Enable Ipv6",
	AppInstFieldObjId:                            "Obj Id",
	AppInstFieldStaticUri:                        "Static Uri",
	AppInstFieldCloudletKeyOrganization:          "Cloudlet Key Organization",
	AppInstFieldCloudletKeyName:                  "Cloudlet Key Name",
	AppInstFieldCloudletKeyFederatedOrganization: "Cloudlet Key Federated Organization",
	AppInstFieldAnnotationsKey:                   "Annotations Key",
	AppInstFieldAnnotationsValue:                 "Annotations Value",
}

func (m *AppInst) IsKeyField(s string) bool {
	return strings.HasPrefix(s, AppInstFieldKey+".") || s == AppInstFieldKey
}

func (m *AppInst) DiffFields(o *AppInst, fields *FieldMap) {
	if m.Key.Name != o.Key.Name {
		fields.Set(AppInstFieldKeyName)
		fields.Set(AppInstFieldKey)
	}
	if m.Key.Organization != o.Key.Organization {
		fields.Set(AppInstFieldKeyOrganization)
		fields.Set(AppInstFieldKey)
	}
	if m.CloudletLoc.Latitude != o.CloudletLoc.Latitude {
		fields.Set(AppInstFieldCloudletLocLatitude)
		fields.Set(AppInstFieldCloudletLoc)
	}
	if m.CloudletLoc.Longitude != o.CloudletLoc.Longitude {
		fields.Set(AppInstFieldCloudletLocLongitude)
		fields.Set(AppInstFieldCloudletLoc)
	}
	if m.CloudletLoc.HorizontalAccuracy != o.CloudletLoc.HorizontalAccuracy {
		fields.Set(AppInstFieldCloudletLocHorizontalAccuracy)
		fields.Set(AppInstFieldCloudletLoc)
	}
	if m.CloudletLoc.VerticalAccuracy != o.CloudletLoc.VerticalAccuracy {
		fields.Set(AppInstFieldCloudletLocVerticalAccuracy)
		fields.Set(AppInstFieldCloudletLoc)
	}
	if m.CloudletLoc.Altitude != o.CloudletLoc.Altitude {
		fields.Set(AppInstFieldCloudletLocAltitude)
		fields.Set(AppInstFieldCloudletLoc)
	}
	if m.CloudletLoc.Course != o.CloudletLoc.Course {
		fields.Set(AppInstFieldCloudletLocCourse)
		fields.Set(AppInstFieldCloudletLoc)
	}
	if m.CloudletLoc.Speed != o.CloudletLoc.Speed {
		fields.Set(AppInstFieldCloudletLocSpeed)
		fields.Set(AppInstFieldCloudletLoc)
	}
	if m.CloudletLoc.Timestamp != nil && o.CloudletLoc.Timestamp != nil {
		if m.CloudletLoc.Timestamp.Seconds != o.CloudletLoc.Timestamp.Seconds {
			fields.Set(AppInstFieldCloudletLocTimestampSeconds)
			fields.Set(AppInstFieldCloudletLocTimestamp)
			fields.Set(AppInstFieldCloudletLoc)
		}
		if m.CloudletLoc.Timestamp.Nanos != o.CloudletLoc.Timestamp.Nanos {
			fields.Set(AppInstFieldCloudletLocTimestampNanos)
			fields.Set(AppInstFieldCloudletLocTimestamp)
			fields.Set(AppInstFieldCloudletLoc)
		}
	} else if (m.CloudletLoc.Timestamp != nil && o.CloudletLoc.Timestamp == nil) || (m.CloudletLoc.Timestamp == nil && o.CloudletLoc.Timestamp != nil) {
		fields.Set(AppInstFieldCloudletLocTimestamp)
		fields.Set(AppInstFieldCloudletLoc)
	}
	if m.Uri != o.Uri {
		fields.Set(AppInstFieldUri)
	}
	if m.Liveness != o.Liveness {
		fields.Set(AppInstFieldLiveness)
	}
	if len(m.MappedPorts) != len(o.MappedPorts) {
		fields.Set(AppInstFieldMappedPorts)
	} else {
		for i0 := 0; i0 < len(m.MappedPorts); i0++ {
			if m.MappedPorts[i0].Proto != o.MappedPorts[i0].Proto {
				fields.Set(AppInstFieldMappedPortsProto)
				fields.Set(AppInstFieldMappedPorts)
			}
			if m.MappedPorts[i0].InternalPort != o.MappedPorts[i0].InternalPort {
				fields.Set(AppInstFieldMappedPortsInternalPort)
				fields.Set(AppInstFieldMappedPorts)
			}
			if m.MappedPorts[i0].PublicPort != o.MappedPorts[i0].PublicPort {
				fields.Set(AppInstFieldMappedPortsPublicPort)
				fields.Set(AppInstFieldMappedPorts)
			}
			if m.MappedPorts[i0].FqdnPrefix != o.MappedPorts[i0].FqdnPrefix {
				fields.Set(AppInstFieldMappedPortsFqdnPrefix)
				fields.Set(AppInstFieldMappedPorts)
			}
			if m.MappedPorts[i0].EndPort != o.MappedPorts[i0].EndPort {
				fields.Set(AppInstFieldMappedPortsEndPort)
				fields.Set(AppInstFieldMappedPorts)
			}
			if m.MappedPorts[i0].Tls != o.MappedPorts[i0].Tls {
				fields.Set(AppInstFieldMappedPortsTls)
				fields.Set(AppInstFieldMappedPorts)
			}
			if m.MappedPorts[i0].Nginx != o.MappedPorts[i0].Nginx {
				fields.Set(AppInstFieldMappedPortsNginx)
				fields.Set(AppInstFieldMappedPorts)
			}
			if m.MappedPorts[i0].MaxPktSize != o.MappedPorts[i0].MaxPktSize {
				fields.Set(AppInstFieldMappedPortsMaxPktSize)
				fields.Set(AppInstFieldMappedPorts)
			}
		}
	}
	if m.Flavor.Name != o.Flavor.Name {
		fields.Set(AppInstFieldFlavorName)
		fields.Set(AppInstFieldFlavor)
	}
	if m.State != o.State {
		fields.Set(AppInstFieldState)
	}
	if len(m.Errors) != len(o.Errors) {
		fields.Set(AppInstFieldErrors)
	} else {
		for i0 := 0; i0 < len(m.Errors); i0++ {
			if m.Errors[i0] != o.Errors[i0] {
				fields.Set(AppInstFieldErrors)
				break
			}
		}
	}
	if m.CrmOverride != o.CrmOverride {
		fields.Set(AppInstFieldCrmOverride)
	}
	if len(m.RuntimeInfo.ContainerIds) != len(o.RuntimeInfo.ContainerIds) {
		fields.Set(AppInstFieldRuntimeInfoContainerIds)
		fields.Set(AppInstFieldRuntimeInfo)
	} else {
		for i1 := 0; i1 < len(m.RuntimeInfo.ContainerIds); i1++ {
			if m.RuntimeInfo.ContainerIds[i1] != o.RuntimeInfo.ContainerIds[i1] {
				fields.Set(AppInstFieldRuntimeInfoContainerIds)
				fields.Set(AppInstFieldRuntimeInfo)
				break
			}
		}
	}
	if m.CreatedAt.Seconds != o.CreatedAt.Seconds {
		fields.Set(AppInstFieldCreatedAtSeconds)
		fields.Set(AppInstFieldCreatedAt)
	}
	if m.CreatedAt.Nanos != o.CreatedAt.Nanos {
		fields.Set(AppInstFieldCreatedAtNanos)
		fields.Set(AppInstFieldCreatedAt)
	}
	if m.AutoClusterIpAccess != o.AutoClusterIpAccess {
		fields.Set(AppInstFieldAutoClusterIpAccess)
	}
	if m.Revision != o.Revision {
		fields.Set(AppInstFieldRevision)
	}
	if m.ForceUpdate != o.ForceUpdate {
		fields.Set(AppInstFieldForceUpdate)
	}
	if m.UpdateMultiple != o.UpdateMultiple {
		fields.Set(AppInstFieldUpdateMultiple)
	}
	if m.Configs != nil && o.Configs != nil {
		if len(m.Configs) != len(o.Configs) {
			fields.Set(AppInstFieldConfigs)
		} else {
			for i0 := 0; i0 < len(m.Configs); i0++ {
				if m.Configs[i0].Kind != o.Configs[i0].Kind {
					fields.Set(AppInstFieldConfigsKind)
					fields.Set(AppInstFieldConfigs)
				}
				if m.Configs[i0].Config != o.Configs[i0].Config {
					fields.Set(AppInstFieldConfigsConfig)
					fields.Set(AppInstFieldConfigs)
				}
			}
		}
	} else if (m.Configs != nil && o.Configs == nil) || (m.Configs == nil && o.Configs != nil) {
		fields.Set(AppInstFieldConfigs)
	}
	if m.HealthCheck != o.HealthCheck {
		fields.Set(AppInstFieldHealthCheck)
	}
	if m.PowerState != o.PowerState {
		fields.Set(AppInstFieldPowerState)
	}
	if m.ExternalVolumeSize != o.ExternalVolumeSize {
		fields.Set(AppInstFieldExternalVolumeSize)
	}
	if m.AvailabilityZone != o.AvailabilityZone {
		fields.Set(AppInstFieldAvailabilityZone)
	}
	if m.VmFlavor != o.VmFlavor {
		fields.Set(AppInstFieldVmFlavor)
	}
	if m.OptRes != o.OptRes {
		fields.Set(AppInstFieldOptRes)
	}
	if m.UpdatedAt.Seconds != o.UpdatedAt.Seconds {
		fields.Set(AppInstFieldUpdatedAtSeconds)
		fields.Set(AppInstFieldUpdatedAt)
	}
	if m.UpdatedAt.Nanos != o.UpdatedAt.Nanos {
		fields.Set(AppInstFieldUpdatedAtNanos)
		fields.Set(AppInstFieldUpdatedAt)
	}
	if m.RealClusterName != o.RealClusterName {
		fields.Set(AppInstFieldRealClusterName)
	}
	if m.InternalPortToLbIp != nil && o.InternalPortToLbIp != nil {
		if len(m.InternalPortToLbIp) != len(o.InternalPortToLbIp) {
			fields.Set(AppInstFieldInternalPortToLbIp)
		} else {
			for k0, _ := range m.InternalPortToLbIp {
				_, vok0 := o.InternalPortToLbIp[k0]
				if !vok0 {
					fields.Set(AppInstFieldInternalPortToLbIp)
				} else {
					if m.InternalPortToLbIp[k0] != o.InternalPortToLbIp[k0] {
						fields.Set(AppInstFieldInternalPortToLbIp)
						break
					}
				}
			}
		}
	} else if (m.InternalPortToLbIp != nil && o.InternalPortToLbIp == nil) || (m.InternalPortToLbIp == nil && o.InternalPortToLbIp != nil) {
		fields.Set(AppInstFieldInternalPortToLbIp)
	}
	if m.DedicatedIp != o.DedicatedIp {
		fields.Set(AppInstFieldDedicatedIp)
	}
	if m.UniqueId != o.UniqueId {
		fields.Set(AppInstFieldUniqueId)
	}
	if m.DnsLabel != o.DnsLabel {
		fields.Set(AppInstFieldDnsLabel)
	}
	if m.CloudletFlavor != o.CloudletFlavor {
		fields.Set(AppInstFieldCloudletFlavor)
	}
	if m.FedKey.FederationName != o.FedKey.FederationName {
		fields.Set(AppInstFieldFedKeyFederationName)
		fields.Set(AppInstFieldFedKey)
	}
	if m.FedKey.AppInstId != o.FedKey.AppInstId {
		fields.Set(AppInstFieldFedKeyAppInstId)
		fields.Set(AppInstFieldFedKey)
	}
	if m.AppKey.Organization != o.AppKey.Organization {
		fields.Set(AppInstFieldAppKeyOrganization)
		fields.Set(AppInstFieldAppKey)
	}
	if m.AppKey.Name != o.AppKey.Name {
		fields.Set(AppInstFieldAppKeyName)
		fields.Set(AppInstFieldAppKey)
	}
	if m.AppKey.Version != o.AppKey.Version {
		fields.Set(AppInstFieldAppKeyVersion)
		fields.Set(AppInstFieldAppKey)
	}
	if m.ClusterKey.Name != o.ClusterKey.Name {
		fields.Set(AppInstFieldClusterKeyName)
		fields.Set(AppInstFieldClusterKey)
	}
	if m.ClusterKey.Organization != o.ClusterKey.Organization {
		fields.Set(AppInstFieldClusterKeyOrganization)
		fields.Set(AppInstFieldClusterKey)
	}
	if m.CompatibilityVersion != o.CompatibilityVersion {
		fields.Set(AppInstFieldCompatibilityVersion)
	}
	if m.VirtualClusterKey.Name != o.VirtualClusterKey.Name {
		fields.Set(AppInstFieldVirtualClusterKeyName)
		fields.Set(AppInstFieldVirtualClusterKey)
	}
	if m.VirtualClusterKey.Organization != o.VirtualClusterKey.Organization {
		fields.Set(AppInstFieldVirtualClusterKeyOrganization)
		fields.Set(AppInstFieldVirtualClusterKey)
	}
	if m.EnableIpv6 != o.EnableIpv6 {
		fields.Set(AppInstFieldEnableIpv6)
	}
	if m.ObjId != o.ObjId {
		fields.Set(AppInstFieldObjId)
	}
	if m.StaticUri != o.StaticUri {
		fields.Set(AppInstFieldStaticUri)
	}
	if m.CloudletKey.Organization != o.CloudletKey.Organization {
		fields.Set(AppInstFieldCloudletKeyOrganization)
		fields.Set(AppInstFieldCloudletKey)
	}
	if m.CloudletKey.Name != o.CloudletKey.Name {
		fields.Set(AppInstFieldCloudletKeyName)
		fields.Set(AppInstFieldCloudletKey)
	}
	if m.CloudletKey.FederatedOrganization != o.CloudletKey.FederatedOrganization {
		fields.Set(AppInstFieldCloudletKeyFederatedOrganization)
		fields.Set(AppInstFieldCloudletKey)
	}
	if m.Annotations != nil && o.Annotations != nil {
		if len(m.Annotations) != len(o.Annotations) {
			fields.Set(AppInstFieldAnnotations)
		} else {
			for k0, _ := range m.Annotations {
				_, vok0 := o.Annotations[k0]
				if !vok0 {
					fields.Set(AppInstFieldAnnotations)
				} else {
					if m.Annotations[k0] != o.Annotations[k0] {
						fields.Set(AppInstFieldAnnotations)
						break
					}
				}
			}
		}
	} else if (m.Annotations != nil && o.Annotations == nil) || (m.Annotations == nil && o.Annotations != nil) {
		fields.Set(AppInstFieldAnnotations)
	}
}

func (m *AppInst) GetDiffFields(o *AppInst) *FieldMap {
	diffFields := NewFieldMap(nil)
	m.DiffFields(o, diffFields)
	return diffFields
}

var UpdateAppInstFieldsMap = NewFieldMap(map[string]struct{}{
	AppInstFieldCrmOverride:      struct{}{},
	AppInstFieldConfigs:          struct{}{},
	AppInstFieldConfigsKind:      struct{}{},
	AppInstFieldConfigsConfig:    struct{}{},
	AppInstFieldPowerState:       struct{}{},
	AppInstFieldRealClusterName:  struct{}{},
	AppInstFieldDedicatedIp:      struct{}{},
	AppInstFieldCloudletFlavor:   struct{}{},
	AppInstFieldEnableIpv6:       struct{}{},
	AppInstFieldObjId:            struct{}{},
	AppInstFieldAnnotations:      struct{}{},
	AppInstFieldAnnotationsKey:   struct{}{},
	AppInstFieldAnnotationsValue: struct{}{},
})

func (m *AppInst) ValidateUpdateFields() error {
	if m.Fields == nil {
		return fmt.Errorf("nothing specified to update")
	}
	fmap := MakeFieldMap(m.Fields)
	badFieldStrs := []string{}
	for _, field := range fmap.Fields() {
		if m.IsKeyField(field) {
			continue
		}
		if !UpdateAppInstFieldsMap.Has(field) {
			if _, ok := AppInstAllFieldsStringMap[field]; !ok {
				continue
			}
			badFieldStrs = append(badFieldStrs, AppInstAllFieldsStringMap[field])
		}
	}
	if len(badFieldStrs) > 0 {
		return fmt.Errorf("specified field(s) %s cannot be modified", strings.Join(badFieldStrs, ","))
	}
	return nil
}

func (m *AppInst) Clone() *AppInst {
	cp := &AppInst{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *AppInst) AddMappedPorts(vals ...distributed_match_engine.AppPort) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.MappedPorts {
		cur[v.String()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.String()]; found {
			continue // duplicate
		}
		m.MappedPorts = append(m.MappedPorts, v)
		changes++
	}
	return changes
}

func (m *AppInst) RemoveMappedPorts(vals ...distributed_match_engine.AppPort) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.String()] = struct{}{}
	}
	for i := len(m.MappedPorts); i >= 0; i-- {
		if _, found := remove[m.MappedPorts[i].String()]; found {
			m.MappedPorts = append(m.MappedPorts[:i], m.MappedPorts[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *AppInst) AddErrors(vals ...string) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.Errors {
		cur[v] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v]; found {
			continue // duplicate
		}
		m.Errors = append(m.Errors, v)
		changes++
	}
	return changes
}

func (m *AppInst) RemoveErrors(vals ...string) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v] = struct{}{}
	}
	for i := len(m.Errors); i >= 0; i-- {
		if _, found := remove[m.Errors[i]]; found {
			m.Errors = append(m.Errors[:i], m.Errors[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *AppInst) AddRuntimeInfoContainerIds(vals ...string) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.RuntimeInfo.ContainerIds {
		cur[v] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v]; found {
			continue // duplicate
		}
		m.RuntimeInfo.ContainerIds = append(m.RuntimeInfo.ContainerIds, v)
		changes++
	}
	return changes
}

func (m *AppInst) RemoveRuntimeInfoContainerIds(vals ...string) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v] = struct{}{}
	}
	for i := len(m.RuntimeInfo.ContainerIds); i >= 0; i-- {
		if _, found := remove[m.RuntimeInfo.ContainerIds[i]]; found {
			m.RuntimeInfo.ContainerIds = append(m.RuntimeInfo.ContainerIds[:i], m.RuntimeInfo.ContainerIds[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *AppInst) AddConfigs(vals ...*ConfigFile) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.Configs {
		cur[v.String()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.String()]; found {
			continue // duplicate
		}
		m.Configs = append(m.Configs, v)
		changes++
	}
	return changes
}

func (m *AppInst) RemoveConfigs(vals ...*ConfigFile) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.String()] = struct{}{}
	}
	for i := len(m.Configs); i >= 0; i-- {
		if _, found := remove[m.Configs[i].String()]; found {
			m.Configs = append(m.Configs[:i], m.Configs[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *AppInst) CopyInFields(src *AppInst) int {
	updateListAction := "replace"
	changed := 0
	fmap := MakeFieldMap(src.Fields)
	if fmap.HasOrHasChild("2") {
		if fmap.Has("2.1") {
			if m.Key.Name != src.Key.Name {
				m.Key.Name = src.Key.Name
				changed++
			}
		}
		if fmap.Has("2.2") {
			if m.Key.Organization != src.Key.Organization {
				m.Key.Organization = src.Key.Organization
				changed++
			}
		}
	}
	if fmap.HasOrHasChild("3") {
		if fmap.Has("3.1") {
			if m.CloudletLoc.Latitude != src.CloudletLoc.Latitude {
				m.CloudletLoc.Latitude = src.CloudletLoc.Latitude
				changed++
			}
		}
		if fmap.Has("3.2") {
			if m.CloudletLoc.Longitude != src.CloudletLoc.Longitude {
				m.CloudletLoc.Longitude = src.CloudletLoc.Longitude
				changed++
			}
		}
		if fmap.Has("3.3") {
			if m.CloudletLoc.HorizontalAccuracy != src.CloudletLoc.HorizontalAccuracy {
				m.CloudletLoc.HorizontalAccuracy = src.CloudletLoc.HorizontalAccuracy
				changed++
			}
		}
		if fmap.Has("3.4") {
			if m.CloudletLoc.VerticalAccuracy != src.CloudletLoc.VerticalAccuracy {
				m.CloudletLoc.VerticalAccuracy = src.CloudletLoc.VerticalAccuracy
				changed++
			}
		}
		if fmap.Has("3.5") {
			if m.CloudletLoc.Altitude != src.CloudletLoc.Altitude {
				m.CloudletLoc.Altitude = src.CloudletLoc.Altitude
				changed++
			}
		}
		if fmap.Has("3.6") {
			if m.CloudletLoc.Course != src.CloudletLoc.Course {
				m.CloudletLoc.Course = src.CloudletLoc.Course
				changed++
			}
		}
		if fmap.Has("3.7") {
			if m.CloudletLoc.Speed != src.CloudletLoc.Speed {
				m.CloudletLoc.Speed = src.CloudletLoc.Speed
				changed++
			}
		}
		if fmap.HasOrHasChild("3.8") {
			if src.CloudletLoc.Timestamp != nil {
				if m.CloudletLoc.Timestamp == nil {
					m.CloudletLoc.Timestamp = &distributed_match_engine.Timestamp{}
				}
				if fmap.Has("3.8.1") {
					if m.CloudletLoc.Timestamp.Seconds != src.CloudletLoc.Timestamp.Seconds {
						m.CloudletLoc.Timestamp.Seconds = src.CloudletLoc.Timestamp.Seconds
						changed++
					}
				}
				if fmap.Has("3.8.2") {
					if m.CloudletLoc.Timestamp.Nanos != src.CloudletLoc.Timestamp.Nanos {
						m.CloudletLoc.Timestamp.Nanos = src.CloudletLoc.Timestamp.Nanos
						changed++
					}
				}
			} else if m.CloudletLoc.Timestamp != nil {
				m.CloudletLoc.Timestamp = nil
				changed++
			}
		}
	}
	if fmap.Has("4") {
		if m.Uri != src.Uri {
			m.Uri = src.Uri
			changed++
		}
	}
	if fmap.Has("6") {
		if m.Liveness != src.Liveness {
			m.Liveness = src.Liveness
			changed++
		}
	}
	if fmap.HasOrHasChild("9") {
		if src.MappedPorts != nil {
			if updateListAction == "add" {
				changed += m.AddMappedPorts(src.MappedPorts...)
			} else if updateListAction == "remove" {
				changed += m.RemoveMappedPorts(src.MappedPorts...)
			} else {
				m.MappedPorts = make([]distributed_match_engine.AppPort, 0)
				for k0, _ := range src.MappedPorts {
					m.MappedPorts = append(m.MappedPorts, *src.MappedPorts[k0].Clone())
				}
				changed++
			}
		} else if m.MappedPorts != nil {
			m.MappedPorts = nil
			changed++
		}
	}
	if fmap.HasOrHasChild("12") {
		if fmap.Has("12.1") {
			if m.Flavor.Name != src.Flavor.Name {
				m.Flavor.Name = src.Flavor.Name
				changed++
			}
		}
	}
	if fmap.Has("14") {
		if m.State != src.State {
			m.State = src.State
			changed++
		}
	}
	if fmap.Has("15") {
		if src.Errors != nil {
			if updateListAction == "add" {
				changed += m.AddErrors(src.Errors...)
			} else if updateListAction == "remove" {
				changed += m.RemoveErrors(src.Errors...)
			} else {
				m.Errors = make([]string, 0)
				m.Errors = append(m.Errors, src.Errors...)
				changed++
			}
		} else if m.Errors != nil {
			m.Errors = nil
			changed++
		}
	}
	if fmap.Has("16") {
		if m.CrmOverride != src.CrmOverride {
			m.CrmOverride = src.CrmOverride
			changed++
		}
	}
	if fmap.HasOrHasChild("17") {
		if fmap.Has("17.1") {
			if src.RuntimeInfo.ContainerIds != nil {
				if updateListAction == "add" {
					changed += m.AddRuntimeInfoContainerIds(src.RuntimeInfo.ContainerIds...)
				} else if updateListAction == "remove" {
					changed += m.RemoveRuntimeInfoContainerIds(src.RuntimeInfo.ContainerIds...)
				} else {
					m.RuntimeInfo.ContainerIds = make([]string, 0)
					m.RuntimeInfo.ContainerIds = append(m.RuntimeInfo.ContainerIds, src.RuntimeInfo.ContainerIds...)
					changed++
				}
			} else if m.RuntimeInfo.ContainerIds != nil {
				m.RuntimeInfo.ContainerIds = nil
				changed++
			}
		}
	}
	if fmap.HasOrHasChild("21") {
		if fmap.Has("21.1") {
			if m.CreatedAt.Seconds != src.CreatedAt.Seconds {
				m.CreatedAt.Seconds = src.CreatedAt.Seconds
				changed++
			}
		}
		if fmap.Has("21.2") {
			if m.CreatedAt.Nanos != src.CreatedAt.Nanos {
				m.CreatedAt.Nanos = src.CreatedAt.Nanos
				changed++
			}
		}
	}
	if fmap.Has("22") {
		if m.AutoClusterIpAccess != src.AutoClusterIpAccess {
			m.AutoClusterIpAccess = src.AutoClusterIpAccess
			changed++
		}
	}
	if fmap.Has("24") {
		if m.Revision != src.Revision {
			m.Revision = src.Revision
			changed++
		}
	}
	if fmap.Has("25") {
		if m.ForceUpdate != src.ForceUpdate {
			m.ForceUpdate = src.ForceUpdate
			changed++
		}
	}
	if fmap.Has("26") {
		if m.UpdateMultiple != src.UpdateMultiple {
			m.UpdateMultiple = src.UpdateMultiple
			changed++
		}
	}
	if fmap.HasOrHasChild("27") {
		if src.Configs != nil {
			if updateListAction == "add" {
				changed += m.AddConfigs(src.Configs...)
			} else if updateListAction == "remove" {
				changed += m.RemoveConfigs(src.Configs...)
			} else {
				m.Configs = make([]*ConfigFile, 0)
				for k0, _ := range src.Configs {
					m.Configs = append(m.Configs, src.Configs[k0].Clone())
				}
				changed++
			}
		} else if m.Configs != nil {
			m.Configs = nil
			changed++
		}
	}
	if fmap.Has("29") {
		if m.HealthCheck != src.HealthCheck {
			m.HealthCheck = src.HealthCheck
			changed++
		}
	}
	if fmap.Has("31") {
		if m.PowerState != src.PowerState {
			m.PowerState = src.PowerState
			changed++
		}
	}
	if fmap.Has("32") {
		if m.ExternalVolumeSize != src.ExternalVolumeSize {
			m.ExternalVolumeSize = src.ExternalVolumeSize
			changed++
		}
	}
	if fmap.Has("33") {
		if m.AvailabilityZone != src.AvailabilityZone {
			m.AvailabilityZone = src.AvailabilityZone
			changed++
		}
	}
	if fmap.Has("34") {
		if m.VmFlavor != src.VmFlavor {
			m.VmFlavor = src.VmFlavor
			changed++
		}
	}
	if fmap.Has("35") {
		if m.OptRes != src.OptRes {
			m.OptRes = src.OptRes
			changed++
		}
	}
	if fmap.HasOrHasChild("36") {
		if fmap.Has("36.1") {
			if m.UpdatedAt.Seconds != src.UpdatedAt.Seconds {
				m.UpdatedAt.Seconds = src.UpdatedAt.Seconds
				changed++
			}
		}
		if fmap.Has("36.2") {
			if m.UpdatedAt.Nanos != src.UpdatedAt.Nanos {
				m.UpdatedAt.Nanos = src.UpdatedAt.Nanos
				changed++
			}
		}
	}
	if fmap.Has("37") {
		if m.RealClusterName != src.RealClusterName {
			m.RealClusterName = src.RealClusterName
			changed++
		}
	}
	if fmap.HasOrHasChild("38") {
		if src.InternalPortToLbIp != nil {
			if updateListAction == "add" {
				for k0, v := range src.InternalPortToLbIp {
					m.InternalPortToLbIp[k0] = v
					changed++
				}
			} else if updateListAction == "remove" {
				for k0, _ := range src.InternalPortToLbIp {
					if _, ok := m.InternalPortToLbIp[k0]; ok {
						delete(m.InternalPortToLbIp, k0)
						changed++
					}
				}
			} else {
				m.InternalPortToLbIp = make(map[string]string)
				for k0, v := range src.InternalPortToLbIp {
					m.InternalPortToLbIp[k0] = v
				}
				changed++
			}
		} else if m.InternalPortToLbIp != nil {
			m.InternalPortToLbIp = nil
			changed++
		}
	}
	if fmap.Has("39") {
		if m.DedicatedIp != src.DedicatedIp {
			m.DedicatedIp = src.DedicatedIp
			changed++
		}
	}
	if fmap.Has("40") {
		if m.UniqueId != src.UniqueId {
			m.UniqueId = src.UniqueId
			changed++
		}
	}
	if fmap.Has("41") {
		if m.DnsLabel != src.DnsLabel {
			m.DnsLabel = src.DnsLabel
			changed++
		}
	}
	if fmap.Has("42") {
		if m.CloudletFlavor != src.CloudletFlavor {
			m.CloudletFlavor = src.CloudletFlavor
			changed++
		}
	}
	if fmap.HasOrHasChild("43") {
		if fmap.Has("43.1") {
			if m.FedKey.FederationName != src.FedKey.FederationName {
				m.FedKey.FederationName = src.FedKey.FederationName
				changed++
			}
		}
		if fmap.Has("43.2") {
			if m.FedKey.AppInstId != src.FedKey.AppInstId {
				m.FedKey.AppInstId = src.FedKey.AppInstId
				changed++
			}
		}
	}
	if fmap.HasOrHasChild("44") {
		if fmap.Has("44.1") {
			if m.AppKey.Organization != src.AppKey.Organization {
				m.AppKey.Organization = src.AppKey.Organization
				changed++
			}
		}
		if fmap.Has("44.2") {
			if m.AppKey.Name != src.AppKey.Name {
				m.AppKey.Name = src.AppKey.Name
				changed++
			}
		}
		if fmap.Has("44.3") {
			if m.AppKey.Version != src.AppKey.Version {
				m.AppKey.Version = src.AppKey.Version
				changed++
			}
		}
	}
	if fmap.HasOrHasChild("45") {
		if fmap.Has("45.1") {
			if m.ClusterKey.Name != src.ClusterKey.Name {
				m.ClusterKey.Name = src.ClusterKey.Name
				changed++
			}
		}
		if fmap.Has("45.2") {
			if m.ClusterKey.Organization != src.ClusterKey.Organization {
				m.ClusterKey.Organization = src.ClusterKey.Organization
				changed++
			}
		}
	}
	if fmap.Has("46") {
		if m.CompatibilityVersion != src.CompatibilityVersion {
			m.CompatibilityVersion = src.CompatibilityVersion
			changed++
		}
	}
	if fmap.HasOrHasChild("47") {
		if fmap.Has("47.1") {
			if m.VirtualClusterKey.Name != src.VirtualClusterKey.Name {
				m.VirtualClusterKey.Name = src.VirtualClusterKey.Name
				changed++
			}
		}
		if fmap.Has("47.2") {
			if m.VirtualClusterKey.Organization != src.VirtualClusterKey.Organization {
				m.VirtualClusterKey.Organization = src.VirtualClusterKey.Organization
				changed++
			}
		}
	}
	if fmap.Has("48") {
		if m.EnableIpv6 != src.EnableIpv6 {
			m.EnableIpv6 = src.EnableIpv6
			changed++
		}
	}
	if fmap.Has("49") {
		if m.ObjId != src.ObjId {
			m.ObjId = src.ObjId
			changed++
		}
	}
	if fmap.Has("50") {
		if m.StaticUri != src.StaticUri {
			m.StaticUri = src.StaticUri
			changed++
		}
	}
	if fmap.HasOrHasChild("51") {
		if fmap.Has("51.1") {
			if m.CloudletKey.Organization != src.CloudletKey.Organization {
				m.CloudletKey.Organization = src.CloudletKey.Organization
				changed++
			}
		}
		if fmap.Has("51.2") {
			if m.CloudletKey.Name != src.CloudletKey.Name {
				m.CloudletKey.Name = src.CloudletKey.Name
				changed++
			}
		}
		if fmap.Has("51.3") {
			if m.CloudletKey.FederatedOrganization != src.CloudletKey.FederatedOrganization {
				m.CloudletKey.FederatedOrganization = src.CloudletKey.FederatedOrganization
				changed++
			}
		}
	}
	if fmap.HasOrHasChild("52") {
		if src.Annotations != nil {
			if updateListAction == "add" {
				for k0, v := range src.Annotations {
					m.Annotations[k0] = v
					changed++
				}
			} else if updateListAction == "remove" {
				for k0, _ := range src.Annotations {
					if _, ok := m.Annotations[k0]; ok {
						delete(m.Annotations, k0)
						changed++
					}
				}
			} else {
				m.Annotations = make(map[string]string)
				for k0, v := range src.Annotations {
					m.Annotations[k0] = v
				}
				changed++
			}
		} else if m.Annotations != nil {
			m.Annotations = nil
			changed++
		}
	}
	return changed
}

func (m *AppInst) DeepCopyIn(src *AppInst) {
	m.Key.DeepCopyIn(&src.Key)
	m.CloudletLoc = src.CloudletLoc
	m.Uri = src.Uri
	m.Liveness = src.Liveness
	if src.MappedPorts != nil {
		m.MappedPorts = make([]distributed_match_engine.AppPort, len(src.MappedPorts), len(src.MappedPorts))
		for ii, s := range src.MappedPorts {
			m.MappedPorts[ii] = s
		}
	} else {
		m.MappedPorts = nil
	}
	m.Flavor.DeepCopyIn(&src.Flavor)
	m.State = src.State
	if src.Errors != nil {
		m.Errors = make([]string, len(src.Errors), len(src.Errors))
		for ii, s := range src.Errors {
			m.Errors[ii] = s
		}
	} else {
		m.Errors = nil
	}
	m.CrmOverride = src.CrmOverride
	m.RuntimeInfo.DeepCopyIn(&src.RuntimeInfo)
	m.CreatedAt = src.CreatedAt
	m.AutoClusterIpAccess = src.AutoClusterIpAccess
	m.Revision = src.Revision
	m.ForceUpdate = src.ForceUpdate
	m.UpdateMultiple = src.UpdateMultiple
	if src.Configs != nil {
		m.Configs = make([]*ConfigFile, len(src.Configs), len(src.Configs))
		for ii, s := range src.Configs {
			var tmp_s ConfigFile
			tmp_s.DeepCopyIn(s)
			m.Configs[ii] = &tmp_s
		}
	} else {
		m.Configs = nil
	}
	m.HealthCheck = src.HealthCheck
	m.PowerState = src.PowerState
	m.ExternalVolumeSize = src.ExternalVolumeSize
	m.AvailabilityZone = src.AvailabilityZone
	m.VmFlavor = src.VmFlavor
	m.OptRes = src.OptRes
	m.UpdatedAt = src.UpdatedAt
	m.RealClusterName = src.RealClusterName
	if src.InternalPortToLbIp != nil {
		m.InternalPortToLbIp = make(map[string]string)
		for k, v := range src.InternalPortToLbIp {
			m.InternalPortToLbIp[k] = v
		}
	} else {
		m.InternalPortToLbIp = nil
	}
	m.DedicatedIp = src.DedicatedIp
	m.UniqueId = src.UniqueId
	m.DnsLabel = src.DnsLabel
	m.CloudletFlavor = src.CloudletFlavor
	m.FedKey.DeepCopyIn(&src.FedKey)
	m.AppKey.DeepCopyIn(&src.AppKey)
	m.ClusterKey.DeepCopyIn(&src.ClusterKey)
	m.CompatibilityVersion = src.CompatibilityVersion
	m.VirtualClusterKey.DeepCopyIn(&src.VirtualClusterKey)
	m.EnableIpv6 = src.EnableIpv6
	m.ObjId = src.ObjId
	m.StaticUri = src.StaticUri
	m.CloudletKey.DeepCopyIn(&src.CloudletKey)
	if src.Annotations != nil {
		m.Annotations = make(map[string]string)
		for k, v := range src.Annotations {
			m.Annotations[k] = v
		}
	} else {
		m.Annotations = nil
	}
}

func (s *AppInst) HasFields() bool {
	return true
}

type AppInstStore interface {
	Create(ctx context.Context, m *AppInst, wait func(int64)) (*Result, error)
	Update(ctx context.Context, m *AppInst, wait func(int64)) (*Result, error)
	Delete(ctx context.Context, m *AppInst, wait func(int64)) (*Result, error)
	Put(ctx context.Context, m *AppInst, wait func(int64), ops ...objstore.KVOp) (*Result, error)
	LoadOne(key string) (*AppInst, int64, error)
	Get(ctx context.Context, key *AppInstKey, buf *AppInst) bool
	STMGet(stm concurrency.STM, key *AppInstKey, buf *AppInst) bool
	STMPut(stm concurrency.STM, obj *AppInst, ops ...objstore.KVOp)
	STMDel(stm concurrency.STM, key *AppInstKey)
	STMHas(stm concurrency.STM, key *AppInstKey) bool
}

type AppInstStoreImpl struct {
	kvstore objstore.KVStore
}

func NewAppInstStore(kvstore objstore.KVStore) *AppInstStoreImpl {
	return &AppInstStoreImpl{kvstore: kvstore}
}

func (s *AppInstStoreImpl) Create(ctx context.Context, m *AppInst, wait func(int64)) (*Result, error) {
	err := m.Validate(AppInstAllFieldsMap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("AppInst", m.GetKey())
	val, err := json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Create(ctx, key, string(val))
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *AppInstStoreImpl) Update(ctx context.Context, m *AppInst, wait func(int64)) (*Result, error) {
	fmap := MakeFieldMap(m.Fields)
	err := m.Validate(fmap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("AppInst", m.GetKey())
	var vers int64 = 0
	curBytes, vers, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, err
	}
	var cur AppInst
	err = json.Unmarshal(curBytes, &cur)
	if err != nil {
		return nil, err
	}
	cur.CopyInFields(m)
	// never save fields
	cur.Fields = nil
	val, err := json.Marshal(cur)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Update(ctx, key, string(val), vers)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *AppInstStoreImpl) Put(ctx context.Context, m *AppInst, wait func(int64), ops ...objstore.KVOp) (*Result, error) {
	err := m.Validate(AppInstAllFieldsMap)
	m.Fields = nil
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("AppInst", m.GetKey())
	var val []byte
	val, err = json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Put(ctx, key, string(val), ops...)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *AppInstStoreImpl) Delete(ctx context.Context, m *AppInst, wait func(int64)) (*Result, error) {
	err := m.GetKey().ValidateKey()
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("AppInst", m.GetKey())
	rev, err := s.kvstore.Delete(ctx, key)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *AppInstStoreImpl) LoadOne(key string) (*AppInst, int64, error) {
	val, rev, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, 0, err
	}
	var obj AppInst
	err = json.Unmarshal(val, &obj)
	if err != nil {
		log.DebugLog(log.DebugLevelApi, "Failed to parse AppInst data", "val", string(val), "err", err)
		return nil, 0, err
	}
	return &obj, rev, nil
}

func (s *AppInstStoreImpl) Get(ctx context.Context, key *AppInstKey, buf *AppInst) bool {
	keystr := objstore.DbKeyString("AppInst", key)
	val, _, _, err := s.kvstore.Get(keystr)
	if err != nil {
		return false
	}
	return s.parseGetData(val, buf)
}

func (s *AppInstStoreImpl) STMGet(stm concurrency.STM, key *AppInstKey, buf *AppInst) bool {
	keystr := objstore.DbKeyString("AppInst", key)
	valstr := stm.Get(keystr)
	return s.parseGetData([]byte(valstr), buf)
}

func (s *AppInstStoreImpl) STMHas(stm concurrency.STM, key *AppInstKey) bool {
	keystr := objstore.DbKeyString("AppInst", key)
	return stm.Get(keystr) != ""
}

func (s *AppInstStoreImpl) parseGetData(val []byte, buf *AppInst) bool {
	if len(val) == 0 {
		return false
	}
	if buf != nil {
		// clear buf, because empty values in val won't
		// overwrite non-empty values in buf.
		*buf = AppInst{}
		err := json.Unmarshal(val, buf)
		if err != nil {
			return false
		}
	}
	return true
}

func (s *AppInstStoreImpl) STMPut(stm concurrency.STM, obj *AppInst, ops ...objstore.KVOp) {
	keystr := objstore.DbKeyString("AppInst", obj.GetKey())

	val, err := json.Marshal(obj)
	if err != nil {
		log.InfoLog("AppInst json marshal failed", "obj", obj, "err", err)
	}
	v3opts := GetSTMOpts(ops...)
	stm.Put(keystr, string(val), v3opts...)
}

func (s *AppInstStoreImpl) STMDel(stm concurrency.STM, key *AppInstKey) {
	keystr := objstore.DbKeyString("AppInst", key)
	stm.Del(keystr)
}

type AppInstKeyWatcher struct {
	cb func(ctx context.Context)
}

type AppInstCacheData struct {
	Obj    *AppInst
	ModRev int64
}

func (s *AppInstCacheData) Clone() *AppInstCacheData {
	cp := AppInstCacheData{}
	if s.Obj != nil {
		cp.Obj = &AppInst{}
		cp.Obj.DeepCopyIn(s.Obj)
	}
	cp.ModRev = s.ModRev
	return &cp
}

// AppInstCache caches AppInst objects in memory in a hash table
// and keeps them in sync with the database.
type AppInstCache struct {
	Objs          map[AppInstKey]*AppInstCacheData
	Mux           util.Mutex
	List          map[AppInstKey]struct{}
	FlushAll      bool
	NotifyCbs     []func(ctx context.Context, obj *AppInst, modRev int64)
	UpdatedCbs    []func(ctx context.Context, old *AppInst, new *AppInst)
	DeletedCbs    []func(ctx context.Context, old *AppInst)
	KeyWatchers   map[AppInstKey][]*AppInstKeyWatcher
	UpdatedKeyCbs []func(ctx context.Context, key *AppInstKey)
	DeletedKeyCbs []func(ctx context.Context, key *AppInstKey)
	Store         AppInstStore
}

func NewAppInstCache() *AppInstCache {
	cache := AppInstCache{}
	InitAppInstCache(&cache)
	return &cache
}

func InitAppInstCache(cache *AppInstCache) {
	cache.Objs = make(map[AppInstKey]*AppInstCacheData)
	cache.KeyWatchers = make(map[AppInstKey][]*AppInstKeyWatcher)
	cache.NotifyCbs = nil
	cache.UpdatedCbs = nil
	cache.DeletedCbs = nil
	cache.UpdatedKeyCbs = nil
	cache.DeletedKeyCbs = nil
}

func (c *AppInstCache) GetTypeString() string {
	return "AppInst"
}

func (c *AppInstCache) Get(key *AppInstKey, valbuf *AppInst) bool {
	var modRev int64
	return c.GetWithRev(key, valbuf, &modRev)
}

func (c *AppInstCache) GetWithRev(key *AppInstKey, valbuf *AppInst, modRev *int64) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	inst, found := c.Objs[*key]
	if found {
		valbuf.DeepCopyIn(inst.Obj)
		*modRev = inst.ModRev
	}
	return found
}

func (c *AppInstCache) HasKey(key *AppInstKey) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	_, found := c.Objs[*key]
	return found
}

func (c *AppInstCache) GetAllKeys(ctx context.Context, cb func(key *AppInstKey, modRev int64)) {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for key, data := range c.Objs {
		cb(&key, data.ModRev)
	}
}

func (c *AppInstCache) GetAllLocked(ctx context.Context, cb func(obj *AppInst, modRev int64)) {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for _, data := range c.Objs {
		cb(data.Obj, data.ModRev)
	}
}

func (c *AppInstCache) Update(ctx context.Context, in *AppInst, modRev int64) {
	c.UpdateModFunc(ctx, in.GetKey(), modRev, func(old *AppInst) (*AppInst, bool) {
		return in, true
	})
}

func (c *AppInstCache) UpdateModFunc(ctx context.Context, key *AppInstKey, modRev int64, modFunc func(old *AppInst) (new *AppInst, changed bool)) {
	c.Mux.Lock()
	var old *AppInst
	if oldData, found := c.Objs[*key]; found {
		old = oldData.Obj
	}
	new, changed := modFunc(old)
	if !changed {
		c.Mux.Unlock()
		return
	}
	if len(c.UpdatedCbs) > 0 || len(c.NotifyCbs) > 0 {
		newCopy := &AppInst{}
		newCopy.DeepCopyIn(new)
		for _, cb := range c.UpdatedCbs {
			defer cb(ctx, old, newCopy)
		}
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				defer cb(ctx, newCopy, modRev)
			}
		}
	}
	for _, cb := range c.UpdatedKeyCbs {
		defer cb(ctx, key)
	}
	store := &AppInst{}
	store.DeepCopyIn(new)
	c.Objs[new.GetKeyVal()] = &AppInstCacheData{
		Obj:    store,
		ModRev: modRev,
	}
	log.SpanLog(ctx, log.DebugLevelApi, "cache update", "new", store)
	c.Mux.Unlock()
	c.TriggerKeyWatchers(ctx, new.GetKey())
}

func (c *AppInstCache) Delete(ctx context.Context, in *AppInst, modRev int64) {
	c.DeleteCondFunc(ctx, in, modRev, func(old *AppInst) bool {
		return true
	})
}

func (c *AppInstCache) DeleteCondFunc(ctx context.Context, in *AppInst, modRev int64, condFunc func(old *AppInst) bool) {
	c.Mux.Lock()
	var old *AppInst
	oldData, found := c.Objs[in.GetKeyVal()]
	if found {
		old = oldData.Obj
		if !condFunc(old) {
			c.Mux.Unlock()
			return
		}
	}
	delete(c.Objs, in.GetKeyVal())
	log.SpanLog(ctx, log.DebugLevelApi, "cache delete", "key", in.GetKeyVal())
	c.Mux.Unlock()
	obj := old
	if obj == nil {
		obj = in
	}
	for _, cb := range c.NotifyCbs {
		if cb != nil {
			cb(ctx, obj, modRev)
		}
	}
	if old != nil {
		for _, cb := range c.DeletedCbs {
			cb(ctx, old)
		}
	}
	for _, cb := range c.DeletedKeyCbs {
		cb(ctx, in.GetKey())
	}
	c.TriggerKeyWatchers(ctx, in.GetKey())
}

func (c *AppInstCache) Prune(ctx context.Context, validKeys map[AppInstKey]struct{}) {
	log.SpanLog(ctx, log.DebugLevelApi, "Prune AppInst", "numValidKeys", len(validKeys))
	notify := make(map[AppInstKey]*AppInstCacheData)
	c.Mux.Lock()
	for key, _ := range c.Objs {
		if _, ok := validKeys[key]; !ok {
			if len(c.NotifyCbs) > 0 || len(c.DeletedKeyCbs) > 0 || len(c.DeletedCbs) > 0 {
				notify[key] = c.Objs[key]
			}
			delete(c.Objs, key)
		}
	}
	c.Mux.Unlock()
	for key, old := range notify {
		obj := old.Obj
		if obj == nil {
			obj = &AppInst{}
			obj.SetKey(&key)
		}
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, obj, old.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if old.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, old.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (c *AppInstCache) GetCount() int {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	return len(c.Objs)
}

func (c *AppInstCache) Flush(ctx context.Context, notifyId int64) {
}

func (c *AppInstCache) Show(filter *AppInst, cb func(ret *AppInst) error) error {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for _, data := range c.Objs {
		if !data.Obj.Matches(filter, MatchFilter()) {
			continue
		}
		err := cb(data.Obj)
		if err != nil {
			return err
		}
	}
	return nil
}

func AppInstGenericNotifyCb(fn func(key *AppInstKey, old *AppInst)) func(objstore.ObjKey, objstore.Obj) {
	return func(objkey objstore.ObjKey, obj objstore.Obj) {
		fn(objkey.(*AppInstKey), obj.(*AppInst))
	}
}

func (c *AppInstCache) SetNotifyCb(fn func(ctx context.Context, obj *AppInst, modRev int64)) {
	c.NotifyCbs = []func(ctx context.Context, obj *AppInst, modRev int64){fn}
}

func (c *AppInstCache) SetUpdatedCb(fn func(ctx context.Context, old *AppInst, new *AppInst)) {
	c.UpdatedCbs = []func(ctx context.Context, old *AppInst, new *AppInst){fn}
}

func (c *AppInstCache) SetDeletedCb(fn func(ctx context.Context, old *AppInst)) {
	c.DeletedCbs = []func(ctx context.Context, old *AppInst){fn}
}

func (c *AppInstCache) SetUpdatedKeyCb(fn func(ctx context.Context, key *AppInstKey)) {
	c.UpdatedKeyCbs = []func(ctx context.Context, key *AppInstKey){fn}
}

func (c *AppInstCache) SetDeletedKeyCb(fn func(ctx context.Context, key *AppInstKey)) {
	c.DeletedKeyCbs = []func(ctx context.Context, key *AppInstKey){fn}
}

func (c *AppInstCache) AddUpdatedCb(fn func(ctx context.Context, old *AppInst, new *AppInst)) {
	c.UpdatedCbs = append(c.UpdatedCbs, fn)
}

func (c *AppInstCache) AddDeletedCb(fn func(ctx context.Context, old *AppInst)) {
	c.DeletedCbs = append(c.DeletedCbs, fn)
}

func (c *AppInstCache) AddNotifyCb(fn func(ctx context.Context, obj *AppInst, modRev int64)) {
	c.NotifyCbs = append(c.NotifyCbs, fn)
}

func (c *AppInstCache) AddUpdatedKeyCb(fn func(ctx context.Context, key *AppInstKey)) {
	c.UpdatedKeyCbs = append(c.UpdatedKeyCbs, fn)
}

func (c *AppInstCache) AddDeletedKeyCb(fn func(ctx context.Context, key *AppInstKey)) {
	c.DeletedKeyCbs = append(c.DeletedKeyCbs, fn)
}

func (c *AppInstCache) SetFlushAll() {
	c.FlushAll = true
}

func (c *AppInstCache) WatchKey(key *AppInstKey, cb func(ctx context.Context)) context.CancelFunc {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	list, ok := c.KeyWatchers[*key]
	if !ok {
		list = make([]*AppInstKeyWatcher, 0)
	}
	watcher := AppInstKeyWatcher{cb: cb}
	c.KeyWatchers[*key] = append(list, &watcher)
	log.DebugLog(log.DebugLevelApi, "Watching AppInst", "key", key)
	return func() {
		c.Mux.Lock()
		defer c.Mux.Unlock()
		list, ok := c.KeyWatchers[*key]
		if !ok {
			return
		}
		for ii, _ := range list {
			if list[ii] != &watcher {
				continue
			}
			if len(list) == 1 {
				delete(c.KeyWatchers, *key)
				return
			}
			list[ii] = list[len(list)-1]
			list[len(list)-1] = nil
			c.KeyWatchers[*key] = list[:len(list)-1]
			return
		}
	}
}

func (c *AppInstCache) TriggerKeyWatchers(ctx context.Context, key *AppInstKey) {
	watchers := make([]*AppInstKeyWatcher, 0)
	c.Mux.Lock()
	if list, ok := c.KeyWatchers[*key]; ok {
		watchers = append(watchers, list...)
	}
	c.Mux.Unlock()
	for ii, _ := range watchers {
		watchers[ii].cb(ctx)
	}
}

// Note that we explicitly ignore the global revision number, because of the way
// the notify framework sends updates (by hashing keys and doing lookups, instead
// of sequentially through a history buffer), updates may be done out-of-order
// or multiple updates compressed into one update, so the state of the cache at
// any point in time may not by in sync with a particular database revision number.

func (c *AppInstCache) SyncUpdate(ctx context.Context, key, val []byte, rev, modRev int64) {
	obj := AppInst{}
	err := json.Unmarshal(val, &obj)
	if err != nil {
		log.WarnLog("Failed to parse AppInst data", "val", string(val), "err", err)
		return
	}
	c.Update(ctx, &obj, modRev)
	c.Mux.Lock()
	if c.List != nil {
		c.List[obj.GetKeyVal()] = struct{}{}
	}
	c.Mux.Unlock()
}

func (c *AppInstCache) SyncDelete(ctx context.Context, key []byte, rev, modRev int64) {
	obj := AppInst{}
	keystr := objstore.DbKeyPrefixRemove(string(key))
	AppInstKeyStringParse(keystr, obj.GetKey())
	c.Delete(ctx, &obj, modRev)
}

func (c *AppInstCache) SyncListStart(ctx context.Context) {
	c.List = make(map[AppInstKey]struct{})
}

func (c *AppInstCache) SyncListEnd(ctx context.Context) {
	deleted := make(map[AppInstKey]*AppInstCacheData)
	c.Mux.Lock()
	for key, val := range c.Objs {
		if _, found := c.List[key]; !found {
			deleted[key] = val
			delete(c.Objs, key)
		}
	}
	c.List = nil
	c.Mux.Unlock()
	for key, val := range deleted {
		obj := val.Obj
		if obj == nil {
			obj = &AppInst{}
			obj.SetKey(&key)
		}
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, obj, val.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if val.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, val.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (s *AppInstCache) InitCacheWithSync(sync DataSync) {
	InitAppInstCache(s)
	s.InitSync(sync)
}

func (s *AppInstCache) InitSync(sync DataSync) {
	if sync != nil {
		s.Store = NewAppInstStore(sync.GetKVStore())
		sync.RegisterCache(s)
	}
}

func (c *AppInstCache) UsesOrg(org string) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for key, val := range c.Objs {
		if key.Organization == org {
			return true
		}
		if val.Obj.CloudletKey.Organization == org {
			return true
		}
	}
	return false
}

func (m *AppInst) GetObjKey() objstore.ObjKey {
	return m.GetKey()
}

func (m *AppInst) GetKey() *AppInstKey {
	return &m.Key
}

func (m *AppInst) GetKeyVal() AppInstKey {
	return m.Key
}

func (m *AppInst) SetKey(key *AppInstKey) {
	m.Key = *key
}

func CmpSortAppInst(a AppInst, b AppInst) bool {
	return a.Key.GetKeyString() < b.Key.GetKeyString()
}
func (m *AppInstKey) StreamKey() string {
	return fmt.Sprintf("AppInstStreamKey: %s", m.String())
}

// Helper method to check that enums have valid values
// NOTE: ValidateEnums checks all Fields even if some are not set
func (m *AppInst) ValidateEnums() error {
	if err := m.Key.ValidateEnums(); err != nil {
		return err
	}
	if _, ok := Liveness_name[int32(m.Liveness)]; !ok {
		return errors.New("invalid Liveness")
	}
	if err := m.Flavor.ValidateEnums(); err != nil {
		return err
	}
	if _, ok := TrackedState_name[int32(m.State)]; !ok {
		return errors.New("invalid State")
	}
	if _, ok := CRMOverride_name[int32(m.CrmOverride)]; !ok {
		return errors.New("invalid CrmOverride")
	}
	if err := m.RuntimeInfo.ValidateEnums(); err != nil {
		return err
	}
	if _, ok := IpAccess_name[int32(m.AutoClusterIpAccess)]; !ok {
		return errors.New("invalid AutoClusterIpAccess")
	}
	for _, e := range m.Configs {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	if _, ok := distributed_match_engine.HealthCheck_name[int32(m.HealthCheck)]; !ok {
		return errors.New("invalid HealthCheck")
	}
	if _, ok := PowerState_name[int32(m.PowerState)]; !ok {
		return errors.New("invalid PowerState")
	}
	if err := m.FedKey.ValidateEnums(); err != nil {
		return err
	}
	if err := m.AppKey.ValidateEnums(); err != nil {
		return err
	}
	if err := m.ClusterKey.ValidateEnums(); err != nil {
		return err
	}
	if err := m.VirtualClusterKey.ValidateEnums(); err != nil {
		return err
	}
	if err := m.CloudletKey.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func (s *AppInst) ClearTagged(tags map[string]struct{}) {
	s.Key.ClearTagged(tags)
	s.Flavor.ClearTagged(tags)
	s.RuntimeInfo.ClearTagged(tags)
	if _, found := tags["timestamp"]; found {
		s.CreatedAt = distributed_match_engine.Timestamp{}
	}
	if _, found := tags["nocmp"]; found {
		s.Revision = ""
	}
	if _, found := tags["nocmp"]; found {
		s.ForceUpdate = false
	}
	if _, found := tags["nocmp"]; found {
		s.UpdateMultiple = false
	}
	if s.Configs != nil {
		for ii := 0; ii < len(s.Configs); ii++ {
			s.Configs[ii].ClearTagged(tags)
		}
	}
	if _, found := tags["timestamp"]; found {
		s.UpdatedAt = distributed_match_engine.Timestamp{}
	}
	s.FedKey.ClearTagged(tags)
	s.AppKey.ClearTagged(tags)
	s.ClusterKey.ClearTagged(tags)
	if _, found := tags["nocmp"]; found {
		s.CompatibilityVersion = 0
	}
	if _, found := tags["nocmp"]; found {
		s.VirtualClusterKey = ClusterKey{}
	}
	if _, found := tags["nocmp"]; found {
		s.ObjId = ""
	}
	s.CloudletKey.ClearTagged(tags)
}

func IgnoreAppInstFields(taglist string) cmp.Option {
	names := []string{}
	tags := make(map[string]struct{})
	for _, tag := range strings.Split(taglist, ",") {
		tags[tag] = struct{}{}
	}
	if _, found := tags["timestamp"]; found {
		names = append(names, "CreatedAt")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Revision")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "ForceUpdate")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "UpdateMultiple")
	}
	if _, found := tags["timestamp"]; found {
		names = append(names, "UpdatedAt")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "CompatibilityVersion")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "VirtualClusterKey")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "ObjId")
	}
	return cmpopts.IgnoreFields(AppInst{}, names...)
}

func (m *AppInstRuntime) Clone() *AppInstRuntime {
	cp := &AppInstRuntime{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *AppInstRuntime) AddContainerIds(vals ...string) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.ContainerIds {
		cur[v] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v]; found {
			continue // duplicate
		}
		m.ContainerIds = append(m.ContainerIds, v)
		changes++
	}
	return changes
}

func (m *AppInstRuntime) RemoveContainerIds(vals ...string) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v] = struct{}{}
	}
	for i := len(m.ContainerIds); i >= 0; i-- {
		if _, found := remove[m.ContainerIds[i]]; found {
			m.ContainerIds = append(m.ContainerIds[:i], m.ContainerIds[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *AppInstRuntime) CopyInFields(src *AppInstRuntime) int {
	updateListAction := "replace"
	changed := 0
	if src.ContainerIds != nil {
		if updateListAction == "add" {
			changed += m.AddContainerIds(src.ContainerIds...)
		} else if updateListAction == "remove" {
			changed += m.RemoveContainerIds(src.ContainerIds...)
		} else {
			m.ContainerIds = make([]string, 0)
			m.ContainerIds = append(m.ContainerIds, src.ContainerIds...)
			changed++
		}
	} else if m.ContainerIds != nil {
		m.ContainerIds = nil
		changed++
	}
	return changed
}

func (m *AppInstRuntime) DeepCopyIn(src *AppInstRuntime) {
	if src.ContainerIds != nil {
		m.ContainerIds = make([]string, len(src.ContainerIds), len(src.ContainerIds))
		for ii, s := range src.ContainerIds {
			m.ContainerIds[ii] = s
		}
	} else {
		m.ContainerIds = nil
	}
}

// Helper method to check that enums have valid values
func (m *AppInstRuntime) ValidateEnums() error {
	return nil
}

func (s *AppInstRuntime) ClearTagged(tags map[string]struct{}) {
}

func (m *AppInstInfo) Matches(o *AppInstInfo, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !m.Key.Matches(&o.Key, fopts...) {
		return false
	}
	if !opts.Filter || o.NotifyId != 0 {
		if o.NotifyId != m.NotifyId {
			return false
		}
	}
	if !opts.Filter || o.State != 0 {
		if o.State != m.State {
			return false
		}
	}
	if !opts.Filter || o.Errors != nil {
		if len(m.Errors) == 0 && len(o.Errors) > 0 || len(m.Errors) > 0 && len(o.Errors) == 0 {
			return false
		} else if m.Errors != nil && o.Errors != nil {
			if !opts.Filter && len(m.Errors) != len(o.Errors) {
				return false
			}
			found := 0
			for oIndex, _ := range o.Errors {
				for mIndex, _ := range m.Errors {
					if o.Errors[oIndex] == m.Errors[mIndex] {
						found++
						break
					}
				}
			}
			if found != len(o.Errors) {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
	}
	if !opts.Filter || o.PowerState != 0 {
		if o.PowerState != m.PowerState {
			return false
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.Uri != "" {
			if o.Uri != m.Uri {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !m.FedKey.Matches(&o.FedKey, fopts...) {
			return false
		}
	}
	if !opts.Filter || o.FedPorts != nil {
		if len(m.FedPorts) == 0 && len(o.FedPorts) > 0 || len(m.FedPorts) > 0 && len(o.FedPorts) == 0 {
			return false
		} else if m.FedPorts != nil && o.FedPorts != nil {
			if !opts.Filter && len(m.FedPorts) != len(o.FedPorts) {
				return false
			}
		}
	}
	return true
}

const AppInstInfoFieldKey = "2"
const AppInstInfoFieldKeyName = "2.1"
const AppInstInfoFieldKeyOrganization = "2.2"
const AppInstInfoFieldNotifyId = "3"
const AppInstInfoFieldState = "4"
const AppInstInfoFieldErrors = "5"
const AppInstInfoFieldRuntimeInfo = "6"
const AppInstInfoFieldRuntimeInfoContainerIds = "6.1"
const AppInstInfoFieldStatus = "7"
const AppInstInfoFieldStatusTaskNumber = "7.1"
const AppInstInfoFieldStatusMaxTasks = "7.2"
const AppInstInfoFieldStatusTaskName = "7.3"
const AppInstInfoFieldStatusStepName = "7.4"
const AppInstInfoFieldStatusMsgCount = "7.5"
const AppInstInfoFieldStatusMsgs = "7.6"
const AppInstInfoFieldPowerState = "8"
const AppInstInfoFieldUri = "9"
const AppInstInfoFieldFedKey = "10"
const AppInstInfoFieldFedKeyFederationName = "10.1"
const AppInstInfoFieldFedKeyAppInstId = "10.2"
const AppInstInfoFieldFedPorts = "11"
const AppInstInfoFieldFedPortsProto = "11.1"
const AppInstInfoFieldFedPortsInternalPort = "11.2"
const AppInstInfoFieldFedPortsPublicPort = "11.3"
const AppInstInfoFieldFedPortsFqdnPrefix = "11.5"
const AppInstInfoFieldFedPortsEndPort = "11.6"
const AppInstInfoFieldFedPortsTls = "11.7"
const AppInstInfoFieldFedPortsNginx = "11.8"
const AppInstInfoFieldFedPortsMaxPktSize = "11.9"

var AppInstInfoAllFields = []string{
	AppInstInfoFieldKeyName,
	AppInstInfoFieldKeyOrganization,
	AppInstInfoFieldNotifyId,
	AppInstInfoFieldState,
	AppInstInfoFieldErrors,
	AppInstInfoFieldRuntimeInfoContainerIds,
	AppInstInfoFieldStatusTaskNumber,
	AppInstInfoFieldStatusMaxTasks,
	AppInstInfoFieldStatusTaskName,
	AppInstInfoFieldStatusStepName,
	AppInstInfoFieldStatusMsgCount,
	AppInstInfoFieldStatusMsgs,
	AppInstInfoFieldPowerState,
	AppInstInfoFieldUri,
	AppInstInfoFieldFedKeyFederationName,
	AppInstInfoFieldFedKeyAppInstId,
	AppInstInfoFieldFedPortsProto,
	AppInstInfoFieldFedPortsInternalPort,
	AppInstInfoFieldFedPortsPublicPort,
	AppInstInfoFieldFedPortsFqdnPrefix,
	AppInstInfoFieldFedPortsEndPort,
	AppInstInfoFieldFedPortsTls,
	AppInstInfoFieldFedPortsNginx,
	AppInstInfoFieldFedPortsMaxPktSize,
}

var AppInstInfoAllFieldsMap = NewFieldMap(map[string]struct{}{
	AppInstInfoFieldKeyName:                 struct{}{},
	AppInstInfoFieldKeyOrganization:         struct{}{},
	AppInstInfoFieldNotifyId:                struct{}{},
	AppInstInfoFieldState:                   struct{}{},
	AppInstInfoFieldErrors:                  struct{}{},
	AppInstInfoFieldRuntimeInfoContainerIds: struct{}{},
	AppInstInfoFieldStatusTaskNumber:        struct{}{},
	AppInstInfoFieldStatusMaxTasks:          struct{}{},
	AppInstInfoFieldStatusTaskName:          struct{}{},
	AppInstInfoFieldStatusStepName:          struct{}{},
	AppInstInfoFieldStatusMsgCount:          struct{}{},
	AppInstInfoFieldStatusMsgs:              struct{}{},
	AppInstInfoFieldPowerState:              struct{}{},
	AppInstInfoFieldUri:                     struct{}{},
	AppInstInfoFieldFedKeyFederationName:    struct{}{},
	AppInstInfoFieldFedKeyAppInstId:         struct{}{},
	AppInstInfoFieldFedPortsProto:           struct{}{},
	AppInstInfoFieldFedPortsInternalPort:    struct{}{},
	AppInstInfoFieldFedPortsPublicPort:      struct{}{},
	AppInstInfoFieldFedPortsFqdnPrefix:      struct{}{},
	AppInstInfoFieldFedPortsEndPort:         struct{}{},
	AppInstInfoFieldFedPortsTls:             struct{}{},
	AppInstInfoFieldFedPortsNginx:           struct{}{},
	AppInstInfoFieldFedPortsMaxPktSize:      struct{}{},
})

var AppInstInfoAllFieldsStringMap = map[string]string{
	AppInstInfoFieldKeyName:                 "Key Name",
	AppInstInfoFieldKeyOrganization:         "Key Organization",
	AppInstInfoFieldNotifyId:                "Notify Id",
	AppInstInfoFieldState:                   "State",
	AppInstInfoFieldErrors:                  "Errors",
	AppInstInfoFieldRuntimeInfoContainerIds: "Runtime Info Container Ids",
	AppInstInfoFieldStatusTaskNumber:        "Status Task Number",
	AppInstInfoFieldStatusMaxTasks:          "Status Max Tasks",
	AppInstInfoFieldStatusTaskName:          "Status Task Name",
	AppInstInfoFieldStatusStepName:          "Status Step Name",
	AppInstInfoFieldStatusMsgCount:          "Status Msg Count",
	AppInstInfoFieldStatusMsgs:              "Status Msgs",
	AppInstInfoFieldPowerState:              "Power State",
	AppInstInfoFieldUri:                     "Uri",
	AppInstInfoFieldFedKeyFederationName:    "Fed Key Federation Name",
	AppInstInfoFieldFedKeyAppInstId:         "Fed Key App Inst Id",
	AppInstInfoFieldFedPortsProto:           "Fed Ports Proto",
	AppInstInfoFieldFedPortsInternalPort:    "Fed Ports Internal Port",
	AppInstInfoFieldFedPortsPublicPort:      "Fed Ports Public Port",
	AppInstInfoFieldFedPortsFqdnPrefix:      "Fed Ports Fqdn Prefix",
	AppInstInfoFieldFedPortsEndPort:         "Fed Ports End Port",
	AppInstInfoFieldFedPortsTls:             "Fed Ports Tls",
	AppInstInfoFieldFedPortsNginx:           "Fed Ports Nginx",
	AppInstInfoFieldFedPortsMaxPktSize:      "Fed Ports Max Pkt Size",
}

func (m *AppInstInfo) IsKeyField(s string) bool {
	return strings.HasPrefix(s, AppInstInfoFieldKey+".") || s == AppInstInfoFieldKey
}

func (m *AppInstInfo) DiffFields(o *AppInstInfo, fields *FieldMap) {
	if m.Key.Name != o.Key.Name {
		fields.Set(AppInstInfoFieldKeyName)
		fields.Set(AppInstInfoFieldKey)
	}
	if m.Key.Organization != o.Key.Organization {
		fields.Set(AppInstInfoFieldKeyOrganization)
		fields.Set(AppInstInfoFieldKey)
	}
	if m.NotifyId != o.NotifyId {
		fields.Set(AppInstInfoFieldNotifyId)
	}
	if m.State != o.State {
		fields.Set(AppInstInfoFieldState)
	}
	if len(m.Errors) != len(o.Errors) {
		fields.Set(AppInstInfoFieldErrors)
	} else {
		for i0 := 0; i0 < len(m.Errors); i0++ {
			if m.Errors[i0] != o.Errors[i0] {
				fields.Set(AppInstInfoFieldErrors)
				break
			}
		}
	}
	if len(m.RuntimeInfo.ContainerIds) != len(o.RuntimeInfo.ContainerIds) {
		fields.Set(AppInstInfoFieldRuntimeInfoContainerIds)
		fields.Set(AppInstInfoFieldRuntimeInfo)
	} else {
		for i1 := 0; i1 < len(m.RuntimeInfo.ContainerIds); i1++ {
			if m.RuntimeInfo.ContainerIds[i1] != o.RuntimeInfo.ContainerIds[i1] {
				fields.Set(AppInstInfoFieldRuntimeInfoContainerIds)
				fields.Set(AppInstInfoFieldRuntimeInfo)
				break
			}
		}
	}
	if m.Status.TaskNumber != o.Status.TaskNumber {
		fields.Set(AppInstInfoFieldStatusTaskNumber)
		fields.Set(AppInstInfoFieldStatus)
	}
	if m.Status.MaxTasks != o.Status.MaxTasks {
		fields.Set(AppInstInfoFieldStatusMaxTasks)
		fields.Set(AppInstInfoFieldStatus)
	}
	if m.Status.TaskName != o.Status.TaskName {
		fields.Set(AppInstInfoFieldStatusTaskName)
		fields.Set(AppInstInfoFieldStatus)
	}
	if m.Status.StepName != o.Status.StepName {
		fields.Set(AppInstInfoFieldStatusStepName)
		fields.Set(AppInstInfoFieldStatus)
	}
	if m.Status.MsgCount != o.Status.MsgCount {
		fields.Set(AppInstInfoFieldStatusMsgCount)
		fields.Set(AppInstInfoFieldStatus)
	}
	if len(m.Status.Msgs) != len(o.Status.Msgs) {
		fields.Set(AppInstInfoFieldStatusMsgs)
		fields.Set(AppInstInfoFieldStatus)
	} else {
		for i1 := 0; i1 < len(m.Status.Msgs); i1++ {
			if m.Status.Msgs[i1] != o.Status.Msgs[i1] {
				fields.Set(AppInstInfoFieldStatusMsgs)
				fields.Set(AppInstInfoFieldStatus)
				break
			}
		}
	}
	if m.PowerState != o.PowerState {
		fields.Set(AppInstInfoFieldPowerState)
	}
	if m.Uri != o.Uri {
		fields.Set(AppInstInfoFieldUri)
	}
	if m.FedKey.FederationName != o.FedKey.FederationName {
		fields.Set(AppInstInfoFieldFedKeyFederationName)
		fields.Set(AppInstInfoFieldFedKey)
	}
	if m.FedKey.AppInstId != o.FedKey.AppInstId {
		fields.Set(AppInstInfoFieldFedKeyAppInstId)
		fields.Set(AppInstInfoFieldFedKey)
	}
	if len(m.FedPorts) != len(o.FedPorts) {
		fields.Set(AppInstInfoFieldFedPorts)
	} else {
		for i0 := 0; i0 < len(m.FedPorts); i0++ {
			if m.FedPorts[i0].Proto != o.FedPorts[i0].Proto {
				fields.Set(AppInstInfoFieldFedPortsProto)
				fields.Set(AppInstInfoFieldFedPorts)
			}
			if m.FedPorts[i0].InternalPort != o.FedPorts[i0].InternalPort {
				fields.Set(AppInstInfoFieldFedPortsInternalPort)
				fields.Set(AppInstInfoFieldFedPorts)
			}
			if m.FedPorts[i0].PublicPort != o.FedPorts[i0].PublicPort {
				fields.Set(AppInstInfoFieldFedPortsPublicPort)
				fields.Set(AppInstInfoFieldFedPorts)
			}
			if m.FedPorts[i0].FqdnPrefix != o.FedPorts[i0].FqdnPrefix {
				fields.Set(AppInstInfoFieldFedPortsFqdnPrefix)
				fields.Set(AppInstInfoFieldFedPorts)
			}
			if m.FedPorts[i0].EndPort != o.FedPorts[i0].EndPort {
				fields.Set(AppInstInfoFieldFedPortsEndPort)
				fields.Set(AppInstInfoFieldFedPorts)
			}
			if m.FedPorts[i0].Tls != o.FedPorts[i0].Tls {
				fields.Set(AppInstInfoFieldFedPortsTls)
				fields.Set(AppInstInfoFieldFedPorts)
			}
			if m.FedPorts[i0].Nginx != o.FedPorts[i0].Nginx {
				fields.Set(AppInstInfoFieldFedPortsNginx)
				fields.Set(AppInstInfoFieldFedPorts)
			}
			if m.FedPorts[i0].MaxPktSize != o.FedPorts[i0].MaxPktSize {
				fields.Set(AppInstInfoFieldFedPortsMaxPktSize)
				fields.Set(AppInstInfoFieldFedPorts)
			}
		}
	}
}

func (m *AppInstInfo) GetDiffFields(o *AppInstInfo) *FieldMap {
	diffFields := NewFieldMap(nil)
	m.DiffFields(o, diffFields)
	return diffFields
}

func (m *AppInstInfo) Clone() *AppInstInfo {
	cp := &AppInstInfo{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *AppInstInfo) AddErrors(vals ...string) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.Errors {
		cur[v] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v]; found {
			continue // duplicate
		}
		m.Errors = append(m.Errors, v)
		changes++
	}
	return changes
}

func (m *AppInstInfo) RemoveErrors(vals ...string) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v] = struct{}{}
	}
	for i := len(m.Errors); i >= 0; i-- {
		if _, found := remove[m.Errors[i]]; found {
			m.Errors = append(m.Errors[:i], m.Errors[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *AppInstInfo) AddRuntimeInfoContainerIds(vals ...string) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.RuntimeInfo.ContainerIds {
		cur[v] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v]; found {
			continue // duplicate
		}
		m.RuntimeInfo.ContainerIds = append(m.RuntimeInfo.ContainerIds, v)
		changes++
	}
	return changes
}

func (m *AppInstInfo) RemoveRuntimeInfoContainerIds(vals ...string) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v] = struct{}{}
	}
	for i := len(m.RuntimeInfo.ContainerIds); i >= 0; i-- {
		if _, found := remove[m.RuntimeInfo.ContainerIds[i]]; found {
			m.RuntimeInfo.ContainerIds = append(m.RuntimeInfo.ContainerIds[:i], m.RuntimeInfo.ContainerIds[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *AppInstInfo) AddStatusMsgs(vals ...string) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.Status.Msgs {
		cur[v] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v]; found {
			continue // duplicate
		}
		m.Status.Msgs = append(m.Status.Msgs, v)
		changes++
	}
	return changes
}

func (m *AppInstInfo) RemoveStatusMsgs(vals ...string) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v] = struct{}{}
	}
	for i := len(m.Status.Msgs); i >= 0; i-- {
		if _, found := remove[m.Status.Msgs[i]]; found {
			m.Status.Msgs = append(m.Status.Msgs[:i], m.Status.Msgs[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *AppInstInfo) AddFedPorts(vals ...distributed_match_engine.AppPort) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.FedPorts {
		cur[v.String()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.String()]; found {
			continue // duplicate
		}
		m.FedPorts = append(m.FedPorts, v)
		changes++
	}
	return changes
}

func (m *AppInstInfo) RemoveFedPorts(vals ...distributed_match_engine.AppPort) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.String()] = struct{}{}
	}
	for i := len(m.FedPorts); i >= 0; i-- {
		if _, found := remove[m.FedPorts[i].String()]; found {
			m.FedPorts = append(m.FedPorts[:i], m.FedPorts[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *AppInstInfo) CopyInFields(src *AppInstInfo) int {
	updateListAction := "replace"
	changed := 0
	fmap := MakeFieldMap(src.Fields)
	if fmap.HasOrHasChild("2") {
		if fmap.Has("2.1") {
			if m.Key.Name != src.Key.Name {
				m.Key.Name = src.Key.Name
				changed++
			}
		}
		if fmap.Has("2.2") {
			if m.Key.Organization != src.Key.Organization {
				m.Key.Organization = src.Key.Organization
				changed++
			}
		}
	}
	if fmap.Has("3") {
		if m.NotifyId != src.NotifyId {
			m.NotifyId = src.NotifyId
			changed++
		}
	}
	if fmap.Has("4") {
		if m.State != src.State {
			m.State = src.State
			changed++
		}
	}
	if fmap.Has("5") {
		if src.Errors != nil {
			if updateListAction == "add" {
				changed += m.AddErrors(src.Errors...)
			} else if updateListAction == "remove" {
				changed += m.RemoveErrors(src.Errors...)
			} else {
				m.Errors = make([]string, 0)
				m.Errors = append(m.Errors, src.Errors...)
				changed++
			}
		} else if m.Errors != nil {
			m.Errors = nil
			changed++
		}
	}
	if fmap.HasOrHasChild("6") {
		if fmap.Has("6.1") {
			if src.RuntimeInfo.ContainerIds != nil {
				if updateListAction == "add" {
					changed += m.AddRuntimeInfoContainerIds(src.RuntimeInfo.ContainerIds...)
				} else if updateListAction == "remove" {
					changed += m.RemoveRuntimeInfoContainerIds(src.RuntimeInfo.ContainerIds...)
				} else {
					m.RuntimeInfo.ContainerIds = make([]string, 0)
					m.RuntimeInfo.ContainerIds = append(m.RuntimeInfo.ContainerIds, src.RuntimeInfo.ContainerIds...)
					changed++
				}
			} else if m.RuntimeInfo.ContainerIds != nil {
				m.RuntimeInfo.ContainerIds = nil
				changed++
			}
		}
	}
	if fmap.HasOrHasChild("7") {
		if fmap.Has("7.1") {
			if m.Status.TaskNumber != src.Status.TaskNumber {
				m.Status.TaskNumber = src.Status.TaskNumber
				changed++
			}
		}
		if fmap.Has("7.2") {
			if m.Status.MaxTasks != src.Status.MaxTasks {
				m.Status.MaxTasks = src.Status.MaxTasks
				changed++
			}
		}
		if fmap.Has("7.3") {
			if m.Status.TaskName != src.Status.TaskName {
				m.Status.TaskName = src.Status.TaskName
				changed++
			}
		}
		if fmap.Has("7.4") {
			if m.Status.StepName != src.Status.StepName {
				m.Status.StepName = src.Status.StepName
				changed++
			}
		}
		if fmap.Has("7.5") {
			if m.Status.MsgCount != src.Status.MsgCount {
				m.Status.MsgCount = src.Status.MsgCount
				changed++
			}
		}
		if fmap.Has("7.6") {
			if src.Status.Msgs != nil {
				if updateListAction == "add" {
					changed += m.AddStatusMsgs(src.Status.Msgs...)
				} else if updateListAction == "remove" {
					changed += m.RemoveStatusMsgs(src.Status.Msgs...)
				} else {
					m.Status.Msgs = make([]string, 0)
					m.Status.Msgs = append(m.Status.Msgs, src.Status.Msgs...)
					changed++
				}
			} else if m.Status.Msgs != nil {
				m.Status.Msgs = nil
				changed++
			}
		}
	}
	if fmap.Has("8") {
		if m.PowerState != src.PowerState {
			m.PowerState = src.PowerState
			changed++
		}
	}
	if fmap.Has("9") {
		if m.Uri != src.Uri {
			m.Uri = src.Uri
			changed++
		}
	}
	if fmap.HasOrHasChild("10") {
		if fmap.Has("10.1") {
			if m.FedKey.FederationName != src.FedKey.FederationName {
				m.FedKey.FederationName = src.FedKey.FederationName
				changed++
			}
		}
		if fmap.Has("10.2") {
			if m.FedKey.AppInstId != src.FedKey.AppInstId {
				m.FedKey.AppInstId = src.FedKey.AppInstId
				changed++
			}
		}
	}
	if fmap.HasOrHasChild("11") {
		if src.FedPorts != nil {
			if updateListAction == "add" {
				changed += m.AddFedPorts(src.FedPorts...)
			} else if updateListAction == "remove" {
				changed += m.RemoveFedPorts(src.FedPorts...)
			} else {
				m.FedPorts = make([]distributed_match_engine.AppPort, 0)
				for k0, _ := range src.FedPorts {
					m.FedPorts = append(m.FedPorts, *src.FedPorts[k0].Clone())
				}
				changed++
			}
		} else if m.FedPorts != nil {
			m.FedPorts = nil
			changed++
		}
	}
	return changed
}

func (m *AppInstInfo) DeepCopyIn(src *AppInstInfo) {
	m.Key.DeepCopyIn(&src.Key)
	m.NotifyId = src.NotifyId
	m.State = src.State
	if src.Errors != nil {
		m.Errors = make([]string, len(src.Errors), len(src.Errors))
		for ii, s := range src.Errors {
			m.Errors[ii] = s
		}
	} else {
		m.Errors = nil
	}
	m.RuntimeInfo.DeepCopyIn(&src.RuntimeInfo)
	m.Status.DeepCopyIn(&src.Status)
	m.PowerState = src.PowerState
	m.Uri = src.Uri
	m.FedKey.DeepCopyIn(&src.FedKey)
	if src.FedPorts != nil {
		m.FedPorts = make([]distributed_match_engine.AppPort, len(src.FedPorts), len(src.FedPorts))
		for ii, s := range src.FedPorts {
			m.FedPorts[ii] = s
		}
	} else {
		m.FedPorts = nil
	}
}

func (s *AppInstInfo) HasFields() bool {
	return true
}

type AppInstInfoStore interface {
	Create(ctx context.Context, m *AppInstInfo, wait func(int64)) (*Result, error)
	Update(ctx context.Context, m *AppInstInfo, wait func(int64)) (*Result, error)
	Delete(ctx context.Context, m *AppInstInfo, wait func(int64)) (*Result, error)
	Put(ctx context.Context, m *AppInstInfo, wait func(int64), ops ...objstore.KVOp) (*Result, error)
	LoadOne(key string) (*AppInstInfo, int64, error)
	Get(ctx context.Context, key *AppInstKey, buf *AppInstInfo) bool
	STMGet(stm concurrency.STM, key *AppInstKey, buf *AppInstInfo) bool
	STMPut(stm concurrency.STM, obj *AppInstInfo, ops ...objstore.KVOp)
	STMDel(stm concurrency.STM, key *AppInstKey)
	STMHas(stm concurrency.STM, key *AppInstKey) bool
}

type AppInstInfoStoreImpl struct {
	kvstore objstore.KVStore
}

func NewAppInstInfoStore(kvstore objstore.KVStore) *AppInstInfoStoreImpl {
	return &AppInstInfoStoreImpl{kvstore: kvstore}
}

func (s *AppInstInfoStoreImpl) Create(ctx context.Context, m *AppInstInfo, wait func(int64)) (*Result, error) {
	err := m.Validate(AppInstInfoAllFieldsMap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("AppInstInfo", m.GetKey())
	val, err := json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Create(ctx, key, string(val))
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *AppInstInfoStoreImpl) Update(ctx context.Context, m *AppInstInfo, wait func(int64)) (*Result, error) {
	fmap := MakeFieldMap(m.Fields)
	err := m.Validate(fmap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("AppInstInfo", m.GetKey())
	var vers int64 = 0
	curBytes, vers, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, err
	}
	var cur AppInstInfo
	err = json.Unmarshal(curBytes, &cur)
	if err != nil {
		return nil, err
	}
	cur.CopyInFields(m)
	// never save fields
	cur.Fields = nil
	val, err := json.Marshal(cur)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Update(ctx, key, string(val), vers)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *AppInstInfoStoreImpl) Put(ctx context.Context, m *AppInstInfo, wait func(int64), ops ...objstore.KVOp) (*Result, error) {
	err := m.Validate(AppInstInfoAllFieldsMap)
	m.Fields = nil
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("AppInstInfo", m.GetKey())
	var val []byte
	val, err = json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Put(ctx, key, string(val), ops...)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *AppInstInfoStoreImpl) Delete(ctx context.Context, m *AppInstInfo, wait func(int64)) (*Result, error) {
	err := m.GetKey().ValidateKey()
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("AppInstInfo", m.GetKey())
	rev, err := s.kvstore.Delete(ctx, key)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *AppInstInfoStoreImpl) LoadOne(key string) (*AppInstInfo, int64, error) {
	val, rev, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, 0, err
	}
	var obj AppInstInfo
	err = json.Unmarshal(val, &obj)
	if err != nil {
		log.DebugLog(log.DebugLevelApi, "Failed to parse AppInstInfo data", "val", string(val), "err", err)
		return nil, 0, err
	}
	return &obj, rev, nil
}

func (s *AppInstInfoStoreImpl) Get(ctx context.Context, key *AppInstKey, buf *AppInstInfo) bool {
	keystr := objstore.DbKeyString("AppInstInfo", key)
	val, _, _, err := s.kvstore.Get(keystr)
	if err != nil {
		return false
	}
	return s.parseGetData(val, buf)
}

func (s *AppInstInfoStoreImpl) STMGet(stm concurrency.STM, key *AppInstKey, buf *AppInstInfo) bool {
	keystr := objstore.DbKeyString("AppInstInfo", key)
	valstr := stm.Get(keystr)
	return s.parseGetData([]byte(valstr), buf)
}

func (s *AppInstInfoStoreImpl) STMHas(stm concurrency.STM, key *AppInstKey) bool {
	keystr := objstore.DbKeyString("AppInstInfo", key)
	return stm.Get(keystr) != ""
}

func (s *AppInstInfoStoreImpl) parseGetData(val []byte, buf *AppInstInfo) bool {
	if len(val) == 0 {
		return false
	}
	if buf != nil {
		// clear buf, because empty values in val won't
		// overwrite non-empty values in buf.
		*buf = AppInstInfo{}
		err := json.Unmarshal(val, buf)
		if err != nil {
			return false
		}
	}
	return true
}

func (s *AppInstInfoStoreImpl) STMPut(stm concurrency.STM, obj *AppInstInfo, ops ...objstore.KVOp) {
	keystr := objstore.DbKeyString("AppInstInfo", obj.GetKey())

	val, err := json.Marshal(obj)
	if err != nil {
		log.InfoLog("AppInstInfo json marshal failed", "obj", obj, "err", err)
	}
	v3opts := GetSTMOpts(ops...)
	stm.Put(keystr, string(val), v3opts...)
}

func (s *AppInstInfoStoreImpl) STMDel(stm concurrency.STM, key *AppInstKey) {
	keystr := objstore.DbKeyString("AppInstInfo", key)
	stm.Del(keystr)
}

type AppInstInfoKeyWatcher struct {
	cb func(ctx context.Context)
}

type AppInstInfoCacheData struct {
	Obj    *AppInstInfo
	ModRev int64
}

func (s *AppInstInfoCacheData) Clone() *AppInstInfoCacheData {
	cp := AppInstInfoCacheData{}
	if s.Obj != nil {
		cp.Obj = &AppInstInfo{}
		cp.Obj.DeepCopyIn(s.Obj)
	}
	cp.ModRev = s.ModRev
	return &cp
}

// AppInstInfoCache caches AppInstInfo objects in memory in a hash table
// and keeps them in sync with the database.
type AppInstInfoCache struct {
	Objs          map[AppInstKey]*AppInstInfoCacheData
	Mux           util.Mutex
	List          map[AppInstKey]struct{}
	FlushAll      bool
	NotifyCbs     []func(ctx context.Context, obj *AppInstInfo, modRev int64)
	UpdatedCbs    []func(ctx context.Context, old *AppInstInfo, new *AppInstInfo)
	DeletedCbs    []func(ctx context.Context, old *AppInstInfo)
	KeyWatchers   map[AppInstKey][]*AppInstInfoKeyWatcher
	UpdatedKeyCbs []func(ctx context.Context, key *AppInstKey)
	DeletedKeyCbs []func(ctx context.Context, key *AppInstKey)
	Store         AppInstInfoStore
}

func NewAppInstInfoCache() *AppInstInfoCache {
	cache := AppInstInfoCache{}
	InitAppInstInfoCache(&cache)
	return &cache
}

func InitAppInstInfoCache(cache *AppInstInfoCache) {
	cache.Objs = make(map[AppInstKey]*AppInstInfoCacheData)
	cache.KeyWatchers = make(map[AppInstKey][]*AppInstInfoKeyWatcher)
	cache.NotifyCbs = nil
	cache.UpdatedCbs = nil
	cache.DeletedCbs = nil
	cache.UpdatedKeyCbs = nil
	cache.DeletedKeyCbs = nil
}

func (c *AppInstInfoCache) GetTypeString() string {
	return "AppInstInfo"
}

func (c *AppInstInfoCache) Get(key *AppInstKey, valbuf *AppInstInfo) bool {
	var modRev int64
	return c.GetWithRev(key, valbuf, &modRev)
}

func (c *AppInstInfoCache) GetWithRev(key *AppInstKey, valbuf *AppInstInfo, modRev *int64) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	inst, found := c.Objs[*key]
	if found {
		valbuf.DeepCopyIn(inst.Obj)
		*modRev = inst.ModRev
	}
	return found
}

func (c *AppInstInfoCache) HasKey(key *AppInstKey) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	_, found := c.Objs[*key]
	return found
}

func (c *AppInstInfoCache) GetAllKeys(ctx context.Context, cb func(key *AppInstKey, modRev int64)) {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for key, data := range c.Objs {
		cb(&key, data.ModRev)
	}
}

func (c *AppInstInfoCache) GetAllLocked(ctx context.Context, cb func(obj *AppInstInfo, modRev int64)) {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for _, data := range c.Objs {
		cb(data.Obj, data.ModRev)
	}
}

func (c *AppInstInfoCache) Update(ctx context.Context, in *AppInstInfo, modRev int64) {
	c.UpdateModFunc(ctx, in.GetKey(), modRev, func(old *AppInstInfo) (*AppInstInfo, bool) {
		return in, true
	})
}

func (c *AppInstInfoCache) UpdateModFunc(ctx context.Context, key *AppInstKey, modRev int64, modFunc func(old *AppInstInfo) (new *AppInstInfo, changed bool)) {
	c.Mux.Lock()
	var old *AppInstInfo
	if oldData, found := c.Objs[*key]; found {
		old = oldData.Obj
	}
	new, changed := modFunc(old)
	if !changed {
		c.Mux.Unlock()
		return
	}
	if len(c.UpdatedCbs) > 0 || len(c.NotifyCbs) > 0 {
		newCopy := &AppInstInfo{}
		newCopy.DeepCopyIn(new)
		for _, cb := range c.UpdatedCbs {
			defer cb(ctx, old, newCopy)
		}
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				defer cb(ctx, newCopy, modRev)
			}
		}
	}
	for _, cb := range c.UpdatedKeyCbs {
		defer cb(ctx, key)
	}
	store := &AppInstInfo{}
	store.DeepCopyIn(new)
	c.Objs[new.GetKeyVal()] = &AppInstInfoCacheData{
		Obj:    store,
		ModRev: modRev,
	}
	log.SpanLog(ctx, log.DebugLevelApi, "cache update", "new", store)
	c.Mux.Unlock()
	c.TriggerKeyWatchers(ctx, new.GetKey())
}

func (c *AppInstInfoCache) Delete(ctx context.Context, in *AppInstInfo, modRev int64) {
	c.DeleteCondFunc(ctx, in, modRev, func(old *AppInstInfo) bool {
		return true
	})
}

func (c *AppInstInfoCache) DeleteCondFunc(ctx context.Context, in *AppInstInfo, modRev int64, condFunc func(old *AppInstInfo) bool) {
	c.Mux.Lock()
	var old *AppInstInfo
	oldData, found := c.Objs[in.GetKeyVal()]
	if found {
		old = oldData.Obj
		if !condFunc(old) {
			c.Mux.Unlock()
			return
		}
	}
	delete(c.Objs, in.GetKeyVal())
	log.SpanLog(ctx, log.DebugLevelApi, "cache delete", "key", in.GetKeyVal())
	c.Mux.Unlock()
	obj := old
	if obj == nil {
		obj = in
	}
	for _, cb := range c.NotifyCbs {
		if cb != nil {
			cb(ctx, obj, modRev)
		}
	}
	if old != nil {
		for _, cb := range c.DeletedCbs {
			cb(ctx, old)
		}
	}
	for _, cb := range c.DeletedKeyCbs {
		cb(ctx, in.GetKey())
	}
	c.TriggerKeyWatchers(ctx, in.GetKey())
}

func (c *AppInstInfoCache) Prune(ctx context.Context, validKeys map[AppInstKey]struct{}) {
	log.SpanLog(ctx, log.DebugLevelApi, "Prune AppInstInfo", "numValidKeys", len(validKeys))
	notify := make(map[AppInstKey]*AppInstInfoCacheData)
	c.Mux.Lock()
	for key, _ := range c.Objs {
		if _, ok := validKeys[key]; !ok {
			if len(c.NotifyCbs) > 0 || len(c.DeletedKeyCbs) > 0 || len(c.DeletedCbs) > 0 {
				notify[key] = c.Objs[key]
			}
			delete(c.Objs, key)
		}
	}
	c.Mux.Unlock()
	for key, old := range notify {
		obj := old.Obj
		if obj == nil {
			obj = &AppInstInfo{}
			obj.SetKey(&key)
		}
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, obj, old.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if old.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, old.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (c *AppInstInfoCache) GetCount() int {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	return len(c.Objs)
}

func (c *AppInstInfoCache) Flush(ctx context.Context, notifyId int64) {
	log.SpanLog(ctx, log.DebugLevelApi, "CacheFlush AppInstInfo", "notifyId", notifyId, "FlushAll", c.FlushAll)
	flushed := make(map[AppInstKey]*AppInstInfoCacheData)
	c.Mux.Lock()
	for key, val := range c.Objs {
		if !c.FlushAll && val.Obj.NotifyId != notifyId {
			continue
		}
		flushed[key] = c.Objs[key]
		log.SpanLog(ctx, log.DebugLevelApi, "CacheFlush AppInstInfo delete", "key", key)
		delete(c.Objs, key)
	}
	c.Mux.Unlock()
	if len(flushed) > 0 {
		for key, old := range flushed {
			obj := old.Obj
			if obj == nil {
				obj = &AppInstInfo{}
				obj.SetKey(&key)
			}
			for _, cb := range c.NotifyCbs {
				if cb != nil {
					cb(ctx, obj, old.ModRev)
				}
			}
			for _, cb := range c.DeletedKeyCbs {
				cb(ctx, &key)
			}
			if old.Obj != nil {
				for _, cb := range c.DeletedCbs {
					cb(ctx, old.Obj)
				}
			}
			c.TriggerKeyWatchers(ctx, &key)
		}
	}
}

func (c *AppInstInfoCache) Show(filter *AppInstInfo, cb func(ret *AppInstInfo) error) error {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for _, data := range c.Objs {
		if !data.Obj.Matches(filter, MatchFilter()) {
			continue
		}
		err := cb(data.Obj)
		if err != nil {
			return err
		}
	}
	return nil
}

func AppInstInfoGenericNotifyCb(fn func(key *AppInstKey, old *AppInstInfo)) func(objstore.ObjKey, objstore.Obj) {
	return func(objkey objstore.ObjKey, obj objstore.Obj) {
		fn(objkey.(*AppInstKey), obj.(*AppInstInfo))
	}
}

func (c *AppInstInfoCache) SetNotifyCb(fn func(ctx context.Context, obj *AppInstInfo, modRev int64)) {
	c.NotifyCbs = []func(ctx context.Context, obj *AppInstInfo, modRev int64){fn}
}

func (c *AppInstInfoCache) SetUpdatedCb(fn func(ctx context.Context, old *AppInstInfo, new *AppInstInfo)) {
	c.UpdatedCbs = []func(ctx context.Context, old *AppInstInfo, new *AppInstInfo){fn}
}

func (c *AppInstInfoCache) SetDeletedCb(fn func(ctx context.Context, old *AppInstInfo)) {
	c.DeletedCbs = []func(ctx context.Context, old *AppInstInfo){fn}
}

func (c *AppInstInfoCache) SetUpdatedKeyCb(fn func(ctx context.Context, key *AppInstKey)) {
	c.UpdatedKeyCbs = []func(ctx context.Context, key *AppInstKey){fn}
}

func (c *AppInstInfoCache) SetDeletedKeyCb(fn func(ctx context.Context, key *AppInstKey)) {
	c.DeletedKeyCbs = []func(ctx context.Context, key *AppInstKey){fn}
}

func (c *AppInstInfoCache) AddUpdatedCb(fn func(ctx context.Context, old *AppInstInfo, new *AppInstInfo)) {
	c.UpdatedCbs = append(c.UpdatedCbs, fn)
}

func (c *AppInstInfoCache) AddDeletedCb(fn func(ctx context.Context, old *AppInstInfo)) {
	c.DeletedCbs = append(c.DeletedCbs, fn)
}

func (c *AppInstInfoCache) AddNotifyCb(fn func(ctx context.Context, obj *AppInstInfo, modRev int64)) {
	c.NotifyCbs = append(c.NotifyCbs, fn)
}

func (c *AppInstInfoCache) AddUpdatedKeyCb(fn func(ctx context.Context, key *AppInstKey)) {
	c.UpdatedKeyCbs = append(c.UpdatedKeyCbs, fn)
}

func (c *AppInstInfoCache) AddDeletedKeyCb(fn func(ctx context.Context, key *AppInstKey)) {
	c.DeletedKeyCbs = append(c.DeletedKeyCbs, fn)
}

func (c *AppInstInfoCache) SetFlushAll() {
	c.FlushAll = true
}

func (c *AppInstInfoCache) WatchKey(key *AppInstKey, cb func(ctx context.Context)) context.CancelFunc {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	list, ok := c.KeyWatchers[*key]
	if !ok {
		list = make([]*AppInstInfoKeyWatcher, 0)
	}
	watcher := AppInstInfoKeyWatcher{cb: cb}
	c.KeyWatchers[*key] = append(list, &watcher)
	log.DebugLog(log.DebugLevelApi, "Watching AppInstInfo", "key", key)
	return func() {
		c.Mux.Lock()
		defer c.Mux.Unlock()
		list, ok := c.KeyWatchers[*key]
		if !ok {
			return
		}
		for ii, _ := range list {
			if list[ii] != &watcher {
				continue
			}
			if len(list) == 1 {
				delete(c.KeyWatchers, *key)
				return
			}
			list[ii] = list[len(list)-1]
			list[len(list)-1] = nil
			c.KeyWatchers[*key] = list[:len(list)-1]
			return
		}
	}
}

func (c *AppInstInfoCache) TriggerKeyWatchers(ctx context.Context, key *AppInstKey) {
	watchers := make([]*AppInstInfoKeyWatcher, 0)
	c.Mux.Lock()
	if list, ok := c.KeyWatchers[*key]; ok {
		watchers = append(watchers, list...)
	}
	c.Mux.Unlock()
	for ii, _ := range watchers {
		watchers[ii].cb(ctx)
	}
}

// Note that we explicitly ignore the global revision number, because of the way
// the notify framework sends updates (by hashing keys and doing lookups, instead
// of sequentially through a history buffer), updates may be done out-of-order
// or multiple updates compressed into one update, so the state of the cache at
// any point in time may not by in sync with a particular database revision number.

func (c *AppInstInfoCache) SyncUpdate(ctx context.Context, key, val []byte, rev, modRev int64) {
	obj := AppInstInfo{}
	err := json.Unmarshal(val, &obj)
	if err != nil {
		log.WarnLog("Failed to parse AppInstInfo data", "val", string(val), "err", err)
		return
	}
	c.Update(ctx, &obj, modRev)
	c.Mux.Lock()
	if c.List != nil {
		c.List[obj.GetKeyVal()] = struct{}{}
	}
	c.Mux.Unlock()
}

func (c *AppInstInfoCache) SyncDelete(ctx context.Context, key []byte, rev, modRev int64) {
	obj := AppInstInfo{}
	keystr := objstore.DbKeyPrefixRemove(string(key))
	AppInstKeyStringParse(keystr, obj.GetKey())
	c.Delete(ctx, &obj, modRev)
}

func (c *AppInstInfoCache) SyncListStart(ctx context.Context) {
	c.List = make(map[AppInstKey]struct{})
}

func (c *AppInstInfoCache) SyncListEnd(ctx context.Context) {
	deleted := make(map[AppInstKey]*AppInstInfoCacheData)
	c.Mux.Lock()
	for key, val := range c.Objs {
		if _, found := c.List[key]; !found {
			deleted[key] = val
			delete(c.Objs, key)
		}
	}
	c.List = nil
	c.Mux.Unlock()
	for key, val := range deleted {
		obj := val.Obj
		if obj == nil {
			obj = &AppInstInfo{}
			obj.SetKey(&key)
		}
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, obj, val.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if val.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, val.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (s *AppInstInfoCache) InitCacheWithSync(sync DataSync) {
	InitAppInstInfoCache(s)
	s.InitSync(sync)
}

func (s *AppInstInfoCache) InitSync(sync DataSync) {
	if sync != nil {
		s.Store = NewAppInstInfoStore(sync.GetKVStore())
		sync.RegisterCache(s)
	}
}

// AppInstInfoObjectUpdater defines a way of updating a specific AppInstInfo
type AppInstInfoObjectUpdater interface {
	// Get the current AppInstInfo
	Get() *AppInstInfo
	// Update the AppInstInfo for the specified Fields flags.
	Update(*AppInstInfo) error
}

// AppInstInfoSender allows for streaming updates to AppInstInfo
type AppInstInfoSender interface {
	// SendUpdate sends the updated object, fields without field flags set will be ignored
	SendUpdate(updateFn func(update *AppInstInfo) error) error
	// SendState sends an updated state. It will clear any errors unless
	// the WithStateError option is specified.
	SendState(state TrackedState, ops ...SenderOp) error
	// SendStatus appends the status message and sends it.
	SendStatus(updateType CacheUpdateType, message string, ops ...SenderOp) error
	// SendStatusIgnoreErr is the same as SendStatus but without error return
	// and without options to be compatible with older code.
	SendStatusIgnoreErr(updateType CacheUpdateType, message string)
}

// AppInstInfoSenderHelper implements AppInstInfoSender
type AppInstInfoSenderHelper struct {
	updater AppInstInfoObjectUpdater
}

func (s *AppInstInfoSenderHelper) SetUpdater(updater AppInstInfoObjectUpdater) {
	s.updater = updater
}

// SendUpdate sends only the updated fields set by the Fields flags.
func (s *AppInstInfoSenderHelper) SendUpdate(updateFn func(update *AppInstInfo) error) error {
	obj := s.updater.Get()
	if err := updateFn(obj); err != nil {
		return err
	}
	return s.updater.Update(obj)
}

// SendState sends an updated state
func (s *AppInstInfoSenderHelper) SendState(state TrackedState, ops ...SenderOp) error {
	opts := GetSenderOptions(ops...)
	obj := s.updater.Get()
	obj.Fields = []string{
		AppInstInfoFieldState,
		AppInstInfoFieldErrors,
		AppInstInfoFieldStatus,
	}
	s.applyOpts(obj, opts)

	if opts.stateErr != nil {
		obj.Errors = []string{opts.stateErr.Error()}
	}
	obj.State = state
	obj.Status.SetTask(TrackedState_CamelName[int32(state)])
	return s.updater.Update(obj)
}

// SendStatus appends the status message and sends it.
func (s *AppInstInfoSenderHelper) SendStatus(updateType CacheUpdateType, message string, ops ...SenderOp) error {
	opts := GetSenderOptions(ops...)
	obj := s.updater.Get()
	obj.Fields = []string{
		AppInstInfoFieldStatus,
	}
	s.applyOpts(obj, opts)

	switch updateType {
	case UpdateTask:
		obj.Status.SetTask(message)
	case UpdateStep:
		obj.Status.SetStep(message)
	}
	return s.updater.Update(obj)
}

func (s *AppInstInfoSenderHelper) SendStatusIgnoreErr(updateType CacheUpdateType, message string) {
	s.SendStatus(updateType, message)
}

func (s *AppInstInfoSenderHelper) applyOpts(obj *AppInstInfo, opts *SenderOptions) {
	if opts.resetStatus {
		obj.Fields = append(obj.Fields, AppInstInfoFieldStatus)
		obj.Status.StatusReset()
	}
}

// AppInstInfoCacheUpdater implements AppInstInfoSender via a cache
// that can send data over notify.
type AppInstInfoCacheUpdater struct {
	AppInstInfoSenderHelper
	ctx   context.Context
	key   AppInstKey
	cache *AppInstInfoCache
}

func NewAppInstInfoCacheUpdater(ctx context.Context, cache *AppInstInfoCache, key AppInstKey) *AppInstInfoCacheUpdater {
	s := &AppInstInfoCacheUpdater{
		ctx:   ctx,
		key:   key,
		cache: cache,
	}
	s.SetUpdater(s)
	return s
}

func (s *AppInstInfoCacheUpdater) Get() *AppInstInfo {
	obj := AppInstInfo{}
	if !s.cache.Get(&s.key, &obj) {
		obj.Key = s.key
	}
	return &obj
}

func (s *AppInstInfoCacheUpdater) Update(obj *AppInstInfo) error {
	s.cache.Update(s.ctx, obj, 0)
	return nil
}

type AppInstInfoSendAPI interface {
	Send(*AppInstInfo) error
}

// AppInstInfoSendUpdater implements AppInstInfoObjectUpdater via a generic
// send API. To allow for building up the list of status messages
// which need to accumulate over time, we keep a local copy of
// the object.
type AppInstInfoSendUpdater struct {
	AppInstInfoSenderHelper
	ctx    context.Context
	sender AppInstInfoSendAPI
	local  AppInstInfo
	mux    sync.Mutex
}

func NewAppInstInfoSendUpdater(ctx context.Context, sender AppInstInfoSendAPI, key AppInstKey) *AppInstInfoSendUpdater {
	s := &AppInstInfoSendUpdater{
		ctx:    ctx,
		sender: sender,
	}
	s.local.Key = key
	s.SetUpdater(s)
	return s
}

func (s *AppInstInfoSendUpdater) Get() *AppInstInfo {
	s.mux.Lock()
	defer s.mux.Unlock()
	cp := AppInstInfo{}
	cp.DeepCopyIn(&s.local)
	return &cp
}

func (s *AppInstInfoSendUpdater) Update(obj *AppInstInfo) error {
	s.mux.Lock()
	s.local.DeepCopyIn(obj)
	s.mux.Unlock()
	return s.sender.Send(obj)
}

// AppInstInfoPrintUpdater just prints the updates
type AppInstInfoPrintUpdater struct {
	AppInstInfoSenderHelper
}

func NewAppInstInfoPrintUpdater() *AppInstInfoPrintUpdater {
	s := &AppInstInfoPrintUpdater{}
	s.SetUpdater(s)
	return s
}

func (s *AppInstInfoPrintUpdater) Get() *AppInstInfo {
	return &AppInstInfo{}
}

func (s *AppInstInfoPrintUpdater) Update(obj *AppInstInfo) error {
	fmt.Printf("%v\n", obj)
	return nil
}

func WaitForAppInstInfo(ctx context.Context, key *AppInstKey, store AppInstStore, targetState TrackedState, transitionStates map[TrackedState]struct{}, errorState TrackedState, successMsg string, send func(*Result) error, opts ...WaitStateOps) error {
	var lastMsgCnt int
	var err error

	handleTargetState := func() {
		if targetState == TrackedState_NOT_PRESENT {
			send(&Result{Message: TrackedState_CamelName[int32(targetState)]})
		}
		if successMsg != "" && send != nil {
			send(&Result{Message: successMsg})
		}
	}

	// State updates come via Redis, since they are bundled with status updates.
	// However, the Redis channel is set up after the Etcd transaction to commit
	// the state change (i.e. CREATE_REQUESTED) in order to treat Etcd as the
	// source of truth for concurrent changes, so there is a small timing window
	// where the state may be updated by the info (from CRM) before the Redis
	// subscription is set up. So here our initial state needs to come from Etcd
	// in case both it and Redis were updated before the crmMsgCh was set up.
	curState := TrackedState_NOT_PRESENT
	buf := AppInst{}
	if store.Get(ctx, key, &buf) {
		curState = buf.State
	}
	if curState == targetState {
		handleTargetState()
		return nil
	}

	var wSpec WaitStateSpec
	for _, op := range opts {
		if err := op(&wSpec); err != nil {
			return err
		}
	}

	if wSpec.CrmMsgCh == nil {
		return nil
	}

	for {
		select {
		case chObj := <-wSpec.CrmMsgCh:
			if chObj == nil {
				// Since msg chan is a receive-only chan, it will return nil if
				// connection to redis server is disrupted. But the object might
				// still be in progress. Hence, just show a message about the failure,
				// so that user can manually look at object's progress
				if send != nil {
					msg := fmt.Sprintf("Failed to get progress messages. Please use ShowAppInst to check current status")
					send(&Result{Message: msg})
				}
				return nil
			}
			info := AppInstInfo{}
			err = json.Unmarshal([]byte(chObj.Payload), &info)
			if err != nil {
				return err
			}
			curState = info.State
			log.SpanLog(ctx, log.DebugLevelApi, "Received crm update for AppInstInfo", "key", key, "obj", info)
			if send != nil {
				for ii := lastMsgCnt; ii < len(info.Status.Msgs); ii++ {
					send(&Result{Message: info.Status.Msgs[ii]})
				}
				lastMsgCnt = len(info.Status.Msgs)
			}

			switch info.State {
			case errorState:
				errs := strings.Join(info.Errors, ", ")
				if len(info.Errors) == 1 {
					err = fmt.Errorf("%s", errs)
				} else {
					err = fmt.Errorf("Encountered failures: %s", errs)
				}
				return err
			case targetState:
				handleTargetState()
				return nil
			}
		case <-ctx.Done():
			if _, found := transitionStates[curState]; found {
				// no success response, but state is a valid transition
				// state. That means work is still in progress.
				// Notify user that this is not an error.
				// Do not undo since CRM is still busy.
				if send != nil {
					msg := fmt.Sprintf("Timed out while work still in progress state %s. Please use ShowAppInst to check current status", TrackedState_CamelName[int32(curState)])
					send(&Result{Message: msg})
				}
				err = nil
			} else {
				err = fmt.Errorf("Timed out; expected state %s but is %s",
					TrackedState_CamelName[int32(targetState)],
					TrackedState_CamelName[int32(curState)])
			}
			return err
		}
	}
}

func (c *AppInstInfoCache) UsesOrg(org string) bool {
	return false
}

func (m *AppInstInfo) GetObjKey() objstore.ObjKey {
	return m.GetKey()
}

func (m *AppInstInfo) GetKey() *AppInstKey {
	return &m.Key
}

func (m *AppInstInfo) GetKeyVal() AppInstKey {
	return m.Key
}

func (m *AppInstInfo) SetKey(key *AppInstKey) {
	m.Key = *key
}

func CmpSortAppInstInfo(a AppInstInfo, b AppInstInfo) bool {
	return a.Key.GetKeyString() < b.Key.GetKeyString()
}

// Helper method to check that enums have valid values
// NOTE: ValidateEnums checks all Fields even if some are not set
func (m *AppInstInfo) ValidateEnums() error {
	if err := m.Key.ValidateEnums(); err != nil {
		return err
	}
	if _, ok := TrackedState_name[int32(m.State)]; !ok {
		return errors.New("invalid State")
	}
	if err := m.RuntimeInfo.ValidateEnums(); err != nil {
		return err
	}
	if err := m.Status.ValidateEnums(); err != nil {
		return err
	}
	if _, ok := PowerState_name[int32(m.PowerState)]; !ok {
		return errors.New("invalid PowerState")
	}
	if err := m.FedKey.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func (s *AppInstInfo) ClearTagged(tags map[string]struct{}) {
	s.Key.ClearTagged(tags)
	if _, found := tags["nocmp"]; found {
		s.NotifyId = 0
	}
	s.RuntimeInfo.ClearTagged(tags)
	s.Status.ClearTagged(tags)
	s.FedKey.ClearTagged(tags)
}

func IgnoreAppInstInfoFields(taglist string) cmp.Option {
	names := []string{}
	tags := make(map[string]struct{})
	for _, tag := range strings.Split(taglist, ",") {
		tags[tag] = struct{}{}
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "NotifyId")
	}
	return cmpopts.IgnoreFields(AppInstInfo{}, names...)
}

func (m *AppInstMetrics) Clone() *AppInstMetrics {
	cp := &AppInstMetrics{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *AppInstMetrics) CopyInFields(src *AppInstMetrics) int {
	changed := 0
	if m.Something != src.Something {
		m.Something = src.Something
		changed++
	}
	return changed
}

func (m *AppInstMetrics) DeepCopyIn(src *AppInstMetrics) {
	m.Something = src.Something
}

// Helper method to check that enums have valid values
func (m *AppInstMetrics) ValidateEnums() error {
	return nil
}

func (s *AppInstMetrics) ClearTagged(tags map[string]struct{}) {
}

func (m *AppInstLookup) Clone() *AppInstLookup {
	cp := &AppInstLookup{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *AppInstLookup) CopyInFields(src *AppInstLookup) int {
	changed := 0
	if m.Key.Name != src.Key.Name {
		m.Key.Name = src.Key.Name
		changed++
	}
	if m.Key.Organization != src.Key.Organization {
		m.Key.Organization = src.Key.Organization
		changed++
	}
	if m.PolicyKey.Organization != src.PolicyKey.Organization {
		m.PolicyKey.Organization = src.PolicyKey.Organization
		changed++
	}
	if m.PolicyKey.Name != src.PolicyKey.Name {
		m.PolicyKey.Name = src.PolicyKey.Name
		changed++
	}
	return changed
}

func (m *AppInstLookup) DeepCopyIn(src *AppInstLookup) {
	m.Key.DeepCopyIn(&src.Key)
	m.PolicyKey.DeepCopyIn(&src.PolicyKey)
}

type AppInstLookupByPolicyKey struct {
	PolicyKeys map[PolicyKey]map[AppInstKey]struct{}
	Mux        util.Mutex
}

func (s *AppInstLookupByPolicyKey) Init() {
	s.PolicyKeys = make(map[PolicyKey]map[AppInstKey]struct{})
}

func (s *AppInstLookupByPolicyKey) Updated(obj *AppInstLookup) {
	lookup := obj.PolicyKey

	s.Mux.Lock()
	defer s.Mux.Unlock()

	AppInstKeys, found := s.PolicyKeys[lookup]
	if !found {
		AppInstKeys = make(map[AppInstKey]struct{})
		s.PolicyKeys[lookup] = AppInstKeys
	}
	AppInstKeys[obj.GetKeyVal()] = struct{}{}
}

func (s *AppInstLookupByPolicyKey) Deleted(obj *AppInstLookup) {
	lookup := obj.PolicyKey

	s.Mux.Lock()
	defer s.Mux.Unlock()

	AppInstKeys, found := s.PolicyKeys[lookup]
	if found {
		delete(AppInstKeys, obj.GetKeyVal())
		if len(AppInstKeys) == 0 {
			delete(s.PolicyKeys, lookup)
		}
	}
}

func (s *AppInstLookupByPolicyKey) Find(lookup PolicyKey) []AppInstKey {
	s.Mux.Lock()
	defer s.Mux.Unlock()

	list := []AppInstKey{}
	for k, _ := range s.PolicyKeys[lookup] {
		list = append(list, k)
	}
	return list
}

func (m *AppInstLookup) GetObjKey() objstore.ObjKey {
	return m.GetKey()
}

func (m *AppInstLookup) GetKey() *AppInstKey {
	return &m.Key
}

func (m *AppInstLookup) GetKeyVal() AppInstKey {
	return m.Key
}

func (m *AppInstLookup) SetKey(key *AppInstKey) {
	m.Key = *key
}

func CmpSortAppInstLookup(a AppInstLookup, b AppInstLookup) bool {
	return a.Key.GetKeyString() < b.Key.GetKeyString()
}

// Helper method to check that enums have valid values
func (m *AppInstLookup) ValidateEnums() error {
	if err := m.Key.ValidateEnums(); err != nil {
		return err
	}
	if err := m.PolicyKey.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func (s *AppInstLookup) ClearTagged(tags map[string]struct{}) {
	s.Key.ClearTagged(tags)
	s.PolicyKey.ClearTagged(tags)
}

func (m *AppInstLookup2) Clone() *AppInstLookup2 {
	cp := &AppInstLookup2{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *AppInstLookup2) CopyInFields(src *AppInstLookup2) int {
	changed := 0
	if m.Key.Name != src.Key.Name {
		m.Key.Name = src.Key.Name
		changed++
	}
	if m.Key.Organization != src.Key.Organization {
		m.Key.Organization = src.Key.Organization
		changed++
	}
	if m.CloudletKey.Organization != src.CloudletKey.Organization {
		m.CloudletKey.Organization = src.CloudletKey.Organization
		changed++
	}
	if m.CloudletKey.Name != src.CloudletKey.Name {
		m.CloudletKey.Name = src.CloudletKey.Name
		changed++
	}
	if m.CloudletKey.FederatedOrganization != src.CloudletKey.FederatedOrganization {
		m.CloudletKey.FederatedOrganization = src.CloudletKey.FederatedOrganization
		changed++
	}
	return changed
}

func (m *AppInstLookup2) DeepCopyIn(src *AppInstLookup2) {
	m.Key.DeepCopyIn(&src.Key)
	m.CloudletKey.DeepCopyIn(&src.CloudletKey)
}

type AppInstLookup2ByCloudletKey struct {
	CloudletKeys map[CloudletKey]map[AppInstKey]struct{}
	Mux          util.Mutex
}

func (s *AppInstLookup2ByCloudletKey) Init() {
	s.CloudletKeys = make(map[CloudletKey]map[AppInstKey]struct{})
}

func (s *AppInstLookup2ByCloudletKey) Updated(obj *AppInstLookup2) {
	lookup := obj.CloudletKey

	s.Mux.Lock()
	defer s.Mux.Unlock()

	AppInstKeys, found := s.CloudletKeys[lookup]
	if !found {
		AppInstKeys = make(map[AppInstKey]struct{})
		s.CloudletKeys[lookup] = AppInstKeys
	}
	AppInstKeys[obj.GetKeyVal()] = struct{}{}
}

func (s *AppInstLookup2ByCloudletKey) Deleted(obj *AppInstLookup2) {
	lookup := obj.CloudletKey

	s.Mux.Lock()
	defer s.Mux.Unlock()

	AppInstKeys, found := s.CloudletKeys[lookup]
	if found {
		delete(AppInstKeys, obj.GetKeyVal())
		if len(AppInstKeys) == 0 {
			delete(s.CloudletKeys, lookup)
		}
	}
}

func (s *AppInstLookup2ByCloudletKey) Find(lookup CloudletKey) []AppInstKey {
	s.Mux.Lock()
	defer s.Mux.Unlock()

	list := []AppInstKey{}
	for k, _ := range s.CloudletKeys[lookup] {
		list = append(list, k)
	}
	return list
}

func (m *AppInstLookup2) GetObjKey() objstore.ObjKey {
	return m.GetKey()
}

func (m *AppInstLookup2) GetKey() *AppInstKey {
	return &m.Key
}

func (m *AppInstLookup2) GetKeyVal() AppInstKey {
	return m.Key
}

func (m *AppInstLookup2) SetKey(key *AppInstKey) {
	m.Key = *key
}

func CmpSortAppInstLookup2(a AppInstLookup2, b AppInstLookup2) bool {
	return a.Key.GetKeyString() < b.Key.GetKeyString()
}

// Helper method to check that enums have valid values
func (m *AppInstLookup2) ValidateEnums() error {
	if err := m.Key.ValidateEnums(); err != nil {
		return err
	}
	if err := m.CloudletKey.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func (s *AppInstLookup2) ClearTagged(tags map[string]struct{}) {
	s.Key.ClearTagged(tags)
	s.CloudletKey.ClearTagged(tags)
}

func (m *AppInstLatency) Clone() *AppInstLatency {
	cp := &AppInstLatency{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *AppInstLatency) CopyInFields(src *AppInstLatency) int {
	changed := 0
	if m.Key.Name != src.Key.Name {
		m.Key.Name = src.Key.Name
		changed++
	}
	if m.Key.Organization != src.Key.Organization {
		m.Key.Organization = src.Key.Organization
		changed++
	}
	return changed
}

func (m *AppInstLatency) DeepCopyIn(src *AppInstLatency) {
	m.Key.DeepCopyIn(&src.Key)
}

func (m *AppInstLatency) GetObjKey() objstore.ObjKey {
	return m.GetKey()
}

func (m *AppInstLatency) GetKey() *AppInstKey {
	return &m.Key
}

func (m *AppInstLatency) GetKeyVal() AppInstKey {
	return m.Key
}

func (m *AppInstLatency) SetKey(key *AppInstKey) {
	m.Key = *key
}

func CmpSortAppInstLatency(a AppInstLatency, b AppInstLatency) bool {
	return a.Key.GetKeyString() < b.Key.GetKeyString()
}

// Helper method to check that enums have valid values
func (m *AppInstLatency) ValidateEnums() error {
	if err := m.Key.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func (s *AppInstLatency) ClearTagged(tags map[string]struct{}) {
	s.Key.ClearTagged(tags)
}

func (m *FedAppInstKey) Matches(o *FedAppInstKey, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !opts.Filter || o.FederationName != "" {
		if o.FederationName != m.FederationName {
			return false
		}
	}
	if !opts.Filter || o.AppInstId != "" {
		if o.AppInstId != m.AppInstId {
			return false
		}
	}
	return true
}

func (m *FedAppInstKey) Clone() *FedAppInstKey {
	cp := &FedAppInstKey{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *FedAppInstKey) CopyInFields(src *FedAppInstKey) int {
	changed := 0
	if m.FederationName != src.FederationName {
		m.FederationName = src.FederationName
		changed++
	}
	if m.AppInstId != src.AppInstId {
		m.AppInstId = src.AppInstId
		changed++
	}
	return changed
}

func (m *FedAppInstKey) DeepCopyIn(src *FedAppInstKey) {
	m.FederationName = src.FederationName
	m.AppInstId = src.AppInstId
}

func (m *FedAppInstKey) GetKeyString() string {
	key, err := json.Marshal(m)
	if err != nil {
		log.FatalLog("Failed to marshal FedAppInstKey key string", "obj", m)
	}
	return string(key)
}

func FedAppInstKeyStringParse(str string, key *FedAppInstKey) {
	err := json.Unmarshal([]byte(str), key)
	if err != nil {
		log.FatalLog("Failed to unmarshal FedAppInstKey key string", "str", str)
	}
}

func (m *FedAppInstKey) NotFoundError() error {
	return fmt.Errorf("FedAppInst key %s not found", m.GetKeyString())
}

func (m *FedAppInstKey) ExistsError() error {
	return fmt.Errorf("FedAppInst key %s already exists", m.GetKeyString())
}

func (m *FedAppInstKey) BeingDeletedError() error {
	return fmt.Errorf("FedAppInst %s is being deleted", m.GetKeyString())
}

var FedAppInstKeyTagFederationName = "federationname"
var FedAppInstKeyTagAppInstId = "appinstid"

func (m *FedAppInstKey) GetTags() map[string]string {
	tags := make(map[string]string)
	m.AddTags(tags)
	return tags
}

func (m *FedAppInstKey) AddTagsByFunc(addTag AddTagFunc) {
	addTag("federationname", m.FederationName)
	addTag("appinstid", m.AppInstId)
}

func (m *FedAppInstKey) AddTags(tags map[string]string) {
	tagMap := TagMap(tags)
	m.AddTagsByFunc(tagMap.AddTag)
}

// Helper method to check that enums have valid values
func (m *FedAppInstKey) ValidateEnums() error {
	return nil
}

func (s *FedAppInstKey) ClearTagged(tags map[string]struct{}) {
}

func (m *FedAppInst) Matches(o *FedAppInst, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !m.Key.Matches(&o.Key, fopts...) {
		return false
	}
	if !m.AppInstKey.Matches(&o.AppInstKey, fopts...) {
		return false
	}
	return true
}

func (m *FedAppInst) Clone() *FedAppInst {
	cp := &FedAppInst{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *FedAppInst) CopyInFields(src *FedAppInst) int {
	changed := 0
	if m.Key.FederationName != src.Key.FederationName {
		m.Key.FederationName = src.Key.FederationName
		changed++
	}
	if m.Key.AppInstId != src.Key.AppInstId {
		m.Key.AppInstId = src.Key.AppInstId
		changed++
	}
	if m.AppInstKey.Name != src.AppInstKey.Name {
		m.AppInstKey.Name = src.AppInstKey.Name
		changed++
	}
	if m.AppInstKey.Organization != src.AppInstKey.Organization {
		m.AppInstKey.Organization = src.AppInstKey.Organization
		changed++
	}
	return changed
}

func (m *FedAppInst) DeepCopyIn(src *FedAppInst) {
	m.Key.DeepCopyIn(&src.Key)
	m.AppInstKey.DeepCopyIn(&src.AppInstKey)
}

func (s *FedAppInst) HasFields() bool {
	return false
}

type FedAppInstStore interface {
	Create(ctx context.Context, m *FedAppInst, wait func(int64)) (*Result, error)
	Update(ctx context.Context, m *FedAppInst, wait func(int64)) (*Result, error)
	Delete(ctx context.Context, m *FedAppInst, wait func(int64)) (*Result, error)
	Put(ctx context.Context, m *FedAppInst, wait func(int64), ops ...objstore.KVOp) (*Result, error)
	LoadOne(key string) (*FedAppInst, int64, error)
	Get(ctx context.Context, key *FedAppInstKey, buf *FedAppInst) bool
	STMGet(stm concurrency.STM, key *FedAppInstKey, buf *FedAppInst) bool
	STMPut(stm concurrency.STM, obj *FedAppInst, ops ...objstore.KVOp)
	STMDel(stm concurrency.STM, key *FedAppInstKey)
	STMHas(stm concurrency.STM, key *FedAppInstKey) bool
}

type FedAppInstStoreImpl struct {
	kvstore objstore.KVStore
}

func NewFedAppInstStore(kvstore objstore.KVStore) *FedAppInstStoreImpl {
	return &FedAppInstStoreImpl{kvstore: kvstore}
}

func (s *FedAppInstStoreImpl) Create(ctx context.Context, m *FedAppInst, wait func(int64)) (*Result, error) {
	err := m.Validate(nil)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("FedAppInst", m.GetKey())
	val, err := json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Create(ctx, key, string(val))
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *FedAppInstStoreImpl) Update(ctx context.Context, m *FedAppInst, wait func(int64)) (*Result, error) {
	err := m.Validate(nil)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("FedAppInst", m.GetKey())
	var vers int64 = 0
	val, err := json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Update(ctx, key, string(val), vers)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *FedAppInstStoreImpl) Put(ctx context.Context, m *FedAppInst, wait func(int64), ops ...objstore.KVOp) (*Result, error) {
	err := m.Validate(nil)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("FedAppInst", m.GetKey())
	var val []byte
	val, err = json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Put(ctx, key, string(val), ops...)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *FedAppInstStoreImpl) Delete(ctx context.Context, m *FedAppInst, wait func(int64)) (*Result, error) {
	err := m.GetKey().ValidateKey()
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("FedAppInst", m.GetKey())
	rev, err := s.kvstore.Delete(ctx, key)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *FedAppInstStoreImpl) LoadOne(key string) (*FedAppInst, int64, error) {
	val, rev, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, 0, err
	}
	var obj FedAppInst
	err = json.Unmarshal(val, &obj)
	if err != nil {
		log.DebugLog(log.DebugLevelApi, "Failed to parse FedAppInst data", "val", string(val), "err", err)
		return nil, 0, err
	}
	return &obj, rev, nil
}

func (s *FedAppInstStoreImpl) Get(ctx context.Context, key *FedAppInstKey, buf *FedAppInst) bool {
	keystr := objstore.DbKeyString("FedAppInst", key)
	val, _, _, err := s.kvstore.Get(keystr)
	if err != nil {
		return false
	}
	return s.parseGetData(val, buf)
}

func (s *FedAppInstStoreImpl) STMGet(stm concurrency.STM, key *FedAppInstKey, buf *FedAppInst) bool {
	keystr := objstore.DbKeyString("FedAppInst", key)
	valstr := stm.Get(keystr)
	return s.parseGetData([]byte(valstr), buf)
}

func (s *FedAppInstStoreImpl) STMHas(stm concurrency.STM, key *FedAppInstKey) bool {
	keystr := objstore.DbKeyString("FedAppInst", key)
	return stm.Get(keystr) != ""
}

func (s *FedAppInstStoreImpl) parseGetData(val []byte, buf *FedAppInst) bool {
	if len(val) == 0 {
		return false
	}
	if buf != nil {
		// clear buf, because empty values in val won't
		// overwrite non-empty values in buf.
		*buf = FedAppInst{}
		err := json.Unmarshal(val, buf)
		if err != nil {
			return false
		}
	}
	return true
}

func (s *FedAppInstStoreImpl) STMPut(stm concurrency.STM, obj *FedAppInst, ops ...objstore.KVOp) {
	keystr := objstore.DbKeyString("FedAppInst", obj.GetKey())

	val, err := json.Marshal(obj)
	if err != nil {
		log.InfoLog("FedAppInst json marshal failed", "obj", obj, "err", err)
	}
	v3opts := GetSTMOpts(ops...)
	stm.Put(keystr, string(val), v3opts...)
}

func (s *FedAppInstStoreImpl) STMDel(stm concurrency.STM, key *FedAppInstKey) {
	keystr := objstore.DbKeyString("FedAppInst", key)
	stm.Del(keystr)
}

type FedAppInstKeyWatcher struct {
	cb func(ctx context.Context)
}

type FedAppInstCacheData struct {
	Obj    *FedAppInst
	ModRev int64
}

func (s *FedAppInstCacheData) Clone() *FedAppInstCacheData {
	cp := FedAppInstCacheData{}
	if s.Obj != nil {
		cp.Obj = &FedAppInst{}
		cp.Obj.DeepCopyIn(s.Obj)
	}
	cp.ModRev = s.ModRev
	return &cp
}

// FedAppInstCache caches FedAppInst objects in memory in a hash table
// and keeps them in sync with the database.
type FedAppInstCache struct {
	Objs          map[FedAppInstKey]*FedAppInstCacheData
	Mux           util.Mutex
	List          map[FedAppInstKey]struct{}
	FlushAll      bool
	NotifyCbs     []func(ctx context.Context, obj *FedAppInst, modRev int64)
	UpdatedCbs    []func(ctx context.Context, old *FedAppInst, new *FedAppInst)
	DeletedCbs    []func(ctx context.Context, old *FedAppInst)
	KeyWatchers   map[FedAppInstKey][]*FedAppInstKeyWatcher
	UpdatedKeyCbs []func(ctx context.Context, key *FedAppInstKey)
	DeletedKeyCbs []func(ctx context.Context, key *FedAppInstKey)
	Store         FedAppInstStore
}

func NewFedAppInstCache() *FedAppInstCache {
	cache := FedAppInstCache{}
	InitFedAppInstCache(&cache)
	return &cache
}

func InitFedAppInstCache(cache *FedAppInstCache) {
	cache.Objs = make(map[FedAppInstKey]*FedAppInstCacheData)
	cache.KeyWatchers = make(map[FedAppInstKey][]*FedAppInstKeyWatcher)
	cache.NotifyCbs = nil
	cache.UpdatedCbs = nil
	cache.DeletedCbs = nil
	cache.UpdatedKeyCbs = nil
	cache.DeletedKeyCbs = nil
}

func (c *FedAppInstCache) GetTypeString() string {
	return "FedAppInst"
}

func (c *FedAppInstCache) Get(key *FedAppInstKey, valbuf *FedAppInst) bool {
	var modRev int64
	return c.GetWithRev(key, valbuf, &modRev)
}

func (c *FedAppInstCache) GetWithRev(key *FedAppInstKey, valbuf *FedAppInst, modRev *int64) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	inst, found := c.Objs[*key]
	if found {
		valbuf.DeepCopyIn(inst.Obj)
		*modRev = inst.ModRev
	}
	return found
}

func (c *FedAppInstCache) HasKey(key *FedAppInstKey) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	_, found := c.Objs[*key]
	return found
}

func (c *FedAppInstCache) GetAllKeys(ctx context.Context, cb func(key *FedAppInstKey, modRev int64)) {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for key, data := range c.Objs {
		cb(&key, data.ModRev)
	}
}

func (c *FedAppInstCache) GetAllLocked(ctx context.Context, cb func(obj *FedAppInst, modRev int64)) {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for _, data := range c.Objs {
		cb(data.Obj, data.ModRev)
	}
}

func (c *FedAppInstCache) Update(ctx context.Context, in *FedAppInst, modRev int64) {
	c.UpdateModFunc(ctx, in.GetKey(), modRev, func(old *FedAppInst) (*FedAppInst, bool) {
		return in, true
	})
}

func (c *FedAppInstCache) UpdateModFunc(ctx context.Context, key *FedAppInstKey, modRev int64, modFunc func(old *FedAppInst) (new *FedAppInst, changed bool)) {
	c.Mux.Lock()
	var old *FedAppInst
	if oldData, found := c.Objs[*key]; found {
		old = oldData.Obj
	}
	new, changed := modFunc(old)
	if !changed {
		c.Mux.Unlock()
		return
	}
	if len(c.UpdatedCbs) > 0 || len(c.NotifyCbs) > 0 {
		newCopy := &FedAppInst{}
		newCopy.DeepCopyIn(new)
		for _, cb := range c.UpdatedCbs {
			defer cb(ctx, old, newCopy)
		}
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				defer cb(ctx, newCopy, modRev)
			}
		}
	}
	for _, cb := range c.UpdatedKeyCbs {
		defer cb(ctx, key)
	}
	store := &FedAppInst{}
	store.DeepCopyIn(new)
	c.Objs[new.GetKeyVal()] = &FedAppInstCacheData{
		Obj:    store,
		ModRev: modRev,
	}
	log.SpanLog(ctx, log.DebugLevelApi, "cache update", "new", store)
	c.Mux.Unlock()
	c.TriggerKeyWatchers(ctx, new.GetKey())
}

func (c *FedAppInstCache) Delete(ctx context.Context, in *FedAppInst, modRev int64) {
	c.DeleteCondFunc(ctx, in, modRev, func(old *FedAppInst) bool {
		return true
	})
}

func (c *FedAppInstCache) DeleteCondFunc(ctx context.Context, in *FedAppInst, modRev int64, condFunc func(old *FedAppInst) bool) {
	c.Mux.Lock()
	var old *FedAppInst
	oldData, found := c.Objs[in.GetKeyVal()]
	if found {
		old = oldData.Obj
		if !condFunc(old) {
			c.Mux.Unlock()
			return
		}
	}
	delete(c.Objs, in.GetKeyVal())
	log.SpanLog(ctx, log.DebugLevelApi, "cache delete", "key", in.GetKeyVal())
	c.Mux.Unlock()
	obj := old
	if obj == nil {
		obj = in
	}
	for _, cb := range c.NotifyCbs {
		if cb != nil {
			cb(ctx, obj, modRev)
		}
	}
	if old != nil {
		for _, cb := range c.DeletedCbs {
			cb(ctx, old)
		}
	}
	for _, cb := range c.DeletedKeyCbs {
		cb(ctx, in.GetKey())
	}
	c.TriggerKeyWatchers(ctx, in.GetKey())
}

func (c *FedAppInstCache) Prune(ctx context.Context, validKeys map[FedAppInstKey]struct{}) {
	log.SpanLog(ctx, log.DebugLevelApi, "Prune FedAppInst", "numValidKeys", len(validKeys))
	notify := make(map[FedAppInstKey]*FedAppInstCacheData)
	c.Mux.Lock()
	for key, _ := range c.Objs {
		if _, ok := validKeys[key]; !ok {
			if len(c.NotifyCbs) > 0 || len(c.DeletedKeyCbs) > 0 || len(c.DeletedCbs) > 0 {
				notify[key] = c.Objs[key]
			}
			delete(c.Objs, key)
		}
	}
	c.Mux.Unlock()
	for key, old := range notify {
		obj := old.Obj
		if obj == nil {
			obj = &FedAppInst{}
			obj.SetKey(&key)
		}
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, obj, old.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if old.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, old.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (c *FedAppInstCache) GetCount() int {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	return len(c.Objs)
}

func (c *FedAppInstCache) Flush(ctx context.Context, notifyId int64) {
}

func (c *FedAppInstCache) Show(filter *FedAppInst, cb func(ret *FedAppInst) error) error {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for _, data := range c.Objs {
		if !data.Obj.Matches(filter, MatchFilter()) {
			continue
		}
		err := cb(data.Obj)
		if err != nil {
			return err
		}
	}
	return nil
}

func FedAppInstGenericNotifyCb(fn func(key *FedAppInstKey, old *FedAppInst)) func(objstore.ObjKey, objstore.Obj) {
	return func(objkey objstore.ObjKey, obj objstore.Obj) {
		fn(objkey.(*FedAppInstKey), obj.(*FedAppInst))
	}
}

func (c *FedAppInstCache) SetNotifyCb(fn func(ctx context.Context, obj *FedAppInst, modRev int64)) {
	c.NotifyCbs = []func(ctx context.Context, obj *FedAppInst, modRev int64){fn}
}

func (c *FedAppInstCache) SetUpdatedCb(fn func(ctx context.Context, old *FedAppInst, new *FedAppInst)) {
	c.UpdatedCbs = []func(ctx context.Context, old *FedAppInst, new *FedAppInst){fn}
}

func (c *FedAppInstCache) SetDeletedCb(fn func(ctx context.Context, old *FedAppInst)) {
	c.DeletedCbs = []func(ctx context.Context, old *FedAppInst){fn}
}

func (c *FedAppInstCache) SetUpdatedKeyCb(fn func(ctx context.Context, key *FedAppInstKey)) {
	c.UpdatedKeyCbs = []func(ctx context.Context, key *FedAppInstKey){fn}
}

func (c *FedAppInstCache) SetDeletedKeyCb(fn func(ctx context.Context, key *FedAppInstKey)) {
	c.DeletedKeyCbs = []func(ctx context.Context, key *FedAppInstKey){fn}
}

func (c *FedAppInstCache) AddUpdatedCb(fn func(ctx context.Context, old *FedAppInst, new *FedAppInst)) {
	c.UpdatedCbs = append(c.UpdatedCbs, fn)
}

func (c *FedAppInstCache) AddDeletedCb(fn func(ctx context.Context, old *FedAppInst)) {
	c.DeletedCbs = append(c.DeletedCbs, fn)
}

func (c *FedAppInstCache) AddNotifyCb(fn func(ctx context.Context, obj *FedAppInst, modRev int64)) {
	c.NotifyCbs = append(c.NotifyCbs, fn)
}

func (c *FedAppInstCache) AddUpdatedKeyCb(fn func(ctx context.Context, key *FedAppInstKey)) {
	c.UpdatedKeyCbs = append(c.UpdatedKeyCbs, fn)
}

func (c *FedAppInstCache) AddDeletedKeyCb(fn func(ctx context.Context, key *FedAppInstKey)) {
	c.DeletedKeyCbs = append(c.DeletedKeyCbs, fn)
}

func (c *FedAppInstCache) SetFlushAll() {
	c.FlushAll = true
}

func (c *FedAppInstCache) WatchKey(key *FedAppInstKey, cb func(ctx context.Context)) context.CancelFunc {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	list, ok := c.KeyWatchers[*key]
	if !ok {
		list = make([]*FedAppInstKeyWatcher, 0)
	}
	watcher := FedAppInstKeyWatcher{cb: cb}
	c.KeyWatchers[*key] = append(list, &watcher)
	log.DebugLog(log.DebugLevelApi, "Watching FedAppInst", "key", key)
	return func() {
		c.Mux.Lock()
		defer c.Mux.Unlock()
		list, ok := c.KeyWatchers[*key]
		if !ok {
			return
		}
		for ii, _ := range list {
			if list[ii] != &watcher {
				continue
			}
			if len(list) == 1 {
				delete(c.KeyWatchers, *key)
				return
			}
			list[ii] = list[len(list)-1]
			list[len(list)-1] = nil
			c.KeyWatchers[*key] = list[:len(list)-1]
			return
		}
	}
}

func (c *FedAppInstCache) TriggerKeyWatchers(ctx context.Context, key *FedAppInstKey) {
	watchers := make([]*FedAppInstKeyWatcher, 0)
	c.Mux.Lock()
	if list, ok := c.KeyWatchers[*key]; ok {
		watchers = append(watchers, list...)
	}
	c.Mux.Unlock()
	for ii, _ := range watchers {
		watchers[ii].cb(ctx)
	}
}

// Note that we explicitly ignore the global revision number, because of the way
// the notify framework sends updates (by hashing keys and doing lookups, instead
// of sequentially through a history buffer), updates may be done out-of-order
// or multiple updates compressed into one update, so the state of the cache at
// any point in time may not by in sync with a particular database revision number.

func (c *FedAppInstCache) SyncUpdate(ctx context.Context, key, val []byte, rev, modRev int64) {
	obj := FedAppInst{}
	err := json.Unmarshal(val, &obj)
	if err != nil {
		log.WarnLog("Failed to parse FedAppInst data", "val", string(val), "err", err)
		return
	}
	c.Update(ctx, &obj, modRev)
	c.Mux.Lock()
	if c.List != nil {
		c.List[obj.GetKeyVal()] = struct{}{}
	}
	c.Mux.Unlock()
}

func (c *FedAppInstCache) SyncDelete(ctx context.Context, key []byte, rev, modRev int64) {
	obj := FedAppInst{}
	keystr := objstore.DbKeyPrefixRemove(string(key))
	FedAppInstKeyStringParse(keystr, obj.GetKey())
	c.Delete(ctx, &obj, modRev)
}

func (c *FedAppInstCache) SyncListStart(ctx context.Context) {
	c.List = make(map[FedAppInstKey]struct{})
}

func (c *FedAppInstCache) SyncListEnd(ctx context.Context) {
	deleted := make(map[FedAppInstKey]*FedAppInstCacheData)
	c.Mux.Lock()
	for key, val := range c.Objs {
		if _, found := c.List[key]; !found {
			deleted[key] = val
			delete(c.Objs, key)
		}
	}
	c.List = nil
	c.Mux.Unlock()
	for key, val := range deleted {
		obj := val.Obj
		if obj == nil {
			obj = &FedAppInst{}
			obj.SetKey(&key)
		}
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, obj, val.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if val.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, val.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (s *FedAppInstCache) InitCacheWithSync(sync DataSync) {
	InitFedAppInstCache(s)
	s.InitSync(sync)
}

func (s *FedAppInstCache) InitSync(sync DataSync) {
	if sync != nil {
		s.Store = NewFedAppInstStore(sync.GetKVStore())
		sync.RegisterCache(s)
	}
}

func (c *FedAppInstCache) UsesOrg(org string) bool {
	return false
}

func (m *FedAppInst) GetObjKey() objstore.ObjKey {
	return m.GetKey()
}

func (m *FedAppInst) GetKey() *FedAppInstKey {
	return &m.Key
}

func (m *FedAppInst) GetKeyVal() FedAppInstKey {
	return m.Key
}

func (m *FedAppInst) SetKey(key *FedAppInstKey) {
	m.Key = *key
}

func CmpSortFedAppInst(a FedAppInst, b FedAppInst) bool {
	return a.Key.GetKeyString() < b.Key.GetKeyString()
}

// Helper method to check that enums have valid values
func (m *FedAppInst) ValidateEnums() error {
	if err := m.Key.ValidateEnums(); err != nil {
		return err
	}
	if err := m.AppInstKey.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func (s *FedAppInst) ClearTagged(tags map[string]struct{}) {
	s.Key.ClearTagged(tags)
	s.AppInstKey.ClearTagged(tags)
}

func (m *FedAppInstEvent) Clone() *FedAppInstEvent {
	cp := &FedAppInstEvent{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *FedAppInstEvent) AddPorts(vals ...distributed_match_engine.AppPort) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.Ports {
		cur[v.String()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.String()]; found {
			continue // duplicate
		}
		m.Ports = append(m.Ports, v)
		changes++
	}
	return changes
}

func (m *FedAppInstEvent) RemovePorts(vals ...distributed_match_engine.AppPort) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.String()] = struct{}{}
	}
	for i := len(m.Ports); i >= 0; i-- {
		if _, found := remove[m.Ports[i].String()]; found {
			m.Ports = append(m.Ports[:i], m.Ports[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *FedAppInstEvent) CopyInFields(src *FedAppInstEvent) int {
	updateListAction := "replace"
	changed := 0
	if m.Key.FederationName != src.Key.FederationName {
		m.Key.FederationName = src.Key.FederationName
		changed++
	}
	if m.Key.AppInstId != src.Key.AppInstId {
		m.Key.AppInstId = src.Key.AppInstId
		changed++
	}
	if m.State != src.State {
		m.State = src.State
		changed++
	}
	if m.Message != src.Message {
		m.Message = src.Message
		changed++
	}
	if src.Ports != nil {
		if updateListAction == "add" {
			changed += m.AddPorts(src.Ports...)
		} else if updateListAction == "remove" {
			changed += m.RemovePorts(src.Ports...)
		} else {
			m.Ports = make([]distributed_match_engine.AppPort, 0)
			for k0, _ := range src.Ports {
				m.Ports = append(m.Ports, *src.Ports[k0].Clone())
			}
			changed++
		}
	} else if m.Ports != nil {
		m.Ports = nil
		changed++
	}
	if m.UniqueId != src.UniqueId {
		m.UniqueId = src.UniqueId
		changed++
	}
	return changed
}

func (m *FedAppInstEvent) DeepCopyIn(src *FedAppInstEvent) {
	m.Key.DeepCopyIn(&src.Key)
	m.State = src.State
	m.Message = src.Message
	if src.Ports != nil {
		m.Ports = make([]distributed_match_engine.AppPort, len(src.Ports), len(src.Ports))
		for ii, s := range src.Ports {
			m.Ports[ii] = s
		}
	} else {
		m.Ports = nil
	}
	m.UniqueId = src.UniqueId
}

func (m *FedAppInstEvent) GetObjKey() objstore.ObjKey {
	return m.GetKey()
}

func (m *FedAppInstEvent) GetKey() *FedAppInstKey {
	return &m.Key
}

func (m *FedAppInstEvent) GetKeyVal() FedAppInstKey {
	return m.Key
}

func (m *FedAppInstEvent) SetKey(key *FedAppInstKey) {
	m.Key = *key
}

func CmpSortFedAppInstEvent(a FedAppInstEvent, b FedAppInstEvent) bool {
	return a.Key.GetKeyString() < b.Key.GetKeyString()
}

// MessageKey can be used as a channel name which includes the
// key value for pubsub, to listen for this specific object type
// plus key value.
func (m *FedAppInstEvent) MessageKey() string {
	return fmt.Sprintf("msg/key/FedAppInstEvent/%s", m.GetKey().GetKeyString())
}

func (m *FedAppInstEvent) MessageTypeKey() string {
	return "msg/type/FedAppInstEvent"
}

// Helper method to check that enums have valid values
func (m *FedAppInstEvent) ValidateEnums() error {
	if err := m.Key.ValidateEnums(); err != nil {
		return err
	}
	if _, ok := TrackedState_name[int32(m.State)]; !ok {
		return errors.New("invalid State")
	}
	return nil
}

func (s *FedAppInstEvent) ClearTagged(tags map[string]struct{}) {
	s.Key.ClearTagged(tags)
}

var PowerStateStrings = []string{
	"POWER_STATE_UNKNOWN",
	"POWER_ON_REQUESTED",
	"POWERING_ON",
	"POWER_ON",
	"POWER_OFF_REQUESTED",
	"POWERING_OFF",
	"POWER_OFF",
	"REBOOT_REQUESTED",
	"REBOOTING",
	"REBOOT",
	"POWER_STATE_ERROR",
}

const (
	PowerStatePOWER_STATE_UNKNOWN uint64 = 1 << 0
	PowerStatePOWER_ON_REQUESTED  uint64 = 1 << 1
	PowerStatePOWERING_ON         uint64 = 1 << 2
	PowerStatePOWER_ON            uint64 = 1 << 3
	PowerStatePOWER_OFF_REQUESTED uint64 = 1 << 4
	PowerStatePOWERING_OFF        uint64 = 1 << 5
	PowerStatePOWER_OFF           uint64 = 1 << 6
	PowerStateREBOOT_REQUESTED    uint64 = 1 << 7
	PowerStateREBOOTING           uint64 = 1 << 8
	PowerStateREBOOT              uint64 = 1 << 9
	PowerStatePOWER_STATE_ERROR   uint64 = 1 << 10
)

var PowerState_CamelName = map[int32]string{
	// POWER_STATE_UNKNOWN -> PowerStateUnknown
	0: "PowerStateUnknown",
	// POWER_ON_REQUESTED -> PowerOnRequested
	1: "PowerOnRequested",
	// POWERING_ON -> PoweringOn
	2: "PoweringOn",
	// POWER_ON -> PowerOn
	3: "PowerOn",
	// POWER_OFF_REQUESTED -> PowerOffRequested
	4: "PowerOffRequested",
	// POWERING_OFF -> PoweringOff
	5: "PoweringOff",
	// POWER_OFF -> PowerOff
	6: "PowerOff",
	// REBOOT_REQUESTED -> RebootRequested
	7: "RebootRequested",
	// REBOOTING -> Rebooting
	8: "Rebooting",
	// REBOOT -> Reboot
	9: "Reboot",
	// POWER_STATE_ERROR -> PowerStateError
	10: "PowerStateError",
}
var PowerState_CamelValue = map[string]int32{
	"PowerStateUnknown": 0,
	"PowerOnRequested":  1,
	"PoweringOn":        2,
	"PowerOn":           3,
	"PowerOffRequested": 4,
	"PoweringOff":       5,
	"PowerOff":          6,
	"RebootRequested":   7,
	"Rebooting":         8,
	"Reboot":            9,
	"PowerStateError":   10,
}

func ParsePowerState(data interface{}) (PowerState, error) {
	if val, ok := data.(PowerState); ok {
		return val, nil
	} else if str, ok := data.(string); ok {
		val, ok := PowerState_CamelValue[util.CamelCase(str)]
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = PowerState_CamelName[val]
			}
		}
		if !ok {
			return PowerState(0), fmt.Errorf("Invalid PowerState value %q", str)
		}
		return PowerState(val), nil
	} else if ival, ok := data.(int32); ok {
		if _, ok := PowerState_CamelName[ival]; ok {
			return PowerState(ival), nil
		} else {
			return PowerState(0), fmt.Errorf("Invalid PowerState value %d", ival)
		}
	}
	return PowerState(0), fmt.Errorf("Invalid PowerState value %v", data)
}

func (e *PowerState) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, err := ParsePowerState(str)
	if err != nil {
		return err
	}
	*e = val
	return nil
}

func (e PowerState) MarshalYAML() (interface{}, error) {
	str := proto.EnumName(PowerState_CamelName, int32(e))
	return str, nil
}

// custom JSON encoding/decoding
func (e *PowerState) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, err := ParsePowerState(str)
		if err != nil {
			return &json.UnmarshalTypeError{
				Value: "string " + str,
				Type:  reflect.TypeOf(PowerState(0)),
			}
		}
		*e = PowerState(val)
		return nil
	}
	var ival int32
	err = json.Unmarshal(b, &ival)
	if err == nil {
		val, err := ParsePowerState(ival)
		if err == nil {
			*e = val
			return nil
		}
	}
	return &json.UnmarshalTypeError{
		Value: "value " + string(b),
		Type:  reflect.TypeOf(PowerState(0)),
	}
}

func (e PowerState) MarshalJSON() ([]byte, error) {
	str := proto.EnumName(PowerState_CamelName, int32(e))
	return json.Marshal(str)
}
func (m *AppInst) IsValidArgsForCreateAppInst() error {
	if m.CloudletLoc.Latitude != 0 {
		return fmt.Errorf("Invalid field specified: CloudletLoc.Latitude, this field is only for internal use")
	}
	if m.CloudletLoc.Longitude != 0 {
		return fmt.Errorf("Invalid field specified: CloudletLoc.Longitude, this field is only for internal use")
	}
	if m.CloudletLoc.HorizontalAccuracy != 0 {
		return fmt.Errorf("Invalid field specified: CloudletLoc.HorizontalAccuracy, this field is only for internal use")
	}
	if m.CloudletLoc.VerticalAccuracy != 0 {
		return fmt.Errorf("Invalid field specified: CloudletLoc.VerticalAccuracy, this field is only for internal use")
	}
	if m.CloudletLoc.Altitude != 0 {
		return fmt.Errorf("Invalid field specified: CloudletLoc.Altitude, this field is only for internal use")
	}
	if m.CloudletLoc.Course != 0 {
		return fmt.Errorf("Invalid field specified: CloudletLoc.Course, this field is only for internal use")
	}
	if m.CloudletLoc.Speed != 0 {
		return fmt.Errorf("Invalid field specified: CloudletLoc.Speed, this field is only for internal use")
	}
	if m.CloudletLoc.Timestamp != nil {
		return fmt.Errorf("Invalid field specified: CloudletLoc.Timestamp, this field is only for internal use")
	}
	if m.Uri != "" {
		return fmt.Errorf("Invalid field specified: Uri, this field is only for internal use")
	}
	if m.Liveness != 0 {
		return fmt.Errorf("Invalid field specified: Liveness, this field is only for internal use")
	}
	if m.MappedPorts != nil {
		return fmt.Errorf("Invalid field specified: MappedPorts, this field is only for internal use")
	}
	if m.State != 0 {
		return fmt.Errorf("Invalid field specified: State, this field is only for internal use")
	}
	if m.Errors != nil {
		return fmt.Errorf("Invalid field specified: Errors, this field is only for internal use")
	}
	if m.RuntimeInfo.ContainerIds != nil {
		return fmt.Errorf("Invalid field specified: RuntimeInfo.ContainerIds, this field is only for internal use")
	}
	if m.CreatedAt.Seconds != 0 {
		return fmt.Errorf("Invalid field specified: CreatedAt.Seconds, this field is only for internal use")
	}
	if m.CreatedAt.Nanos != 0 {
		return fmt.Errorf("Invalid field specified: CreatedAt.Nanos, this field is only for internal use")
	}
	if m.AutoClusterIpAccess != 0 {
		return fmt.Errorf("Invalid field specified: AutoClusterIpAccess, this field is only for internal use")
	}
	if m.Revision != "" {
		return fmt.Errorf("Invalid field specified: Revision, this field is only for internal use")
	}
	if m.ForceUpdate != false {
		return fmt.Errorf("Invalid field specified: ForceUpdate, this field is only for internal use")
	}
	if m.UpdateMultiple != false {
		return fmt.Errorf("Invalid field specified: UpdateMultiple, this field is only for internal use")
	}
	if m.PowerState != 0 {
		return fmt.Errorf("Invalid field specified: PowerState, this field is only for internal use")
	}
	if m.ExternalVolumeSize != 0 {
		return fmt.Errorf("Invalid field specified: ExternalVolumeSize, this field is only for internal use")
	}
	if m.AvailabilityZone != "" {
		return fmt.Errorf("Invalid field specified: AvailabilityZone, this field is only for internal use")
	}
	if m.VmFlavor != "" {
		return fmt.Errorf("Invalid field specified: VmFlavor, this field is only for internal use")
	}
	if m.OptRes != "" {
		return fmt.Errorf("Invalid field specified: OptRes, this field is only for internal use")
	}
	if m.UpdatedAt.Seconds != 0 {
		return fmt.Errorf("Invalid field specified: UpdatedAt.Seconds, this field is only for internal use")
	}
	if m.UpdatedAt.Nanos != 0 {
		return fmt.Errorf("Invalid field specified: UpdatedAt.Nanos, this field is only for internal use")
	}
	if m.InternalPortToLbIp != nil {
		return fmt.Errorf("Invalid field specified: InternalPortToLbIp, this field is only for internal use")
	}
	if m.UniqueId != "" {
		return fmt.Errorf("Invalid field specified: UniqueId, this field is only for internal use")
	}
	if m.DnsLabel != "" {
		return fmt.Errorf("Invalid field specified: DnsLabel, this field is only for internal use")
	}
	if m.FedKey.FederationName != "" {
		return fmt.Errorf("Invalid field specified: FedKey.FederationName, this field is only for internal use")
	}
	if m.FedKey.AppInstId != "" {
		return fmt.Errorf("Invalid field specified: FedKey.AppInstId, this field is only for internal use")
	}
	if m.CompatibilityVersion != 0 {
		return fmt.Errorf("Invalid field specified: CompatibilityVersion, this field is only for internal use")
	}
	if m.VirtualClusterKey.Name != "" {
		return fmt.Errorf("Invalid field specified: VirtualClusterKey.Name, this field is only for internal use")
	}
	if m.VirtualClusterKey.Organization != "" {
		return fmt.Errorf("Invalid field specified: VirtualClusterKey.Organization, this field is only for internal use")
	}
	if m.StaticUri != "" {
		return fmt.Errorf("Invalid field specified: StaticUri, this field is only for internal use")
	}
	return nil
}

func (m *AppInst) IsValidArgsForDeleteAppInst() error {
	if m.CloudletLoc.Latitude != 0 {
		return fmt.Errorf("Invalid field specified: CloudletLoc.Latitude, this field is only for internal use")
	}
	if m.CloudletLoc.Longitude != 0 {
		return fmt.Errorf("Invalid field specified: CloudletLoc.Longitude, this field is only for internal use")
	}
	if m.CloudletLoc.HorizontalAccuracy != 0 {
		return fmt.Errorf("Invalid field specified: CloudletLoc.HorizontalAccuracy, this field is only for internal use")
	}
	if m.CloudletLoc.VerticalAccuracy != 0 {
		return fmt.Errorf("Invalid field specified: CloudletLoc.VerticalAccuracy, this field is only for internal use")
	}
	if m.CloudletLoc.Altitude != 0 {
		return fmt.Errorf("Invalid field specified: CloudletLoc.Altitude, this field is only for internal use")
	}
	if m.CloudletLoc.Course != 0 {
		return fmt.Errorf("Invalid field specified: CloudletLoc.Course, this field is only for internal use")
	}
	if m.CloudletLoc.Speed != 0 {
		return fmt.Errorf("Invalid field specified: CloudletLoc.Speed, this field is only for internal use")
	}
	if m.CloudletLoc.Timestamp != nil {
		return fmt.Errorf("Invalid field specified: CloudletLoc.Timestamp, this field is only for internal use")
	}
	if m.Uri != "" {
		return fmt.Errorf("Invalid field specified: Uri, this field is only for internal use")
	}
	if m.Liveness != 0 {
		return fmt.Errorf("Invalid field specified: Liveness, this field is only for internal use")
	}
	if m.MappedPorts != nil {
		return fmt.Errorf("Invalid field specified: MappedPorts, this field is only for internal use")
	}
	if m.State != 0 {
		return fmt.Errorf("Invalid field specified: State, this field is only for internal use")
	}
	if m.Errors != nil {
		return fmt.Errorf("Invalid field specified: Errors, this field is only for internal use")
	}
	if m.RuntimeInfo.ContainerIds != nil {
		return fmt.Errorf("Invalid field specified: RuntimeInfo.ContainerIds, this field is only for internal use")
	}
	if m.CreatedAt.Seconds != 0 {
		return fmt.Errorf("Invalid field specified: CreatedAt.Seconds, this field is only for internal use")
	}
	if m.CreatedAt.Nanos != 0 {
		return fmt.Errorf("Invalid field specified: CreatedAt.Nanos, this field is only for internal use")
	}
	if m.AutoClusterIpAccess != 0 {
		return fmt.Errorf("Invalid field specified: AutoClusterIpAccess, this field is only for internal use")
	}
	if m.Revision != "" {
		return fmt.Errorf("Invalid field specified: Revision, this field is only for internal use")
	}
	if m.PowerState != 0 {
		return fmt.Errorf("Invalid field specified: PowerState, this field is only for internal use")
	}
	if m.ExternalVolumeSize != 0 {
		return fmt.Errorf("Invalid field specified: ExternalVolumeSize, this field is only for internal use")
	}
	if m.AvailabilityZone != "" {
		return fmt.Errorf("Invalid field specified: AvailabilityZone, this field is only for internal use")
	}
	if m.VmFlavor != "" {
		return fmt.Errorf("Invalid field specified: VmFlavor, this field is only for internal use")
	}
	if m.OptRes != "" {
		return fmt.Errorf("Invalid field specified: OptRes, this field is only for internal use")
	}
	if m.UpdatedAt.Seconds != 0 {
		return fmt.Errorf("Invalid field specified: UpdatedAt.Seconds, this field is only for internal use")
	}
	if m.UpdatedAt.Nanos != 0 {
		return fmt.Errorf("Invalid field specified: UpdatedAt.Nanos, this field is only for internal use")
	}
	if m.InternalPortToLbIp != nil {
		return fmt.Errorf("Invalid field specified: InternalPortToLbIp, this field is only for internal use")
	}
	if m.UniqueId != "" {
		return fmt.Errorf("Invalid field specified: UniqueId, this field is only for internal use")
	}
	if m.DnsLabel != "" {
		return fmt.Errorf("Invalid field specified: DnsLabel, this field is only for internal use")
	}
	if m.FedKey.FederationName != "" {
		return fmt.Errorf("Invalid field specified: FedKey.FederationName, this field is only for internal use")
	}
	if m.FedKey.AppInstId != "" {
		return fmt.Errorf("Invalid field specified: FedKey.AppInstId, this field is only for internal use")
	}
	if m.CompatibilityVersion != 0 {
		return fmt.Errorf("Invalid field specified: CompatibilityVersion, this field is only for internal use")
	}
	if m.VirtualClusterKey.Name != "" {
		return fmt.Errorf("Invalid field specified: VirtualClusterKey.Name, this field is only for internal use")
	}
	if m.VirtualClusterKey.Organization != "" {
		return fmt.Errorf("Invalid field specified: VirtualClusterKey.Organization, this field is only for internal use")
	}
	if m.StaticUri != "" {
		return fmt.Errorf("Invalid field specified: StaticUri, this field is only for internal use")
	}
	return nil
}

func (m *AppInst) IsValidArgsForRefreshAppInst() error {
	if m.CloudletLoc.Latitude != 0 {
		return fmt.Errorf("Invalid field specified: CloudletLoc.Latitude, this field is only for internal use")
	}
	if m.CloudletLoc.Longitude != 0 {
		return fmt.Errorf("Invalid field specified: CloudletLoc.Longitude, this field is only for internal use")
	}
	if m.CloudletLoc.HorizontalAccuracy != 0 {
		return fmt.Errorf("Invalid field specified: CloudletLoc.HorizontalAccuracy, this field is only for internal use")
	}
	if m.CloudletLoc.VerticalAccuracy != 0 {
		return fmt.Errorf("Invalid field specified: CloudletLoc.VerticalAccuracy, this field is only for internal use")
	}
	if m.CloudletLoc.Altitude != 0 {
		return fmt.Errorf("Invalid field specified: CloudletLoc.Altitude, this field is only for internal use")
	}
	if m.CloudletLoc.Course != 0 {
		return fmt.Errorf("Invalid field specified: CloudletLoc.Course, this field is only for internal use")
	}
	if m.CloudletLoc.Speed != 0 {
		return fmt.Errorf("Invalid field specified: CloudletLoc.Speed, this field is only for internal use")
	}
	if m.CloudletLoc.Timestamp != nil {
		return fmt.Errorf("Invalid field specified: CloudletLoc.Timestamp, this field is only for internal use")
	}
	if m.Uri != "" {
		return fmt.Errorf("Invalid field specified: Uri, this field is only for internal use")
	}
	if m.Liveness != 0 {
		return fmt.Errorf("Invalid field specified: Liveness, this field is only for internal use")
	}
	if m.MappedPorts != nil {
		return fmt.Errorf("Invalid field specified: MappedPorts, this field is only for internal use")
	}
	if m.Flavor.Name != "" {
		return fmt.Errorf("Invalid field specified: Flavor.Name, this field is only for internal use")
	}
	if m.State != 0 {
		return fmt.Errorf("Invalid field specified: State, this field is only for internal use")
	}
	if m.Errors != nil {
		return fmt.Errorf("Invalid field specified: Errors, this field is only for internal use")
	}
	if m.RuntimeInfo.ContainerIds != nil {
		return fmt.Errorf("Invalid field specified: RuntimeInfo.ContainerIds, this field is only for internal use")
	}
	if m.CreatedAt.Seconds != 0 {
		return fmt.Errorf("Invalid field specified: CreatedAt.Seconds, this field is only for internal use")
	}
	if m.CreatedAt.Nanos != 0 {
		return fmt.Errorf("Invalid field specified: CreatedAt.Nanos, this field is only for internal use")
	}
	if m.AutoClusterIpAccess != 0 {
		return fmt.Errorf("Invalid field specified: AutoClusterIpAccess, this field is only for internal use")
	}
	if m.Revision != "" {
		return fmt.Errorf("Invalid field specified: Revision, this field is only for internal use")
	}
	if m.Configs != nil {
		return fmt.Errorf("Invalid field specified: Configs, this field is only for internal use")
	}
	if m.HealthCheck != 0 {
		return fmt.Errorf("Invalid field specified: HealthCheck, this field is only for internal use")
	}
	if m.PowerState != 0 {
		return fmt.Errorf("Invalid field specified: PowerState, this field is only for internal use")
	}
	if m.ExternalVolumeSize != 0 {
		return fmt.Errorf("Invalid field specified: ExternalVolumeSize, this field is only for internal use")
	}
	if m.AvailabilityZone != "" {
		return fmt.Errorf("Invalid field specified: AvailabilityZone, this field is only for internal use")
	}
	if m.VmFlavor != "" {
		return fmt.Errorf("Invalid field specified: VmFlavor, this field is only for internal use")
	}
	if m.OptRes != "" {
		return fmt.Errorf("Invalid field specified: OptRes, this field is only for internal use")
	}
	if m.UpdatedAt.Seconds != 0 {
		return fmt.Errorf("Invalid field specified: UpdatedAt.Seconds, this field is only for internal use")
	}
	if m.UpdatedAt.Nanos != 0 {
		return fmt.Errorf("Invalid field specified: UpdatedAt.Nanos, this field is only for internal use")
	}
	if m.InternalPortToLbIp != nil {
		return fmt.Errorf("Invalid field specified: InternalPortToLbIp, this field is only for internal use")
	}
	if m.UniqueId != "" {
		return fmt.Errorf("Invalid field specified: UniqueId, this field is only for internal use")
	}
	if m.DnsLabel != "" {
		return fmt.Errorf("Invalid field specified: DnsLabel, this field is only for internal use")
	}
	if m.FedKey.FederationName != "" {
		return fmt.Errorf("Invalid field specified: FedKey.FederationName, this field is only for internal use")
	}
	if m.FedKey.AppInstId != "" {
		return fmt.Errorf("Invalid field specified: FedKey.AppInstId, this field is only for internal use")
	}
	if m.CompatibilityVersion != 0 {
		return fmt.Errorf("Invalid field specified: CompatibilityVersion, this field is only for internal use")
	}
	if m.VirtualClusterKey.Name != "" {
		return fmt.Errorf("Invalid field specified: VirtualClusterKey.Name, this field is only for internal use")
	}
	if m.VirtualClusterKey.Organization != "" {
		return fmt.Errorf("Invalid field specified: VirtualClusterKey.Organization, this field is only for internal use")
	}
	if m.StaticUri != "" {
		return fmt.Errorf("Invalid field specified: StaticUri, this field is only for internal use")
	}
	return nil
}

func (m *AppInst) IsValidArgsForUpdateAppInst() error {
	if m.CloudletLoc.Latitude != 0 {
		return fmt.Errorf("Invalid field specified: CloudletLoc.Latitude, this field is only for internal use")
	}
	if m.CloudletLoc.Longitude != 0 {
		return fmt.Errorf("Invalid field specified: CloudletLoc.Longitude, this field is only for internal use")
	}
	if m.CloudletLoc.HorizontalAccuracy != 0 {
		return fmt.Errorf("Invalid field specified: CloudletLoc.HorizontalAccuracy, this field is only for internal use")
	}
	if m.CloudletLoc.VerticalAccuracy != 0 {
		return fmt.Errorf("Invalid field specified: CloudletLoc.VerticalAccuracy, this field is only for internal use")
	}
	if m.CloudletLoc.Altitude != 0 {
		return fmt.Errorf("Invalid field specified: CloudletLoc.Altitude, this field is only for internal use")
	}
	if m.CloudletLoc.Course != 0 {
		return fmt.Errorf("Invalid field specified: CloudletLoc.Course, this field is only for internal use")
	}
	if m.CloudletLoc.Speed != 0 {
		return fmt.Errorf("Invalid field specified: CloudletLoc.Speed, this field is only for internal use")
	}
	if m.CloudletLoc.Timestamp != nil {
		return fmt.Errorf("Invalid field specified: CloudletLoc.Timestamp, this field is only for internal use")
	}
	if m.Uri != "" {
		return fmt.Errorf("Invalid field specified: Uri, this field is only for internal use")
	}
	if m.Liveness != 0 {
		return fmt.Errorf("Invalid field specified: Liveness, this field is only for internal use")
	}
	if m.MappedPorts != nil {
		return fmt.Errorf("Invalid field specified: MappedPorts, this field is only for internal use")
	}
	if m.Flavor.Name != "" {
		return fmt.Errorf("Invalid field specified: Flavor.Name, this field is only for internal use")
	}
	if m.State != 0 {
		return fmt.Errorf("Invalid field specified: State, this field is only for internal use")
	}
	if m.Errors != nil {
		return fmt.Errorf("Invalid field specified: Errors, this field is only for internal use")
	}
	if m.RuntimeInfo.ContainerIds != nil {
		return fmt.Errorf("Invalid field specified: RuntimeInfo.ContainerIds, this field is only for internal use")
	}
	if m.CreatedAt.Seconds != 0 {
		return fmt.Errorf("Invalid field specified: CreatedAt.Seconds, this field is only for internal use")
	}
	if m.CreatedAt.Nanos != 0 {
		return fmt.Errorf("Invalid field specified: CreatedAt.Nanos, this field is only for internal use")
	}
	if m.AutoClusterIpAccess != 0 {
		return fmt.Errorf("Invalid field specified: AutoClusterIpAccess, this field is only for internal use")
	}
	if m.Revision != "" {
		return fmt.Errorf("Invalid field specified: Revision, this field is only for internal use")
	}
	if m.ForceUpdate != false {
		return fmt.Errorf("Invalid field specified: ForceUpdate, this field is only for internal use")
	}
	if m.UpdateMultiple != false {
		return fmt.Errorf("Invalid field specified: UpdateMultiple, this field is only for internal use")
	}
	if m.HealthCheck != 0 {
		return fmt.Errorf("Invalid field specified: HealthCheck, this field is only for internal use")
	}
	if m.ExternalVolumeSize != 0 {
		return fmt.Errorf("Invalid field specified: ExternalVolumeSize, this field is only for internal use")
	}
	if m.AvailabilityZone != "" {
		return fmt.Errorf("Invalid field specified: AvailabilityZone, this field is only for internal use")
	}
	if m.VmFlavor != "" {
		return fmt.Errorf("Invalid field specified: VmFlavor, this field is only for internal use")
	}
	if m.OptRes != "" {
		return fmt.Errorf("Invalid field specified: OptRes, this field is only for internal use")
	}
	if m.UpdatedAt.Seconds != 0 {
		return fmt.Errorf("Invalid field specified: UpdatedAt.Seconds, this field is only for internal use")
	}
	if m.UpdatedAt.Nanos != 0 {
		return fmt.Errorf("Invalid field specified: UpdatedAt.Nanos, this field is only for internal use")
	}
	if m.InternalPortToLbIp != nil {
		return fmt.Errorf("Invalid field specified: InternalPortToLbIp, this field is only for internal use")
	}
	if m.UniqueId != "" {
		return fmt.Errorf("Invalid field specified: UniqueId, this field is only for internal use")
	}
	if m.DnsLabel != "" {
		return fmt.Errorf("Invalid field specified: DnsLabel, this field is only for internal use")
	}
	if m.FedKey.FederationName != "" {
		return fmt.Errorf("Invalid field specified: FedKey.FederationName, this field is only for internal use")
	}
	if m.FedKey.AppInstId != "" {
		return fmt.Errorf("Invalid field specified: FedKey.AppInstId, this field is only for internal use")
	}
	if m.AppKey.Organization != "" {
		return fmt.Errorf("Invalid field specified: AppKey.Organization, this field is only for internal use")
	}
	if m.AppKey.Name != "" {
		return fmt.Errorf("Invalid field specified: AppKey.Name, this field is only for internal use")
	}
	if m.AppKey.Version != "" {
		return fmt.Errorf("Invalid field specified: AppKey.Version, this field is only for internal use")
	}
	if m.ClusterKey.Name != "" {
		return fmt.Errorf("Invalid field specified: ClusterKey.Name, this field is only for internal use")
	}
	if m.ClusterKey.Organization != "" {
		return fmt.Errorf("Invalid field specified: ClusterKey.Organization, this field is only for internal use")
	}
	if m.CompatibilityVersion != 0 {
		return fmt.Errorf("Invalid field specified: CompatibilityVersion, this field is only for internal use")
	}
	if m.VirtualClusterKey.Name != "" {
		return fmt.Errorf("Invalid field specified: VirtualClusterKey.Name, this field is only for internal use")
	}
	if m.VirtualClusterKey.Organization != "" {
		return fmt.Errorf("Invalid field specified: VirtualClusterKey.Organization, this field is only for internal use")
	}
	if m.StaticUri != "" {
		return fmt.Errorf("Invalid field specified: StaticUri, this field is only for internal use")
	}
	if m.CloudletKey.Organization != "" {
		return fmt.Errorf("Invalid field specified: CloudletKey.Organization, this field is only for internal use")
	}
	if m.CloudletKey.Name != "" {
		return fmt.Errorf("Invalid field specified: CloudletKey.Name, this field is only for internal use")
	}
	if m.CloudletKey.FederatedOrganization != "" {
		return fmt.Errorf("Invalid field specified: CloudletKey.FederatedOrganization, this field is only for internal use")
	}
	return nil
}

func (m *FedAppInstEvent) IsValidArgsForHandleFedAppInstEvent() error {
	return nil
}

func (m *AppInstLatency) IsValidArgsForRequestAppInstLatency() error {
	return nil
}

func (m *VirtualClusterInstKeyV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ClusterKey.Size()
	n += 1 + l + sovAppinst(uint64(l))
	l = m.CloudletKey.Size()
	n += 1 + l + sovAppinst(uint64(l))
	l = len(m.Organization)
	if l > 0 {
		n += 1 + l + sovAppinst(uint64(l))
	}
	return n
}

func (m *AppInstKeyV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.AppKey.Size()
	n += 1 + l + sovAppinst(uint64(l))
	l = m.ClusterInstKey.Size()
	n += 1 + l + sovAppinst(uint64(l))
	return n
}

func (m *AppInstKeyV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAppinst(uint64(l))
	}
	l = len(m.Organization)
	if l > 0 {
		n += 1 + l + sovAppinst(uint64(l))
	}
	l = m.CloudletKey.Size()
	n += 1 + l + sovAppinst(uint64(l))
	return n
}

func (m *AppInstKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAppinst(uint64(l))
	}
	l = len(m.Organization)
	if l > 0 {
		n += 1 + l + sovAppinst(uint64(l))
	}
	return n
}

func (m *AppInst) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovAppinst(uint64(l))
		}
	}
	l = m.Key.Size()
	n += 1 + l + sovAppinst(uint64(l))
	l = m.CloudletLoc.Size()
	n += 1 + l + sovAppinst(uint64(l))
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovAppinst(uint64(l))
	}
	if m.Liveness != 0 {
		n += 1 + sovAppinst(uint64(m.Liveness))
	}
	if len(m.MappedPorts) > 0 {
		for _, e := range m.MappedPorts {
			l = e.Size()
			n += 1 + l + sovAppinst(uint64(l))
		}
	}
	l = m.Flavor.Size()
	n += 1 + l + sovAppinst(uint64(l))
	if m.State != 0 {
		n += 1 + sovAppinst(uint64(m.State))
	}
	if len(m.Errors) > 0 {
		for _, s := range m.Errors {
			l = len(s)
			n += 1 + l + sovAppinst(uint64(l))
		}
	}
	if m.CrmOverride != 0 {
		n += 2 + sovAppinst(uint64(m.CrmOverride))
	}
	l = m.RuntimeInfo.Size()
	n += 2 + l + sovAppinst(uint64(l))
	l = m.CreatedAt.Size()
	n += 2 + l + sovAppinst(uint64(l))
	if m.AutoClusterIpAccess != 0 {
		n += 2 + sovAppinst(uint64(m.AutoClusterIpAccess))
	}
	l = len(m.Revision)
	if l > 0 {
		n += 2 + l + sovAppinst(uint64(l))
	}
	if m.ForceUpdate {
		n += 3
	}
	if m.UpdateMultiple {
		n += 3
	}
	if len(m.Configs) > 0 {
		for _, e := range m.Configs {
			l = e.Size()
			n += 2 + l + sovAppinst(uint64(l))
		}
	}
	if m.HealthCheck != 0 {
		n += 2 + sovAppinst(uint64(m.HealthCheck))
	}
	if m.PowerState != 0 {
		n += 2 + sovAppinst(uint64(m.PowerState))
	}
	if m.ExternalVolumeSize != 0 {
		n += 2 + sovAppinst(uint64(m.ExternalVolumeSize))
	}
	l = len(m.AvailabilityZone)
	if l > 0 {
		n += 2 + l + sovAppinst(uint64(l))
	}
	l = len(m.VmFlavor)
	if l > 0 {
		n += 2 + l + sovAppinst(uint64(l))
	}
	l = len(m.OptRes)
	if l > 0 {
		n += 2 + l + sovAppinst(uint64(l))
	}
	l = m.UpdatedAt.Size()
	n += 2 + l + sovAppinst(uint64(l))
	l = len(m.RealClusterName)
	if l > 0 {
		n += 2 + l + sovAppinst(uint64(l))
	}
	if len(m.InternalPortToLbIp) > 0 {
		for k, v := range m.InternalPortToLbIp {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAppinst(uint64(len(k))) + 1 + len(v) + sovAppinst(uint64(len(v)))
			n += mapEntrySize + 2 + sovAppinst(uint64(mapEntrySize))
		}
	}
	if m.DedicatedIp {
		n += 3
	}
	l = len(m.UniqueId)
	if l > 0 {
		n += 2 + l + sovAppinst(uint64(l))
	}
	l = len(m.DnsLabel)
	if l > 0 {
		n += 2 + l + sovAppinst(uint64(l))
	}
	l = len(m.CloudletFlavor)
	if l > 0 {
		n += 2 + l + sovAppinst(uint64(l))
	}
	l = m.FedKey.Size()
	n += 2 + l + sovAppinst(uint64(l))
	l = m.AppKey.Size()
	n += 2 + l + sovAppinst(uint64(l))
	l = m.ClusterKey.Size()
	n += 2 + l + sovAppinst(uint64(l))
	if m.CompatibilityVersion != 0 {
		n += 2 + sovAppinst(uint64(m.CompatibilityVersion))
	}
	l = m.VirtualClusterKey.Size()
	n += 2 + l + sovAppinst(uint64(l))
	if m.EnableIpv6 {
		n += 3
	}
	l = len(m.ObjId)
	if l > 0 {
		n += 2 + l + sovAppinst(uint64(l))
	}
	l = len(m.StaticUri)
	if l > 0 {
		n += 2 + l + sovAppinst(uint64(l))
	}
	l = m.CloudletKey.Size()
	n += 2 + l + sovAppinst(uint64(l))
	if len(m.Annotations) > 0 {
		for k, v := range m.Annotations {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAppinst(uint64(len(k))) + 1 + len(v) + sovAppinst(uint64(len(v)))
			n += mapEntrySize + 2 + sovAppinst(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *AppInstRuntime) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ContainerIds) > 0 {
		for _, s := range m.ContainerIds {
			l = len(s)
			n += 1 + l + sovAppinst(uint64(l))
		}
	}
	return n
}

func (m *AppInstInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovAppinst(uint64(l))
		}
	}
	l = m.Key.Size()
	n += 1 + l + sovAppinst(uint64(l))
	if m.NotifyId != 0 {
		n += 1 + sovAppinst(uint64(m.NotifyId))
	}
	if m.State != 0 {
		n += 1 + sovAppinst(uint64(m.State))
	}
	if len(m.Errors) > 0 {
		for _, s := range m.Errors {
			l = len(s)
			n += 1 + l + sovAppinst(uint64(l))
		}
	}
	l = m.RuntimeInfo.Size()
	n += 1 + l + sovAppinst(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovAppinst(uint64(l))
	if m.PowerState != 0 {
		n += 1 + sovAppinst(uint64(m.PowerState))
	}
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovAppinst(uint64(l))
	}
	l = m.FedKey.Size()
	n += 1 + l + sovAppinst(uint64(l))
	if len(m.FedPorts) > 0 {
		for _, e := range m.FedPorts {
			l = e.Size()
			n += 1 + l + sovAppinst(uint64(l))
		}
	}
	return n
}

func (m *AppInstMetrics) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Something != 0 {
		n += 1 + sovAppinst(uint64(m.Something))
	}
	return n
}

func (m *AppInstLookup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Key.Size()
	n += 1 + l + sovAppinst(uint64(l))
	l = m.PolicyKey.Size()
	n += 1 + l + sovAppinst(uint64(l))
	return n
}

func (m *AppInstLookup2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Key.Size()
	n += 1 + l + sovAppinst(uint64(l))
	l = m.CloudletKey.Size()
	n += 1 + l + sovAppinst(uint64(l))
	return n
}

func (m *AppInstLatency) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Key.Size()
	n += 1 + l + sovAppinst(uint64(l))
	return n
}

func (m *FedAppInstKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FederationName)
	if l > 0 {
		n += 1 + l + sovAppinst(uint64(l))
	}
	l = len(m.AppInstId)
	if l > 0 {
		n += 1 + l + sovAppinst(uint64(l))
	}
	return n
}

func (m *FedAppInst) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Key.Size()
	n += 1 + l + sovAppinst(uint64(l))
	l = m.AppInstKey.Size()
	n += 1 + l + sovAppinst(uint64(l))
	return n
}

func (m *FedAppInstEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Key.Size()
	n += 1 + l + sovAppinst(uint64(l))
	if m.State != 0 {
		n += 1 + sovAppinst(uint64(m.State))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovAppinst(uint64(l))
	}
	if len(m.Ports) > 0 {
		for _, e := range m.Ports {
			l = e.Size()
			n += 1 + l + sovAppinst(uint64(l))
		}
	}
	l = len(m.UniqueId)
	if l > 0 {
		n += 1 + l + sovAppinst(uint64(l))
	}
	return n
}

func sovAppinst(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozAppinst(x uint64) (n int) {
	return sovAppinst(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *VirtualClusterInstKeyV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppinst
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VirtualClusterInstKeyV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VirtualClusterInstKeyV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ClusterKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudletKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CloudletKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Organization", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Organization = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppinst(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAppinst
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppInstKeyV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppinst
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppInstKeyV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppInstKeyV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AppKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterInstKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ClusterInstKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppinst(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAppinst
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppInstKeyV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppinst
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppInstKeyV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppInstKeyV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Organization", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Organization = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudletKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CloudletKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppinst(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAppinst
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppInstKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppinst
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppInstKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppInstKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Organization", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Organization = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppinst(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAppinst
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppInst) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppinst
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppInst: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppInst: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudletLoc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CloudletLoc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Liveness", wireType)
			}
			m.Liveness = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Liveness |= Liveness(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MappedPorts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MappedPorts = append(m.MappedPorts, distributed_match_engine.AppPort{})
			if err := m.MappedPorts[len(m.MappedPorts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flavor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Flavor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= TrackedState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errors", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Errors = append(m.Errors, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrmOverride", wireType)
			}
			m.CrmOverride = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CrmOverride |= CRMOverride(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RuntimeInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CreatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoClusterIpAccess", wireType)
			}
			m.AutoClusterIpAccess = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AutoClusterIpAccess |= IpAccess(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Revision", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Revision = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceUpdate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ForceUpdate = bool(v != 0)
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateMultiple", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateMultiple = bool(v != 0)
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Configs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Configs = append(m.Configs, &ConfigFile{})
			if err := m.Configs[len(m.Configs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HealthCheck", wireType)
			}
			m.HealthCheck = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HealthCheck |= distributed_match_engine.HealthCheck(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PowerState", wireType)
			}
			m.PowerState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PowerState |= PowerState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalVolumeSize", wireType)
			}
			m.ExternalVolumeSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExternalVolumeSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailabilityZone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AvailabilityZone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VmFlavor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VmFlavor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptRes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OptRes = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.UpdatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RealClusterName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RealClusterName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalPortToLbIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InternalPortToLbIp == nil {
				m.InternalPortToLbIp = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAppinst
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppinst
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAppinst
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAppinst
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppinst
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAppinst
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAppinst
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAppinst(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthAppinst
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.InternalPortToLbIp[mapkey] = mapvalue
			iNdEx = postIndex
		case 39:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DedicatedIp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DedicatedIp = bool(v != 0)
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UniqueId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsLabel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DnsLabel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudletFlavor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CloudletFlavor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 43:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FedKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FedKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 44:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AppKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ClusterKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 46:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompatibilityVersion", wireType)
			}
			m.CompatibilityVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompatibilityVersion |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 47:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualClusterKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.VirtualClusterKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 48:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableIpv6", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableIpv6 = bool(v != 0)
		case 49:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StaticUri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StaticUri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudletKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CloudletKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 52:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAppinst
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppinst
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAppinst
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAppinst
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppinst
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAppinst
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAppinst
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAppinst(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthAppinst
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Annotations[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppinst(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAppinst
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppInstRuntime) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppinst
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppInstRuntime: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppInstRuntime: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerIds = append(m.ContainerIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppinst(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAppinst
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppInstInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppinst
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppInstInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppInstInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotifyId", wireType)
			}
			m.NotifyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NotifyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= TrackedState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errors", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Errors = append(m.Errors, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RuntimeInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PowerState", wireType)
			}
			m.PowerState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PowerState |= PowerState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FedKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FedKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FedPorts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FedPorts = append(m.FedPorts, distributed_match_engine.AppPort{})
			if err := m.FedPorts[len(m.FedPorts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppinst(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAppinst
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppInstMetrics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppinst
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppInstMetrics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppInstMetrics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Something", wireType)
			}
			m.Something = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Something |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAppinst(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAppinst
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppInstLookup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppinst
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppInstLookup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppInstLookup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolicyKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PolicyKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppinst(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAppinst
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppInstLookup2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppinst
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppInstLookup2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppInstLookup2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudletKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CloudletKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppinst(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAppinst
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppInstLatency) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppinst
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppInstLatency: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppInstLatency: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppinst(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAppinst
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FedAppInstKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppinst
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FedAppInstKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FedAppInstKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FederationName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FederationName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppInstId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppInstId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppinst(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAppinst
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FedAppInst) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppinst
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FedAppInst: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FedAppInst: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppInstKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AppInstKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppinst(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAppinst
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FedAppInstEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppinst
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FedAppInstEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FedAppInstEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= TrackedState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ports = append(m.Ports, distributed_match_engine.AppPort{})
			if err := m.Ports[len(m.Ports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UniqueId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppinst(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAppinst
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAppinst(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAppinst
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAppinst
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAppinst
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupAppinst
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthAppinst
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthAppinst        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAppinst          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupAppinst = fmt.Errorf("proto: unexpected end of group")
)
