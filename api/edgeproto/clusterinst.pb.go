// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: clusterinst.proto

package edgeproto

import (
	context "context"
	"encoding/json"
	"errors"
	fmt "fmt"
	distributed_match_engine "github.com/edgexr/edge-cloud-platform/api/distributed_match_engine"
	"github.com/edgexr/edge-cloud-platform/pkg/log"
	"github.com/edgexr/edge-cloud-platform/pkg/objstore"
	"github.com/edgexr/edge-cloud-platform/pkg/util"
	_ "github.com/edgexr/edge-cloud-platform/tools/protogen"
	_ "github.com/gogo/googleapis/google/api"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"go.etcd.io/etcd/client/v3/concurrency"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
	"sync"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// (_deprecated_) Cluster Instance V1 unique key
//
// ClusterInstKeyV1 uniquely identifies a Cluster Instance (ClusterInst) or Cluster Instance state (ClusterInstInfo).
type ClusterInstKeyV1 struct {
	// Name of Cluster
	ClusterKey ClusterKeyV1 `protobuf:"bytes,1,opt,name=cluster_key,json=clusterKey,proto3" json:"cluster_key"`
	// Name of Cloudlet on which the Cluster is instantiated
	CloudletKey CloudletKey `protobuf:"bytes,2,opt,name=cloudlet_key,json=cloudletKey,proto3" json:"cloudlet_key"`
	// Name of Developer organization that this cluster belongs to
	Organization string `protobuf:"bytes,3,opt,name=organization,proto3" json:"organization,omitempty"`
}

func (m *ClusterInstKeyV1) Reset()         { *m = ClusterInstKeyV1{} }
func (m *ClusterInstKeyV1) String() string { return proto.CompactTextString(m) }
func (*ClusterInstKeyV1) ProtoMessage()    {}
func (*ClusterInstKeyV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d2ba73d39f00460, []int{0}
}
func (m *ClusterInstKeyV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterInstKeyV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterInstKeyV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterInstKeyV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterInstKeyV1.Merge(m, src)
}
func (m *ClusterInstKeyV1) XXX_Size() int {
	return m.Size()
}
func (m *ClusterInstKeyV1) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterInstKeyV1.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterInstKeyV1 proto.InternalMessageInfo

// (_deprecated_) Cluster Instance unique key V2
//
// ClusterInstKey uniquely identifies a Cluster Instance (ClusterInst) or Cluster Instance state (ClusterInstInfo).
type ClusterInstKeyV2 struct {
	// Name of Cluster
	ClusterKey ClusterKey `protobuf:"bytes,1,opt,name=cluster_key,json=clusterKey,proto3" json:"cluster_key"`
	// Name of Cloudlet on which the Cluster is instantiated
	CloudletKey CloudletKey `protobuf:"bytes,2,opt,name=cloudlet_key,json=cloudletKey,proto3" json:"cloudlet_key"`
}

func (m *ClusterInstKeyV2) Reset()         { *m = ClusterInstKeyV2{} }
func (m *ClusterInstKeyV2) String() string { return proto.CompactTextString(m) }
func (*ClusterInstKeyV2) ProtoMessage()    {}
func (*ClusterInstKeyV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d2ba73d39f00460, []int{1}
}
func (m *ClusterInstKeyV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterInstKeyV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterInstKeyV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterInstKeyV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterInstKeyV2.Merge(m, src)
}
func (m *ClusterInstKeyV2) XXX_Size() int {
	return m.Size()
}
func (m *ClusterInstKeyV2) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterInstKeyV2.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterInstKeyV2 proto.InternalMessageInfo

// Cluster Instance
//
// ClusterInst is an instance of a Cluster on a Cloudlet.
// It is defined by a Cluster, Cloudlet, and Developer key.
type ClusterInst struct {
	// Fields are used for the Update API to specify which fields to apply
	Fields []string `protobuf:"bytes,1,rep,name=fields,proto3" json:"fields,omitempty"`
	// Unique key
	// required: true
	Key ClusterKey `protobuf:"bytes,2,opt,name=key,proto3" json:"key"`
	// Cloudlet on which the cluster is deployed
	CloudletKey CloudletKey `protobuf:"bytes,41,opt,name=cloudlet_key,json=cloudletKey,proto3" json:"cloudlet_key"`
	// Zone on which the instance is deployed
	ZoneKey ZoneKey `protobuf:"bytes,43,opt,name=zone_key,json=zoneKey,proto3" json:"zone_key"`
	// Flavor for the VM or the primary Kubernetes node pool
	Flavor FlavorKey `protobuf:"bytes,3,opt,name=flavor,proto3" json:"flavor"`
	// Liveness of instance (see Liveness)
	Liveness Liveness `protobuf:"varint,9,opt,name=liveness,proto3,enum=edgeproto.Liveness" json:"liveness,omitempty"`
	// Auto is set to true when automatically created by back-end (internal use only)
	Auto bool `protobuf:"varint,10,opt,name=auto,proto3" json:"auto,omitempty"`
	// State of the cluster instance
	State TrackedState `protobuf:"varint,4,opt,name=state,proto3,enum=edgeproto.TrackedState" json:"state,omitempty"`
	// Any errors trying to create, update, or delete the ClusterInst on the Cloudlet.
	Errors []string `protobuf:"bytes,5,rep,name=errors,proto3" json:"errors,omitempty"`
	// Override actions to CRM
	CrmOverride CRMOverride `protobuf:"varint,6,opt,name=crm_override,json=crmOverride,proto3,enum=edgeproto.CRMOverride" json:"crm_override,omitempty"`
	// IP access type (RootLB Type)
	IpAccess IpAccess `protobuf:"varint,7,opt,name=ip_access,json=ipAccess,proto3,enum=edgeproto.IpAccess" json:"ip_access,omitempty"`
	// Allocated IP for dedicated access
	AllocatedIp string `protobuf:"bytes,8,opt,name=allocated_ip,json=allocatedIp,proto3" json:"allocated_ip,omitempty"`
	// (_deprecated_) Replaced by NodePools.NodeResources.InfraNodeFlavor. Cloudlet specific node flavor.
	NodeFlavor string `protobuf:"bytes,11,opt,name=node_flavor,json=nodeFlavor,proto3" json:"node_flavor,omitempty"`
	// Deployment type (kubernetes or docker)
	Deployment string `protobuf:"bytes,15,opt,name=deployment,proto3" json:"deployment,omitempty"`
	// Number of k8s masters (In case of docker deployment, this field is not required)
	NumMasters uint32 `protobuf:"varint,13,opt,name=num_masters,json=numMasters,proto3" json:"num_masters,omitempty"`
	// (_deprecated_) Replaced by NodePools.NumNodes. Number of k8s nodes.
	NumNodes uint32 `protobuf:"varint,14,opt,name=num_nodes,json=numNodes,proto3" json:"num_nodes,omitempty"`
	// (_deprecated_) Replaced by NodePools.NodeResources.ExternalVolumeSize. Size of external volume to be attached to nodes. This is for the root partition
	ExternalVolumeSize uint64 `protobuf:"varint,17,opt,name=external_volume_size,json=externalVolumeSize,proto3" json:"external_volume_size,omitempty"`
	// Auto scale policy name
	AutoScalePolicy string `protobuf:"bytes,18,opt,name=auto_scale_policy,json=autoScalePolicy,proto3" json:"auto_scale_policy,omitempty"`
	// Optional Resource AZ if any
	AvailabilityZone string `protobuf:"bytes,19,opt,name=availability_zone,json=availabilityZone,proto3" json:"availability_zone,omitempty"`
	// Optional resource specific image to launch
	ImageName string `protobuf:"bytes,20,opt,name=image_name,json=imageName,proto3" json:"image_name,omitempty"`
	// If ClusterInst is reservable
	Reservable bool `protobuf:"varint,21,opt,name=reservable,proto3" json:"reservable,omitempty"`
	// For reservable EdgeCloud ClusterInsts, the current developer tenant
	ReservedBy string `protobuf:"bytes,22,opt,name=reserved_by,json=reservedBy,proto3" json:"reserved_by,omitempty"`
	// Size of an optional shared volume to be mounted on the master
	SharedVolumeSize uint64 `protobuf:"varint,23,opt,name=shared_volume_size,json=sharedVolumeSize,proto3" json:"shared_volume_size,omitempty"`
	// Generic flavor for k8s master VM when worker nodes > 0
	MasterNodeFlavor string `protobuf:"bytes,25,opt,name=master_node_flavor,json=masterNodeFlavor,proto3" json:"master_node_flavor,omitempty"`
	// Prevents cleanup of resources on failure within CRM, used for diagnostic purposes
	SkipCrmCleanupOnFailure bool `protobuf:"varint,26,opt,name=skip_crm_cleanup_on_failure,json=skipCrmCleanupOnFailure,proto3" json:"skip_crm_cleanup_on_failure,omitempty"`
	// Optional Resources required by OS flavor if any
	OptRes string `protobuf:"bytes,27,opt,name=opt_res,json=optRes,proto3" json:"opt_res,omitempty"`
	// Resources used by cluster
	Resources InfraResources `protobuf:"bytes,28,opt,name=resources,proto3" json:"resources"`
	// Created at time
	CreatedAt distributed_match_engine.Timestamp `protobuf:"bytes,29,opt,name=created_at,json=createdAt,proto3" json:"created_at"`
	// Updated at time
	UpdatedAt distributed_match_engine.Timestamp `protobuf:"bytes,30,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at"`
	// For reservable ClusterInsts, when the last reservation ended
	ReservationEndedAt distributed_match_engine.Timestamp `protobuf:"bytes,31,opt,name=reservation_ended_at,json=reservationEndedAt,proto3" json:"reservation_ended_at"`
	// Multi-tenant kubernetes cluster
	MultiTenant bool `protobuf:"varint,32,opt,name=multi_tenant,json=multiTenant,proto3" json:"multi_tenant,omitempty"`
	// networks to connect to
	Networks []string `protobuf:"bytes,33,rep,name=networks,proto3" json:"networks,omitempty"`
	// Preparing to be deleted
	DeletePrepare bool `protobuf:"varint,34,opt,name=delete_prepare,json=deletePrepare,proto3" json:"delete_prepare,omitempty"`
	// DNS label that is unique within the cloudlet and among other AppInsts/ClusterInsts
	DnsLabel string `protobuf:"bytes,35,opt,name=dns_label,json=dnsLabel,proto3" json:"dns_label,omitempty"`
	// FQDN is a globally unique DNS id for the ClusterInst
	Fqdn string `protobuf:"bytes,36,opt,name=fqdn,proto3" json:"fqdn,omitempty"`
	// Static startup FQDN is an immutable globally unique name, set when object is created
	StaticFqdn string `protobuf:"bytes,39,opt,name=static_fqdn,json=staticFqdn,proto3" json:"static_fqdn,omitempty"`
	// Enable IPv6 addressing, requires platform and cloudlet support, defaults to platform setting
	EnableIpv6 bool `protobuf:"varint,37,opt,name=enable_ipv6,json=enableIpv6,proto3" json:"enable_ipv6,omitempty"`
	// Universally unique object ID
	ObjId string `protobuf:"bytes,38,opt,name=obj_id,json=objId,proto3" json:"obj_id,omitempty"`
	// internal compatibility version
	CompatibilityVersion uint32 `protobuf:"varint,40,opt,name=compatibility_version,json=compatibilityVersion,proto3" json:"compatibility_version,omitempty"`
	// Annotations
	Annotations map[string]string `protobuf:"bytes,42,rep,name=annotations,proto3" json:"annotations,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// database version model ID
	DbModelId int32 `protobuf:"varint,44,opt,name=db_model_id,json=dbModelId,proto3" json:"db_model_id,omitempty"`
	// Node resources for VM/docker deployments
	NodeResources *NodeResources `protobuf:"bytes,45,opt,name=node_resources,json=nodeResources,proto3" json:"node_resources,omitempty"`
	// Node Pool specifications for Kubernetes clusters
	NodePools []*NodePool `protobuf:"bytes,46,rep,name=node_pools,json=nodePools,proto3" json:"node_pools,omitempty"`
	// Annotations added by the implementing infrastructure
	InfraAnnotations map[string]string `protobuf:"bytes,47,rep,name=infra_annotations,json=infraAnnotations,proto3" json:"infra_annotations,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Kubernetes version of cluster if applicable
	KubernetesVersion string `protobuf:"bytes,48,opt,name=kubernetes_version,json=kubernetesVersion,proto3" json:"kubernetes_version,omitempty"`
}

func (m *ClusterInst) Reset()         { *m = ClusterInst{} }
func (m *ClusterInst) String() string { return proto.CompactTextString(m) }
func (*ClusterInst) ProtoMessage()    {}
func (*ClusterInst) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d2ba73d39f00460, []int{2}
}
func (m *ClusterInst) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterInst) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterInst.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterInst) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterInst.Merge(m, src)
}
func (m *ClusterInst) XXX_Size() int {
	return m.Size()
}
func (m *ClusterInst) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterInst.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterInst proto.InternalMessageInfo

// Parameters for selecting reservable ClusterInsts to delete
type IdleReservableClusterInsts struct {
	// Idle time (duration)
	IdleTime Duration `protobuf:"varint,1,opt,name=idle_time,json=idleTime,proto3,casttype=Duration" json:"idle_time,omitempty"`
}

func (m *IdleReservableClusterInsts) Reset()         { *m = IdleReservableClusterInsts{} }
func (m *IdleReservableClusterInsts) String() string { return proto.CompactTextString(m) }
func (*IdleReservableClusterInsts) ProtoMessage()    {}
func (*IdleReservableClusterInsts) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d2ba73d39f00460, []int{3}
}
func (m *IdleReservableClusterInsts) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IdleReservableClusterInsts) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IdleReservableClusterInsts.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IdleReservableClusterInsts) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IdleReservableClusterInsts.Merge(m, src)
}
func (m *IdleReservableClusterInsts) XXX_Size() int {
	return m.Size()
}
func (m *IdleReservableClusterInsts) XXX_DiscardUnknown() {
	xxx_messageInfo_IdleReservableClusterInsts.DiscardUnknown(m)
}

var xxx_messageInfo_IdleReservableClusterInsts proto.InternalMessageInfo

type ClusterResourceUsage struct {
	// Cluster Key
	Key ClusterKey `protobuf:"bytes,1,opt,name=key,proto3" json:"key"`
	// Zone Key
	ZoneKey ZoneKey `protobuf:"bytes,2,opt,name=zone_key,json=zoneKey,proto3" json:"zone_key"`
	// Cloudlet Key
	CloudletKey CloudletKey `protobuf:"bytes,3,opt,name=cloudlet_key,json=cloudletKey,proto3" json:"cloudlet_key"`
	// Total resource info
	TotalResources []*InfraResource `protobuf:"bytes,4,rep,name=total_resources,json=totalResources,proto3" json:"total_resources,omitempty"`
	// CPU Pool resource info for Kubernetes clusters
	CpuPoolsResources []*InfraResource `protobuf:"bytes,5,rep,name=cpu_pools_resources,json=cpuPoolsResources,proto3" json:"cpu_pools_resources,omitempty"`
	// GPU Pool resource info for Kubernetes clusters
	GpuPoolsResources []*InfraResource `protobuf:"bytes,6,rep,name=gpu_pools_resources,json=gpuPoolsResources,proto3" json:"gpu_pools_resources,omitempty"`
	// Resource score, higher score means more available resources
	ResourceScore uint64 `protobuf:"varint,7,opt,name=resource_score,json=resourceScore,proto3" json:"resource_score,omitempty"`
	// CPU Pool Resource score for Kubernetes clusters, higher score means more available resources
	CpuPoolsResourceScore uint64 `protobuf:"varint,8,opt,name=cpu_pools_resource_score,json=cpuPoolsResourceScore,proto3" json:"cpu_pools_resource_score,omitempty"`
	// GPU Pool Resource score for Kubernetes clusters, higher score means more available resources
	GpuPoolsResourceScore uint64 `protobuf:"varint,9,opt,name=gpu_pools_resource_score,json=gpuPoolsResourceScore,proto3" json:"gpu_pools_resource_score,omitempty"`
}

func (m *ClusterResourceUsage) Reset()         { *m = ClusterResourceUsage{} }
func (m *ClusterResourceUsage) String() string { return proto.CompactTextString(m) }
func (*ClusterResourceUsage) ProtoMessage()    {}
func (*ClusterResourceUsage) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d2ba73d39f00460, []int{4}
}
func (m *ClusterResourceUsage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterResourceUsage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterResourceUsage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterResourceUsage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterResourceUsage.Merge(m, src)
}
func (m *ClusterResourceUsage) XXX_Size() int {
	return m.Size()
}
func (m *ClusterResourceUsage) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterResourceUsage.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterResourceUsage proto.InternalMessageInfo

// ClusterInstInfo provides information from the Cloudlet Resource Manager about the state of the ClusterInst on the Cloudlet. Whereas the ClusterInst defines the intent of instantiating a Cluster on a Cloudlet, the ClusterInstInfo defines the current state of trying to apply that intent on the physical resources of the Cloudlet.
type ClusterInstInfo struct {
	// Fields are used for the Update API to specify which fields to apply
	Fields []string `protobuf:"bytes,1,rep,name=fields,proto3" json:"fields,omitempty"`
	// Unique identifier key
	Key ClusterKey `protobuf:"bytes,2,opt,name=key,proto3" json:"key"`
	// Id of client assigned by server (internal use only)
	NotifyId int64 `protobuf:"varint,3,opt,name=notify_id,json=notifyId,proto3" json:"notify_id,omitempty"`
	// State of the cluster instance
	State TrackedState `protobuf:"varint,4,opt,name=state,proto3,enum=edgeproto.TrackedState" json:"state,omitempty"`
	// Any errors trying to create, update, or delete the ClusterInst on the Cloudlet.
	Errors []string `protobuf:"bytes,5,rep,name=errors,proto3" json:"errors,omitempty"`
	// status is used to reflect progress of creation or other events
	Status StatusInfo `protobuf:"bytes,6,opt,name=status,proto3" json:"status"`
	// Resources allocated to this cluster
	Resources InfraResources `protobuf:"bytes,7,opt,name=resources,proto3" json:"resources"`
	// Annotations added by the implementing infrastructure
	InfraAnnotations map[string]string `protobuf:"bytes,45,rep,name=infra_annotations,json=infraAnnotations,proto3" json:"infra_annotations,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *ClusterInstInfo) Reset()         { *m = ClusterInstInfo{} }
func (m *ClusterInstInfo) String() string { return proto.CompactTextString(m) }
func (*ClusterInstInfo) ProtoMessage()    {}
func (*ClusterInstInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d2ba73d39f00460, []int{5}
}
func (m *ClusterInstInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterInstInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterInstInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterInstInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterInstInfo.Merge(m, src)
}
func (m *ClusterInstInfo) XXX_Size() int {
	return m.Size()
}
func (m *ClusterInstInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterInstInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterInstInfo proto.InternalMessageInfo

func init() {
	proto.RegisterType((*ClusterInstKeyV1)(nil), "edgeproto.ClusterInstKeyV1")
	proto.RegisterType((*ClusterInstKeyV2)(nil), "edgeproto.ClusterInstKeyV2")
	proto.RegisterType((*ClusterInst)(nil), "edgeproto.ClusterInst")
	proto.RegisterMapType((map[string]string)(nil), "edgeproto.ClusterInst.AnnotationsEntry")
	proto.RegisterMapType((map[string]string)(nil), "edgeproto.ClusterInst.InfraAnnotationsEntry")
	proto.RegisterType((*IdleReservableClusterInsts)(nil), "edgeproto.IdleReservableClusterInsts")
	proto.RegisterType((*ClusterResourceUsage)(nil), "edgeproto.ClusterResourceUsage")
	proto.RegisterType((*ClusterInstInfo)(nil), "edgeproto.ClusterInstInfo")
	proto.RegisterMapType((map[string]string)(nil), "edgeproto.ClusterInstInfo.InfraAnnotationsEntry")
}

func init() { proto.RegisterFile("clusterinst.proto", fileDescriptor_2d2ba73d39f00460) }

var fileDescriptor_2d2ba73d39f00460 = []byte{
	// 2311 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x58, 0xcb, 0x6f, 0x14, 0xc9,
	0x19, 0xa7, 0xec, 0xb1, 0x3d, 0x53, 0xe3, 0xd7, 0x94, 0x6d, 0x28, 0xbc, 0x60, 0x0f, 0x03, 0x5e,
	0xbc, 0xd0, 0x7e, 0xc4, 0x28, 0xde, 0xc4, 0x5a, 0x16, 0x8d, 0x0d, 0x28, 0x13, 0xd6, 0x80, 0xda,
	0x80, 0x92, 0x28, 0x52, 0xab, 0xa7, 0xbb, 0x3c, 0xf4, 0xba, 0xbb, 0xaa, 0xb7, 0x1f, 0x26, 0xc3,
	0x69, 0xb5, 0x8a, 0x94, 0xeb, 0x2a, 0xb9, 0x24, 0x1c, 0x22, 0x2e, 0x91, 0x56, 0x8a, 0x22, 0x6d,
	0x38, 0xee, 0x5f, 0xc0, 0x11, 0x29, 0x17, 0xb4, 0x4a, 0x56, 0xbb, 0x90, 0x48, 0xc8, 0xa7, 0x8d,
	0x18, 0x9b, 0x55, 0x4e, 0x51, 0x55, 0x77, 0xcf, 0xd4, 0xf4, 0x8c, 0x81, 0x98, 0xcd, 0xad, 0xeb,
	0x7b, 0xd5, 0x57, 0x5f, 0x7d, 0x8f, 0x5f, 0x35, 0x2c, 0x18, 0x76, 0xe8, 0x07, 0xc4, 0xb3, 0xa8,
	0x1f, 0xcc, 0xbb, 0x1e, 0x0b, 0x18, 0xca, 0x11, 0xb3, 0x46, 0xc4, 0xe7, 0xe4, 0xb1, 0x1a, 0x63,
	0x35, 0x9b, 0x2c, 0xe8, 0xae, 0xb5, 0xa0, 0x53, 0xca, 0x02, 0x3d, 0xb0, 0x18, 0xf5, 0x23, 0xc1,
	0xc9, 0xe3, 0x01, 0x63, 0xb6, 0xbf, 0x20, 0x16, 0x35, 0x42, 0x9b, 0x1f, 0x31, 0x7b, 0xd0, 0x23,
	0x7e, 0x68, 0x07, 0xc9, 0x6a, 0xd3, 0xd6, 0xb7, 0x99, 0x17, 0xaf, 0x46, 0x3c, 0xe2, 0xb3, 0xd0,
	0x33, 0x48, 0x62, 0x6b, 0x28, 0xf6, 0x23, 0x5e, 0x16, 0x0c, 0x9b, 0x85, 0xa6, 0x4d, 0x82, 0x2d,
	0x52, 0x4f, 0x0c, 0x18, 0xcc, 0x71, 0x58, 0x62, 0x7c, 0xdc, 0xa2, 0x9b, 0x9e, 0x9e, 0xb6, 0x32,
	0x5e, 0x63, 0x35, 0x26, 0x3e, 0x17, 0xf8, 0x57, 0x62, 0xdb, 0x74, 0xc8, 0x82, 0xcd, 0x8c, 0x68,
	0x59, 0xfa, 0x17, 0x80, 0xa3, 0x6b, 0xd1, 0x6e, 0x15, 0xea, 0x07, 0x57, 0x48, 0xfd, 0xd6, 0x0f,
	0xd0, 0xfb, 0x30, 0x1f, 0x7b, 0xa0, 0x6d, 0x91, 0x3a, 0x06, 0x45, 0x30, 0x9b, 0x5f, 0x3a, 0x32,
	0xdf, 0x0c, 0xc5, 0x7c, 0xac, 0x21, 0xa4, 0x57, 0x33, 0x0f, 0xbf, 0x9a, 0x3e, 0xa4, 0x42, 0xa3,
	0x49, 0x43, 0x57, 0xe0, 0x60, 0xe2, 0xb2, 0x30, 0xd0, 0x23, 0x0c, 0x1c, 0x6e, 0x33, 0x10, 0xb1,
	0xaf, 0x90, 0xfa, 0xea, 0xe8, 0xce, 0x1e, 0xce, 0x26, 0x04, 0x61, 0x2b, 0x6f, 0xb4, 0xd8, 0x68,
	0x19, 0x0e, 0x32, 0xaf, 0xa6, 0x53, 0xeb, 0xae, 0x88, 0x37, 0xee, 0x2d, 0x82, 0xd9, 0xdc, 0x2a,
	0xfa, 0x62, 0x0f, 0x27, 0x5b, 0x32, 0xaf, 0xf6, 0x68, 0x0f, 0x03, 0xb5, 0x4d, 0x6e, 0x65, 0xf0,
	0xd9, 0x73, 0x0c, 0xbe, 0x7b, 0x8e, 0xc1, 0xe7, 0xf7, 0xa7, 0x41, 0xe9, 0xcf, 0x9d, 0xe7, 0x5c,
	0x42, 0xef, 0x75, 0x3b, 0xe7, 0x44, 0xd7, 0x73, 0xfe, 0x9f, 0x4f, 0x99, 0xf2, 0xf6, 0x93, 0x23,
	0x30, 0x2f, 0x79, 0x8b, 0x0e, 0xc3, 0xfe, 0x4d, 0x8b, 0xd8, 0xa6, 0x8f, 0x41, 0xb1, 0x77, 0x36,
	0xa7, 0xc6, 0x2b, 0x34, 0x07, 0x7b, 0x5b, 0x3b, 0xbf, 0xd4, 0x71, 0x2e, 0xd7, 0xe1, 0xf1, 0x3b,
	0x6f, 0x72, 0x2f, 0xe7, 0x60, 0xf6, 0x2e, 0xa3, 0x44, 0x18, 0x3a, 0x2b, 0x0c, 0x21, 0xc9, 0xd0,
	0x2f, 0x18, 0x25, 0xad, 0xdd, 0x07, 0xee, 0x46, 0x4b, 0xb4, 0x0c, 0xfb, 0xa3, 0xd4, 0x17, 0xd7,
	0x98, 0x5f, 0x1a, 0x97, 0x54, 0x2e, 0x0b, 0x06, 0x57, 0xca, 0x7e, 0xd6, 0xc0, 0x40, 0x28, 0xc6,
	0xd2, 0xe8, 0x87, 0x30, 0x6b, 0x5b, 0xdb, 0x84, 0x12, 0xdf, 0xc7, 0xb9, 0x22, 0x98, 0x1d, 0x5e,
	0x1a, 0x93, 0x34, 0x3f, 0x88, 0x59, 0xab, 0x19, 0xae, 0xa8, 0x36, 0x45, 0x11, 0x86, 0x19, 0x3d,
	0x0c, 0x18, 0x86, 0x45, 0x30, 0x9b, 0x8d, 0xb9, 0x82, 0x82, 0xce, 0xc1, 0x3e, 0x3f, 0xd0, 0x03,
	0x82, 0x33, 0xc2, 0x9a, 0x9c, 0xdc, 0x37, 0x3c, 0xdd, 0xd8, 0x22, 0xe6, 0x06, 0x67, 0xc7, 0x3a,
	0x91, 0x2c, 0x9a, 0x81, 0xfd, 0xc4, 0xf3, 0x98, 0xe7, 0xe3, 0x3e, 0x7e, 0x0d, 0xab, 0x43, 0x9c,
	0xf9, 0xdb, 0x07, 0x47, 0xfb, 0x28, 0x33, 0x1c, 0x57, 0x8d, 0x99, 0xe8, 0xc7, 0x70, 0xd0, 0xf0,
	0x1c, 0x8d, 0x6d, 0x13, 0xcf, 0xb3, 0x4c, 0x82, 0xfb, 0xc5, 0x16, 0x6d, 0x61, 0x56, 0xd7, 0xaf,
	0xc5, 0x5c, 0x35, 0x6f, 0x78, 0x4e, 0xb2, 0x40, 0xcb, 0x30, 0x67, 0xb9, 0x9a, 0x6e, 0x18, 0xfc,
	0xa0, 0x03, 0x1d, 0x07, 0xad, 0xb8, 0x65, 0xc1, 0x4a, 0x0e, 0x6a, 0xc5, 0x6b, 0xb4, 0x08, 0x07,
	0x75, 0xdb, 0x66, 0x86, 0x1e, 0x10, 0x53, 0xb3, 0x5c, 0x9c, 0x15, 0x45, 0x92, 0xf2, 0x2f, 0xdf,
	0x14, 0xa9, 0xb8, 0x68, 0x06, 0xe6, 0x29, 0x33, 0x89, 0x16, 0x5f, 0x47, 0x5e, 0x28, 0x44, 0x66,
	0x21, 0x67, 0x44, 0xb7, 0x81, 0x4e, 0x41, 0x68, 0x12, 0xd7, 0x66, 0x75, 0x87, 0xd0, 0x00, 0x8f,
	0xc8, 0x52, 0x2d, 0x3a, 0x9a, 0x86, 0x79, 0x1a, 0x3a, 0x9a, 0xa3, 0xf3, 0xa4, 0xf3, 0xf1, 0x50,
	0x11, 0xcc, 0x0e, 0xa9, 0x90, 0x86, 0xce, 0x7a, 0x44, 0x41, 0x6f, 0xc1, 0x1c, 0x17, 0xe0, 0x86,
	0x7d, 0x3c, 0x2c, 0xd8, 0x59, 0x1a, 0x3a, 0x57, 0xf9, 0x1a, 0x2d, 0xc3, 0x71, 0xf2, 0xab, 0x80,
	0x78, 0x54, 0xb7, 0xb5, 0x6d, 0x66, 0x87, 0x0e, 0xd1, 0x7c, 0xeb, 0x2e, 0xc1, 0x85, 0x22, 0x98,
	0xcd, 0xc4, 0xbb, 0xa1, 0x44, 0xe2, 0x96, 0x10, 0xd8, 0xb0, 0xee, 0x12, 0x74, 0x01, 0x16, 0xf8,
	0x5d, 0x6a, 0xbe, 0xa1, 0xdb, 0x44, 0x73, 0x99, 0x6d, 0x19, 0x75, 0x8c, 0x84, 0x8b, 0x63, 0x3b,
	0x7b, 0x78, 0xa4, 0x1c, 0x06, 0x6c, 0x83, 0xf3, 0xae, 0x0b, 0x96, 0x3a, 0xa2, 0xb7, 0x13, 0xd0,
	0x59, 0x58, 0xd0, 0xb7, 0x75, 0xcb, 0xd6, 0xab, 0x96, 0x6d, 0x05, 0x75, 0x8d, 0x67, 0x29, 0x1e,
	0xe3, 0x06, 0xd4, 0x51, 0x99, 0xc1, 0x93, 0x19, 0x9d, 0x84, 0xd0, 0x72, 0xf4, 0x1a, 0xd1, 0xa8,
	0xee, 0x10, 0x3c, 0x2e, 0x45, 0x22, 0x27, 0xe8, 0x57, 0x75, 0x87, 0xa0, 0x29, 0x08, 0x3d, 0xe2,
	0x13, 0x6f, 0x5b, 0xaf, 0xda, 0x04, 0x4f, 0xf0, 0xb4, 0x53, 0x25, 0x0a, 0x8f, 0x7a, 0xb4, 0x22,
	0xa6, 0x56, 0xad, 0xe3, 0xc3, 0x72, 0x3c, 0x13, 0xc6, 0x6a, 0x1d, 0x29, 0x10, 0xf9, 0xb7, 0x75,
	0x8f, 0x98, 0x6d, 0xf1, 0x38, 0xc2, 0xe3, 0xa1, 0x8e, 0x46, 0x1c, 0x29, 0x0e, 0x4b, 0x10, 0x45,
	0x91, 0xd7, 0xe4, 0x1b, 0x3d, 0x2a, 0xd9, 0x1e, 0x8d, 0xf8, 0x57, 0x5b, 0xf7, 0xfa, 0x1e, 0x7c,
	0xcb, 0xdf, 0xb2, 0x5c, 0x8d, 0x27, 0xaa, 0x61, 0x13, 0x9d, 0x86, 0xae, 0xc6, 0xa8, 0xb6, 0xa9,
	0x5b, 0x76, 0xe8, 0x11, 0x3c, 0x29, 0x3c, 0x3f, 0xc2, 0x45, 0xd6, 0x3c, 0x67, 0x2d, 0x12, 0xb8,
	0x46, 0x2f, 0x47, 0x6c, 0x74, 0x1c, 0x0e, 0x30, 0x37, 0xd0, 0x3c, 0xe2, 0xe3, 0xb7, 0xa4, 0x6d,
	0xfa, 0x99, 0x1b, 0xa8, 0xc4, 0x47, 0x65, 0x98, 0x6b, 0x0e, 0x23, 0x7c, 0x4c, 0x14, 0xfa, 0x51,
	0x39, 0x8b, 0xf9, 0xb4, 0x52, 0x13, 0x01, 0xa9, 0xda, 0x5b, 0x5a, 0xe8, 0xe7, 0x10, 0x1a, 0x1e,
	0x11, 0xe9, 0xac, 0x07, 0xf8, 0xb8, 0xb0, 0x71, 0x72, 0xde, 0xb4, 0xfc, 0xc0, 0xb3, 0xaa, 0x21,
	0x27, 0x3b, 0x7a, 0x60, 0xdc, 0xd6, 0x08, 0xad, 0x59, 0x94, 0xcc, 0xdf, 0xb0, 0x1c, 0xe2, 0x07,
	0xba, 0xe3, 0xae, 0x4e, 0xc4, 0x39, 0x9f, 0x0b, 0x12, 0x52, 0x64, 0x3a, 0xb6, 0x56, 0x0e, 0xb8,
	0xe9, 0xd0, 0x35, 0x13, 0xd3, 0x53, 0x6f, 0x6e, 0x3a, 0xb6, 0x56, 0x0e, 0x90, 0x0d, 0xc7, 0xe3,
	0xcb, 0xe6, 0x23, 0x48, 0x23, 0xd4, 0x8c, 0x36, 0x99, 0x7e, 0xe3, 0x4d, 0x90, 0x64, 0xf7, 0x12,
	0x37, 0x5b, 0x0e, 0xd0, 0x09, 0x38, 0xe8, 0x84, 0x76, 0x60, 0x69, 0x01, 0xa1, 0x3a, 0x0d, 0x70,
	0x51, 0x5c, 0x5a, 0x5e, 0xd0, 0x6e, 0x08, 0x12, 0x3a, 0x0d, 0xb3, 0x94, 0x04, 0x77, 0x98, 0xb7,
	0xe5, 0xe3, 0x13, 0xa2, 0x67, 0xe5, 0x77, 0xf6, 0xf0, 0xc0, 0xd5, 0x88, 0xa6, 0x36, 0x99, 0xe8,
	0x2c, 0x1c, 0x36, 0x89, 0x4d, 0x02, 0xa2, 0xb9, 0x1e, 0x71, 0x75, 0x8f, 0xe0, 0x92, 0xd4, 0x33,
	0x87, 0x22, 0xde, 0xf5, 0x88, 0x85, 0x4e, 0xc0, 0x9c, 0x49, 0x7d, 0xcd, 0xd6, 0xab, 0xc4, 0xc6,
	0x27, 0xa5, 0x04, 0xc8, 0x9a, 0xd4, 0xff, 0x80, 0x53, 0x79, 0xe7, 0xdd, 0xfc, 0xc8, 0xa4, 0xf8,
	0x94, 0xc4, 0x15, 0x14, 0x5e, 0x02, 0xbc, 0x9b, 0x5a, 0x86, 0x26, 0x04, 0x4e, 0xcb, 0x25, 0x10,
	0x31, 0x2e, 0x73, 0xb1, 0x69, 0x98, 0x27, 0x94, 0xd7, 0x8c, 0x66, 0xb9, 0xdb, 0xcb, 0x78, 0x26,
	0x2a, 0xa5, 0x88, 0x54, 0x71, 0xb7, 0x97, 0xd1, 0x29, 0xd8, 0xcf, 0xaa, 0x1f, 0x6a, 0x96, 0x89,
	0xdf, 0xee, 0xd6, 0xec, 0xfa, 0x58, 0xf5, 0xc3, 0x8a, 0x89, 0x56, 0xe1, 0x84, 0xc1, 0x1c, 0x57,
	0x0f, 0xac, 0xb8, 0xc6, 0xb7, 0x89, 0xe7, 0x73, 0x18, 0x31, 0xcb, 0x9b, 0x50, 0x5a, 0x69, 0xbc,
	0x4d, 0xf6, 0x56, 0x24, 0x8a, 0x2a, 0x30, 0x2f, 0xe1, 0x3d, 0x7c, 0xa6, 0xd8, 0x3b, 0x9b, 0x5f,
	0x3a, 0xdd, 0x39, 0x6d, 0xf9, 0xa8, 0x9e, 0x2f, 0xb7, 0x24, 0x2f, 0xd1, 0xc0, 0xab, 0xab, 0xb2,
	0x2e, 0x9a, 0x83, 0x79, 0xb3, 0xaa, 0x39, 0xcc, 0x24, 0x36, 0xf7, 0x5c, 0x29, 0x82, 0xd9, 0xbe,
	0xb4, 0x13, 0x39, 0xb3, 0xba, 0xce, 0x05, 0x2a, 0x26, 0xba, 0x00, 0x87, 0x45, 0x49, 0xb7, 0xaa,
	0x69, 0x4e, 0x64, 0x12, 0x96, 0x36, 0xe7, 0x45, 0xdd, 0x2c, 0x26, 0x75, 0x88, 0xca, 0x4b, 0xb4,
	0x04, 0x45, 0x33, 0xd7, 0x5c, 0x0e, 0x4e, 0xf1, 0xbc, 0xf0, 0x7c, 0x2c, 0xa5, 0x7c, 0x9d, 0x31,
	0x5b, 0xcd, 0xd1, 0xf8, 0xcb, 0x47, 0xb7, 0x61, 0x41, 0xe0, 0x49, 0x4d, 0x3e, 0xf4, 0x82, 0x50,
	0x55, 0xf6, 0x39, 0xb4, 0xa8, 0xe8, 0xf4, 0xc9, 0xd3, 0xe7, 0x1a, 0xb5, 0x52, 0x52, 0x68, 0x0e,
	0xa2, 0xad, 0xb0, 0x4a, 0x3c, 0x4a, 0x02, 0xe2, 0x37, 0x6f, 0x66, 0x51, 0x34, 0xe0, 0x42, 0x8b,
	0x13, 0xdf, 0xc3, 0xe4, 0xfb, 0x70, 0x34, 0xbd, 0x07, 0x1a, 0x8d, 0x10, 0x10, 0x10, 0x3a, 0x02,
	0xe4, 0x8c, 0xc3, 0xbe, 0x6d, 0xdd, 0x0e, 0x89, 0x40, 0x45, 0x39, 0x35, 0x5a, 0xac, 0xf4, 0xfc,
	0x08, 0x4c, 0xae, 0xc1, 0x89, 0xae, 0x8e, 0xfe, 0x2f, 0x46, 0x56, 0xbe, 0xe9, 0xe5, 0x48, 0xed,
	0xdb, 0xe7, 0x18, 0x7c, 0xdc, 0xc0, 0xe0, 0xd3, 0x06, 0x06, 0xbf, 0x6f, 0x60, 0xf0, 0x39, 0x6f,
	0x61, 0x0d, 0x0c, 0x1e, 0xf3, 0x13, 0xef, 0xe2, 0x7f, 0x83, 0x04, 0x92, 0x28, 0x7c, 0x08, 0x29,
	0xeb, 0xa9, 0xf6, 0xab, 0x48, 0x9f, 0x97, 0x3a, 0x06, 0x9b, 0x52, 0x6e, 0xcd, 0x69, 0x45, 0x6d,
	0x4e, 0x05, 0x45, 0x20, 0x12, 0xe5, 0x92, 0x00, 0x19, 0x4a, 0xf3, 0x8e, 0x95, 0x72, 0x6a, 0x52,
	0x29, 0x6b, 0x49, 0xab, 0x53, 0x6e, 0x26, 0x9d, 0x49, 0xb9, 0x26, 0x3a, 0x73, 0x6c, 0x4d, 0xee,
	0x22, 0xca, 0x45, 0xb9, 0xb4, 0x95, 0x8b, 0x71, 0x01, 0x2b, 0xbc, 0x08, 0xc5, 0x8e, 0x51, 0x3d,
	0x2a, 0x6b, 0x5d, 0x2a, 0x43, 0x91, 0xe0, 0xe2, 0xbd, 0x5d, 0xfc, 0x17, 0x10, 0xa3, 0xe3, 0xf3,
	0x57, 0x48, 0x7d, 0x9e, 0xcf, 0x43, 0x25, 0x01, 0x8c, 0xe7, 0x25, 0xc9, 0x76, 0x0e, 0xf3, 0x6a,
	0x6d, 0xcc, 0x6b, 0x12, 0x86, 0x57, 0x36, 0x89, 0x49, 0x3c, 0x7e, 0x82, 0xb4, 0xd4, 0xe5, 0x84,
	0xd1, 0x26, 0xde, 0x7a, 0x0f, 0x9c, 0xef, 0x34, 0x25, 0xa2, 0x7d, 0x3e, 0x0a, 0xba, 0x70, 0xe1,
	0xcb, 0x5d, 0x3c, 0x10, 0xc3, 0xd4, 0x07, 0x7b, 0xb8, 0xdf, 0x08, 0xfd, 0x80, 0x39, 0xf7, 0x5f,
	0x60, 0xf0, 0xd3, 0x4c, 0x76, 0x74, 0xb4, 0x50, 0xba, 0x09, 0x27, 0x2b, 0xa6, 0x4d, 0xd4, 0xe6,
	0xf4, 0x96, 0x32, 0xde, 0x47, 0xef, 0xc0, 0x9c, 0x65, 0xda, 0x44, 0xe3, 0x6d, 0x5a, 0x64, 0x4e,
	0xef, 0xea, 0xe0, 0x7f, 0xbe, 0x9a, 0xce, 0x5e, 0x0c, 0x3d, 0xb1, 0xa1, 0x9a, 0xe5, 0x6c, 0xde,
	0xd7, 0x57, 0x06, 0xbf, 0xdb, 0xc5, 0xe0, 0xc1, 0x1e, 0xce, 0x50, 0x46, 0x49, 0xe9, 0x1f, 0x19,
	0x38, 0x1e, 0x5b, 0x4a, 0xee, 0xf0, 0xa6, 0xaf, 0xd7, 0x48, 0x02, 0xe6, 0xc1, 0x6b, 0x82, 0x79,
	0x19, 0x7f, 0xf7, 0xbc, 0x2e, 0xfe, 0xbe, 0x90, 0x7a, 0x01, 0xf4, 0xbe, 0xf4, 0x05, 0x90, 0xe9,
	0x44, 0xfd, 0x65, 0x38, 0x12, 0xb0, 0x40, 0xb7, 0xa5, 0x96, 0x94, 0x11, 0xad, 0x01, 0xef, 0x37,
	0xe0, 0xd5, 0x61, 0xa1, 0xd0, 0xea, 0x49, 0x3f, 0x81, 0x63, 0x86, 0x1b, 0x46, 0x2d, 0x49, 0x32,
	0xd3, 0xf7, 0x0a, 0x33, 0x05, 0xc3, 0x0d, 0x45, 0x83, 0x6a, 0xb3, 0x54, 0xeb, 0x62, 0xa9, 0xff,
	0x55, 0x96, 0x6a, 0x1d, 0x96, 0x66, 0xe0, 0x70, 0xa2, 0xaf, 0xf9, 0x06, 0xf3, 0x88, 0x00, 0xdf,
	0x19, 0x75, 0x28, 0xa1, 0x6e, 0x70, 0x22, 0x7a, 0x17, 0xe2, 0x4e, 0xd7, 0x63, 0x85, 0xac, 0x50,
	0x98, 0x48, 0x7b, 0xd9, 0x54, 0xac, 0xed, 0xa7, 0x98, 0x8b, 0x14, 0x6b, 0xdd, 0x14, 0x57, 0x16,
	0xef, 0xed, 0x62, 0xa5, 0x4b, 0x59, 0xed, 0x9b, 0xe8, 0xa5, 0x07, 0x19, 0x38, 0x22, 0x65, 0x6a,
	0x85, 0x6e, 0xb2, 0xef, 0xeb, 0xfd, 0xf8, 0x36, 0xcc, 0x51, 0x16, 0x58, 0x9b, 0x75, 0x3e, 0xbb,
	0x7a, 0x45, 0xce, 0xe7, 0x5a, 0xfd, 0x3d, 0x1b, 0xf1, 0x2a, 0x26, 0x9a, 0x7b, 0xbd, 0xc7, 0x55,
	0xf2, 0xac, 0x3a, 0xdc, 0xfe, 0xac, 0x6a, 0xbe, 0xa3, 0xde, 0x85, 0xfd, 0x5c, 0x20, 0xf4, 0xc5,
	0x0b, 0xaa, 0xdd, 0xc1, 0x0d, 0xc1, 0xe0, 0x87, 0x93, 0x5f, 0x8b, 0x91, 0x78, 0x3b, 0xfe, 0x1c,
	0x38, 0x10, 0xfe, 0x34, 0xba, 0x0d, 0xc1, 0x39, 0x91, 0x58, 0x8b, 0xdd, 0x87, 0x20, 0xf7, 0x65,
	0x9f, 0x41, 0x18, 0x83, 0xf0, 0xf4, 0xfc, 0xfb, 0x7e, 0x06, 0xd2, 0x5a, 0x7a, 0x1e, 0xdd, 0x6f,
	0x60, 0xf0, 0x45, 0x03, 0x0f, 0xca, 0xa1, 0xfe, 0xba, 0xd1, 0xea, 0x40, 0xdf, 0xee, 0x61, 0xf0,
	0xe0, 0x05, 0x96, 0x7f, 0x30, 0x2c, 0x3d, 0xcb, 0xc1, 0x61, 0x69, 0x5d, 0x76, 0x2d, 0xf4, 0x47,
	0x00, 0x0b, 0xd1, 0x24, 0x69, 0xfb, 0x13, 0xd1, 0xfd, 0xf0, 0x93, 0x05, 0x89, 0xae, 0x8a, 0x5f,
	0x5d, 0xa5, 0x5f, 0xee, 0x34, 0xf0, 0x52, 0x12, 0x66, 0xb9, 0x77, 0x2a, 0x65, 0x83, 0x9f, 0x75,
	0x5d, 0xa7, 0x7a, 0x8d, 0x28, 0xe9, 0x04, 0xfe, 0x6c, 0x17, 0x83, 0x47, 0xbb, 0x18, 0x7c, 0xf2,
	0xb7, 0x7f, 0xfe, 0xae, 0x07, 0x97, 0xc6, 0x16, 0x22, 0xe4, 0xbe, 0x20, 0xfd, 0x9b, 0x5b, 0x01,
	0x67, 0x16, 0x01, 0xba, 0x07, 0x60, 0x21, 0x1a, 0x5e, 0x07, 0x74, 0xf0, 0x67, 0x07, 0x77, 0xb0,
	0xe9, 0x5c, 0x04, 0x8c, 0x3b, 0x9d, 0x7b, 0xd6, 0x03, 0x0b, 0xd1, 0xf4, 0x3d, 0xa0, 0x73, 0x7f,
	0xea, 0x39, 0xb8, 0x77, 0x5f, 0xee, 0xe2, 0x87, 0x20, 0x41, 0x1a, 0xcd, 0x47, 0x78, 0x27, 0x50,
	0x68, 0x8d, 0x36, 0x65, 0x23, 0xf5, 0xa8, 0x54, 0x92, 0x5f, 0x0d, 0xca, 0xc5, 0xe6, 0x33, 0x5f,
	0xa9, 0x24, 0xef, 0x5c, 0x25, 0x7e, 0x40, 0xf8, 0xca, 0x7a, 0xeb, 0xb1, 0x21, 0xa3, 0x01, 0xa5,
	0x0d, 0x95, 0x2a, 0x09, 0xcc, 0xf4, 0x57, 0x4e, 0x46, 0x0d, 0xac, 0x8d, 0xd0, 0x26, 0x7a, 0x25,
	0x0d, 0xfb, 0x9a, 0xa1, 0x8e, 0x9e, 0x59, 0x9d, 0xa1, 0xfe, 0x03, 0x80, 0x23, 0x1b, 0xb7, 0xd9,
	0x9d, 0xd7, 0x09, 0xf4, 0x3e, 0xf4, 0xd2, 0x8d, 0x9d, 0x06, 0x5e, 0x7c, 0x49, 0xb0, 0x6f, 0x59,
	0xe4, 0x4e, 0x47, 0xa8, 0x9b, 0x59, 0x7a, 0xb8, 0x54, 0x58, 0xf0, 0x6f, 0xb3, 0x3b, 0x9d, 0xbe,
	0xfd, 0x15, 0xc0, 0x62, 0x94, 0xa3, 0x2f, 0x81, 0x12, 0x33, 0x72, 0x6f, 0xda, 0x57, 0xac, 0x5b,
	0x92, 0x6c, 0xec, 0x34, 0x70, 0xe9, 0xd5, 0x39, 0x22, 0x9c, 0x3c, 0x5d, 0x2a, 0x25, 0xd9, 0xca,
	0x91, 0x49, 0xeb, 0xa7, 0x84, 0xe4, 0xb4, 0xbf, 0x02, 0xce, 0xa0, 0xbf, 0x03, 0x88, 0xa5, 0x78,
	0xb6, 0x83, 0x94, 0xfd, 0x02, 0x3b, 0xdd, 0x49, 0x6f, 0x53, 0x2c, 0xfd, 0x1a, 0x1c, 0x24, 0xc4,
	0x3b, 0xbb, 0xf8, 0x68, 0x07, 0x94, 0x4b, 0xc6, 0xe0, 0xc7, 0x7b, 0x18, 0x3c, 0x7e, 0x11, 0xdf,
	0xc1, 0x4c, 0xa9, 0xd8, 0x71, 0x07, 0x0b, 0x49, 0x3f, 0x5f, 0x08, 0xb9, 0x0f, 0xe2, 0x4a, 0x96,
	0x7e, 0x03, 0x20, 0x4a, 0xb5, 0x6d, 0xde, 0xee, 0x3e, 0x82, 0x63, 0xa9, 0x24, 0x12, 0x93, 0x73,
	0x72, 0xff, 0x66, 0x3f, 0xf9, 0x12, 0x5e, 0xa9, 0x28, 0x9c, 0x9a, 0x2c, 0x4d, 0x74, 0x38, 0x65,
	0xd1, 0x4d, 0x26, 0x3c, 0x59, 0x3d, 0xf6, 0xf0, 0x9b, 0xa9, 0x43, 0x0f, 0x9f, 0x4c, 0x81, 0x47,
	0x4f, 0xa6, 0xc0, 0xd7, 0x4f, 0xa6, 0xc0, 0xa7, 0x4f, 0xa7, 0x0e, 0x3d, 0x7a, 0x3a, 0x75, 0xe8,
	0xf1, 0xd3, 0xa9, 0x43, 0xd5, 0x7e, 0x61, 0xf8, 0xdc, 0x7f, 0x03, 0x00, 0x00, 0xff, 0xff, 0xce,
	0x8b, 0x41, 0x4e, 0x95, 0x18, 0x00, 0x00,
}

func (this *ClusterInstKeyV1) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&edgeproto.ClusterInstKeyV1{")
	s = append(s, "ClusterKey: "+strings.Replace(this.ClusterKey.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "CloudletKey: "+strings.Replace(this.CloudletKey.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "Organization: "+fmt.Sprintf("%#v", this.Organization)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ClusterInstKeyV2) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&edgeproto.ClusterInstKeyV2{")
	s = append(s, "ClusterKey: "+strings.Replace(this.ClusterKey.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "CloudletKey: "+strings.Replace(this.CloudletKey.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringClusterinst(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ClusterInstApiClient is the client API for ClusterInstApi service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ClusterInstApiClient interface {
	// Create Cluster Instance. Creates an instance of a Cluster on a Cloudlet,
	// defined by a Cluster Key and a Cloudlet Key. ClusterInst is a collection of
	// compute resources on a Cloudlet on which AppInsts are deployed.
	CreateClusterInst(ctx context.Context, in *ClusterInst, opts ...grpc.CallOption) (ClusterInstApi_CreateClusterInstClient, error)
	// Delete Cluster Instance. Deletes an instance of a Cluster deployed on a Cloudlet.
	DeleteClusterInst(ctx context.Context, in *ClusterInst, opts ...grpc.CallOption) (ClusterInstApi_DeleteClusterInstClient, error)
	// Update Cluster Instance. Updates an instance of a Cluster deployed on a Cloudlet.
	UpdateClusterInst(ctx context.Context, in *ClusterInst, opts ...grpc.CallOption) (ClusterInstApi_UpdateClusterInstClient, error)
	// Show Cluster Instances. Lists all the cluster instances managed by Edge Controller.
	ShowClusterInst(ctx context.Context, in *ClusterInst, opts ...grpc.CallOption) (ClusterInstApi_ShowClusterInstClient, error)
	// Cleanup Reservable Cluster Instances. Deletes reservable cluster instances that are not in use.
	DeleteIdleReservableClusterInsts(ctx context.Context, in *IdleReservableClusterInsts, opts ...grpc.CallOption) (*Result, error)
	// Show Cluster resource information
	ShowClusterResourceUsage(ctx context.Context, in *ClusterInst, opts ...grpc.CallOption) (ClusterInstApi_ShowClusterResourceUsageClient, error)
}

type clusterInstApiClient struct {
	cc *grpc.ClientConn
}

func NewClusterInstApiClient(cc *grpc.ClientConn) ClusterInstApiClient {
	return &clusterInstApiClient{cc}
}

func (c *clusterInstApiClient) CreateClusterInst(ctx context.Context, in *ClusterInst, opts ...grpc.CallOption) (ClusterInstApi_CreateClusterInstClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ClusterInstApi_serviceDesc.Streams[0], "/edgeproto.ClusterInstApi/CreateClusterInst", opts...)
	if err != nil {
		return nil, err
	}
	x := &clusterInstApiCreateClusterInstClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ClusterInstApi_CreateClusterInstClient interface {
	Recv() (*Result, error)
	grpc.ClientStream
}

type clusterInstApiCreateClusterInstClient struct {
	grpc.ClientStream
}

func (x *clusterInstApiCreateClusterInstClient) Recv() (*Result, error) {
	m := new(Result)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *clusterInstApiClient) DeleteClusterInst(ctx context.Context, in *ClusterInst, opts ...grpc.CallOption) (ClusterInstApi_DeleteClusterInstClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ClusterInstApi_serviceDesc.Streams[1], "/edgeproto.ClusterInstApi/DeleteClusterInst", opts...)
	if err != nil {
		return nil, err
	}
	x := &clusterInstApiDeleteClusterInstClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ClusterInstApi_DeleteClusterInstClient interface {
	Recv() (*Result, error)
	grpc.ClientStream
}

type clusterInstApiDeleteClusterInstClient struct {
	grpc.ClientStream
}

func (x *clusterInstApiDeleteClusterInstClient) Recv() (*Result, error) {
	m := new(Result)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *clusterInstApiClient) UpdateClusterInst(ctx context.Context, in *ClusterInst, opts ...grpc.CallOption) (ClusterInstApi_UpdateClusterInstClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ClusterInstApi_serviceDesc.Streams[2], "/edgeproto.ClusterInstApi/UpdateClusterInst", opts...)
	if err != nil {
		return nil, err
	}
	x := &clusterInstApiUpdateClusterInstClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ClusterInstApi_UpdateClusterInstClient interface {
	Recv() (*Result, error)
	grpc.ClientStream
}

type clusterInstApiUpdateClusterInstClient struct {
	grpc.ClientStream
}

func (x *clusterInstApiUpdateClusterInstClient) Recv() (*Result, error) {
	m := new(Result)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *clusterInstApiClient) ShowClusterInst(ctx context.Context, in *ClusterInst, opts ...grpc.CallOption) (ClusterInstApi_ShowClusterInstClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ClusterInstApi_serviceDesc.Streams[3], "/edgeproto.ClusterInstApi/ShowClusterInst", opts...)
	if err != nil {
		return nil, err
	}
	x := &clusterInstApiShowClusterInstClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ClusterInstApi_ShowClusterInstClient interface {
	Recv() (*ClusterInst, error)
	grpc.ClientStream
}

type clusterInstApiShowClusterInstClient struct {
	grpc.ClientStream
}

func (x *clusterInstApiShowClusterInstClient) Recv() (*ClusterInst, error) {
	m := new(ClusterInst)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *clusterInstApiClient) DeleteIdleReservableClusterInsts(ctx context.Context, in *IdleReservableClusterInsts, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/edgeproto.ClusterInstApi/DeleteIdleReservableClusterInsts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterInstApiClient) ShowClusterResourceUsage(ctx context.Context, in *ClusterInst, opts ...grpc.CallOption) (ClusterInstApi_ShowClusterResourceUsageClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ClusterInstApi_serviceDesc.Streams[4], "/edgeproto.ClusterInstApi/ShowClusterResourceUsage", opts...)
	if err != nil {
		return nil, err
	}
	x := &clusterInstApiShowClusterResourceUsageClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ClusterInstApi_ShowClusterResourceUsageClient interface {
	Recv() (*ClusterResourceUsage, error)
	grpc.ClientStream
}

type clusterInstApiShowClusterResourceUsageClient struct {
	grpc.ClientStream
}

func (x *clusterInstApiShowClusterResourceUsageClient) Recv() (*ClusterResourceUsage, error) {
	m := new(ClusterResourceUsage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ClusterInstApiServer is the server API for ClusterInstApi service.
type ClusterInstApiServer interface {
	// Create Cluster Instance. Creates an instance of a Cluster on a Cloudlet,
	// defined by a Cluster Key and a Cloudlet Key. ClusterInst is a collection of
	// compute resources on a Cloudlet on which AppInsts are deployed.
	CreateClusterInst(*ClusterInst, ClusterInstApi_CreateClusterInstServer) error
	// Delete Cluster Instance. Deletes an instance of a Cluster deployed on a Cloudlet.
	DeleteClusterInst(*ClusterInst, ClusterInstApi_DeleteClusterInstServer) error
	// Update Cluster Instance. Updates an instance of a Cluster deployed on a Cloudlet.
	UpdateClusterInst(*ClusterInst, ClusterInstApi_UpdateClusterInstServer) error
	// Show Cluster Instances. Lists all the cluster instances managed by Edge Controller.
	ShowClusterInst(*ClusterInst, ClusterInstApi_ShowClusterInstServer) error
	// Cleanup Reservable Cluster Instances. Deletes reservable cluster instances that are not in use.
	DeleteIdleReservableClusterInsts(context.Context, *IdleReservableClusterInsts) (*Result, error)
	// Show Cluster resource information
	ShowClusterResourceUsage(*ClusterInst, ClusterInstApi_ShowClusterResourceUsageServer) error
}

// UnimplementedClusterInstApiServer can be embedded to have forward compatible implementations.
type UnimplementedClusterInstApiServer struct {
}

func (*UnimplementedClusterInstApiServer) CreateClusterInst(req *ClusterInst, srv ClusterInstApi_CreateClusterInstServer) error {
	return status.Errorf(codes.Unimplemented, "method CreateClusterInst not implemented")
}
func (*UnimplementedClusterInstApiServer) DeleteClusterInst(req *ClusterInst, srv ClusterInstApi_DeleteClusterInstServer) error {
	return status.Errorf(codes.Unimplemented, "method DeleteClusterInst not implemented")
}
func (*UnimplementedClusterInstApiServer) UpdateClusterInst(req *ClusterInst, srv ClusterInstApi_UpdateClusterInstServer) error {
	return status.Errorf(codes.Unimplemented, "method UpdateClusterInst not implemented")
}
func (*UnimplementedClusterInstApiServer) ShowClusterInst(req *ClusterInst, srv ClusterInstApi_ShowClusterInstServer) error {
	return status.Errorf(codes.Unimplemented, "method ShowClusterInst not implemented")
}
func (*UnimplementedClusterInstApiServer) DeleteIdleReservableClusterInsts(ctx context.Context, req *IdleReservableClusterInsts) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteIdleReservableClusterInsts not implemented")
}
func (*UnimplementedClusterInstApiServer) ShowClusterResourceUsage(req *ClusterInst, srv ClusterInstApi_ShowClusterResourceUsageServer) error {
	return status.Errorf(codes.Unimplemented, "method ShowClusterResourceUsage not implemented")
}

func RegisterClusterInstApiServer(s *grpc.Server, srv ClusterInstApiServer) {
	s.RegisterService(&_ClusterInstApi_serviceDesc, srv)
}

func _ClusterInstApi_CreateClusterInst_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ClusterInst)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ClusterInstApiServer).CreateClusterInst(m, &clusterInstApiCreateClusterInstServer{stream})
}

type ClusterInstApi_CreateClusterInstServer interface {
	Send(*Result) error
	grpc.ServerStream
}

type clusterInstApiCreateClusterInstServer struct {
	grpc.ServerStream
}

func (x *clusterInstApiCreateClusterInstServer) Send(m *Result) error {
	return x.ServerStream.SendMsg(m)
}

func _ClusterInstApi_DeleteClusterInst_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ClusterInst)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ClusterInstApiServer).DeleteClusterInst(m, &clusterInstApiDeleteClusterInstServer{stream})
}

type ClusterInstApi_DeleteClusterInstServer interface {
	Send(*Result) error
	grpc.ServerStream
}

type clusterInstApiDeleteClusterInstServer struct {
	grpc.ServerStream
}

func (x *clusterInstApiDeleteClusterInstServer) Send(m *Result) error {
	return x.ServerStream.SendMsg(m)
}

func _ClusterInstApi_UpdateClusterInst_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ClusterInst)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ClusterInstApiServer).UpdateClusterInst(m, &clusterInstApiUpdateClusterInstServer{stream})
}

type ClusterInstApi_UpdateClusterInstServer interface {
	Send(*Result) error
	grpc.ServerStream
}

type clusterInstApiUpdateClusterInstServer struct {
	grpc.ServerStream
}

func (x *clusterInstApiUpdateClusterInstServer) Send(m *Result) error {
	return x.ServerStream.SendMsg(m)
}

func _ClusterInstApi_ShowClusterInst_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ClusterInst)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ClusterInstApiServer).ShowClusterInst(m, &clusterInstApiShowClusterInstServer{stream})
}

type ClusterInstApi_ShowClusterInstServer interface {
	Send(*ClusterInst) error
	grpc.ServerStream
}

type clusterInstApiShowClusterInstServer struct {
	grpc.ServerStream
}

func (x *clusterInstApiShowClusterInstServer) Send(m *ClusterInst) error {
	return x.ServerStream.SendMsg(m)
}

func _ClusterInstApi_DeleteIdleReservableClusterInsts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IdleReservableClusterInsts)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterInstApiServer).DeleteIdleReservableClusterInsts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.ClusterInstApi/DeleteIdleReservableClusterInsts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterInstApiServer).DeleteIdleReservableClusterInsts(ctx, req.(*IdleReservableClusterInsts))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterInstApi_ShowClusterResourceUsage_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ClusterInst)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ClusterInstApiServer).ShowClusterResourceUsage(m, &clusterInstApiShowClusterResourceUsageServer{stream})
}

type ClusterInstApi_ShowClusterResourceUsageServer interface {
	Send(*ClusterResourceUsage) error
	grpc.ServerStream
}

type clusterInstApiShowClusterResourceUsageServer struct {
	grpc.ServerStream
}

func (x *clusterInstApiShowClusterResourceUsageServer) Send(m *ClusterResourceUsage) error {
	return x.ServerStream.SendMsg(m)
}

var _ClusterInstApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "edgeproto.ClusterInstApi",
	HandlerType: (*ClusterInstApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "DeleteIdleReservableClusterInsts",
			Handler:    _ClusterInstApi_DeleteIdleReservableClusterInsts_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "CreateClusterInst",
			Handler:       _ClusterInstApi_CreateClusterInst_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "DeleteClusterInst",
			Handler:       _ClusterInstApi_DeleteClusterInst_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "UpdateClusterInst",
			Handler:       _ClusterInstApi_UpdateClusterInst_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ShowClusterInst",
			Handler:       _ClusterInstApi_ShowClusterInst_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ShowClusterResourceUsage",
			Handler:       _ClusterInstApi_ShowClusterResourceUsage_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "clusterinst.proto",
}

// ClusterInstInfoApiClient is the client API for ClusterInstInfoApi service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ClusterInstInfoApiClient interface {
	// Show Cluster instances state.
	ShowClusterInstInfo(ctx context.Context, in *ClusterInstInfo, opts ...grpc.CallOption) (ClusterInstInfoApi_ShowClusterInstInfoClient, error)
}

type clusterInstInfoApiClient struct {
	cc *grpc.ClientConn
}

func NewClusterInstInfoApiClient(cc *grpc.ClientConn) ClusterInstInfoApiClient {
	return &clusterInstInfoApiClient{cc}
}

func (c *clusterInstInfoApiClient) ShowClusterInstInfo(ctx context.Context, in *ClusterInstInfo, opts ...grpc.CallOption) (ClusterInstInfoApi_ShowClusterInstInfoClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ClusterInstInfoApi_serviceDesc.Streams[0], "/edgeproto.ClusterInstInfoApi/ShowClusterInstInfo", opts...)
	if err != nil {
		return nil, err
	}
	x := &clusterInstInfoApiShowClusterInstInfoClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ClusterInstInfoApi_ShowClusterInstInfoClient interface {
	Recv() (*ClusterInstInfo, error)
	grpc.ClientStream
}

type clusterInstInfoApiShowClusterInstInfoClient struct {
	grpc.ClientStream
}

func (x *clusterInstInfoApiShowClusterInstInfoClient) Recv() (*ClusterInstInfo, error) {
	m := new(ClusterInstInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ClusterInstInfoApiServer is the server API for ClusterInstInfoApi service.
type ClusterInstInfoApiServer interface {
	// Show Cluster instances state.
	ShowClusterInstInfo(*ClusterInstInfo, ClusterInstInfoApi_ShowClusterInstInfoServer) error
}

// UnimplementedClusterInstInfoApiServer can be embedded to have forward compatible implementations.
type UnimplementedClusterInstInfoApiServer struct {
}

func (*UnimplementedClusterInstInfoApiServer) ShowClusterInstInfo(req *ClusterInstInfo, srv ClusterInstInfoApi_ShowClusterInstInfoServer) error {
	return status.Errorf(codes.Unimplemented, "method ShowClusterInstInfo not implemented")
}

func RegisterClusterInstInfoApiServer(s *grpc.Server, srv ClusterInstInfoApiServer) {
	s.RegisterService(&_ClusterInstInfoApi_serviceDesc, srv)
}

func _ClusterInstInfoApi_ShowClusterInstInfo_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ClusterInstInfo)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ClusterInstInfoApiServer).ShowClusterInstInfo(m, &clusterInstInfoApiShowClusterInstInfoServer{stream})
}

type ClusterInstInfoApi_ShowClusterInstInfoServer interface {
	Send(*ClusterInstInfo) error
	grpc.ServerStream
}

type clusterInstInfoApiShowClusterInstInfoServer struct {
	grpc.ServerStream
}

func (x *clusterInstInfoApiShowClusterInstInfoServer) Send(m *ClusterInstInfo) error {
	return x.ServerStream.SendMsg(m)
}

var _ClusterInstInfoApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "edgeproto.ClusterInstInfoApi",
	HandlerType: (*ClusterInstInfoApiServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ShowClusterInstInfo",
			Handler:       _ClusterInstInfoApi_ShowClusterInstInfo_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "clusterinst.proto",
}

func (m *ClusterInstKeyV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterInstKeyV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterInstKeyV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Organization) > 0 {
		i -= len(m.Organization)
		copy(dAtA[i:], m.Organization)
		i = encodeVarintClusterinst(dAtA, i, uint64(len(m.Organization)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.CloudletKey.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintClusterinst(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ClusterKey.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintClusterinst(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ClusterInstKeyV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterInstKeyV2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterInstKeyV2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.CloudletKey.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintClusterinst(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ClusterKey.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintClusterinst(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ClusterInst) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterInst) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterInst) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.KubernetesVersion) > 0 {
		i -= len(m.KubernetesVersion)
		copy(dAtA[i:], m.KubernetesVersion)
		i = encodeVarintClusterinst(dAtA, i, uint64(len(m.KubernetesVersion)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x82
	}
	if len(m.InfraAnnotations) > 0 {
		for k := range m.InfraAnnotations {
			v := m.InfraAnnotations[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintClusterinst(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintClusterinst(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintClusterinst(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xfa
		}
	}
	if len(m.NodePools) > 0 {
		for iNdEx := len(m.NodePools) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NodePools[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintClusterinst(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xf2
		}
	}
	if m.NodeResources != nil {
		{
			size, err := m.NodeResources.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintClusterinst(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xea
	}
	if m.DbModelId != 0 {
		i = encodeVarintClusterinst(dAtA, i, uint64(m.DbModelId))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe0
	}
	{
		size, err := m.ZoneKey.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintClusterinst(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0xda
	if len(m.Annotations) > 0 {
		for k := range m.Annotations {
			v := m.Annotations[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintClusterinst(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintClusterinst(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintClusterinst(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xd2
		}
	}
	{
		size, err := m.CloudletKey.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintClusterinst(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0xca
	if m.CompatibilityVersion != 0 {
		i = encodeVarintClusterinst(dAtA, i, uint64(m.CompatibilityVersion))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc0
	}
	if len(m.StaticFqdn) > 0 {
		i -= len(m.StaticFqdn)
		copy(dAtA[i:], m.StaticFqdn)
		i = encodeVarintClusterinst(dAtA, i, uint64(len(m.StaticFqdn)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xba
	}
	if len(m.ObjId) > 0 {
		i -= len(m.ObjId)
		copy(dAtA[i:], m.ObjId)
		i = encodeVarintClusterinst(dAtA, i, uint64(len(m.ObjId)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb2
	}
	if m.EnableIpv6 {
		i--
		if m.EnableIpv6 {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa8
	}
	if len(m.Fqdn) > 0 {
		i -= len(m.Fqdn)
		copy(dAtA[i:], m.Fqdn)
		i = encodeVarintClusterinst(dAtA, i, uint64(len(m.Fqdn)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa2
	}
	if len(m.DnsLabel) > 0 {
		i -= len(m.DnsLabel)
		copy(dAtA[i:], m.DnsLabel)
		i = encodeVarintClusterinst(dAtA, i, uint64(len(m.DnsLabel)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x9a
	}
	if m.DeletePrepare {
		i--
		if m.DeletePrepare {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x90
	}
	if len(m.Networks) > 0 {
		for iNdEx := len(m.Networks) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Networks[iNdEx])
			copy(dAtA[i:], m.Networks[iNdEx])
			i = encodeVarintClusterinst(dAtA, i, uint64(len(m.Networks[iNdEx])))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0x8a
		}
	}
	if m.MultiTenant {
		i--
		if m.MultiTenant {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x80
	}
	{
		size, err := m.ReservationEndedAt.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintClusterinst(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xfa
	{
		size, err := m.UpdatedAt.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintClusterinst(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xf2
	{
		size, err := m.CreatedAt.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintClusterinst(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xea
	{
		size, err := m.Resources.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintClusterinst(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xe2
	if len(m.OptRes) > 0 {
		i -= len(m.OptRes)
		copy(dAtA[i:], m.OptRes)
		i = encodeVarintClusterinst(dAtA, i, uint64(len(m.OptRes)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	if m.SkipCrmCleanupOnFailure {
		i--
		if m.SkipCrmCleanupOnFailure {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if len(m.MasterNodeFlavor) > 0 {
		i -= len(m.MasterNodeFlavor)
		copy(dAtA[i:], m.MasterNodeFlavor)
		i = encodeVarintClusterinst(dAtA, i, uint64(len(m.MasterNodeFlavor)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if m.SharedVolumeSize != 0 {
		i = encodeVarintClusterinst(dAtA, i, uint64(m.SharedVolumeSize))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if len(m.ReservedBy) > 0 {
		i -= len(m.ReservedBy)
		copy(dAtA[i:], m.ReservedBy)
		i = encodeVarintClusterinst(dAtA, i, uint64(len(m.ReservedBy)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.Reservable {
		i--
		if m.Reservable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if len(m.ImageName) > 0 {
		i -= len(m.ImageName)
		copy(dAtA[i:], m.ImageName)
		i = encodeVarintClusterinst(dAtA, i, uint64(len(m.ImageName)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if len(m.AvailabilityZone) > 0 {
		i -= len(m.AvailabilityZone)
		copy(dAtA[i:], m.AvailabilityZone)
		i = encodeVarintClusterinst(dAtA, i, uint64(len(m.AvailabilityZone)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if len(m.AutoScalePolicy) > 0 {
		i -= len(m.AutoScalePolicy)
		copy(dAtA[i:], m.AutoScalePolicy)
		i = encodeVarintClusterinst(dAtA, i, uint64(len(m.AutoScalePolicy)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.ExternalVolumeSize != 0 {
		i = encodeVarintClusterinst(dAtA, i, uint64(m.ExternalVolumeSize))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if len(m.Deployment) > 0 {
		i -= len(m.Deployment)
		copy(dAtA[i:], m.Deployment)
		i = encodeVarintClusterinst(dAtA, i, uint64(len(m.Deployment)))
		i--
		dAtA[i] = 0x7a
	}
	if m.NumNodes != 0 {
		i = encodeVarintClusterinst(dAtA, i, uint64(m.NumNodes))
		i--
		dAtA[i] = 0x70
	}
	if m.NumMasters != 0 {
		i = encodeVarintClusterinst(dAtA, i, uint64(m.NumMasters))
		i--
		dAtA[i] = 0x68
	}
	if len(m.NodeFlavor) > 0 {
		i -= len(m.NodeFlavor)
		copy(dAtA[i:], m.NodeFlavor)
		i = encodeVarintClusterinst(dAtA, i, uint64(len(m.NodeFlavor)))
		i--
		dAtA[i] = 0x5a
	}
	if m.Auto {
		i--
		if m.Auto {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.Liveness != 0 {
		i = encodeVarintClusterinst(dAtA, i, uint64(m.Liveness))
		i--
		dAtA[i] = 0x48
	}
	if len(m.AllocatedIp) > 0 {
		i -= len(m.AllocatedIp)
		copy(dAtA[i:], m.AllocatedIp)
		i = encodeVarintClusterinst(dAtA, i, uint64(len(m.AllocatedIp)))
		i--
		dAtA[i] = 0x42
	}
	if m.IpAccess != 0 {
		i = encodeVarintClusterinst(dAtA, i, uint64(m.IpAccess))
		i--
		dAtA[i] = 0x38
	}
	if m.CrmOverride != 0 {
		i = encodeVarintClusterinst(dAtA, i, uint64(m.CrmOverride))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Errors) > 0 {
		for iNdEx := len(m.Errors) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Errors[iNdEx])
			copy(dAtA[i:], m.Errors[iNdEx])
			i = encodeVarintClusterinst(dAtA, i, uint64(len(m.Errors[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.State != 0 {
		i = encodeVarintClusterinst(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x20
	}
	{
		size, err := m.Flavor.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintClusterinst(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintClusterinst(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Fields) > 0 {
		for iNdEx := len(m.Fields) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Fields[iNdEx])
			copy(dAtA[i:], m.Fields[iNdEx])
			i = encodeVarintClusterinst(dAtA, i, uint64(len(m.Fields[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *IdleReservableClusterInsts) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IdleReservableClusterInsts) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IdleReservableClusterInsts) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IdleTime != 0 {
		i = encodeVarintClusterinst(dAtA, i, uint64(m.IdleTime))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ClusterResourceUsage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterResourceUsage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterResourceUsage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GpuPoolsResourceScore != 0 {
		i = encodeVarintClusterinst(dAtA, i, uint64(m.GpuPoolsResourceScore))
		i--
		dAtA[i] = 0x48
	}
	if m.CpuPoolsResourceScore != 0 {
		i = encodeVarintClusterinst(dAtA, i, uint64(m.CpuPoolsResourceScore))
		i--
		dAtA[i] = 0x40
	}
	if m.ResourceScore != 0 {
		i = encodeVarintClusterinst(dAtA, i, uint64(m.ResourceScore))
		i--
		dAtA[i] = 0x38
	}
	if len(m.GpuPoolsResources) > 0 {
		for iNdEx := len(m.GpuPoolsResources) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.GpuPoolsResources[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintClusterinst(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.CpuPoolsResources) > 0 {
		for iNdEx := len(m.CpuPoolsResources) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CpuPoolsResources[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintClusterinst(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.TotalResources) > 0 {
		for iNdEx := len(m.TotalResources) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TotalResources[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintClusterinst(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	{
		size, err := m.CloudletKey.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintClusterinst(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.ZoneKey.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintClusterinst(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintClusterinst(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ClusterInstInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterInstInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterInstInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.InfraAnnotations) > 0 {
		for k := range m.InfraAnnotations {
			v := m.InfraAnnotations[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintClusterinst(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintClusterinst(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintClusterinst(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xea
		}
	}
	{
		size, err := m.Resources.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintClusterinst(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintClusterinst(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if len(m.Errors) > 0 {
		for iNdEx := len(m.Errors) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Errors[iNdEx])
			copy(dAtA[i:], m.Errors[iNdEx])
			i = encodeVarintClusterinst(dAtA, i, uint64(len(m.Errors[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.State != 0 {
		i = encodeVarintClusterinst(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x20
	}
	if m.NotifyId != 0 {
		i = encodeVarintClusterinst(dAtA, i, uint64(m.NotifyId))
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintClusterinst(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Fields) > 0 {
		for iNdEx := len(m.Fields) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Fields[iNdEx])
			copy(dAtA[i:], m.Fields[iNdEx])
			i = encodeVarintClusterinst(dAtA, i, uint64(len(m.Fields[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintClusterinst(dAtA []byte, offset int, v uint64) int {
	offset -= sovClusterinst(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ClusterInstKeyV1) Matches(o *ClusterInstKeyV1, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !m.ClusterKey.Matches(&o.ClusterKey, fopts...) {
		return false
	}
	if !m.CloudletKey.Matches(&o.CloudletKey, fopts...) {
		return false
	}
	if !opts.Filter || o.Organization != "" {
		if o.Organization != m.Organization {
			return false
		}
	}
	return true
}

func (m *ClusterInstKeyV1) Clone() *ClusterInstKeyV1 {
	cp := &ClusterInstKeyV1{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *ClusterInstKeyV1) CopyInFields(src *ClusterInstKeyV1) int {
	changed := 0
	if m.ClusterKey.Name != src.ClusterKey.Name {
		m.ClusterKey.Name = src.ClusterKey.Name
		changed++
	}
	if m.CloudletKey.Organization != src.CloudletKey.Organization {
		m.CloudletKey.Organization = src.CloudletKey.Organization
		changed++
	}
	if m.CloudletKey.Name != src.CloudletKey.Name {
		m.CloudletKey.Name = src.CloudletKey.Name
		changed++
	}
	if m.CloudletKey.FederatedOrganization != src.CloudletKey.FederatedOrganization {
		m.CloudletKey.FederatedOrganization = src.CloudletKey.FederatedOrganization
		changed++
	}
	if m.Organization != src.Organization {
		m.Organization = src.Organization
		changed++
	}
	return changed
}

func (m *ClusterInstKeyV1) DeepCopyIn(src *ClusterInstKeyV1) {
	m.ClusterKey.DeepCopyIn(&src.ClusterKey)
	m.CloudletKey.DeepCopyIn(&src.CloudletKey)
	m.Organization = src.Organization
}

func (m *ClusterInstKeyV1) GetKeyString() string {
	key, err := json.Marshal(m)
	if err != nil {
		log.FatalLog("Failed to marshal ClusterInstKeyV1 key string", "obj", m)
	}
	return string(key)
}

func ClusterInstKeyV1StringParse(str string, key *ClusterInstKeyV1) {
	err := json.Unmarshal([]byte(str), key)
	if err != nil {
		log.FatalLog("Failed to unmarshal ClusterInstKeyV1 key string", "str", str)
	}
}

func (m *ClusterInstKeyV1) NotFoundError() error {
	return fmt.Errorf("ClusterInstKeyV1 key %s not found", m.GetKeyString())
}

func (m *ClusterInstKeyV1) ExistsError() error {
	return fmt.Errorf("ClusterInstKeyV1 key %s already exists", m.GetKeyString())
}

func (m *ClusterInstKeyV1) BeingDeletedError() error {
	return fmt.Errorf("ClusterInstKeyV1 %s is being deleted", m.GetKeyString())
}

var ClusterInstKeyV1TagOrganization = "clusterorg"

func (m *ClusterInstKeyV1) GetTags() map[string]string {
	tags := make(map[string]string)
	m.AddTags(tags)
	return tags
}

func (m *ClusterInstKeyV1) AddTagsByFunc(addTag AddTagFunc) {
	addTag("cluster", m.ClusterKey.Name)
	addTag("cloudletorg", m.CloudletKey.Organization)
	addTag("cloudlet", m.CloudletKey.Name)
	addTag("cloudletfedorg", m.CloudletKey.FederatedOrganization)
	addTag("clusterorg", m.Organization)
}

func (m *ClusterInstKeyV1) AddTags(tags map[string]string) {
	tagMap := TagMap(tags)
	m.AddTagsByFunc(tagMap.AddTag)
}

// Helper method to check that enums have valid values
func (m *ClusterInstKeyV1) ValidateEnums() error {
	if err := m.ClusterKey.ValidateEnums(); err != nil {
		return err
	}
	if err := m.CloudletKey.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func (s *ClusterInstKeyV1) ClearTagged(tags map[string]struct{}) {
	s.ClusterKey.ClearTagged(tags)
	s.CloudletKey.ClearTagged(tags)
}

func (m *ClusterInstKeyV2) Matches(o *ClusterInstKeyV2, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !m.ClusterKey.Matches(&o.ClusterKey, fopts...) {
		return false
	}
	if !m.CloudletKey.Matches(&o.CloudletKey, fopts...) {
		return false
	}
	return true
}

func (m *ClusterInstKeyV2) Clone() *ClusterInstKeyV2 {
	cp := &ClusterInstKeyV2{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *ClusterInstKeyV2) CopyInFields(src *ClusterInstKeyV2) int {
	changed := 0
	if m.ClusterKey.Name != src.ClusterKey.Name {
		m.ClusterKey.Name = src.ClusterKey.Name
		changed++
	}
	if m.ClusterKey.Organization != src.ClusterKey.Organization {
		m.ClusterKey.Organization = src.ClusterKey.Organization
		changed++
	}
	if m.CloudletKey.Organization != src.CloudletKey.Organization {
		m.CloudletKey.Organization = src.CloudletKey.Organization
		changed++
	}
	if m.CloudletKey.Name != src.CloudletKey.Name {
		m.CloudletKey.Name = src.CloudletKey.Name
		changed++
	}
	if m.CloudletKey.FederatedOrganization != src.CloudletKey.FederatedOrganization {
		m.CloudletKey.FederatedOrganization = src.CloudletKey.FederatedOrganization
		changed++
	}
	return changed
}

func (m *ClusterInstKeyV2) DeepCopyIn(src *ClusterInstKeyV2) {
	m.ClusterKey.DeepCopyIn(&src.ClusterKey)
	m.CloudletKey.DeepCopyIn(&src.CloudletKey)
}

func (m *ClusterInstKeyV2) GetKeyString() string {
	key, err := json.Marshal(m)
	if err != nil {
		log.FatalLog("Failed to marshal ClusterInstKeyV2 key string", "obj", m)
	}
	return string(key)
}

func ClusterInstKeyV2StringParse(str string, key *ClusterInstKeyV2) {
	err := json.Unmarshal([]byte(str), key)
	if err != nil {
		log.FatalLog("Failed to unmarshal ClusterInstKeyV2 key string", "str", str)
	}
}

func (m *ClusterInstKeyV2) NotFoundError() error {
	return fmt.Errorf("ClusterInstKeyV2 key %s not found", m.GetKeyString())
}

func (m *ClusterInstKeyV2) ExistsError() error {
	return fmt.Errorf("ClusterInstKeyV2 key %s already exists", m.GetKeyString())
}

func (m *ClusterInstKeyV2) BeingDeletedError() error {
	return fmt.Errorf("ClusterInstKeyV2 %s is being deleted", m.GetKeyString())
}

func (m *ClusterInstKeyV2) GetTags() map[string]string {
	tags := make(map[string]string)
	m.AddTags(tags)
	return tags
}

func (m *ClusterInstKeyV2) AddTagsByFunc(addTag AddTagFunc) {
	addTag("cluster", m.ClusterKey.Name)
	addTag("clusterorg", m.ClusterKey.Organization)
	addTag("cloudletorg", m.CloudletKey.Organization)
	addTag("cloudlet", m.CloudletKey.Name)
	addTag("cloudletfedorg", m.CloudletKey.FederatedOrganization)
}

func (m *ClusterInstKeyV2) AddTags(tags map[string]string) {
	tagMap := TagMap(tags)
	m.AddTagsByFunc(tagMap.AddTag)
}

// Helper method to check that enums have valid values
func (m *ClusterInstKeyV2) ValidateEnums() error {
	if err := m.ClusterKey.ValidateEnums(); err != nil {
		return err
	}
	if err := m.CloudletKey.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func (s *ClusterInstKeyV2) ClearTagged(tags map[string]struct{}) {
	s.ClusterKey.ClearTagged(tags)
	s.CloudletKey.ClearTagged(tags)
}

func (m *ClusterInst) Matches(o *ClusterInst, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !m.Key.Matches(&o.Key, fopts...) {
		return false
	}
	if !opts.IgnoreBackend {
		if !m.Flavor.Matches(&o.Flavor, fopts...) {
			return false
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.State != 0 {
			if o.State != m.State {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.Errors != nil {
			if len(m.Errors) == 0 && len(o.Errors) > 0 || len(m.Errors) > 0 && len(o.Errors) == 0 {
				return false
			} else if m.Errors != nil && o.Errors != nil {
				if !opts.Filter && len(m.Errors) != len(o.Errors) {
					return false
				}
				found := 0
				for oIndex, _ := range o.Errors {
					for mIndex, _ := range m.Errors {
						if o.Errors[oIndex] == m.Errors[mIndex] {
							found++
							break
						}
					}
				}
				if found != len(o.Errors) {
					return false
				}
			}
		}
	}
	if !opts.Filter || o.CrmOverride != 0 {
		if o.CrmOverride != m.CrmOverride {
			return false
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.IpAccess != 0 {
			if o.IpAccess != m.IpAccess {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.AllocatedIp != "" {
			if o.AllocatedIp != m.AllocatedIp {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.Liveness != 0 {
			if o.Liveness != m.Liveness {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.Auto != false {
			if o.Auto != m.Auto {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.NodeFlavor != "" {
			if o.NodeFlavor != m.NodeFlavor {
				return false
			}
		}
	}
	if !opts.Filter || o.NumMasters != 0 {
		if o.NumMasters != m.NumMasters {
			return false
		}
	}
	if !opts.Filter || o.NumNodes != 0 {
		if o.NumNodes != m.NumNodes {
			return false
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.Deployment != "" {
			if o.Deployment != m.Deployment {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.ExternalVolumeSize != 0 {
			if o.ExternalVolumeSize != m.ExternalVolumeSize {
				return false
			}
		}
	}
	if !opts.Filter || o.AutoScalePolicy != "" {
		if o.AutoScalePolicy != m.AutoScalePolicy {
			return false
		}
	}
	if !opts.Filter || o.AvailabilityZone != "" {
		if o.AvailabilityZone != m.AvailabilityZone {
			return false
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.ImageName != "" {
			if o.ImageName != m.ImageName {
				return false
			}
		}
	}
	if !opts.Filter || o.Reservable != false {
		if o.Reservable != m.Reservable {
			return false
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.ReservedBy != "" {
			if o.ReservedBy != m.ReservedBy {
				return false
			}
		}
	}
	if !opts.Filter || o.SharedVolumeSize != 0 {
		if o.SharedVolumeSize != m.SharedVolumeSize {
			return false
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.MasterNodeFlavor != "" {
			if o.MasterNodeFlavor != m.MasterNodeFlavor {
				return false
			}
		}
	}
	if !opts.Filter || o.SkipCrmCleanupOnFailure != false {
		if o.SkipCrmCleanupOnFailure != m.SkipCrmCleanupOnFailure {
			return false
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.OptRes != "" {
			if o.OptRes != m.OptRes {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
	}
	if !opts.IgnoreBackend {
	}
	if !opts.IgnoreBackend {
	}
	if !opts.IgnoreBackend {
	}
	if !opts.Filter || o.MultiTenant != false {
		if o.MultiTenant != m.MultiTenant {
			return false
		}
	}
	if !opts.Filter || o.Networks != nil {
		if len(m.Networks) == 0 && len(o.Networks) > 0 || len(m.Networks) > 0 && len(o.Networks) == 0 {
			return false
		} else if m.Networks != nil && o.Networks != nil {
			if !opts.Filter && len(m.Networks) != len(o.Networks) {
				return false
			}
			found := 0
			for oIndex, _ := range o.Networks {
				for mIndex, _ := range m.Networks {
					if o.Networks[oIndex] == m.Networks[mIndex] {
						found++
						break
					}
				}
			}
			if found != len(o.Networks) {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.DeletePrepare != false {
			if o.DeletePrepare != m.DeletePrepare {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.DnsLabel != "" {
			if o.DnsLabel != m.DnsLabel {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.Fqdn != "" {
			if o.Fqdn != m.Fqdn {
				return false
			}
		}
	}
	if !opts.Filter || o.EnableIpv6 != false {
		if o.EnableIpv6 != m.EnableIpv6 {
			return false
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.ObjId != "" {
			if o.ObjId != m.ObjId {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.StaticFqdn != "" {
			if o.StaticFqdn != m.StaticFqdn {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.CompatibilityVersion != 0 {
			if o.CompatibilityVersion != m.CompatibilityVersion {
				return false
			}
		}
	}
	if !m.CloudletKey.Matches(&o.CloudletKey, fopts...) {
		return false
	}
	if !opts.Filter || o.Annotations != nil {
		if len(m.Annotations) == 0 && len(o.Annotations) > 0 || len(m.Annotations) > 0 && len(o.Annotations) == 0 {
			return false
		} else if m.Annotations != nil && o.Annotations != nil {
			if !opts.Filter && len(m.Annotations) != len(o.Annotations) {
				return false
			}
			for k, _ := range o.Annotations {
				_, ok := m.Annotations[k]
				if !ok {
					return false
				}
				if o.Annotations[k] != m.Annotations[k] {
					return false
				}
			}
		}
	}
	if !m.ZoneKey.Matches(&o.ZoneKey, fopts...) {
		return false
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.DbModelId != 0 {
			if o.DbModelId != m.DbModelId {
				return false
			}
		}
	}
	if !opts.Filter || o.NodeResources != nil {
		if m.NodeResources == nil && o.NodeResources != nil || m.NodeResources != nil && o.NodeResources == nil {
			return false
		} else if m.NodeResources != nil && o.NodeResources != nil {
		}
	}
	if !opts.Filter || o.NodePools != nil {
		if len(m.NodePools) == 0 && len(o.NodePools) > 0 || len(m.NodePools) > 0 && len(o.NodePools) == 0 {
			return false
		} else if m.NodePools != nil && o.NodePools != nil {
			if !opts.Filter && len(m.NodePools) != len(o.NodePools) {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.InfraAnnotations != nil {
			if len(m.InfraAnnotations) == 0 && len(o.InfraAnnotations) > 0 || len(m.InfraAnnotations) > 0 && len(o.InfraAnnotations) == 0 {
				return false
			} else if m.InfraAnnotations != nil && o.InfraAnnotations != nil {
				if !opts.Filter && len(m.InfraAnnotations) != len(o.InfraAnnotations) {
					return false
				}
				for k, _ := range o.InfraAnnotations {
					_, ok := m.InfraAnnotations[k]
					if !ok {
						return false
					}
					if o.InfraAnnotations[k] != m.InfraAnnotations[k] {
						return false
					}
				}
			}
		}
	}
	if !opts.Filter || o.KubernetesVersion != "" {
		if o.KubernetesVersion != m.KubernetesVersion {
			return false
		}
	}
	return true
}

const ClusterInstFieldKey = "2"
const ClusterInstFieldKeyName = "2.1"
const ClusterInstFieldKeyOrganization = "2.2"
const ClusterInstFieldFlavor = "3"
const ClusterInstFieldFlavorName = "3.1"
const ClusterInstFieldState = "4"
const ClusterInstFieldErrors = "5"
const ClusterInstFieldCrmOverride = "6"
const ClusterInstFieldIpAccess = "7"
const ClusterInstFieldAllocatedIp = "8"
const ClusterInstFieldLiveness = "9"
const ClusterInstFieldAuto = "10"
const ClusterInstFieldNodeFlavor = "11"
const ClusterInstFieldNumMasters = "13"
const ClusterInstFieldNumNodes = "14"
const ClusterInstFieldDeployment = "15"
const ClusterInstFieldExternalVolumeSize = "17"
const ClusterInstFieldAutoScalePolicy = "18"
const ClusterInstFieldAvailabilityZone = "19"
const ClusterInstFieldImageName = "20"
const ClusterInstFieldReservable = "21"
const ClusterInstFieldReservedBy = "22"
const ClusterInstFieldSharedVolumeSize = "23"
const ClusterInstFieldMasterNodeFlavor = "25"
const ClusterInstFieldSkipCrmCleanupOnFailure = "26"
const ClusterInstFieldOptRes = "27"
const ClusterInstFieldResources = "28"
const ClusterInstFieldResourcesVms = "28.1"
const ClusterInstFieldResourcesVmsName = "28.1.1"
const ClusterInstFieldResourcesVmsType = "28.1.2"
const ClusterInstFieldResourcesVmsStatus = "28.1.3"
const ClusterInstFieldResourcesVmsInfraFlavor = "28.1.4"
const ClusterInstFieldResourcesVmsIpaddresses = "28.1.5"
const ClusterInstFieldResourcesVmsIpaddressesExternalIp = "28.1.5.1"
const ClusterInstFieldResourcesVmsIpaddressesInternalIp = "28.1.5.2"
const ClusterInstFieldResourcesVmsContainers = "28.1.6"
const ClusterInstFieldResourcesVmsContainersName = "28.1.6.1"
const ClusterInstFieldResourcesVmsContainersType = "28.1.6.2"
const ClusterInstFieldResourcesVmsContainersStatus = "28.1.6.3"
const ClusterInstFieldResourcesVmsContainersClusterip = "28.1.6.4"
const ClusterInstFieldResourcesVmsContainersRestarts = "28.1.6.5"
const ClusterInstFieldCreatedAt = "29"
const ClusterInstFieldCreatedAtSeconds = "29.1"
const ClusterInstFieldCreatedAtNanos = "29.2"
const ClusterInstFieldUpdatedAt = "30"
const ClusterInstFieldUpdatedAtSeconds = "30.1"
const ClusterInstFieldUpdatedAtNanos = "30.2"
const ClusterInstFieldReservationEndedAt = "31"
const ClusterInstFieldReservationEndedAtSeconds = "31.1"
const ClusterInstFieldReservationEndedAtNanos = "31.2"
const ClusterInstFieldMultiTenant = "32"
const ClusterInstFieldNetworks = "33"
const ClusterInstFieldDeletePrepare = "34"
const ClusterInstFieldDnsLabel = "35"
const ClusterInstFieldFqdn = "36"
const ClusterInstFieldEnableIpv6 = "37"
const ClusterInstFieldObjId = "38"
const ClusterInstFieldStaticFqdn = "39"
const ClusterInstFieldCompatibilityVersion = "40"
const ClusterInstFieldCloudletKey = "41"
const ClusterInstFieldCloudletKeyOrganization = "41.1"
const ClusterInstFieldCloudletKeyName = "41.2"
const ClusterInstFieldCloudletKeyFederatedOrganization = "41.3"
const ClusterInstFieldAnnotations = "42"
const ClusterInstFieldAnnotationsKey = "42.1"
const ClusterInstFieldAnnotationsValue = "42.2"
const ClusterInstFieldZoneKey = "43"
const ClusterInstFieldZoneKeyOrganization = "43.1"
const ClusterInstFieldZoneKeyName = "43.2"
const ClusterInstFieldZoneKeyFederatedOrganization = "43.3"
const ClusterInstFieldDbModelId = "44"
const ClusterInstFieldNodeResources = "45"
const ClusterInstFieldNodeResourcesVcpus = "45.1"
const ClusterInstFieldNodeResourcesRam = "45.2"
const ClusterInstFieldNodeResourcesDisk = "45.3"
const ClusterInstFieldNodeResourcesOptResMap = "45.4"
const ClusterInstFieldNodeResourcesOptResMapKey = "45.4.1"
const ClusterInstFieldNodeResourcesOptResMapValue = "45.4.2"
const ClusterInstFieldNodeResourcesInfraNodeFlavor = "45.5"
const ClusterInstFieldNodeResourcesExternalVolumeSize = "45.6"
const ClusterInstFieldNodePools = "46"
const ClusterInstFieldNodePoolsName = "46.1"
const ClusterInstFieldNodePoolsNumNodes = "46.2"
const ClusterInstFieldNodePoolsNodeResources = "46.3"
const ClusterInstFieldNodePoolsNodeResourcesVcpus = "46.3.1"
const ClusterInstFieldNodePoolsNodeResourcesRam = "46.3.2"
const ClusterInstFieldNodePoolsNodeResourcesDisk = "46.3.3"
const ClusterInstFieldNodePoolsNodeResourcesOptResMap = "46.3.4"
const ClusterInstFieldNodePoolsNodeResourcesOptResMapKey = "46.3.4.1"
const ClusterInstFieldNodePoolsNodeResourcesOptResMapValue = "46.3.4.2"
const ClusterInstFieldNodePoolsNodeResourcesInfraNodeFlavor = "46.3.5"
const ClusterInstFieldNodePoolsNodeResourcesExternalVolumeSize = "46.3.6"
const ClusterInstFieldNodePoolsScalable = "46.4"
const ClusterInstFieldInfraAnnotations = "47"
const ClusterInstFieldInfraAnnotationsKey = "47.1"
const ClusterInstFieldInfraAnnotationsValue = "47.2"
const ClusterInstFieldKubernetesVersion = "48"

var ClusterInstAllFields = []string{
	ClusterInstFieldKeyName,
	ClusterInstFieldKeyOrganization,
	ClusterInstFieldFlavorName,
	ClusterInstFieldState,
	ClusterInstFieldErrors,
	ClusterInstFieldCrmOverride,
	ClusterInstFieldIpAccess,
	ClusterInstFieldAllocatedIp,
	ClusterInstFieldLiveness,
	ClusterInstFieldAuto,
	ClusterInstFieldNodeFlavor,
	ClusterInstFieldNumMasters,
	ClusterInstFieldNumNodes,
	ClusterInstFieldDeployment,
	ClusterInstFieldExternalVolumeSize,
	ClusterInstFieldAutoScalePolicy,
	ClusterInstFieldAvailabilityZone,
	ClusterInstFieldImageName,
	ClusterInstFieldReservable,
	ClusterInstFieldReservedBy,
	ClusterInstFieldSharedVolumeSize,
	ClusterInstFieldMasterNodeFlavor,
	ClusterInstFieldSkipCrmCleanupOnFailure,
	ClusterInstFieldOptRes,
	ClusterInstFieldResourcesVmsName,
	ClusterInstFieldResourcesVmsType,
	ClusterInstFieldResourcesVmsStatus,
	ClusterInstFieldResourcesVmsInfraFlavor,
	ClusterInstFieldResourcesVmsIpaddressesExternalIp,
	ClusterInstFieldResourcesVmsIpaddressesInternalIp,
	ClusterInstFieldResourcesVmsContainersName,
	ClusterInstFieldResourcesVmsContainersType,
	ClusterInstFieldResourcesVmsContainersStatus,
	ClusterInstFieldResourcesVmsContainersClusterip,
	ClusterInstFieldResourcesVmsContainersRestarts,
	ClusterInstFieldCreatedAtSeconds,
	ClusterInstFieldCreatedAtNanos,
	ClusterInstFieldUpdatedAtSeconds,
	ClusterInstFieldUpdatedAtNanos,
	ClusterInstFieldReservationEndedAtSeconds,
	ClusterInstFieldReservationEndedAtNanos,
	ClusterInstFieldMultiTenant,
	ClusterInstFieldNetworks,
	ClusterInstFieldDeletePrepare,
	ClusterInstFieldDnsLabel,
	ClusterInstFieldFqdn,
	ClusterInstFieldEnableIpv6,
	ClusterInstFieldObjId,
	ClusterInstFieldStaticFqdn,
	ClusterInstFieldCompatibilityVersion,
	ClusterInstFieldCloudletKeyOrganization,
	ClusterInstFieldCloudletKeyName,
	ClusterInstFieldCloudletKeyFederatedOrganization,
	ClusterInstFieldAnnotationsKey,
	ClusterInstFieldAnnotationsValue,
	ClusterInstFieldZoneKeyOrganization,
	ClusterInstFieldZoneKeyName,
	ClusterInstFieldZoneKeyFederatedOrganization,
	ClusterInstFieldDbModelId,
	ClusterInstFieldNodeResourcesVcpus,
	ClusterInstFieldNodeResourcesRam,
	ClusterInstFieldNodeResourcesDisk,
	ClusterInstFieldNodeResourcesOptResMapKey,
	ClusterInstFieldNodeResourcesOptResMapValue,
	ClusterInstFieldNodeResourcesInfraNodeFlavor,
	ClusterInstFieldNodeResourcesExternalVolumeSize,
	ClusterInstFieldNodePoolsName,
	ClusterInstFieldNodePoolsNumNodes,
	ClusterInstFieldNodePoolsNodeResourcesVcpus,
	ClusterInstFieldNodePoolsNodeResourcesRam,
	ClusterInstFieldNodePoolsNodeResourcesDisk,
	ClusterInstFieldNodePoolsNodeResourcesOptResMapKey,
	ClusterInstFieldNodePoolsNodeResourcesOptResMapValue,
	ClusterInstFieldNodePoolsNodeResourcesInfraNodeFlavor,
	ClusterInstFieldNodePoolsNodeResourcesExternalVolumeSize,
	ClusterInstFieldNodePoolsScalable,
	ClusterInstFieldInfraAnnotationsKey,
	ClusterInstFieldInfraAnnotationsValue,
	ClusterInstFieldKubernetesVersion,
}

var ClusterInstAllFieldsMap = NewFieldMap(map[string]struct{}{
	ClusterInstFieldKeyName:                                  struct{}{},
	ClusterInstFieldKeyOrganization:                          struct{}{},
	ClusterInstFieldFlavorName:                               struct{}{},
	ClusterInstFieldState:                                    struct{}{},
	ClusterInstFieldErrors:                                   struct{}{},
	ClusterInstFieldCrmOverride:                              struct{}{},
	ClusterInstFieldIpAccess:                                 struct{}{},
	ClusterInstFieldAllocatedIp:                              struct{}{},
	ClusterInstFieldLiveness:                                 struct{}{},
	ClusterInstFieldAuto:                                     struct{}{},
	ClusterInstFieldNodeFlavor:                               struct{}{},
	ClusterInstFieldNumMasters:                               struct{}{},
	ClusterInstFieldNumNodes:                                 struct{}{},
	ClusterInstFieldDeployment:                               struct{}{},
	ClusterInstFieldExternalVolumeSize:                       struct{}{},
	ClusterInstFieldAutoScalePolicy:                          struct{}{},
	ClusterInstFieldAvailabilityZone:                         struct{}{},
	ClusterInstFieldImageName:                                struct{}{},
	ClusterInstFieldReservable:                               struct{}{},
	ClusterInstFieldReservedBy:                               struct{}{},
	ClusterInstFieldSharedVolumeSize:                         struct{}{},
	ClusterInstFieldMasterNodeFlavor:                         struct{}{},
	ClusterInstFieldSkipCrmCleanupOnFailure:                  struct{}{},
	ClusterInstFieldOptRes:                                   struct{}{},
	ClusterInstFieldResourcesVmsName:                         struct{}{},
	ClusterInstFieldResourcesVmsType:                         struct{}{},
	ClusterInstFieldResourcesVmsStatus:                       struct{}{},
	ClusterInstFieldResourcesVmsInfraFlavor:                  struct{}{},
	ClusterInstFieldResourcesVmsIpaddressesExternalIp:        struct{}{},
	ClusterInstFieldResourcesVmsIpaddressesInternalIp:        struct{}{},
	ClusterInstFieldResourcesVmsContainersName:               struct{}{},
	ClusterInstFieldResourcesVmsContainersType:               struct{}{},
	ClusterInstFieldResourcesVmsContainersStatus:             struct{}{},
	ClusterInstFieldResourcesVmsContainersClusterip:          struct{}{},
	ClusterInstFieldResourcesVmsContainersRestarts:           struct{}{},
	ClusterInstFieldCreatedAtSeconds:                         struct{}{},
	ClusterInstFieldCreatedAtNanos:                           struct{}{},
	ClusterInstFieldUpdatedAtSeconds:                         struct{}{},
	ClusterInstFieldUpdatedAtNanos:                           struct{}{},
	ClusterInstFieldReservationEndedAtSeconds:                struct{}{},
	ClusterInstFieldReservationEndedAtNanos:                  struct{}{},
	ClusterInstFieldMultiTenant:                              struct{}{},
	ClusterInstFieldNetworks:                                 struct{}{},
	ClusterInstFieldDeletePrepare:                            struct{}{},
	ClusterInstFieldDnsLabel:                                 struct{}{},
	ClusterInstFieldFqdn:                                     struct{}{},
	ClusterInstFieldEnableIpv6:                               struct{}{},
	ClusterInstFieldObjId:                                    struct{}{},
	ClusterInstFieldStaticFqdn:                               struct{}{},
	ClusterInstFieldCompatibilityVersion:                     struct{}{},
	ClusterInstFieldCloudletKeyOrganization:                  struct{}{},
	ClusterInstFieldCloudletKeyName:                          struct{}{},
	ClusterInstFieldCloudletKeyFederatedOrganization:         struct{}{},
	ClusterInstFieldAnnotationsKey:                           struct{}{},
	ClusterInstFieldAnnotationsValue:                         struct{}{},
	ClusterInstFieldZoneKeyOrganization:                      struct{}{},
	ClusterInstFieldZoneKeyName:                              struct{}{},
	ClusterInstFieldZoneKeyFederatedOrganization:             struct{}{},
	ClusterInstFieldDbModelId:                                struct{}{},
	ClusterInstFieldNodeResourcesVcpus:                       struct{}{},
	ClusterInstFieldNodeResourcesRam:                         struct{}{},
	ClusterInstFieldNodeResourcesDisk:                        struct{}{},
	ClusterInstFieldNodeResourcesOptResMapKey:                struct{}{},
	ClusterInstFieldNodeResourcesOptResMapValue:              struct{}{},
	ClusterInstFieldNodeResourcesInfraNodeFlavor:             struct{}{},
	ClusterInstFieldNodeResourcesExternalVolumeSize:          struct{}{},
	ClusterInstFieldNodePoolsName:                            struct{}{},
	ClusterInstFieldNodePoolsNumNodes:                        struct{}{},
	ClusterInstFieldNodePoolsNodeResourcesVcpus:              struct{}{},
	ClusterInstFieldNodePoolsNodeResourcesRam:                struct{}{},
	ClusterInstFieldNodePoolsNodeResourcesDisk:               struct{}{},
	ClusterInstFieldNodePoolsNodeResourcesOptResMapKey:       struct{}{},
	ClusterInstFieldNodePoolsNodeResourcesOptResMapValue:     struct{}{},
	ClusterInstFieldNodePoolsNodeResourcesInfraNodeFlavor:    struct{}{},
	ClusterInstFieldNodePoolsNodeResourcesExternalVolumeSize: struct{}{},
	ClusterInstFieldNodePoolsScalable:                        struct{}{},
	ClusterInstFieldInfraAnnotationsKey:                      struct{}{},
	ClusterInstFieldInfraAnnotationsValue:                    struct{}{},
	ClusterInstFieldKubernetesVersion:                        struct{}{},
})

var ClusterInstAllFieldsStringMap = map[string]string{
	ClusterInstFieldKeyName:                                  "Key Name",
	ClusterInstFieldKeyOrganization:                          "Key Organization",
	ClusterInstFieldFlavorName:                               "Flavor Name",
	ClusterInstFieldState:                                    "State",
	ClusterInstFieldErrors:                                   "Errors",
	ClusterInstFieldCrmOverride:                              "Crm Override",
	ClusterInstFieldIpAccess:                                 "Ip Access",
	ClusterInstFieldAllocatedIp:                              "Allocated Ip",
	ClusterInstFieldLiveness:                                 "Liveness",
	ClusterInstFieldAuto:                                     "Auto",
	ClusterInstFieldNodeFlavor:                               "Node Flavor",
	ClusterInstFieldNumMasters:                               "Num Masters",
	ClusterInstFieldNumNodes:                                 "Num Nodes",
	ClusterInstFieldDeployment:                               "Deployment",
	ClusterInstFieldExternalVolumeSize:                       "External Volume Size",
	ClusterInstFieldAutoScalePolicy:                          "Auto Scale Policy",
	ClusterInstFieldAvailabilityZone:                         "Availability Zone",
	ClusterInstFieldImageName:                                "Image Name",
	ClusterInstFieldReservable:                               "Reservable",
	ClusterInstFieldReservedBy:                               "Reserved By",
	ClusterInstFieldSharedVolumeSize:                         "Shared Volume Size",
	ClusterInstFieldMasterNodeFlavor:                         "Master Node Flavor",
	ClusterInstFieldSkipCrmCleanupOnFailure:                  "Skip Crm Cleanup On Failure",
	ClusterInstFieldOptRes:                                   "Opt Res",
	ClusterInstFieldResourcesVmsName:                         "Resources Vms Name",
	ClusterInstFieldResourcesVmsType:                         "Resources Vms Type",
	ClusterInstFieldResourcesVmsStatus:                       "Resources Vms Status",
	ClusterInstFieldResourcesVmsInfraFlavor:                  "Resources Vms Infra Flavor",
	ClusterInstFieldResourcesVmsIpaddressesExternalIp:        "Resources Vms Ipaddresses External Ip",
	ClusterInstFieldResourcesVmsIpaddressesInternalIp:        "Resources Vms Ipaddresses Internal Ip",
	ClusterInstFieldResourcesVmsContainersName:               "Resources Vms Containers Name",
	ClusterInstFieldResourcesVmsContainersType:               "Resources Vms Containers Type",
	ClusterInstFieldResourcesVmsContainersStatus:             "Resources Vms Containers Status",
	ClusterInstFieldResourcesVmsContainersClusterip:          "Resources Vms Containers Clusterip",
	ClusterInstFieldResourcesVmsContainersRestarts:           "Resources Vms Containers Restarts",
	ClusterInstFieldCreatedAtSeconds:                         "Created At Seconds",
	ClusterInstFieldCreatedAtNanos:                           "Created At Nanos",
	ClusterInstFieldUpdatedAtSeconds:                         "Updated At Seconds",
	ClusterInstFieldUpdatedAtNanos:                           "Updated At Nanos",
	ClusterInstFieldReservationEndedAtSeconds:                "Reservation Ended At Seconds",
	ClusterInstFieldReservationEndedAtNanos:                  "Reservation Ended At Nanos",
	ClusterInstFieldMultiTenant:                              "Multi Tenant",
	ClusterInstFieldNetworks:                                 "Networks",
	ClusterInstFieldDeletePrepare:                            "Delete Prepare",
	ClusterInstFieldDnsLabel:                                 "Dns Label",
	ClusterInstFieldFqdn:                                     "Fqdn",
	ClusterInstFieldEnableIpv6:                               "Enable Ipv6",
	ClusterInstFieldObjId:                                    "Obj Id",
	ClusterInstFieldStaticFqdn:                               "Static Fqdn",
	ClusterInstFieldCompatibilityVersion:                     "Compatibility Version",
	ClusterInstFieldCloudletKeyOrganization:                  "Cloudlet Key Organization",
	ClusterInstFieldCloudletKeyName:                          "Cloudlet Key Name",
	ClusterInstFieldCloudletKeyFederatedOrganization:         "Cloudlet Key Federated Organization",
	ClusterInstFieldAnnotationsKey:                           "Annotations Key",
	ClusterInstFieldAnnotationsValue:                         "Annotations Value",
	ClusterInstFieldZoneKeyOrganization:                      "Zone Key Organization",
	ClusterInstFieldZoneKeyName:                              "Zone Key Name",
	ClusterInstFieldZoneKeyFederatedOrganization:             "Zone Key Federated Organization",
	ClusterInstFieldDbModelId:                                "Db Model Id",
	ClusterInstFieldNodeResourcesVcpus:                       "Node Resources Vcpus",
	ClusterInstFieldNodeResourcesRam:                         "Node Resources Ram",
	ClusterInstFieldNodeResourcesDisk:                        "Node Resources Disk",
	ClusterInstFieldNodeResourcesOptResMapKey:                "Node Resources Opt Res Map Key",
	ClusterInstFieldNodeResourcesOptResMapValue:              "Node Resources Opt Res Map Value",
	ClusterInstFieldNodeResourcesInfraNodeFlavor:             "Node Resources Infra Node Flavor",
	ClusterInstFieldNodeResourcesExternalVolumeSize:          "Node Resources External Volume Size",
	ClusterInstFieldNodePoolsName:                            "Node Pools Name",
	ClusterInstFieldNodePoolsNumNodes:                        "Node Pools Num Nodes",
	ClusterInstFieldNodePoolsNodeResourcesVcpus:              "Node Pools Node Resources Vcpus",
	ClusterInstFieldNodePoolsNodeResourcesRam:                "Node Pools Node Resources Ram",
	ClusterInstFieldNodePoolsNodeResourcesDisk:               "Node Pools Node Resources Disk",
	ClusterInstFieldNodePoolsNodeResourcesOptResMapKey:       "Node Pools Node Resources Opt Res Map Key",
	ClusterInstFieldNodePoolsNodeResourcesOptResMapValue:     "Node Pools Node Resources Opt Res Map Value",
	ClusterInstFieldNodePoolsNodeResourcesInfraNodeFlavor:    "Node Pools Node Resources Infra Node Flavor",
	ClusterInstFieldNodePoolsNodeResourcesExternalVolumeSize: "Node Pools Node Resources External Volume Size",
	ClusterInstFieldNodePoolsScalable:                        "Node Pools Scalable",
	ClusterInstFieldInfraAnnotationsKey:                      "Infra Annotations Key",
	ClusterInstFieldInfraAnnotationsValue:                    "Infra Annotations Value",
	ClusterInstFieldKubernetesVersion:                        "Kubernetes Version",
}

func (m *ClusterInst) IsKeyField(s string) bool {
	return strings.HasPrefix(s, ClusterInstFieldKey+".") || s == ClusterInstFieldKey
}

func (m *ClusterInst) DiffFields(o *ClusterInst, fields *FieldMap) {
	if m.Key.Name != o.Key.Name {
		fields.Set(ClusterInstFieldKeyName)
		fields.Set(ClusterInstFieldKey)
	}
	if m.Key.Organization != o.Key.Organization {
		fields.Set(ClusterInstFieldKeyOrganization)
		fields.Set(ClusterInstFieldKey)
	}
	if m.Flavor.Name != o.Flavor.Name {
		fields.Set(ClusterInstFieldFlavorName)
		fields.Set(ClusterInstFieldFlavor)
	}
	if m.State != o.State {
		fields.Set(ClusterInstFieldState)
	}
	if len(m.Errors) != len(o.Errors) {
		fields.Set(ClusterInstFieldErrors)
	} else {
		for i0 := 0; i0 < len(m.Errors); i0++ {
			if m.Errors[i0] != o.Errors[i0] {
				fields.Set(ClusterInstFieldErrors)
				break
			}
		}
	}
	if m.CrmOverride != o.CrmOverride {
		fields.Set(ClusterInstFieldCrmOverride)
	}
	if m.IpAccess != o.IpAccess {
		fields.Set(ClusterInstFieldIpAccess)
	}
	if m.AllocatedIp != o.AllocatedIp {
		fields.Set(ClusterInstFieldAllocatedIp)
	}
	if m.Liveness != o.Liveness {
		fields.Set(ClusterInstFieldLiveness)
	}
	if m.Auto != o.Auto {
		fields.Set(ClusterInstFieldAuto)
	}
	if m.NodeFlavor != o.NodeFlavor {
		fields.Set(ClusterInstFieldNodeFlavor)
	}
	if m.NumMasters != o.NumMasters {
		fields.Set(ClusterInstFieldNumMasters)
	}
	if m.NumNodes != o.NumNodes {
		fields.Set(ClusterInstFieldNumNodes)
	}
	if m.Deployment != o.Deployment {
		fields.Set(ClusterInstFieldDeployment)
	}
	if m.ExternalVolumeSize != o.ExternalVolumeSize {
		fields.Set(ClusterInstFieldExternalVolumeSize)
	}
	if m.AutoScalePolicy != o.AutoScalePolicy {
		fields.Set(ClusterInstFieldAutoScalePolicy)
	}
	if m.AvailabilityZone != o.AvailabilityZone {
		fields.Set(ClusterInstFieldAvailabilityZone)
	}
	if m.ImageName != o.ImageName {
		fields.Set(ClusterInstFieldImageName)
	}
	if m.Reservable != o.Reservable {
		fields.Set(ClusterInstFieldReservable)
	}
	if m.ReservedBy != o.ReservedBy {
		fields.Set(ClusterInstFieldReservedBy)
	}
	if m.SharedVolumeSize != o.SharedVolumeSize {
		fields.Set(ClusterInstFieldSharedVolumeSize)
	}
	if m.MasterNodeFlavor != o.MasterNodeFlavor {
		fields.Set(ClusterInstFieldMasterNodeFlavor)
	}
	if m.SkipCrmCleanupOnFailure != o.SkipCrmCleanupOnFailure {
		fields.Set(ClusterInstFieldSkipCrmCleanupOnFailure)
	}
	if m.OptRes != o.OptRes {
		fields.Set(ClusterInstFieldOptRes)
	}
	if len(m.Resources.Vms) != len(o.Resources.Vms) {
		fields.Set(ClusterInstFieldResourcesVms)
		fields.Set(ClusterInstFieldResources)
	} else {
		for i1 := 0; i1 < len(m.Resources.Vms); i1++ {
			if m.Resources.Vms[i1].Name != o.Resources.Vms[i1].Name {
				fields.Set(ClusterInstFieldResourcesVmsName)
				fields.Set(ClusterInstFieldResourcesVms)
				fields.Set(ClusterInstFieldResources)
			}
			if m.Resources.Vms[i1].Type != o.Resources.Vms[i1].Type {
				fields.Set(ClusterInstFieldResourcesVmsType)
				fields.Set(ClusterInstFieldResourcesVms)
				fields.Set(ClusterInstFieldResources)
			}
			if m.Resources.Vms[i1].Status != o.Resources.Vms[i1].Status {
				fields.Set(ClusterInstFieldResourcesVmsStatus)
				fields.Set(ClusterInstFieldResourcesVms)
				fields.Set(ClusterInstFieldResources)
			}
			if m.Resources.Vms[i1].InfraFlavor != o.Resources.Vms[i1].InfraFlavor {
				fields.Set(ClusterInstFieldResourcesVmsInfraFlavor)
				fields.Set(ClusterInstFieldResourcesVms)
				fields.Set(ClusterInstFieldResources)
			}
			if len(m.Resources.Vms[i1].Ipaddresses) != len(o.Resources.Vms[i1].Ipaddresses) {
				fields.Set(ClusterInstFieldResourcesVmsIpaddresses)
				fields.Set(ClusterInstFieldResourcesVms)
				fields.Set(ClusterInstFieldResources)
			} else {
				for i2 := 0; i2 < len(m.Resources.Vms[i1].Ipaddresses); i2++ {
					if m.Resources.Vms[i1].Ipaddresses[i2].ExternalIp != o.Resources.Vms[i1].Ipaddresses[i2].ExternalIp {
						fields.Set(ClusterInstFieldResourcesVmsIpaddressesExternalIp)
						fields.Set(ClusterInstFieldResourcesVmsIpaddresses)
						fields.Set(ClusterInstFieldResourcesVms)
						fields.Set(ClusterInstFieldResources)
					}
					if m.Resources.Vms[i1].Ipaddresses[i2].InternalIp != o.Resources.Vms[i1].Ipaddresses[i2].InternalIp {
						fields.Set(ClusterInstFieldResourcesVmsIpaddressesInternalIp)
						fields.Set(ClusterInstFieldResourcesVmsIpaddresses)
						fields.Set(ClusterInstFieldResourcesVms)
						fields.Set(ClusterInstFieldResources)
					}
				}
			}
			if m.Resources.Vms[i1].Containers != nil && o.Resources.Vms[i1].Containers != nil {
				if len(m.Resources.Vms[i1].Containers) != len(o.Resources.Vms[i1].Containers) {
					fields.Set(ClusterInstFieldResourcesVmsContainers)
					fields.Set(ClusterInstFieldResourcesVms)
					fields.Set(ClusterInstFieldResources)
				} else {
					for i2 := 0; i2 < len(m.Resources.Vms[i1].Containers); i2++ {
						if m.Resources.Vms[i1].Containers[i2].Name != o.Resources.Vms[i1].Containers[i2].Name {
							fields.Set(ClusterInstFieldResourcesVmsContainersName)
							fields.Set(ClusterInstFieldResourcesVmsContainers)
							fields.Set(ClusterInstFieldResourcesVms)
							fields.Set(ClusterInstFieldResources)
						}
						if m.Resources.Vms[i1].Containers[i2].Type != o.Resources.Vms[i1].Containers[i2].Type {
							fields.Set(ClusterInstFieldResourcesVmsContainersType)
							fields.Set(ClusterInstFieldResourcesVmsContainers)
							fields.Set(ClusterInstFieldResourcesVms)
							fields.Set(ClusterInstFieldResources)
						}
						if m.Resources.Vms[i1].Containers[i2].Status != o.Resources.Vms[i1].Containers[i2].Status {
							fields.Set(ClusterInstFieldResourcesVmsContainersStatus)
							fields.Set(ClusterInstFieldResourcesVmsContainers)
							fields.Set(ClusterInstFieldResourcesVms)
							fields.Set(ClusterInstFieldResources)
						}
						if m.Resources.Vms[i1].Containers[i2].Clusterip != o.Resources.Vms[i1].Containers[i2].Clusterip {
							fields.Set(ClusterInstFieldResourcesVmsContainersClusterip)
							fields.Set(ClusterInstFieldResourcesVmsContainers)
							fields.Set(ClusterInstFieldResourcesVms)
							fields.Set(ClusterInstFieldResources)
						}
						if m.Resources.Vms[i1].Containers[i2].Restarts != o.Resources.Vms[i1].Containers[i2].Restarts {
							fields.Set(ClusterInstFieldResourcesVmsContainersRestarts)
							fields.Set(ClusterInstFieldResourcesVmsContainers)
							fields.Set(ClusterInstFieldResourcesVms)
							fields.Set(ClusterInstFieldResources)
						}
					}
				}
			} else if (m.Resources.Vms[i1].Containers != nil && o.Resources.Vms[i1].Containers == nil) || (m.Resources.Vms[i1].Containers == nil && o.Resources.Vms[i1].Containers != nil) {
				fields.Set(ClusterInstFieldResourcesVmsContainers)
				fields.Set(ClusterInstFieldResourcesVms)
				fields.Set(ClusterInstFieldResources)
			}
		}
	}
	if m.CreatedAt.Seconds != o.CreatedAt.Seconds {
		fields.Set(ClusterInstFieldCreatedAtSeconds)
		fields.Set(ClusterInstFieldCreatedAt)
	}
	if m.CreatedAt.Nanos != o.CreatedAt.Nanos {
		fields.Set(ClusterInstFieldCreatedAtNanos)
		fields.Set(ClusterInstFieldCreatedAt)
	}
	if m.UpdatedAt.Seconds != o.UpdatedAt.Seconds {
		fields.Set(ClusterInstFieldUpdatedAtSeconds)
		fields.Set(ClusterInstFieldUpdatedAt)
	}
	if m.UpdatedAt.Nanos != o.UpdatedAt.Nanos {
		fields.Set(ClusterInstFieldUpdatedAtNanos)
		fields.Set(ClusterInstFieldUpdatedAt)
	}
	if m.ReservationEndedAt.Seconds != o.ReservationEndedAt.Seconds {
		fields.Set(ClusterInstFieldReservationEndedAtSeconds)
		fields.Set(ClusterInstFieldReservationEndedAt)
	}
	if m.ReservationEndedAt.Nanos != o.ReservationEndedAt.Nanos {
		fields.Set(ClusterInstFieldReservationEndedAtNanos)
		fields.Set(ClusterInstFieldReservationEndedAt)
	}
	if m.MultiTenant != o.MultiTenant {
		fields.Set(ClusterInstFieldMultiTenant)
	}
	if len(m.Networks) != len(o.Networks) {
		fields.Set(ClusterInstFieldNetworks)
	} else {
		for i0 := 0; i0 < len(m.Networks); i0++ {
			if m.Networks[i0] != o.Networks[i0] {
				fields.Set(ClusterInstFieldNetworks)
				break
			}
		}
	}
	if m.DeletePrepare != o.DeletePrepare {
		fields.Set(ClusterInstFieldDeletePrepare)
	}
	if m.DnsLabel != o.DnsLabel {
		fields.Set(ClusterInstFieldDnsLabel)
	}
	if m.Fqdn != o.Fqdn {
		fields.Set(ClusterInstFieldFqdn)
	}
	if m.EnableIpv6 != o.EnableIpv6 {
		fields.Set(ClusterInstFieldEnableIpv6)
	}
	if m.ObjId != o.ObjId {
		fields.Set(ClusterInstFieldObjId)
	}
	if m.StaticFqdn != o.StaticFqdn {
		fields.Set(ClusterInstFieldStaticFqdn)
	}
	if m.CompatibilityVersion != o.CompatibilityVersion {
		fields.Set(ClusterInstFieldCompatibilityVersion)
	}
	if m.CloudletKey.Organization != o.CloudletKey.Organization {
		fields.Set(ClusterInstFieldCloudletKeyOrganization)
		fields.Set(ClusterInstFieldCloudletKey)
	}
	if m.CloudletKey.Name != o.CloudletKey.Name {
		fields.Set(ClusterInstFieldCloudletKeyName)
		fields.Set(ClusterInstFieldCloudletKey)
	}
	if m.CloudletKey.FederatedOrganization != o.CloudletKey.FederatedOrganization {
		fields.Set(ClusterInstFieldCloudletKeyFederatedOrganization)
		fields.Set(ClusterInstFieldCloudletKey)
	}
	if m.Annotations != nil && o.Annotations != nil {
		if len(m.Annotations) != len(o.Annotations) {
			fields.Set(ClusterInstFieldAnnotations)
		} else {
			for k0, _ := range m.Annotations {
				_, vok0 := o.Annotations[k0]
				if !vok0 {
					fields.Set(ClusterInstFieldAnnotations)
				} else {
					if m.Annotations[k0] != o.Annotations[k0] {
						fields.Set(ClusterInstFieldAnnotations)
						break
					}
				}
			}
		}
	} else if (m.Annotations != nil && o.Annotations == nil) || (m.Annotations == nil && o.Annotations != nil) {
		fields.Set(ClusterInstFieldAnnotations)
	}
	if m.ZoneKey.Organization != o.ZoneKey.Organization {
		fields.Set(ClusterInstFieldZoneKeyOrganization)
		fields.Set(ClusterInstFieldZoneKey)
	}
	if m.ZoneKey.Name != o.ZoneKey.Name {
		fields.Set(ClusterInstFieldZoneKeyName)
		fields.Set(ClusterInstFieldZoneKey)
	}
	if m.ZoneKey.FederatedOrganization != o.ZoneKey.FederatedOrganization {
		fields.Set(ClusterInstFieldZoneKeyFederatedOrganization)
		fields.Set(ClusterInstFieldZoneKey)
	}
	if m.DbModelId != o.DbModelId {
		fields.Set(ClusterInstFieldDbModelId)
	}
	if m.NodeResources != nil && o.NodeResources != nil {
		if m.NodeResources.Vcpus != o.NodeResources.Vcpus {
			fields.Set(ClusterInstFieldNodeResourcesVcpus)
			fields.Set(ClusterInstFieldNodeResources)
		}
		if m.NodeResources.Ram != o.NodeResources.Ram {
			fields.Set(ClusterInstFieldNodeResourcesRam)
			fields.Set(ClusterInstFieldNodeResources)
		}
		if m.NodeResources.Disk != o.NodeResources.Disk {
			fields.Set(ClusterInstFieldNodeResourcesDisk)
			fields.Set(ClusterInstFieldNodeResources)
		}
		if m.NodeResources.OptResMap != nil && o.NodeResources.OptResMap != nil {
			if len(m.NodeResources.OptResMap) != len(o.NodeResources.OptResMap) {
				fields.Set(ClusterInstFieldNodeResourcesOptResMap)
				fields.Set(ClusterInstFieldNodeResources)
			} else {
				for k1, _ := range m.NodeResources.OptResMap {
					_, vok1 := o.NodeResources.OptResMap[k1]
					if !vok1 {
						fields.Set(ClusterInstFieldNodeResourcesOptResMap)
						fields.Set(ClusterInstFieldNodeResources)
					} else {
						if m.NodeResources.OptResMap[k1] != o.NodeResources.OptResMap[k1] {
							fields.Set(ClusterInstFieldNodeResourcesOptResMap)
							fields.Set(ClusterInstFieldNodeResources)
							break
						}
					}
				}
			}
		} else if (m.NodeResources.OptResMap != nil && o.NodeResources.OptResMap == nil) || (m.NodeResources.OptResMap == nil && o.NodeResources.OptResMap != nil) {
			fields.Set(ClusterInstFieldNodeResourcesOptResMap)
			fields.Set(ClusterInstFieldNodeResources)
		}
		if m.NodeResources.InfraNodeFlavor != o.NodeResources.InfraNodeFlavor {
			fields.Set(ClusterInstFieldNodeResourcesInfraNodeFlavor)
			fields.Set(ClusterInstFieldNodeResources)
		}
		if m.NodeResources.ExternalVolumeSize != o.NodeResources.ExternalVolumeSize {
			fields.Set(ClusterInstFieldNodeResourcesExternalVolumeSize)
			fields.Set(ClusterInstFieldNodeResources)
		}
	} else if (m.NodeResources != nil && o.NodeResources == nil) || (m.NodeResources == nil && o.NodeResources != nil) {
		fields.Set(ClusterInstFieldNodeResources)
	}
	if m.NodePools != nil && o.NodePools != nil {
		if len(m.NodePools) != len(o.NodePools) {
			fields.Set(ClusterInstFieldNodePools)
		} else {
			for i0 := 0; i0 < len(m.NodePools); i0++ {
				if m.NodePools[i0].Name != o.NodePools[i0].Name {
					fields.Set(ClusterInstFieldNodePoolsName)
					fields.Set(ClusterInstFieldNodePools)
				}
				if m.NodePools[i0].NumNodes != o.NodePools[i0].NumNodes {
					fields.Set(ClusterInstFieldNodePoolsNumNodes)
					fields.Set(ClusterInstFieldNodePools)
				}
				if m.NodePools[i0].NodeResources != nil && o.NodePools[i0].NodeResources != nil {
					if m.NodePools[i0].NodeResources.Vcpus != o.NodePools[i0].NodeResources.Vcpus {
						fields.Set(ClusterInstFieldNodePoolsNodeResourcesVcpus)
						fields.Set(ClusterInstFieldNodePoolsNodeResources)
						fields.Set(ClusterInstFieldNodePools)
					}
					if m.NodePools[i0].NodeResources.Ram != o.NodePools[i0].NodeResources.Ram {
						fields.Set(ClusterInstFieldNodePoolsNodeResourcesRam)
						fields.Set(ClusterInstFieldNodePoolsNodeResources)
						fields.Set(ClusterInstFieldNodePools)
					}
					if m.NodePools[i0].NodeResources.Disk != o.NodePools[i0].NodeResources.Disk {
						fields.Set(ClusterInstFieldNodePoolsNodeResourcesDisk)
						fields.Set(ClusterInstFieldNodePoolsNodeResources)
						fields.Set(ClusterInstFieldNodePools)
					}
					if m.NodePools[i0].NodeResources.OptResMap != nil && o.NodePools[i0].NodeResources.OptResMap != nil {
						if len(m.NodePools[i0].NodeResources.OptResMap) != len(o.NodePools[i0].NodeResources.OptResMap) {
							fields.Set(ClusterInstFieldNodePoolsNodeResourcesOptResMap)
							fields.Set(ClusterInstFieldNodePoolsNodeResources)
							fields.Set(ClusterInstFieldNodePools)
						} else {
							for k2, _ := range m.NodePools[i0].NodeResources.OptResMap {
								_, vok2 := o.NodePools[i0].NodeResources.OptResMap[k2]
								if !vok2 {
									fields.Set(ClusterInstFieldNodePoolsNodeResourcesOptResMap)
									fields.Set(ClusterInstFieldNodePoolsNodeResources)
									fields.Set(ClusterInstFieldNodePools)
								} else {
									if m.NodePools[i0].NodeResources.OptResMap[k2] != o.NodePools[i0].NodeResources.OptResMap[k2] {
										fields.Set(ClusterInstFieldNodePoolsNodeResourcesOptResMap)
										fields.Set(ClusterInstFieldNodePoolsNodeResources)
										fields.Set(ClusterInstFieldNodePools)
										break
									}
								}
							}
						}
					} else if (m.NodePools[i0].NodeResources.OptResMap != nil && o.NodePools[i0].NodeResources.OptResMap == nil) || (m.NodePools[i0].NodeResources.OptResMap == nil && o.NodePools[i0].NodeResources.OptResMap != nil) {
						fields.Set(ClusterInstFieldNodePoolsNodeResourcesOptResMap)
						fields.Set(ClusterInstFieldNodePoolsNodeResources)
						fields.Set(ClusterInstFieldNodePools)
					}
					if m.NodePools[i0].NodeResources.InfraNodeFlavor != o.NodePools[i0].NodeResources.InfraNodeFlavor {
						fields.Set(ClusterInstFieldNodePoolsNodeResourcesInfraNodeFlavor)
						fields.Set(ClusterInstFieldNodePoolsNodeResources)
						fields.Set(ClusterInstFieldNodePools)
					}
					if m.NodePools[i0].NodeResources.ExternalVolumeSize != o.NodePools[i0].NodeResources.ExternalVolumeSize {
						fields.Set(ClusterInstFieldNodePoolsNodeResourcesExternalVolumeSize)
						fields.Set(ClusterInstFieldNodePoolsNodeResources)
						fields.Set(ClusterInstFieldNodePools)
					}
				} else if (m.NodePools[i0].NodeResources != nil && o.NodePools[i0].NodeResources == nil) || (m.NodePools[i0].NodeResources == nil && o.NodePools[i0].NodeResources != nil) {
					fields.Set(ClusterInstFieldNodePoolsNodeResources)
					fields.Set(ClusterInstFieldNodePools)
				}
				if m.NodePools[i0].Scalable != o.NodePools[i0].Scalable {
					fields.Set(ClusterInstFieldNodePoolsScalable)
					fields.Set(ClusterInstFieldNodePools)
				}
			}
		}
	} else if (m.NodePools != nil && o.NodePools == nil) || (m.NodePools == nil && o.NodePools != nil) {
		fields.Set(ClusterInstFieldNodePools)
	}
	if m.InfraAnnotations != nil && o.InfraAnnotations != nil {
		if len(m.InfraAnnotations) != len(o.InfraAnnotations) {
			fields.Set(ClusterInstFieldInfraAnnotations)
		} else {
			for k0, _ := range m.InfraAnnotations {
				_, vok0 := o.InfraAnnotations[k0]
				if !vok0 {
					fields.Set(ClusterInstFieldInfraAnnotations)
				} else {
					if m.InfraAnnotations[k0] != o.InfraAnnotations[k0] {
						fields.Set(ClusterInstFieldInfraAnnotations)
						break
					}
				}
			}
		}
	} else if (m.InfraAnnotations != nil && o.InfraAnnotations == nil) || (m.InfraAnnotations == nil && o.InfraAnnotations != nil) {
		fields.Set(ClusterInstFieldInfraAnnotations)
	}
	if m.KubernetesVersion != o.KubernetesVersion {
		fields.Set(ClusterInstFieldKubernetesVersion)
	}
}

func (m *ClusterInst) GetDiffFields(o *ClusterInst) *FieldMap {
	diffFields := NewFieldMap(nil)
	m.DiffFields(o, diffFields)
	return diffFields
}

var UpdateClusterInstFieldsMap = NewFieldMap(map[string]struct{}{
	ClusterInstFieldCrmOverride:                              struct{}{},
	ClusterInstFieldNumNodes:                                 struct{}{},
	ClusterInstFieldAutoScalePolicy:                          struct{}{},
	ClusterInstFieldSkipCrmCleanupOnFailure:                  struct{}{},
	ClusterInstFieldEnableIpv6:                               struct{}{},
	ClusterInstFieldObjId:                                    struct{}{},
	ClusterInstFieldAnnotations:                              struct{}{},
	ClusterInstFieldAnnotationsKey:                           struct{}{},
	ClusterInstFieldAnnotationsValue:                         struct{}{},
	ClusterInstFieldZoneKey:                                  struct{}{},
	ClusterInstFieldZoneKeyOrganization:                      struct{}{},
	ClusterInstFieldZoneKeyName:                              struct{}{},
	ClusterInstFieldZoneKeyFederatedOrganization:             struct{}{},
	ClusterInstFieldDbModelId:                                struct{}{},
	ClusterInstFieldNodePools:                                struct{}{},
	ClusterInstFieldNodePoolsName:                            struct{}{},
	ClusterInstFieldNodePoolsNumNodes:                        struct{}{},
	ClusterInstFieldNodePoolsNodeResources:                   struct{}{},
	ClusterInstFieldNodePoolsNodeResourcesVcpus:              struct{}{},
	ClusterInstFieldNodePoolsNodeResourcesRam:                struct{}{},
	ClusterInstFieldNodePoolsNodeResourcesDisk:               struct{}{},
	ClusterInstFieldNodePoolsNodeResourcesOptResMap:          struct{}{},
	ClusterInstFieldNodePoolsNodeResourcesOptResMapKey:       struct{}{},
	ClusterInstFieldNodePoolsNodeResourcesOptResMapValue:     struct{}{},
	ClusterInstFieldNodePoolsNodeResourcesInfraNodeFlavor:    struct{}{},
	ClusterInstFieldNodePoolsNodeResourcesExternalVolumeSize: struct{}{},
	ClusterInstFieldNodePoolsScalable:                        struct{}{},
	ClusterInstFieldInfraAnnotations:                         struct{}{},
	ClusterInstFieldInfraAnnotationsKey:                      struct{}{},
	ClusterInstFieldInfraAnnotationsValue:                    struct{}{},
})

func (m *ClusterInst) ValidateUpdateFields() error {
	if m.Fields == nil {
		return fmt.Errorf("nothing specified to update")
	}
	fmap := MakeFieldMap(m.Fields)
	badFieldStrs := []string{}
	for _, field := range fmap.Fields() {
		if m.IsKeyField(field) {
			continue
		}
		if !UpdateClusterInstFieldsMap.Has(field) {
			if _, ok := ClusterInstAllFieldsStringMap[field]; !ok {
				continue
			}
			badFieldStrs = append(badFieldStrs, ClusterInstAllFieldsStringMap[field])
		}
	}
	if len(badFieldStrs) > 0 {
		return fmt.Errorf("specified field(s) %s cannot be modified", strings.Join(badFieldStrs, ","))
	}
	return nil
}

func (m *ClusterInst) Clone() *ClusterInst {
	cp := &ClusterInst{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *ClusterInst) AddErrors(vals ...string) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.Errors {
		cur[v] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v]; found {
			continue // duplicate
		}
		m.Errors = append(m.Errors, v)
		changes++
	}
	return changes
}

func (m *ClusterInst) RemoveErrors(vals ...string) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v] = struct{}{}
	}
	for i := len(m.Errors); i >= 0; i-- {
		if _, found := remove[m.Errors[i]]; found {
			m.Errors = append(m.Errors[:i], m.Errors[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *ClusterInst) AddResourcesVms(vals ...VmInfo) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.Resources.Vms {
		cur[v.String()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.String()]; found {
			continue // duplicate
		}
		m.Resources.Vms = append(m.Resources.Vms, v)
		changes++
	}
	return changes
}

func (m *ClusterInst) RemoveResourcesVms(vals ...VmInfo) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.String()] = struct{}{}
	}
	for i := len(m.Resources.Vms); i >= 0; i-- {
		if _, found := remove[m.Resources.Vms[i].String()]; found {
			m.Resources.Vms = append(m.Resources.Vms[:i], m.Resources.Vms[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *ClusterInst) AddNetworks(vals ...string) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.Networks {
		cur[v] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v]; found {
			continue // duplicate
		}
		m.Networks = append(m.Networks, v)
		changes++
	}
	return changes
}

func (m *ClusterInst) RemoveNetworks(vals ...string) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v] = struct{}{}
	}
	for i := len(m.Networks); i >= 0; i-- {
		if _, found := remove[m.Networks[i]]; found {
			m.Networks = append(m.Networks[:i], m.Networks[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *ClusterInst) AddNodePools(vals ...*NodePool) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.NodePools {
		cur[v.String()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.String()]; found {
			continue // duplicate
		}
		m.NodePools = append(m.NodePools, v)
		changes++
	}
	return changes
}

func (m *ClusterInst) RemoveNodePools(vals ...*NodePool) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.String()] = struct{}{}
	}
	for i := len(m.NodePools); i >= 0; i-- {
		if _, found := remove[m.NodePools[i].String()]; found {
			m.NodePools = append(m.NodePools[:i], m.NodePools[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *ClusterInst) CopyInFields(src *ClusterInst) int {
	updateListAction := "replace"
	changed := 0
	fmap := MakeFieldMap(src.Fields)
	if fmap.HasOrHasChild("2") {
		if fmap.Has("2.1") {
			if m.Key.Name != src.Key.Name {
				m.Key.Name = src.Key.Name
				changed++
			}
		}
		if fmap.Has("2.2") {
			if m.Key.Organization != src.Key.Organization {
				m.Key.Organization = src.Key.Organization
				changed++
			}
		}
	}
	if fmap.HasOrHasChild("3") {
		if fmap.Has("3.1") {
			if m.Flavor.Name != src.Flavor.Name {
				m.Flavor.Name = src.Flavor.Name
				changed++
			}
		}
	}
	if fmap.Has("4") {
		if m.State != src.State {
			m.State = src.State
			changed++
		}
	}
	if fmap.Has("5") {
		if src.Errors != nil {
			if updateListAction == "add" {
				changed += m.AddErrors(src.Errors...)
			} else if updateListAction == "remove" {
				changed += m.RemoveErrors(src.Errors...)
			} else {
				m.Errors = make([]string, 0)
				m.Errors = append(m.Errors, src.Errors...)
				changed++
			}
		} else if m.Errors != nil {
			m.Errors = nil
			changed++
		}
	}
	if fmap.Has("6") {
		if m.CrmOverride != src.CrmOverride {
			m.CrmOverride = src.CrmOverride
			changed++
		}
	}
	if fmap.Has("7") {
		if m.IpAccess != src.IpAccess {
			m.IpAccess = src.IpAccess
			changed++
		}
	}
	if fmap.Has("8") {
		if m.AllocatedIp != src.AllocatedIp {
			m.AllocatedIp = src.AllocatedIp
			changed++
		}
	}
	if fmap.Has("9") {
		if m.Liveness != src.Liveness {
			m.Liveness = src.Liveness
			changed++
		}
	}
	if fmap.Has("10") {
		if m.Auto != src.Auto {
			m.Auto = src.Auto
			changed++
		}
	}
	if fmap.Has("11") {
		if m.NodeFlavor != src.NodeFlavor {
			m.NodeFlavor = src.NodeFlavor
			changed++
		}
	}
	if fmap.Has("13") {
		if m.NumMasters != src.NumMasters {
			m.NumMasters = src.NumMasters
			changed++
		}
	}
	if fmap.Has("14") {
		if m.NumNodes != src.NumNodes {
			m.NumNodes = src.NumNodes
			changed++
		}
	}
	if fmap.Has("15") {
		if m.Deployment != src.Deployment {
			m.Deployment = src.Deployment
			changed++
		}
	}
	if fmap.Has("17") {
		if m.ExternalVolumeSize != src.ExternalVolumeSize {
			m.ExternalVolumeSize = src.ExternalVolumeSize
			changed++
		}
	}
	if fmap.Has("18") {
		if m.AutoScalePolicy != src.AutoScalePolicy {
			m.AutoScalePolicy = src.AutoScalePolicy
			changed++
		}
	}
	if fmap.Has("19") {
		if m.AvailabilityZone != src.AvailabilityZone {
			m.AvailabilityZone = src.AvailabilityZone
			changed++
		}
	}
	if fmap.Has("20") {
		if m.ImageName != src.ImageName {
			m.ImageName = src.ImageName
			changed++
		}
	}
	if fmap.Has("21") {
		if m.Reservable != src.Reservable {
			m.Reservable = src.Reservable
			changed++
		}
	}
	if fmap.Has("22") {
		if m.ReservedBy != src.ReservedBy {
			m.ReservedBy = src.ReservedBy
			changed++
		}
	}
	if fmap.Has("23") {
		if m.SharedVolumeSize != src.SharedVolumeSize {
			m.SharedVolumeSize = src.SharedVolumeSize
			changed++
		}
	}
	if fmap.Has("25") {
		if m.MasterNodeFlavor != src.MasterNodeFlavor {
			m.MasterNodeFlavor = src.MasterNodeFlavor
			changed++
		}
	}
	if fmap.Has("26") {
		if m.SkipCrmCleanupOnFailure != src.SkipCrmCleanupOnFailure {
			m.SkipCrmCleanupOnFailure = src.SkipCrmCleanupOnFailure
			changed++
		}
	}
	if fmap.Has("27") {
		if m.OptRes != src.OptRes {
			m.OptRes = src.OptRes
			changed++
		}
	}
	if fmap.HasOrHasChild("28") {
		if fmap.HasOrHasChild("28.1") {
			if src.Resources.Vms != nil {
				if updateListAction == "add" {
					changed += m.AddResourcesVms(src.Resources.Vms...)
				} else if updateListAction == "remove" {
					changed += m.RemoveResourcesVms(src.Resources.Vms...)
				} else {
					m.Resources.Vms = make([]VmInfo, 0)
					for k1, _ := range src.Resources.Vms {
						m.Resources.Vms = append(m.Resources.Vms, *src.Resources.Vms[k1].Clone())
					}
					changed++
				}
			} else if m.Resources.Vms != nil {
				m.Resources.Vms = nil
				changed++
			}
		}
	}
	if fmap.HasOrHasChild("29") {
		if fmap.Has("29.1") {
			if m.CreatedAt.Seconds != src.CreatedAt.Seconds {
				m.CreatedAt.Seconds = src.CreatedAt.Seconds
				changed++
			}
		}
		if fmap.Has("29.2") {
			if m.CreatedAt.Nanos != src.CreatedAt.Nanos {
				m.CreatedAt.Nanos = src.CreatedAt.Nanos
				changed++
			}
		}
	}
	if fmap.HasOrHasChild("30") {
		if fmap.Has("30.1") {
			if m.UpdatedAt.Seconds != src.UpdatedAt.Seconds {
				m.UpdatedAt.Seconds = src.UpdatedAt.Seconds
				changed++
			}
		}
		if fmap.Has("30.2") {
			if m.UpdatedAt.Nanos != src.UpdatedAt.Nanos {
				m.UpdatedAt.Nanos = src.UpdatedAt.Nanos
				changed++
			}
		}
	}
	if fmap.HasOrHasChild("31") {
		if fmap.Has("31.1") {
			if m.ReservationEndedAt.Seconds != src.ReservationEndedAt.Seconds {
				m.ReservationEndedAt.Seconds = src.ReservationEndedAt.Seconds
				changed++
			}
		}
		if fmap.Has("31.2") {
			if m.ReservationEndedAt.Nanos != src.ReservationEndedAt.Nanos {
				m.ReservationEndedAt.Nanos = src.ReservationEndedAt.Nanos
				changed++
			}
		}
	}
	if fmap.Has("32") {
		if m.MultiTenant != src.MultiTenant {
			m.MultiTenant = src.MultiTenant
			changed++
		}
	}
	if fmap.Has("33") {
		if src.Networks != nil {
			if updateListAction == "add" {
				changed += m.AddNetworks(src.Networks...)
			} else if updateListAction == "remove" {
				changed += m.RemoveNetworks(src.Networks...)
			} else {
				m.Networks = make([]string, 0)
				m.Networks = append(m.Networks, src.Networks...)
				changed++
			}
		} else if m.Networks != nil {
			m.Networks = nil
			changed++
		}
	}
	if fmap.Has("34") {
		if m.DeletePrepare != src.DeletePrepare {
			m.DeletePrepare = src.DeletePrepare
			changed++
		}
	}
	if fmap.Has("35") {
		if m.DnsLabel != src.DnsLabel {
			m.DnsLabel = src.DnsLabel
			changed++
		}
	}
	if fmap.Has("36") {
		if m.Fqdn != src.Fqdn {
			m.Fqdn = src.Fqdn
			changed++
		}
	}
	if fmap.Has("37") {
		if m.EnableIpv6 != src.EnableIpv6 {
			m.EnableIpv6 = src.EnableIpv6
			changed++
		}
	}
	if fmap.Has("38") {
		if m.ObjId != src.ObjId {
			m.ObjId = src.ObjId
			changed++
		}
	}
	if fmap.Has("39") {
		if m.StaticFqdn != src.StaticFqdn {
			m.StaticFqdn = src.StaticFqdn
			changed++
		}
	}
	if fmap.Has("40") {
		if m.CompatibilityVersion != src.CompatibilityVersion {
			m.CompatibilityVersion = src.CompatibilityVersion
			changed++
		}
	}
	if fmap.HasOrHasChild("41") {
		if fmap.Has("41.1") {
			if m.CloudletKey.Organization != src.CloudletKey.Organization {
				m.CloudletKey.Organization = src.CloudletKey.Organization
				changed++
			}
		}
		if fmap.Has("41.2") {
			if m.CloudletKey.Name != src.CloudletKey.Name {
				m.CloudletKey.Name = src.CloudletKey.Name
				changed++
			}
		}
		if fmap.Has("41.3") {
			if m.CloudletKey.FederatedOrganization != src.CloudletKey.FederatedOrganization {
				m.CloudletKey.FederatedOrganization = src.CloudletKey.FederatedOrganization
				changed++
			}
		}
	}
	if fmap.HasOrHasChild("42") {
		if src.Annotations != nil {
			if updateListAction == "add" {
				for k0, v := range src.Annotations {
					m.Annotations[k0] = v
					changed++
				}
			} else if updateListAction == "remove" {
				for k0, _ := range src.Annotations {
					if _, ok := m.Annotations[k0]; ok {
						delete(m.Annotations, k0)
						changed++
					}
				}
			} else {
				m.Annotations = make(map[string]string)
				for k0, v := range src.Annotations {
					m.Annotations[k0] = v
				}
				changed++
			}
		} else if m.Annotations != nil {
			m.Annotations = nil
			changed++
		}
	}
	if fmap.HasOrHasChild("43") {
		if fmap.Has("43.1") {
			if m.ZoneKey.Organization != src.ZoneKey.Organization {
				m.ZoneKey.Organization = src.ZoneKey.Organization
				changed++
			}
		}
		if fmap.Has("43.2") {
			if m.ZoneKey.Name != src.ZoneKey.Name {
				m.ZoneKey.Name = src.ZoneKey.Name
				changed++
			}
		}
		if fmap.Has("43.3") {
			if m.ZoneKey.FederatedOrganization != src.ZoneKey.FederatedOrganization {
				m.ZoneKey.FederatedOrganization = src.ZoneKey.FederatedOrganization
				changed++
			}
		}
	}
	if fmap.Has("44") {
		if m.DbModelId != src.DbModelId {
			m.DbModelId = src.DbModelId
			changed++
		}
	}
	if fmap.HasOrHasChild("45") {
		if src.NodeResources != nil {
			if m.NodeResources == nil {
				m.NodeResources = &NodeResources{}
			}
			if fmap.Has("45.1") {
				if m.NodeResources.Vcpus != src.NodeResources.Vcpus {
					m.NodeResources.Vcpus = src.NodeResources.Vcpus
					changed++
				}
			}
			if fmap.Has("45.2") {
				if m.NodeResources.Ram != src.NodeResources.Ram {
					m.NodeResources.Ram = src.NodeResources.Ram
					changed++
				}
			}
			if fmap.Has("45.3") {
				if m.NodeResources.Disk != src.NodeResources.Disk {
					m.NodeResources.Disk = src.NodeResources.Disk
					changed++
				}
			}
			if fmap.HasOrHasChild("45.4") {
				if src.NodeResources.OptResMap != nil {
					if updateListAction == "add" {
						for k1, v := range src.NodeResources.OptResMap {
							m.NodeResources.OptResMap[k1] = v
							changed++
						}
					} else if updateListAction == "remove" {
						for k1, _ := range src.NodeResources.OptResMap {
							if _, ok := m.NodeResources.OptResMap[k1]; ok {
								delete(m.NodeResources.OptResMap, k1)
								changed++
							}
						}
					} else {
						m.NodeResources.OptResMap = make(map[string]string)
						for k1, v := range src.NodeResources.OptResMap {
							m.NodeResources.OptResMap[k1] = v
						}
						changed++
					}
				} else if m.NodeResources.OptResMap != nil {
					m.NodeResources.OptResMap = nil
					changed++
				}
			}
			if fmap.Has("45.5") {
				if m.NodeResources.InfraNodeFlavor != src.NodeResources.InfraNodeFlavor {
					m.NodeResources.InfraNodeFlavor = src.NodeResources.InfraNodeFlavor
					changed++
				}
			}
			if fmap.Has("45.6") {
				if m.NodeResources.ExternalVolumeSize != src.NodeResources.ExternalVolumeSize {
					m.NodeResources.ExternalVolumeSize = src.NodeResources.ExternalVolumeSize
					changed++
				}
			}
		} else if m.NodeResources != nil {
			m.NodeResources = nil
			changed++
		}
	}
	if fmap.HasOrHasChild("46") {
		if src.NodePools != nil {
			if updateListAction == "add" {
				changed += m.AddNodePools(src.NodePools...)
			} else if updateListAction == "remove" {
				changed += m.RemoveNodePools(src.NodePools...)
			} else {
				m.NodePools = make([]*NodePool, 0)
				for k0, _ := range src.NodePools {
					m.NodePools = append(m.NodePools, src.NodePools[k0].Clone())
				}
				changed++
			}
		} else if m.NodePools != nil {
			m.NodePools = nil
			changed++
		}
	}
	if fmap.HasOrHasChild("47") {
		if src.InfraAnnotations != nil {
			if updateListAction == "add" {
				for k0, v := range src.InfraAnnotations {
					m.InfraAnnotations[k0] = v
					changed++
				}
			} else if updateListAction == "remove" {
				for k0, _ := range src.InfraAnnotations {
					if _, ok := m.InfraAnnotations[k0]; ok {
						delete(m.InfraAnnotations, k0)
						changed++
					}
				}
			} else {
				m.InfraAnnotations = make(map[string]string)
				for k0, v := range src.InfraAnnotations {
					m.InfraAnnotations[k0] = v
				}
				changed++
			}
		} else if m.InfraAnnotations != nil {
			m.InfraAnnotations = nil
			changed++
		}
	}
	if fmap.Has("48") {
		if m.KubernetesVersion != src.KubernetesVersion {
			m.KubernetesVersion = src.KubernetesVersion
			changed++
		}
	}
	return changed
}

func (m *ClusterInst) DeepCopyIn(src *ClusterInst) {
	m.Key.DeepCopyIn(&src.Key)
	m.Flavor.DeepCopyIn(&src.Flavor)
	m.State = src.State
	if src.Errors != nil {
		m.Errors = make([]string, len(src.Errors), len(src.Errors))
		for ii, s := range src.Errors {
			m.Errors[ii] = s
		}
	} else {
		m.Errors = nil
	}
	m.CrmOverride = src.CrmOverride
	m.IpAccess = src.IpAccess
	m.AllocatedIp = src.AllocatedIp
	m.Liveness = src.Liveness
	m.Auto = src.Auto
	m.NodeFlavor = src.NodeFlavor
	m.NumMasters = src.NumMasters
	m.NumNodes = src.NumNodes
	m.Deployment = src.Deployment
	m.ExternalVolumeSize = src.ExternalVolumeSize
	m.AutoScalePolicy = src.AutoScalePolicy
	m.AvailabilityZone = src.AvailabilityZone
	m.ImageName = src.ImageName
	m.Reservable = src.Reservable
	m.ReservedBy = src.ReservedBy
	m.SharedVolumeSize = src.SharedVolumeSize
	m.MasterNodeFlavor = src.MasterNodeFlavor
	m.SkipCrmCleanupOnFailure = src.SkipCrmCleanupOnFailure
	m.OptRes = src.OptRes
	m.Resources.DeepCopyIn(&src.Resources)
	m.CreatedAt = src.CreatedAt
	m.UpdatedAt = src.UpdatedAt
	m.ReservationEndedAt = src.ReservationEndedAt
	m.MultiTenant = src.MultiTenant
	if src.Networks != nil {
		m.Networks = make([]string, len(src.Networks), len(src.Networks))
		for ii, s := range src.Networks {
			m.Networks[ii] = s
		}
	} else {
		m.Networks = nil
	}
	m.DeletePrepare = src.DeletePrepare
	m.DnsLabel = src.DnsLabel
	m.Fqdn = src.Fqdn
	m.EnableIpv6 = src.EnableIpv6
	m.ObjId = src.ObjId
	m.StaticFqdn = src.StaticFqdn
	m.CompatibilityVersion = src.CompatibilityVersion
	m.CloudletKey.DeepCopyIn(&src.CloudletKey)
	if src.Annotations != nil {
		m.Annotations = make(map[string]string)
		for k, v := range src.Annotations {
			m.Annotations[k] = v
		}
	} else {
		m.Annotations = nil
	}
	m.ZoneKey.DeepCopyIn(&src.ZoneKey)
	m.DbModelId = src.DbModelId
	if src.NodeResources != nil {
		var tmp_NodeResources NodeResources
		tmp_NodeResources.DeepCopyIn(src.NodeResources)
		m.NodeResources = &tmp_NodeResources
	} else {
		m.NodeResources = nil
	}
	if src.NodePools != nil {
		m.NodePools = make([]*NodePool, len(src.NodePools), len(src.NodePools))
		for ii, s := range src.NodePools {
			var tmp_s NodePool
			tmp_s.DeepCopyIn(s)
			m.NodePools[ii] = &tmp_s
		}
	} else {
		m.NodePools = nil
	}
	if src.InfraAnnotations != nil {
		m.InfraAnnotations = make(map[string]string)
		for k, v := range src.InfraAnnotations {
			m.InfraAnnotations[k] = v
		}
	} else {
		m.InfraAnnotations = nil
	}
	m.KubernetesVersion = src.KubernetesVersion
}

func (s *ClusterInst) HasFields() bool {
	return true
}

type ClusterInstStore interface {
	Create(ctx context.Context, m *ClusterInst, wait func(int64)) (*Result, error)
	Update(ctx context.Context, m *ClusterInst, wait func(int64)) (*Result, error)
	Delete(ctx context.Context, m *ClusterInst, wait func(int64)) (*Result, error)
	Put(ctx context.Context, m *ClusterInst, wait func(int64), ops ...objstore.KVOp) (*Result, error)
	LoadOne(key string) (*ClusterInst, int64, error)
	Get(ctx context.Context, key *ClusterKey, buf *ClusterInst) bool
	STMGet(stm concurrency.STM, key *ClusterKey, buf *ClusterInst) bool
	STMPut(stm concurrency.STM, obj *ClusterInst, ops ...objstore.KVOp)
	STMDel(stm concurrency.STM, key *ClusterKey)
	STMHas(stm concurrency.STM, key *ClusterKey) bool
}

type ClusterInstStoreImpl struct {
	kvstore objstore.KVStore
}

func NewClusterInstStore(kvstore objstore.KVStore) *ClusterInstStoreImpl {
	return &ClusterInstStoreImpl{kvstore: kvstore}
}

func (s *ClusterInstStoreImpl) Create(ctx context.Context, m *ClusterInst, wait func(int64)) (*Result, error) {
	err := m.Validate(ClusterInstAllFieldsMap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("ClusterInst", m.GetKey())
	val, err := json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Create(ctx, key, string(val))
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *ClusterInstStoreImpl) Update(ctx context.Context, m *ClusterInst, wait func(int64)) (*Result, error) {
	fmap := MakeFieldMap(m.Fields)
	err := m.Validate(fmap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("ClusterInst", m.GetKey())
	var vers int64 = 0
	curBytes, vers, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, err
	}
	var cur ClusterInst
	err = json.Unmarshal(curBytes, &cur)
	if err != nil {
		return nil, err
	}
	cur.CopyInFields(m)
	// never save fields
	cur.Fields = nil
	val, err := json.Marshal(cur)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Update(ctx, key, string(val), vers)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *ClusterInstStoreImpl) Put(ctx context.Context, m *ClusterInst, wait func(int64), ops ...objstore.KVOp) (*Result, error) {
	err := m.Validate(ClusterInstAllFieldsMap)
	m.Fields = nil
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("ClusterInst", m.GetKey())
	var val []byte
	val, err = json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Put(ctx, key, string(val), ops...)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *ClusterInstStoreImpl) Delete(ctx context.Context, m *ClusterInst, wait func(int64)) (*Result, error) {
	err := m.GetKey().ValidateKey()
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("ClusterInst", m.GetKey())
	rev, err := s.kvstore.Delete(ctx, key)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *ClusterInstStoreImpl) LoadOne(key string) (*ClusterInst, int64, error) {
	val, rev, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, 0, err
	}
	var obj ClusterInst
	err = json.Unmarshal(val, &obj)
	if err != nil {
		log.DebugLog(log.DebugLevelApi, "Failed to parse ClusterInst data", "val", string(val), "err", err)
		return nil, 0, err
	}
	return &obj, rev, nil
}

func (s *ClusterInstStoreImpl) Get(ctx context.Context, key *ClusterKey, buf *ClusterInst) bool {
	keystr := objstore.DbKeyString("ClusterInst", key)
	val, _, _, err := s.kvstore.Get(keystr)
	if err != nil {
		return false
	}
	return s.parseGetData(val, buf)
}

func (s *ClusterInstStoreImpl) STMGet(stm concurrency.STM, key *ClusterKey, buf *ClusterInst) bool {
	keystr := objstore.DbKeyString("ClusterInst", key)
	valstr := stm.Get(keystr)
	return s.parseGetData([]byte(valstr), buf)
}

func (s *ClusterInstStoreImpl) STMHas(stm concurrency.STM, key *ClusterKey) bool {
	keystr := objstore.DbKeyString("ClusterInst", key)
	return stm.Get(keystr) != ""
}

func (s *ClusterInstStoreImpl) parseGetData(val []byte, buf *ClusterInst) bool {
	if len(val) == 0 {
		return false
	}
	if buf != nil {
		// clear buf, because empty values in val won't
		// overwrite non-empty values in buf.
		*buf = ClusterInst{}
		err := json.Unmarshal(val, buf)
		if err != nil {
			return false
		}
	}
	return true
}

func (s *ClusterInstStoreImpl) STMPut(stm concurrency.STM, obj *ClusterInst, ops ...objstore.KVOp) {
	keystr := objstore.DbKeyString("ClusterInst", obj.GetKey())

	val, err := json.Marshal(obj)
	if err != nil {
		log.InfoLog("ClusterInst json marshal failed", "obj", obj, "err", err)
	}
	v3opts := GetSTMOpts(ops...)
	stm.Put(keystr, string(val), v3opts...)
}

func (s *ClusterInstStoreImpl) STMDel(stm concurrency.STM, key *ClusterKey) {
	keystr := objstore.DbKeyString("ClusterInst", key)
	stm.Del(keystr)
}

func StoreListClusterInst(ctx context.Context, kvstore objstore.KVStore) ([]ClusterInst, error) {
	keyPrefix := objstore.DbKeyPrefixString("ClusterInst") + "/"
	objs := []ClusterInst{}
	err := kvstore.List(keyPrefix, func(key, val []byte, rev, modRev int64) error {
		obj := ClusterInst{}
		err := json.Unmarshal(val, &obj)
		if err != nil {
			return fmt.Errorf("failed to unmarshal ClusterInst json %s, %s", string(val), err)
		}
		objs = append(objs, obj)
		return nil
	})
	return objs, err
}

type ClusterInstKeyWatcher struct {
	cb func(ctx context.Context)
}

type ClusterInstCacheData struct {
	Obj    *ClusterInst
	ModRev int64
}

func (s *ClusterInstCacheData) Clone() *ClusterInstCacheData {
	cp := ClusterInstCacheData{}
	if s.Obj != nil {
		cp.Obj = &ClusterInst{}
		cp.Obj.DeepCopyIn(s.Obj)
	}
	cp.ModRev = s.ModRev
	return &cp
}

// ClusterInstCache caches ClusterInst objects in memory in a hash table
// and keeps them in sync with the database.
type ClusterInstCache struct {
	Objs          map[ClusterKey]*ClusterInstCacheData
	Mux           util.Mutex
	List          map[ClusterKey]struct{}
	FlushAll      bool
	NotifyCbs     []func(ctx context.Context, obj *ClusterInst, modRev int64)
	UpdatedCbs    []func(ctx context.Context, old *ClusterInst, new *ClusterInst)
	DeletedCbs    []func(ctx context.Context, old *ClusterInst)
	KeyWatchers   map[ClusterKey][]*ClusterInstKeyWatcher
	UpdatedKeyCbs []func(ctx context.Context, key *ClusterKey)
	DeletedKeyCbs []func(ctx context.Context, key *ClusterKey)
	Store         ClusterInstStore
}

func NewClusterInstCache() *ClusterInstCache {
	cache := ClusterInstCache{}
	InitClusterInstCache(&cache)
	return &cache
}

func InitClusterInstCache(cache *ClusterInstCache) {
	cache.Objs = make(map[ClusterKey]*ClusterInstCacheData)
	cache.KeyWatchers = make(map[ClusterKey][]*ClusterInstKeyWatcher)
	cache.NotifyCbs = nil
	cache.UpdatedCbs = nil
	cache.DeletedCbs = nil
	cache.UpdatedKeyCbs = nil
	cache.DeletedKeyCbs = nil
}

func (c *ClusterInstCache) GetTypeString() string {
	return "ClusterInst"
}

func (c *ClusterInstCache) Get(key *ClusterKey, valbuf *ClusterInst) bool {
	var modRev int64
	return c.GetWithRev(key, valbuf, &modRev)
}

// STMGet gets from the store if STM is set, otherwise gets from cache
func (c *ClusterInstCache) STMGet(ostm *OptionalSTM, key *ClusterKey, valbuf *ClusterInst) bool {
	if ostm.stm != nil {
		if c.Store == nil {
			// panic, otherwise if we fallback to cache, we may silently
			// introduce race conditions and intermittent failures due to
			// reading from cache during a transaction.
			panic("ClusterInstCache store not set, cannot read via STM")
		}
		return c.Store.STMGet(ostm.stm, key, valbuf)
	}
	var modRev int64
	return c.GetWithRev(key, valbuf, &modRev)
}

func (c *ClusterInstCache) GetWithRev(key *ClusterKey, valbuf *ClusterInst, modRev *int64) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	inst, found := c.Objs[*key]
	if found {
		valbuf.DeepCopyIn(inst.Obj)
		*modRev = inst.ModRev
	}
	return found
}

func (c *ClusterInstCache) HasKey(key *ClusterKey) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	_, found := c.Objs[*key]
	return found
}

func (c *ClusterInstCache) GetAllKeys(ctx context.Context, cb func(key *ClusterKey, modRev int64)) {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for key, data := range c.Objs {
		cb(&key, data.ModRev)
	}
}

func (c *ClusterInstCache) GetAllLocked(ctx context.Context, cb func(obj *ClusterInst, modRev int64)) {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for _, data := range c.Objs {
		cb(data.Obj, data.ModRev)
	}
}

func (c *ClusterInstCache) Update(ctx context.Context, in *ClusterInst, modRev int64) {
	c.UpdateModFunc(ctx, in.GetKey(), modRev, func(old *ClusterInst) (*ClusterInst, bool) {
		return in, true
	})
}

func (c *ClusterInstCache) UpdateModFunc(ctx context.Context, key *ClusterKey, modRev int64, modFunc func(old *ClusterInst) (new *ClusterInst, changed bool)) {
	c.Mux.Lock()
	var old *ClusterInst
	if oldData, found := c.Objs[*key]; found {
		old = oldData.Obj
	}
	new, changed := modFunc(old)
	if !changed {
		c.Mux.Unlock()
		return
	}
	if len(c.UpdatedCbs) > 0 || len(c.NotifyCbs) > 0 {
		newCopy := &ClusterInst{}
		newCopy.DeepCopyIn(new)
		for _, cb := range c.UpdatedCbs {
			defer cb(ctx, old, newCopy)
		}
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				defer cb(ctx, newCopy, modRev)
			}
		}
	}
	for _, cb := range c.UpdatedKeyCbs {
		defer cb(ctx, key)
	}
	store := &ClusterInst{}
	store.DeepCopyIn(new)
	c.Objs[new.GetKeyVal()] = &ClusterInstCacheData{
		Obj:    store,
		ModRev: modRev,
	}
	log.SpanLog(ctx, log.DebugLevelApi, "cache update", "new", store)
	c.Mux.Unlock()
	c.TriggerKeyWatchers(ctx, new.GetKey())
}

func (c *ClusterInstCache) Delete(ctx context.Context, in *ClusterInst, modRev int64) {
	c.DeleteCondFunc(ctx, in, modRev, func(old *ClusterInst) bool {
		return true
	})
}

func (c *ClusterInstCache) DeleteCondFunc(ctx context.Context, in *ClusterInst, modRev int64, condFunc func(old *ClusterInst) bool) {
	c.Mux.Lock()
	var old *ClusterInst
	oldData, found := c.Objs[in.GetKeyVal()]
	if found {
		old = oldData.Obj
		if !condFunc(old) {
			c.Mux.Unlock()
			return
		}
	}
	delete(c.Objs, in.GetKeyVal())
	log.SpanLog(ctx, log.DebugLevelApi, "cache delete", "key", in.GetKeyVal())
	c.Mux.Unlock()
	obj := old
	if obj == nil {
		obj = in
	}
	for _, cb := range c.NotifyCbs {
		if cb != nil {
			cb(ctx, obj, modRev)
		}
	}
	if old != nil {
		for _, cb := range c.DeletedCbs {
			cb(ctx, old)
		}
	}
	for _, cb := range c.DeletedKeyCbs {
		cb(ctx, in.GetKey())
	}
	c.TriggerKeyWatchers(ctx, in.GetKey())
}

func (c *ClusterInstCache) Prune(ctx context.Context, validKeys map[ClusterKey]struct{}) {
	log.SpanLog(ctx, log.DebugLevelApi, "Prune ClusterInst", "numValidKeys", len(validKeys))
	notify := make(map[ClusterKey]*ClusterInstCacheData)
	c.Mux.Lock()
	for key, _ := range c.Objs {
		if _, ok := validKeys[key]; !ok {
			if len(c.NotifyCbs) > 0 || len(c.DeletedKeyCbs) > 0 || len(c.DeletedCbs) > 0 {
				notify[key] = c.Objs[key]
			}
			delete(c.Objs, key)
		}
	}
	c.Mux.Unlock()
	for key, old := range notify {
		obj := old.Obj
		if obj == nil {
			obj = &ClusterInst{}
			obj.SetKey(&key)
		}
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, obj, old.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if old.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, old.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (c *ClusterInstCache) GetCount() int {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	return len(c.Objs)
}

func (c *ClusterInstCache) Flush(ctx context.Context, notifyId int64) {
}

func (c *ClusterInstCache) Show(filter *ClusterInst, cb func(ret *ClusterInst) error) error {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for _, data := range c.Objs {
		if !data.Obj.Matches(filter, MatchFilter()) {
			continue
		}
		err := cb(data.Obj)
		if err != nil {
			return err
		}
	}
	return nil
}

func ClusterInstGenericNotifyCb(fn func(key *ClusterKey, old *ClusterInst)) func(objstore.ObjKey, objstore.Obj) {
	return func(objkey objstore.ObjKey, obj objstore.Obj) {
		fn(objkey.(*ClusterKey), obj.(*ClusterInst))
	}
}

func (c *ClusterInstCache) SetNotifyCb(fn func(ctx context.Context, obj *ClusterInst, modRev int64)) {
	c.NotifyCbs = []func(ctx context.Context, obj *ClusterInst, modRev int64){fn}
}

func (c *ClusterInstCache) SetUpdatedCb(fn func(ctx context.Context, old *ClusterInst, new *ClusterInst)) {
	c.UpdatedCbs = []func(ctx context.Context, old *ClusterInst, new *ClusterInst){fn}
}

func (c *ClusterInstCache) SetDeletedCb(fn func(ctx context.Context, old *ClusterInst)) {
	c.DeletedCbs = []func(ctx context.Context, old *ClusterInst){fn}
}

func (c *ClusterInstCache) SetUpdatedKeyCb(fn func(ctx context.Context, key *ClusterKey)) {
	c.UpdatedKeyCbs = []func(ctx context.Context, key *ClusterKey){fn}
}

func (c *ClusterInstCache) SetDeletedKeyCb(fn func(ctx context.Context, key *ClusterKey)) {
	c.DeletedKeyCbs = []func(ctx context.Context, key *ClusterKey){fn}
}

func (c *ClusterInstCache) AddUpdatedCb(fn func(ctx context.Context, old *ClusterInst, new *ClusterInst)) {
	c.UpdatedCbs = append(c.UpdatedCbs, fn)
}

func (c *ClusterInstCache) AddDeletedCb(fn func(ctx context.Context, old *ClusterInst)) {
	c.DeletedCbs = append(c.DeletedCbs, fn)
}

func (c *ClusterInstCache) AddNotifyCb(fn func(ctx context.Context, obj *ClusterInst, modRev int64)) {
	c.NotifyCbs = append(c.NotifyCbs, fn)
}

func (c *ClusterInstCache) AddUpdatedKeyCb(fn func(ctx context.Context, key *ClusterKey)) {
	c.UpdatedKeyCbs = append(c.UpdatedKeyCbs, fn)
}

func (c *ClusterInstCache) AddDeletedKeyCb(fn func(ctx context.Context, key *ClusterKey)) {
	c.DeletedKeyCbs = append(c.DeletedKeyCbs, fn)
}

func (c *ClusterInstCache) SetFlushAll() {
	c.FlushAll = true
}

func (c *ClusterInstCache) WatchKey(key *ClusterKey, cb func(ctx context.Context)) context.CancelFunc {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	list, ok := c.KeyWatchers[*key]
	if !ok {
		list = make([]*ClusterInstKeyWatcher, 0)
	}
	watcher := ClusterInstKeyWatcher{cb: cb}
	c.KeyWatchers[*key] = append(list, &watcher)
	log.DebugLog(log.DebugLevelApi, "Watching ClusterInst", "key", key)
	return func() {
		c.Mux.Lock()
		defer c.Mux.Unlock()
		list, ok := c.KeyWatchers[*key]
		if !ok {
			return
		}
		for ii, _ := range list {
			if list[ii] != &watcher {
				continue
			}
			if len(list) == 1 {
				delete(c.KeyWatchers, *key)
				return
			}
			list[ii] = list[len(list)-1]
			list[len(list)-1] = nil
			c.KeyWatchers[*key] = list[:len(list)-1]
			return
		}
	}
}

func (c *ClusterInstCache) TriggerKeyWatchers(ctx context.Context, key *ClusterKey) {
	watchers := make([]*ClusterInstKeyWatcher, 0)
	c.Mux.Lock()
	if list, ok := c.KeyWatchers[*key]; ok {
		watchers = append(watchers, list...)
	}
	c.Mux.Unlock()
	for ii, _ := range watchers {
		watchers[ii].cb(ctx)
	}
}

// Note that we explicitly ignore the global revision number, because of the way
// the notify framework sends updates (by hashing keys and doing lookups, instead
// of sequentially through a history buffer), updates may be done out-of-order
// or multiple updates compressed into one update, so the state of the cache at
// any point in time may not by in sync with a particular database revision number.

func (c *ClusterInstCache) SyncUpdate(ctx context.Context, key, val []byte, rev, modRev int64) {
	obj := ClusterInst{}
	err := json.Unmarshal(val, &obj)
	if err != nil {
		log.WarnLog("Failed to parse ClusterInst data", "val", string(val), "err", err)
		return
	}
	c.Update(ctx, &obj, modRev)
	c.Mux.Lock()
	if c.List != nil {
		c.List[obj.GetKeyVal()] = struct{}{}
	}
	c.Mux.Unlock()
}

func (c *ClusterInstCache) SyncDelete(ctx context.Context, key []byte, rev, modRev int64) {
	obj := ClusterInst{}
	keystr := objstore.DbKeyPrefixRemove(string(key))
	ClusterKeyStringParse(keystr, obj.GetKey())
	c.Delete(ctx, &obj, modRev)
}

func (c *ClusterInstCache) SyncListStart(ctx context.Context) {
	c.List = make(map[ClusterKey]struct{})
}

func (c *ClusterInstCache) SyncListEnd(ctx context.Context) {
	deleted := make(map[ClusterKey]*ClusterInstCacheData)
	c.Mux.Lock()
	for key, val := range c.Objs {
		if _, found := c.List[key]; !found {
			deleted[key] = val
			delete(c.Objs, key)
		}
	}
	c.List = nil
	c.Mux.Unlock()
	for key, val := range deleted {
		obj := val.Obj
		if obj == nil {
			obj = &ClusterInst{}
			obj.SetKey(&key)
		}
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, obj, val.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if val.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, val.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (s *ClusterInstCache) InitCacheWithSync(sync DataSync) {
	InitClusterInstCache(s)
	s.InitSync(sync)
}

func (s *ClusterInstCache) InitSync(sync DataSync) {
	if sync != nil {
		s.Store = NewClusterInstStore(sync.GetKVStore())
		sync.RegisterCache(s)
	}
}

func InitClusterInstCacheWithStore(cache *ClusterInstCache, store ClusterInstStore) {
	InitClusterInstCache(cache)
	cache.Store = store
}

func (m *ClusterInst) GetObjKey() objstore.ObjKey {
	return m.GetKey()
}

func (m *ClusterInst) GetKey() *ClusterKey {
	return &m.Key
}

func (m *ClusterInst) GetKeyVal() ClusterKey {
	return m.Key
}

func (m *ClusterInst) SetKey(key *ClusterKey) {
	m.Key = *key
}

func CmpSortClusterInst(a ClusterInst, b ClusterInst) bool {
	return a.Key.GetKeyString() < b.Key.GetKeyString()
}
func (m *ClusterKey) StreamKey() string {
	return fmt.Sprintf("ClusterInstStreamKey: %s", m.String())
}

// Helper method to check that enums have valid values
// NOTE: ValidateEnums checks all Fields even if some are not set
func (m *ClusterInst) ValidateEnums() error {
	if err := m.Key.ValidateEnums(); err != nil {
		return err
	}
	if err := m.Flavor.ValidateEnums(); err != nil {
		return err
	}
	if _, ok := TrackedState_name[int32(m.State)]; !ok {
		return errors.New("invalid State")
	}
	if _, ok := CRMOverride_name[int32(m.CrmOverride)]; !ok {
		return errors.New("invalid CrmOverride")
	}
	if _, ok := IpAccess_name[int32(m.IpAccess)]; !ok {
		return errors.New("invalid IpAccess")
	}
	if _, ok := Liveness_name[int32(m.Liveness)]; !ok {
		return errors.New("invalid Liveness")
	}
	if err := m.Resources.ValidateEnums(); err != nil {
		return err
	}
	if err := m.CloudletKey.ValidateEnums(); err != nil {
		return err
	}
	if err := m.ZoneKey.ValidateEnums(); err != nil {
		return err
	}
	if m.NodeResources != nil {
		if err := m.NodeResources.ValidateEnums(); err != nil {
			return err
		}
	}
	for _, e := range m.NodePools {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (s *ClusterInst) ClearTagged(tags map[string]struct{}) {
	s.Key.ClearTagged(tags)
	s.Flavor.ClearTagged(tags)
	if _, found := tags["nocmp"]; found {
		s.Errors = nil
	}
	if _, found := tags["nocmp"]; found {
		s.AllocatedIp = ""
	}
	s.Resources.ClearTagged(tags)
	if _, found := tags["timestamp"]; found {
		s.CreatedAt = distributed_match_engine.Timestamp{}
	}
	if _, found := tags["timestamp"]; found {
		s.UpdatedAt = distributed_match_engine.Timestamp{}
	}
	if _, found := tags["timestamp"]; found {
		s.ReservationEndedAt = distributed_match_engine.Timestamp{}
	}
	if _, found := tags["nocmp"]; found {
		s.ObjId = ""
	}
	if _, found := tags["nocmp"]; found {
		s.CompatibilityVersion = 0
	}
	s.CloudletKey.ClearTagged(tags)
	s.ZoneKey.ClearTagged(tags)
	if _, found := tags["nocmp"]; found {
		s.DbModelId = 0
	}
	if s.NodeResources != nil {
		s.NodeResources.ClearTagged(tags)
	}
	if s.NodePools != nil {
		for ii := 0; ii < len(s.NodePools); ii++ {
			s.NodePools[ii].ClearTagged(tags)
		}
	}
	if _, found := tags["nocmp"]; found {
		s.InfraAnnotations = nil
	}
}

func IgnoreClusterInstFields(taglist string) cmp.Option {
	names := []string{}
	tags := make(map[string]struct{})
	for _, tag := range strings.Split(taglist, ",") {
		tags[tag] = struct{}{}
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Errors")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "AllocatedIp")
	}
	if _, found := tags["timestamp"]; found {
		names = append(names, "CreatedAt")
	}
	if _, found := tags["timestamp"]; found {
		names = append(names, "UpdatedAt")
	}
	if _, found := tags["timestamp"]; found {
		names = append(names, "ReservationEndedAt")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "ObjId")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "CompatibilityVersion")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "DbModelId")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "InfraAnnotations")
	}
	return cmpopts.IgnoreFields(ClusterInst{}, names...)
}

func (m *IdleReservableClusterInsts) Clone() *IdleReservableClusterInsts {
	cp := &IdleReservableClusterInsts{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *IdleReservableClusterInsts) CopyInFields(src *IdleReservableClusterInsts) int {
	changed := 0
	if m.IdleTime != src.IdleTime {
		m.IdleTime = src.IdleTime
		changed++
	}
	return changed
}

func (m *IdleReservableClusterInsts) DeepCopyIn(src *IdleReservableClusterInsts) {
	m.IdleTime = src.IdleTime
}

// Helper method to check that enums have valid values
func (m *IdleReservableClusterInsts) ValidateEnums() error {
	return nil
}

func (s *IdleReservableClusterInsts) ClearTagged(tags map[string]struct{}) {
}

func (m *ClusterResourceUsage) Clone() *ClusterResourceUsage {
	cp := &ClusterResourceUsage{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *ClusterResourceUsage) AddTotalResources(vals ...*InfraResource) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.TotalResources {
		cur[v.String()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.String()]; found {
			continue // duplicate
		}
		m.TotalResources = append(m.TotalResources, v)
		changes++
	}
	return changes
}

func (m *ClusterResourceUsage) RemoveTotalResources(vals ...*InfraResource) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.String()] = struct{}{}
	}
	for i := len(m.TotalResources); i >= 0; i-- {
		if _, found := remove[m.TotalResources[i].String()]; found {
			m.TotalResources = append(m.TotalResources[:i], m.TotalResources[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *ClusterResourceUsage) AddCpuPoolsResources(vals ...*InfraResource) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.CpuPoolsResources {
		cur[v.String()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.String()]; found {
			continue // duplicate
		}
		m.CpuPoolsResources = append(m.CpuPoolsResources, v)
		changes++
	}
	return changes
}

func (m *ClusterResourceUsage) RemoveCpuPoolsResources(vals ...*InfraResource) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.String()] = struct{}{}
	}
	for i := len(m.CpuPoolsResources); i >= 0; i-- {
		if _, found := remove[m.CpuPoolsResources[i].String()]; found {
			m.CpuPoolsResources = append(m.CpuPoolsResources[:i], m.CpuPoolsResources[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *ClusterResourceUsage) AddGpuPoolsResources(vals ...*InfraResource) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.GpuPoolsResources {
		cur[v.String()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.String()]; found {
			continue // duplicate
		}
		m.GpuPoolsResources = append(m.GpuPoolsResources, v)
		changes++
	}
	return changes
}

func (m *ClusterResourceUsage) RemoveGpuPoolsResources(vals ...*InfraResource) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.String()] = struct{}{}
	}
	for i := len(m.GpuPoolsResources); i >= 0; i-- {
		if _, found := remove[m.GpuPoolsResources[i].String()]; found {
			m.GpuPoolsResources = append(m.GpuPoolsResources[:i], m.GpuPoolsResources[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *ClusterResourceUsage) CopyInFields(src *ClusterResourceUsage) int {
	updateListAction := "replace"
	changed := 0
	if m.Key.Name != src.Key.Name {
		m.Key.Name = src.Key.Name
		changed++
	}
	if m.Key.Organization != src.Key.Organization {
		m.Key.Organization = src.Key.Organization
		changed++
	}
	if m.ZoneKey.Organization != src.ZoneKey.Organization {
		m.ZoneKey.Organization = src.ZoneKey.Organization
		changed++
	}
	if m.ZoneKey.Name != src.ZoneKey.Name {
		m.ZoneKey.Name = src.ZoneKey.Name
		changed++
	}
	if m.ZoneKey.FederatedOrganization != src.ZoneKey.FederatedOrganization {
		m.ZoneKey.FederatedOrganization = src.ZoneKey.FederatedOrganization
		changed++
	}
	if m.CloudletKey.Organization != src.CloudletKey.Organization {
		m.CloudletKey.Organization = src.CloudletKey.Organization
		changed++
	}
	if m.CloudletKey.Name != src.CloudletKey.Name {
		m.CloudletKey.Name = src.CloudletKey.Name
		changed++
	}
	if m.CloudletKey.FederatedOrganization != src.CloudletKey.FederatedOrganization {
		m.CloudletKey.FederatedOrganization = src.CloudletKey.FederatedOrganization
		changed++
	}
	if src.TotalResources != nil {
		if updateListAction == "add" {
			changed += m.AddTotalResources(src.TotalResources...)
		} else if updateListAction == "remove" {
			changed += m.RemoveTotalResources(src.TotalResources...)
		} else {
			m.TotalResources = make([]*InfraResource, 0)
			for k0, _ := range src.TotalResources {
				m.TotalResources = append(m.TotalResources, src.TotalResources[k0].Clone())
			}
			changed++
		}
	} else if m.TotalResources != nil {
		m.TotalResources = nil
		changed++
	}
	if src.CpuPoolsResources != nil {
		if updateListAction == "add" {
			changed += m.AddCpuPoolsResources(src.CpuPoolsResources...)
		} else if updateListAction == "remove" {
			changed += m.RemoveCpuPoolsResources(src.CpuPoolsResources...)
		} else {
			m.CpuPoolsResources = make([]*InfraResource, 0)
			for k0, _ := range src.CpuPoolsResources {
				m.CpuPoolsResources = append(m.CpuPoolsResources, src.CpuPoolsResources[k0].Clone())
			}
			changed++
		}
	} else if m.CpuPoolsResources != nil {
		m.CpuPoolsResources = nil
		changed++
	}
	if src.GpuPoolsResources != nil {
		if updateListAction == "add" {
			changed += m.AddGpuPoolsResources(src.GpuPoolsResources...)
		} else if updateListAction == "remove" {
			changed += m.RemoveGpuPoolsResources(src.GpuPoolsResources...)
		} else {
			m.GpuPoolsResources = make([]*InfraResource, 0)
			for k0, _ := range src.GpuPoolsResources {
				m.GpuPoolsResources = append(m.GpuPoolsResources, src.GpuPoolsResources[k0].Clone())
			}
			changed++
		}
	} else if m.GpuPoolsResources != nil {
		m.GpuPoolsResources = nil
		changed++
	}
	if m.ResourceScore != src.ResourceScore {
		m.ResourceScore = src.ResourceScore
		changed++
	}
	if m.CpuPoolsResourceScore != src.CpuPoolsResourceScore {
		m.CpuPoolsResourceScore = src.CpuPoolsResourceScore
		changed++
	}
	if m.GpuPoolsResourceScore != src.GpuPoolsResourceScore {
		m.GpuPoolsResourceScore = src.GpuPoolsResourceScore
		changed++
	}
	return changed
}

func (m *ClusterResourceUsage) DeepCopyIn(src *ClusterResourceUsage) {
	m.Key.DeepCopyIn(&src.Key)
	m.ZoneKey.DeepCopyIn(&src.ZoneKey)
	m.CloudletKey.DeepCopyIn(&src.CloudletKey)
	if src.TotalResources != nil {
		m.TotalResources = make([]*InfraResource, len(src.TotalResources), len(src.TotalResources))
		for ii, s := range src.TotalResources {
			var tmp_s InfraResource
			tmp_s.DeepCopyIn(s)
			m.TotalResources[ii] = &tmp_s
		}
	} else {
		m.TotalResources = nil
	}
	if src.CpuPoolsResources != nil {
		m.CpuPoolsResources = make([]*InfraResource, len(src.CpuPoolsResources), len(src.CpuPoolsResources))
		for ii, s := range src.CpuPoolsResources {
			var tmp_s InfraResource
			tmp_s.DeepCopyIn(s)
			m.CpuPoolsResources[ii] = &tmp_s
		}
	} else {
		m.CpuPoolsResources = nil
	}
	if src.GpuPoolsResources != nil {
		m.GpuPoolsResources = make([]*InfraResource, len(src.GpuPoolsResources), len(src.GpuPoolsResources))
		for ii, s := range src.GpuPoolsResources {
			var tmp_s InfraResource
			tmp_s.DeepCopyIn(s)
			m.GpuPoolsResources[ii] = &tmp_s
		}
	} else {
		m.GpuPoolsResources = nil
	}
	m.ResourceScore = src.ResourceScore
	m.CpuPoolsResourceScore = src.CpuPoolsResourceScore
	m.GpuPoolsResourceScore = src.GpuPoolsResourceScore
}

func (m *ClusterResourceUsage) GetObjKey() objstore.ObjKey {
	return m.GetKey()
}

func (m *ClusterResourceUsage) GetKey() *ClusterKey {
	return &m.Key
}

func (m *ClusterResourceUsage) GetKeyVal() ClusterKey {
	return m.Key
}

func (m *ClusterResourceUsage) SetKey(key *ClusterKey) {
	m.Key = *key
}

func CmpSortClusterResourceUsage(a ClusterResourceUsage, b ClusterResourceUsage) bool {
	return a.Key.GetKeyString() < b.Key.GetKeyString()
}

// Helper method to check that enums have valid values
func (m *ClusterResourceUsage) ValidateEnums() error {
	if err := m.Key.ValidateEnums(); err != nil {
		return err
	}
	if err := m.ZoneKey.ValidateEnums(); err != nil {
		return err
	}
	if err := m.CloudletKey.ValidateEnums(); err != nil {
		return err
	}
	for _, e := range m.TotalResources {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	for _, e := range m.CpuPoolsResources {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	for _, e := range m.GpuPoolsResources {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (s *ClusterResourceUsage) ClearTagged(tags map[string]struct{}) {
	s.Key.ClearTagged(tags)
	s.ZoneKey.ClearTagged(tags)
	s.CloudletKey.ClearTagged(tags)
	if s.TotalResources != nil {
		for ii := 0; ii < len(s.TotalResources); ii++ {
			s.TotalResources[ii].ClearTagged(tags)
		}
	}
	if s.CpuPoolsResources != nil {
		for ii := 0; ii < len(s.CpuPoolsResources); ii++ {
			s.CpuPoolsResources[ii].ClearTagged(tags)
		}
	}
	if s.GpuPoolsResources != nil {
		for ii := 0; ii < len(s.GpuPoolsResources); ii++ {
			s.GpuPoolsResources[ii].ClearTagged(tags)
		}
	}
}

func (m *ClusterInstInfo) Matches(o *ClusterInstInfo, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !m.Key.Matches(&o.Key, fopts...) {
		return false
	}
	if !opts.Filter || o.NotifyId != 0 {
		if o.NotifyId != m.NotifyId {
			return false
		}
	}
	if !opts.Filter || o.State != 0 {
		if o.State != m.State {
			return false
		}
	}
	if !opts.Filter || o.Errors != nil {
		if len(m.Errors) == 0 && len(o.Errors) > 0 || len(m.Errors) > 0 && len(o.Errors) == 0 {
			return false
		} else if m.Errors != nil && o.Errors != nil {
			if !opts.Filter && len(m.Errors) != len(o.Errors) {
				return false
			}
			found := 0
			for oIndex, _ := range o.Errors {
				for mIndex, _ := range m.Errors {
					if o.Errors[oIndex] == m.Errors[mIndex] {
						found++
						break
					}
				}
			}
			if found != len(o.Errors) {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
	}
	if !opts.IgnoreBackend {
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.InfraAnnotations != nil {
			if len(m.InfraAnnotations) == 0 && len(o.InfraAnnotations) > 0 || len(m.InfraAnnotations) > 0 && len(o.InfraAnnotations) == 0 {
				return false
			} else if m.InfraAnnotations != nil && o.InfraAnnotations != nil {
				if !opts.Filter && len(m.InfraAnnotations) != len(o.InfraAnnotations) {
					return false
				}
				for k, _ := range o.InfraAnnotations {
					_, ok := m.InfraAnnotations[k]
					if !ok {
						return false
					}
					if o.InfraAnnotations[k] != m.InfraAnnotations[k] {
						return false
					}
				}
			}
		}
	}
	return true
}

const ClusterInstInfoFieldKey = "2"
const ClusterInstInfoFieldKeyName = "2.1"
const ClusterInstInfoFieldKeyOrganization = "2.2"
const ClusterInstInfoFieldNotifyId = "3"
const ClusterInstInfoFieldState = "4"
const ClusterInstInfoFieldErrors = "5"
const ClusterInstInfoFieldStatus = "6"
const ClusterInstInfoFieldStatusTaskNumber = "6.1"
const ClusterInstInfoFieldStatusMaxTasks = "6.2"
const ClusterInstInfoFieldStatusTaskName = "6.3"
const ClusterInstInfoFieldStatusStepName = "6.4"
const ClusterInstInfoFieldStatusMsgCount = "6.5"
const ClusterInstInfoFieldStatusMsgs = "6.6"
const ClusterInstInfoFieldResources = "7"
const ClusterInstInfoFieldResourcesVms = "7.1"
const ClusterInstInfoFieldResourcesVmsName = "7.1.1"
const ClusterInstInfoFieldResourcesVmsType = "7.1.2"
const ClusterInstInfoFieldResourcesVmsStatus = "7.1.3"
const ClusterInstInfoFieldResourcesVmsInfraFlavor = "7.1.4"
const ClusterInstInfoFieldResourcesVmsIpaddresses = "7.1.5"
const ClusterInstInfoFieldResourcesVmsIpaddressesExternalIp = "7.1.5.1"
const ClusterInstInfoFieldResourcesVmsIpaddressesInternalIp = "7.1.5.2"
const ClusterInstInfoFieldResourcesVmsContainers = "7.1.6"
const ClusterInstInfoFieldResourcesVmsContainersName = "7.1.6.1"
const ClusterInstInfoFieldResourcesVmsContainersType = "7.1.6.2"
const ClusterInstInfoFieldResourcesVmsContainersStatus = "7.1.6.3"
const ClusterInstInfoFieldResourcesVmsContainersClusterip = "7.1.6.4"
const ClusterInstInfoFieldResourcesVmsContainersRestarts = "7.1.6.5"
const ClusterInstInfoFieldInfraAnnotations = "45"
const ClusterInstInfoFieldInfraAnnotationsKey = "45.1"
const ClusterInstInfoFieldInfraAnnotationsValue = "45.2"

var ClusterInstInfoAllFields = []string{
	ClusterInstInfoFieldKeyName,
	ClusterInstInfoFieldKeyOrganization,
	ClusterInstInfoFieldNotifyId,
	ClusterInstInfoFieldState,
	ClusterInstInfoFieldErrors,
	ClusterInstInfoFieldStatusTaskNumber,
	ClusterInstInfoFieldStatusMaxTasks,
	ClusterInstInfoFieldStatusTaskName,
	ClusterInstInfoFieldStatusStepName,
	ClusterInstInfoFieldStatusMsgCount,
	ClusterInstInfoFieldStatusMsgs,
	ClusterInstInfoFieldResourcesVmsName,
	ClusterInstInfoFieldResourcesVmsType,
	ClusterInstInfoFieldResourcesVmsStatus,
	ClusterInstInfoFieldResourcesVmsInfraFlavor,
	ClusterInstInfoFieldResourcesVmsIpaddressesExternalIp,
	ClusterInstInfoFieldResourcesVmsIpaddressesInternalIp,
	ClusterInstInfoFieldResourcesVmsContainersName,
	ClusterInstInfoFieldResourcesVmsContainersType,
	ClusterInstInfoFieldResourcesVmsContainersStatus,
	ClusterInstInfoFieldResourcesVmsContainersClusterip,
	ClusterInstInfoFieldResourcesVmsContainersRestarts,
	ClusterInstInfoFieldInfraAnnotationsKey,
	ClusterInstInfoFieldInfraAnnotationsValue,
}

var ClusterInstInfoAllFieldsMap = NewFieldMap(map[string]struct{}{
	ClusterInstInfoFieldKeyName:                           struct{}{},
	ClusterInstInfoFieldKeyOrganization:                   struct{}{},
	ClusterInstInfoFieldNotifyId:                          struct{}{},
	ClusterInstInfoFieldState:                             struct{}{},
	ClusterInstInfoFieldErrors:                            struct{}{},
	ClusterInstInfoFieldStatusTaskNumber:                  struct{}{},
	ClusterInstInfoFieldStatusMaxTasks:                    struct{}{},
	ClusterInstInfoFieldStatusTaskName:                    struct{}{},
	ClusterInstInfoFieldStatusStepName:                    struct{}{},
	ClusterInstInfoFieldStatusMsgCount:                    struct{}{},
	ClusterInstInfoFieldStatusMsgs:                        struct{}{},
	ClusterInstInfoFieldResourcesVmsName:                  struct{}{},
	ClusterInstInfoFieldResourcesVmsType:                  struct{}{},
	ClusterInstInfoFieldResourcesVmsStatus:                struct{}{},
	ClusterInstInfoFieldResourcesVmsInfraFlavor:           struct{}{},
	ClusterInstInfoFieldResourcesVmsIpaddressesExternalIp: struct{}{},
	ClusterInstInfoFieldResourcesVmsIpaddressesInternalIp: struct{}{},
	ClusterInstInfoFieldResourcesVmsContainersName:        struct{}{},
	ClusterInstInfoFieldResourcesVmsContainersType:        struct{}{},
	ClusterInstInfoFieldResourcesVmsContainersStatus:      struct{}{},
	ClusterInstInfoFieldResourcesVmsContainersClusterip:   struct{}{},
	ClusterInstInfoFieldResourcesVmsContainersRestarts:    struct{}{},
	ClusterInstInfoFieldInfraAnnotationsKey:               struct{}{},
	ClusterInstInfoFieldInfraAnnotationsValue:             struct{}{},
})

var ClusterInstInfoAllFieldsStringMap = map[string]string{
	ClusterInstInfoFieldKeyName:                           "Key Name",
	ClusterInstInfoFieldKeyOrganization:                   "Key Organization",
	ClusterInstInfoFieldNotifyId:                          "Notify Id",
	ClusterInstInfoFieldState:                             "State",
	ClusterInstInfoFieldErrors:                            "Errors",
	ClusterInstInfoFieldStatusTaskNumber:                  "Status Task Number",
	ClusterInstInfoFieldStatusMaxTasks:                    "Status Max Tasks",
	ClusterInstInfoFieldStatusTaskName:                    "Status Task Name",
	ClusterInstInfoFieldStatusStepName:                    "Status Step Name",
	ClusterInstInfoFieldStatusMsgCount:                    "Status Msg Count",
	ClusterInstInfoFieldStatusMsgs:                        "Status Msgs",
	ClusterInstInfoFieldResourcesVmsName:                  "Resources Vms Name",
	ClusterInstInfoFieldResourcesVmsType:                  "Resources Vms Type",
	ClusterInstInfoFieldResourcesVmsStatus:                "Resources Vms Status",
	ClusterInstInfoFieldResourcesVmsInfraFlavor:           "Resources Vms Infra Flavor",
	ClusterInstInfoFieldResourcesVmsIpaddressesExternalIp: "Resources Vms Ipaddresses External Ip",
	ClusterInstInfoFieldResourcesVmsIpaddressesInternalIp: "Resources Vms Ipaddresses Internal Ip",
	ClusterInstInfoFieldResourcesVmsContainersName:        "Resources Vms Containers Name",
	ClusterInstInfoFieldResourcesVmsContainersType:        "Resources Vms Containers Type",
	ClusterInstInfoFieldResourcesVmsContainersStatus:      "Resources Vms Containers Status",
	ClusterInstInfoFieldResourcesVmsContainersClusterip:   "Resources Vms Containers Clusterip",
	ClusterInstInfoFieldResourcesVmsContainersRestarts:    "Resources Vms Containers Restarts",
	ClusterInstInfoFieldInfraAnnotationsKey:               "Infra Annotations Key",
	ClusterInstInfoFieldInfraAnnotationsValue:             "Infra Annotations Value",
}

func (m *ClusterInstInfo) IsKeyField(s string) bool {
	return strings.HasPrefix(s, ClusterInstInfoFieldKey+".") || s == ClusterInstInfoFieldKey
}

func (m *ClusterInstInfo) DiffFields(o *ClusterInstInfo, fields *FieldMap) {
	if m.Key.Name != o.Key.Name {
		fields.Set(ClusterInstInfoFieldKeyName)
		fields.Set(ClusterInstInfoFieldKey)
	}
	if m.Key.Organization != o.Key.Organization {
		fields.Set(ClusterInstInfoFieldKeyOrganization)
		fields.Set(ClusterInstInfoFieldKey)
	}
	if m.NotifyId != o.NotifyId {
		fields.Set(ClusterInstInfoFieldNotifyId)
	}
	if m.State != o.State {
		fields.Set(ClusterInstInfoFieldState)
	}
	if len(m.Errors) != len(o.Errors) {
		fields.Set(ClusterInstInfoFieldErrors)
	} else {
		for i0 := 0; i0 < len(m.Errors); i0++ {
			if m.Errors[i0] != o.Errors[i0] {
				fields.Set(ClusterInstInfoFieldErrors)
				break
			}
		}
	}
	if m.Status.TaskNumber != o.Status.TaskNumber {
		fields.Set(ClusterInstInfoFieldStatusTaskNumber)
		fields.Set(ClusterInstInfoFieldStatus)
	}
	if m.Status.MaxTasks != o.Status.MaxTasks {
		fields.Set(ClusterInstInfoFieldStatusMaxTasks)
		fields.Set(ClusterInstInfoFieldStatus)
	}
	if m.Status.TaskName != o.Status.TaskName {
		fields.Set(ClusterInstInfoFieldStatusTaskName)
		fields.Set(ClusterInstInfoFieldStatus)
	}
	if m.Status.StepName != o.Status.StepName {
		fields.Set(ClusterInstInfoFieldStatusStepName)
		fields.Set(ClusterInstInfoFieldStatus)
	}
	if m.Status.MsgCount != o.Status.MsgCount {
		fields.Set(ClusterInstInfoFieldStatusMsgCount)
		fields.Set(ClusterInstInfoFieldStatus)
	}
	if len(m.Status.Msgs) != len(o.Status.Msgs) {
		fields.Set(ClusterInstInfoFieldStatusMsgs)
		fields.Set(ClusterInstInfoFieldStatus)
	} else {
		for i1 := 0; i1 < len(m.Status.Msgs); i1++ {
			if m.Status.Msgs[i1] != o.Status.Msgs[i1] {
				fields.Set(ClusterInstInfoFieldStatusMsgs)
				fields.Set(ClusterInstInfoFieldStatus)
				break
			}
		}
	}
	if len(m.Resources.Vms) != len(o.Resources.Vms) {
		fields.Set(ClusterInstInfoFieldResourcesVms)
		fields.Set(ClusterInstInfoFieldResources)
	} else {
		for i1 := 0; i1 < len(m.Resources.Vms); i1++ {
			if m.Resources.Vms[i1].Name != o.Resources.Vms[i1].Name {
				fields.Set(ClusterInstInfoFieldResourcesVmsName)
				fields.Set(ClusterInstInfoFieldResourcesVms)
				fields.Set(ClusterInstInfoFieldResources)
			}
			if m.Resources.Vms[i1].Type != o.Resources.Vms[i1].Type {
				fields.Set(ClusterInstInfoFieldResourcesVmsType)
				fields.Set(ClusterInstInfoFieldResourcesVms)
				fields.Set(ClusterInstInfoFieldResources)
			}
			if m.Resources.Vms[i1].Status != o.Resources.Vms[i1].Status {
				fields.Set(ClusterInstInfoFieldResourcesVmsStatus)
				fields.Set(ClusterInstInfoFieldResourcesVms)
				fields.Set(ClusterInstInfoFieldResources)
			}
			if m.Resources.Vms[i1].InfraFlavor != o.Resources.Vms[i1].InfraFlavor {
				fields.Set(ClusterInstInfoFieldResourcesVmsInfraFlavor)
				fields.Set(ClusterInstInfoFieldResourcesVms)
				fields.Set(ClusterInstInfoFieldResources)
			}
			if len(m.Resources.Vms[i1].Ipaddresses) != len(o.Resources.Vms[i1].Ipaddresses) {
				fields.Set(ClusterInstInfoFieldResourcesVmsIpaddresses)
				fields.Set(ClusterInstInfoFieldResourcesVms)
				fields.Set(ClusterInstInfoFieldResources)
			} else {
				for i2 := 0; i2 < len(m.Resources.Vms[i1].Ipaddresses); i2++ {
					if m.Resources.Vms[i1].Ipaddresses[i2].ExternalIp != o.Resources.Vms[i1].Ipaddresses[i2].ExternalIp {
						fields.Set(ClusterInstInfoFieldResourcesVmsIpaddressesExternalIp)
						fields.Set(ClusterInstInfoFieldResourcesVmsIpaddresses)
						fields.Set(ClusterInstInfoFieldResourcesVms)
						fields.Set(ClusterInstInfoFieldResources)
					}
					if m.Resources.Vms[i1].Ipaddresses[i2].InternalIp != o.Resources.Vms[i1].Ipaddresses[i2].InternalIp {
						fields.Set(ClusterInstInfoFieldResourcesVmsIpaddressesInternalIp)
						fields.Set(ClusterInstInfoFieldResourcesVmsIpaddresses)
						fields.Set(ClusterInstInfoFieldResourcesVms)
						fields.Set(ClusterInstInfoFieldResources)
					}
				}
			}
			if m.Resources.Vms[i1].Containers != nil && o.Resources.Vms[i1].Containers != nil {
				if len(m.Resources.Vms[i1].Containers) != len(o.Resources.Vms[i1].Containers) {
					fields.Set(ClusterInstInfoFieldResourcesVmsContainers)
					fields.Set(ClusterInstInfoFieldResourcesVms)
					fields.Set(ClusterInstInfoFieldResources)
				} else {
					for i2 := 0; i2 < len(m.Resources.Vms[i1].Containers); i2++ {
						if m.Resources.Vms[i1].Containers[i2].Name != o.Resources.Vms[i1].Containers[i2].Name {
							fields.Set(ClusterInstInfoFieldResourcesVmsContainersName)
							fields.Set(ClusterInstInfoFieldResourcesVmsContainers)
							fields.Set(ClusterInstInfoFieldResourcesVms)
							fields.Set(ClusterInstInfoFieldResources)
						}
						if m.Resources.Vms[i1].Containers[i2].Type != o.Resources.Vms[i1].Containers[i2].Type {
							fields.Set(ClusterInstInfoFieldResourcesVmsContainersType)
							fields.Set(ClusterInstInfoFieldResourcesVmsContainers)
							fields.Set(ClusterInstInfoFieldResourcesVms)
							fields.Set(ClusterInstInfoFieldResources)
						}
						if m.Resources.Vms[i1].Containers[i2].Status != o.Resources.Vms[i1].Containers[i2].Status {
							fields.Set(ClusterInstInfoFieldResourcesVmsContainersStatus)
							fields.Set(ClusterInstInfoFieldResourcesVmsContainers)
							fields.Set(ClusterInstInfoFieldResourcesVms)
							fields.Set(ClusterInstInfoFieldResources)
						}
						if m.Resources.Vms[i1].Containers[i2].Clusterip != o.Resources.Vms[i1].Containers[i2].Clusterip {
							fields.Set(ClusterInstInfoFieldResourcesVmsContainersClusterip)
							fields.Set(ClusterInstInfoFieldResourcesVmsContainers)
							fields.Set(ClusterInstInfoFieldResourcesVms)
							fields.Set(ClusterInstInfoFieldResources)
						}
						if m.Resources.Vms[i1].Containers[i2].Restarts != o.Resources.Vms[i1].Containers[i2].Restarts {
							fields.Set(ClusterInstInfoFieldResourcesVmsContainersRestarts)
							fields.Set(ClusterInstInfoFieldResourcesVmsContainers)
							fields.Set(ClusterInstInfoFieldResourcesVms)
							fields.Set(ClusterInstInfoFieldResources)
						}
					}
				}
			} else if (m.Resources.Vms[i1].Containers != nil && o.Resources.Vms[i1].Containers == nil) || (m.Resources.Vms[i1].Containers == nil && o.Resources.Vms[i1].Containers != nil) {
				fields.Set(ClusterInstInfoFieldResourcesVmsContainers)
				fields.Set(ClusterInstInfoFieldResourcesVms)
				fields.Set(ClusterInstInfoFieldResources)
			}
		}
	}
	if m.InfraAnnotations != nil && o.InfraAnnotations != nil {
		if len(m.InfraAnnotations) != len(o.InfraAnnotations) {
			fields.Set(ClusterInstInfoFieldInfraAnnotations)
		} else {
			for k0, _ := range m.InfraAnnotations {
				_, vok0 := o.InfraAnnotations[k0]
				if !vok0 {
					fields.Set(ClusterInstInfoFieldInfraAnnotations)
				} else {
					if m.InfraAnnotations[k0] != o.InfraAnnotations[k0] {
						fields.Set(ClusterInstInfoFieldInfraAnnotations)
						break
					}
				}
			}
		}
	} else if (m.InfraAnnotations != nil && o.InfraAnnotations == nil) || (m.InfraAnnotations == nil && o.InfraAnnotations != nil) {
		fields.Set(ClusterInstInfoFieldInfraAnnotations)
	}
}

func (m *ClusterInstInfo) GetDiffFields(o *ClusterInstInfo) *FieldMap {
	diffFields := NewFieldMap(nil)
	m.DiffFields(o, diffFields)
	return diffFields
}

func (m *ClusterInstInfo) Clone() *ClusterInstInfo {
	cp := &ClusterInstInfo{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *ClusterInstInfo) AddErrors(vals ...string) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.Errors {
		cur[v] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v]; found {
			continue // duplicate
		}
		m.Errors = append(m.Errors, v)
		changes++
	}
	return changes
}

func (m *ClusterInstInfo) RemoveErrors(vals ...string) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v] = struct{}{}
	}
	for i := len(m.Errors); i >= 0; i-- {
		if _, found := remove[m.Errors[i]]; found {
			m.Errors = append(m.Errors[:i], m.Errors[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *ClusterInstInfo) AddStatusMsgs(vals ...string) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.Status.Msgs {
		cur[v] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v]; found {
			continue // duplicate
		}
		m.Status.Msgs = append(m.Status.Msgs, v)
		changes++
	}
	return changes
}

func (m *ClusterInstInfo) RemoveStatusMsgs(vals ...string) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v] = struct{}{}
	}
	for i := len(m.Status.Msgs); i >= 0; i-- {
		if _, found := remove[m.Status.Msgs[i]]; found {
			m.Status.Msgs = append(m.Status.Msgs[:i], m.Status.Msgs[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *ClusterInstInfo) AddResourcesVms(vals ...VmInfo) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.Resources.Vms {
		cur[v.String()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.String()]; found {
			continue // duplicate
		}
		m.Resources.Vms = append(m.Resources.Vms, v)
		changes++
	}
	return changes
}

func (m *ClusterInstInfo) RemoveResourcesVms(vals ...VmInfo) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.String()] = struct{}{}
	}
	for i := len(m.Resources.Vms); i >= 0; i-- {
		if _, found := remove[m.Resources.Vms[i].String()]; found {
			m.Resources.Vms = append(m.Resources.Vms[:i], m.Resources.Vms[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *ClusterInstInfo) CopyInFields(src *ClusterInstInfo) int {
	updateListAction := "replace"
	changed := 0
	fmap := MakeFieldMap(src.Fields)
	if fmap.HasOrHasChild("2") {
		if fmap.Has("2.1") {
			if m.Key.Name != src.Key.Name {
				m.Key.Name = src.Key.Name
				changed++
			}
		}
		if fmap.Has("2.2") {
			if m.Key.Organization != src.Key.Organization {
				m.Key.Organization = src.Key.Organization
				changed++
			}
		}
	}
	if fmap.Has("3") {
		if m.NotifyId != src.NotifyId {
			m.NotifyId = src.NotifyId
			changed++
		}
	}
	if fmap.Has("4") {
		if m.State != src.State {
			m.State = src.State
			changed++
		}
	}
	if fmap.Has("5") {
		if src.Errors != nil {
			if updateListAction == "add" {
				changed += m.AddErrors(src.Errors...)
			} else if updateListAction == "remove" {
				changed += m.RemoveErrors(src.Errors...)
			} else {
				m.Errors = make([]string, 0)
				m.Errors = append(m.Errors, src.Errors...)
				changed++
			}
		} else if m.Errors != nil {
			m.Errors = nil
			changed++
		}
	}
	if fmap.HasOrHasChild("6") {
		if fmap.Has("6.1") {
			if m.Status.TaskNumber != src.Status.TaskNumber {
				m.Status.TaskNumber = src.Status.TaskNumber
				changed++
			}
		}
		if fmap.Has("6.2") {
			if m.Status.MaxTasks != src.Status.MaxTasks {
				m.Status.MaxTasks = src.Status.MaxTasks
				changed++
			}
		}
		if fmap.Has("6.3") {
			if m.Status.TaskName != src.Status.TaskName {
				m.Status.TaskName = src.Status.TaskName
				changed++
			}
		}
		if fmap.Has("6.4") {
			if m.Status.StepName != src.Status.StepName {
				m.Status.StepName = src.Status.StepName
				changed++
			}
		}
		if fmap.Has("6.5") {
			if m.Status.MsgCount != src.Status.MsgCount {
				m.Status.MsgCount = src.Status.MsgCount
				changed++
			}
		}
		if fmap.Has("6.6") {
			if src.Status.Msgs != nil {
				if updateListAction == "add" {
					changed += m.AddStatusMsgs(src.Status.Msgs...)
				} else if updateListAction == "remove" {
					changed += m.RemoveStatusMsgs(src.Status.Msgs...)
				} else {
					m.Status.Msgs = make([]string, 0)
					m.Status.Msgs = append(m.Status.Msgs, src.Status.Msgs...)
					changed++
				}
			} else if m.Status.Msgs != nil {
				m.Status.Msgs = nil
				changed++
			}
		}
	}
	if fmap.HasOrHasChild("7") {
		if fmap.HasOrHasChild("7.1") {
			if src.Resources.Vms != nil {
				if updateListAction == "add" {
					changed += m.AddResourcesVms(src.Resources.Vms...)
				} else if updateListAction == "remove" {
					changed += m.RemoveResourcesVms(src.Resources.Vms...)
				} else {
					m.Resources.Vms = make([]VmInfo, 0)
					for k1, _ := range src.Resources.Vms {
						m.Resources.Vms = append(m.Resources.Vms, *src.Resources.Vms[k1].Clone())
					}
					changed++
				}
			} else if m.Resources.Vms != nil {
				m.Resources.Vms = nil
				changed++
			}
		}
	}
	if fmap.HasOrHasChild("45") {
		if src.InfraAnnotations != nil {
			if updateListAction == "add" {
				for k0, v := range src.InfraAnnotations {
					m.InfraAnnotations[k0] = v
					changed++
				}
			} else if updateListAction == "remove" {
				for k0, _ := range src.InfraAnnotations {
					if _, ok := m.InfraAnnotations[k0]; ok {
						delete(m.InfraAnnotations, k0)
						changed++
					}
				}
			} else {
				m.InfraAnnotations = make(map[string]string)
				for k0, v := range src.InfraAnnotations {
					m.InfraAnnotations[k0] = v
				}
				changed++
			}
		} else if m.InfraAnnotations != nil {
			m.InfraAnnotations = nil
			changed++
		}
	}
	return changed
}

func (m *ClusterInstInfo) DeepCopyIn(src *ClusterInstInfo) {
	m.Key.DeepCopyIn(&src.Key)
	m.NotifyId = src.NotifyId
	m.State = src.State
	if src.Errors != nil {
		m.Errors = make([]string, len(src.Errors), len(src.Errors))
		for ii, s := range src.Errors {
			m.Errors[ii] = s
		}
	} else {
		m.Errors = nil
	}
	m.Status.DeepCopyIn(&src.Status)
	m.Resources.DeepCopyIn(&src.Resources)
	if src.InfraAnnotations != nil {
		m.InfraAnnotations = make(map[string]string)
		for k, v := range src.InfraAnnotations {
			m.InfraAnnotations[k] = v
		}
	} else {
		m.InfraAnnotations = nil
	}
}

func (s *ClusterInstInfo) HasFields() bool {
	return true
}

type ClusterInstInfoStore interface {
	Create(ctx context.Context, m *ClusterInstInfo, wait func(int64)) (*Result, error)
	Update(ctx context.Context, m *ClusterInstInfo, wait func(int64)) (*Result, error)
	Delete(ctx context.Context, m *ClusterInstInfo, wait func(int64)) (*Result, error)
	Put(ctx context.Context, m *ClusterInstInfo, wait func(int64), ops ...objstore.KVOp) (*Result, error)
	LoadOne(key string) (*ClusterInstInfo, int64, error)
	Get(ctx context.Context, key *ClusterKey, buf *ClusterInstInfo) bool
	STMGet(stm concurrency.STM, key *ClusterKey, buf *ClusterInstInfo) bool
	STMPut(stm concurrency.STM, obj *ClusterInstInfo, ops ...objstore.KVOp)
	STMDel(stm concurrency.STM, key *ClusterKey)
	STMHas(stm concurrency.STM, key *ClusterKey) bool
}

type ClusterInstInfoStoreImpl struct {
	kvstore objstore.KVStore
}

func NewClusterInstInfoStore(kvstore objstore.KVStore) *ClusterInstInfoStoreImpl {
	return &ClusterInstInfoStoreImpl{kvstore: kvstore}
}

func (s *ClusterInstInfoStoreImpl) Create(ctx context.Context, m *ClusterInstInfo, wait func(int64)) (*Result, error) {
	err := m.Validate(ClusterInstInfoAllFieldsMap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("ClusterInstInfo", m.GetKey())
	val, err := json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Create(ctx, key, string(val))
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *ClusterInstInfoStoreImpl) Update(ctx context.Context, m *ClusterInstInfo, wait func(int64)) (*Result, error) {
	fmap := MakeFieldMap(m.Fields)
	err := m.Validate(fmap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("ClusterInstInfo", m.GetKey())
	var vers int64 = 0
	curBytes, vers, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, err
	}
	var cur ClusterInstInfo
	err = json.Unmarshal(curBytes, &cur)
	if err != nil {
		return nil, err
	}
	cur.CopyInFields(m)
	// never save fields
	cur.Fields = nil
	val, err := json.Marshal(cur)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Update(ctx, key, string(val), vers)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *ClusterInstInfoStoreImpl) Put(ctx context.Context, m *ClusterInstInfo, wait func(int64), ops ...objstore.KVOp) (*Result, error) {
	err := m.Validate(ClusterInstInfoAllFieldsMap)
	m.Fields = nil
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("ClusterInstInfo", m.GetKey())
	var val []byte
	val, err = json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Put(ctx, key, string(val), ops...)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *ClusterInstInfoStoreImpl) Delete(ctx context.Context, m *ClusterInstInfo, wait func(int64)) (*Result, error) {
	err := m.GetKey().ValidateKey()
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("ClusterInstInfo", m.GetKey())
	rev, err := s.kvstore.Delete(ctx, key)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *ClusterInstInfoStoreImpl) LoadOne(key string) (*ClusterInstInfo, int64, error) {
	val, rev, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, 0, err
	}
	var obj ClusterInstInfo
	err = json.Unmarshal(val, &obj)
	if err != nil {
		log.DebugLog(log.DebugLevelApi, "Failed to parse ClusterInstInfo data", "val", string(val), "err", err)
		return nil, 0, err
	}
	return &obj, rev, nil
}

func (s *ClusterInstInfoStoreImpl) Get(ctx context.Context, key *ClusterKey, buf *ClusterInstInfo) bool {
	keystr := objstore.DbKeyString("ClusterInstInfo", key)
	val, _, _, err := s.kvstore.Get(keystr)
	if err != nil {
		return false
	}
	return s.parseGetData(val, buf)
}

func (s *ClusterInstInfoStoreImpl) STMGet(stm concurrency.STM, key *ClusterKey, buf *ClusterInstInfo) bool {
	keystr := objstore.DbKeyString("ClusterInstInfo", key)
	valstr := stm.Get(keystr)
	return s.parseGetData([]byte(valstr), buf)
}

func (s *ClusterInstInfoStoreImpl) STMHas(stm concurrency.STM, key *ClusterKey) bool {
	keystr := objstore.DbKeyString("ClusterInstInfo", key)
	return stm.Get(keystr) != ""
}

func (s *ClusterInstInfoStoreImpl) parseGetData(val []byte, buf *ClusterInstInfo) bool {
	if len(val) == 0 {
		return false
	}
	if buf != nil {
		// clear buf, because empty values in val won't
		// overwrite non-empty values in buf.
		*buf = ClusterInstInfo{}
		err := json.Unmarshal(val, buf)
		if err != nil {
			return false
		}
	}
	return true
}

func (s *ClusterInstInfoStoreImpl) STMPut(stm concurrency.STM, obj *ClusterInstInfo, ops ...objstore.KVOp) {
	keystr := objstore.DbKeyString("ClusterInstInfo", obj.GetKey())

	val, err := json.Marshal(obj)
	if err != nil {
		log.InfoLog("ClusterInstInfo json marshal failed", "obj", obj, "err", err)
	}
	v3opts := GetSTMOpts(ops...)
	stm.Put(keystr, string(val), v3opts...)
}

func (s *ClusterInstInfoStoreImpl) STMDel(stm concurrency.STM, key *ClusterKey) {
	keystr := objstore.DbKeyString("ClusterInstInfo", key)
	stm.Del(keystr)
}

func StoreListClusterInstInfo(ctx context.Context, kvstore objstore.KVStore) ([]ClusterInstInfo, error) {
	keyPrefix := objstore.DbKeyPrefixString("ClusterInstInfo") + "/"
	objs := []ClusterInstInfo{}
	err := kvstore.List(keyPrefix, func(key, val []byte, rev, modRev int64) error {
		obj := ClusterInstInfo{}
		err := json.Unmarshal(val, &obj)
		if err != nil {
			return fmt.Errorf("failed to unmarshal ClusterInstInfo json %s, %s", string(val), err)
		}
		objs = append(objs, obj)
		return nil
	})
	return objs, err
}

type ClusterInstInfoKeyWatcher struct {
	cb func(ctx context.Context)
}

type ClusterInstInfoCacheData struct {
	Obj    *ClusterInstInfo
	ModRev int64
}

func (s *ClusterInstInfoCacheData) Clone() *ClusterInstInfoCacheData {
	cp := ClusterInstInfoCacheData{}
	if s.Obj != nil {
		cp.Obj = &ClusterInstInfo{}
		cp.Obj.DeepCopyIn(s.Obj)
	}
	cp.ModRev = s.ModRev
	return &cp
}

// ClusterInstInfoCache caches ClusterInstInfo objects in memory in a hash table
// and keeps them in sync with the database.
type ClusterInstInfoCache struct {
	Objs          map[ClusterKey]*ClusterInstInfoCacheData
	Mux           util.Mutex
	List          map[ClusterKey]struct{}
	FlushAll      bool
	NotifyCbs     []func(ctx context.Context, obj *ClusterInstInfo, modRev int64)
	UpdatedCbs    []func(ctx context.Context, old *ClusterInstInfo, new *ClusterInstInfo)
	DeletedCbs    []func(ctx context.Context, old *ClusterInstInfo)
	KeyWatchers   map[ClusterKey][]*ClusterInstInfoKeyWatcher
	UpdatedKeyCbs []func(ctx context.Context, key *ClusterKey)
	DeletedKeyCbs []func(ctx context.Context, key *ClusterKey)
	Store         ClusterInstInfoStore
}

func NewClusterInstInfoCache() *ClusterInstInfoCache {
	cache := ClusterInstInfoCache{}
	InitClusterInstInfoCache(&cache)
	return &cache
}

func InitClusterInstInfoCache(cache *ClusterInstInfoCache) {
	cache.Objs = make(map[ClusterKey]*ClusterInstInfoCacheData)
	cache.KeyWatchers = make(map[ClusterKey][]*ClusterInstInfoKeyWatcher)
	cache.NotifyCbs = nil
	cache.UpdatedCbs = nil
	cache.DeletedCbs = nil
	cache.UpdatedKeyCbs = nil
	cache.DeletedKeyCbs = nil
}

func (c *ClusterInstInfoCache) GetTypeString() string {
	return "ClusterInstInfo"
}

func (c *ClusterInstInfoCache) Get(key *ClusterKey, valbuf *ClusterInstInfo) bool {
	var modRev int64
	return c.GetWithRev(key, valbuf, &modRev)
}

// STMGet gets from the store if STM is set, otherwise gets from cache
func (c *ClusterInstInfoCache) STMGet(ostm *OptionalSTM, key *ClusterKey, valbuf *ClusterInstInfo) bool {
	if ostm.stm != nil {
		if c.Store == nil {
			// panic, otherwise if we fallback to cache, we may silently
			// introduce race conditions and intermittent failures due to
			// reading from cache during a transaction.
			panic("ClusterInstInfoCache store not set, cannot read via STM")
		}
		return c.Store.STMGet(ostm.stm, key, valbuf)
	}
	var modRev int64
	return c.GetWithRev(key, valbuf, &modRev)
}

func (c *ClusterInstInfoCache) GetWithRev(key *ClusterKey, valbuf *ClusterInstInfo, modRev *int64) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	inst, found := c.Objs[*key]
	if found {
		valbuf.DeepCopyIn(inst.Obj)
		*modRev = inst.ModRev
	}
	return found
}

func (c *ClusterInstInfoCache) HasKey(key *ClusterKey) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	_, found := c.Objs[*key]
	return found
}

func (c *ClusterInstInfoCache) GetAllKeys(ctx context.Context, cb func(key *ClusterKey, modRev int64)) {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for key, data := range c.Objs {
		cb(&key, data.ModRev)
	}
}

func (c *ClusterInstInfoCache) GetAllLocked(ctx context.Context, cb func(obj *ClusterInstInfo, modRev int64)) {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for _, data := range c.Objs {
		cb(data.Obj, data.ModRev)
	}
}

func (c *ClusterInstInfoCache) Update(ctx context.Context, in *ClusterInstInfo, modRev int64) {
	c.UpdateModFunc(ctx, in.GetKey(), modRev, func(old *ClusterInstInfo) (*ClusterInstInfo, bool) {
		return in, true
	})
}

func (c *ClusterInstInfoCache) UpdateModFunc(ctx context.Context, key *ClusterKey, modRev int64, modFunc func(old *ClusterInstInfo) (new *ClusterInstInfo, changed bool)) {
	c.Mux.Lock()
	var old *ClusterInstInfo
	if oldData, found := c.Objs[*key]; found {
		old = oldData.Obj
	}
	new, changed := modFunc(old)
	if !changed {
		c.Mux.Unlock()
		return
	}
	if len(c.UpdatedCbs) > 0 || len(c.NotifyCbs) > 0 {
		newCopy := &ClusterInstInfo{}
		newCopy.DeepCopyIn(new)
		for _, cb := range c.UpdatedCbs {
			defer cb(ctx, old, newCopy)
		}
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				defer cb(ctx, newCopy, modRev)
			}
		}
	}
	for _, cb := range c.UpdatedKeyCbs {
		defer cb(ctx, key)
	}
	store := &ClusterInstInfo{}
	store.DeepCopyIn(new)
	c.Objs[new.GetKeyVal()] = &ClusterInstInfoCacheData{
		Obj:    store,
		ModRev: modRev,
	}
	log.SpanLog(ctx, log.DebugLevelApi, "cache update", "new", store)
	c.Mux.Unlock()
	c.TriggerKeyWatchers(ctx, new.GetKey())
}

func (c *ClusterInstInfoCache) Delete(ctx context.Context, in *ClusterInstInfo, modRev int64) {
	c.DeleteCondFunc(ctx, in, modRev, func(old *ClusterInstInfo) bool {
		return true
	})
}

func (c *ClusterInstInfoCache) DeleteCondFunc(ctx context.Context, in *ClusterInstInfo, modRev int64, condFunc func(old *ClusterInstInfo) bool) {
	c.Mux.Lock()
	var old *ClusterInstInfo
	oldData, found := c.Objs[in.GetKeyVal()]
	if found {
		old = oldData.Obj
		if !condFunc(old) {
			c.Mux.Unlock()
			return
		}
	}
	delete(c.Objs, in.GetKeyVal())
	log.SpanLog(ctx, log.DebugLevelApi, "cache delete", "key", in.GetKeyVal())
	c.Mux.Unlock()
	obj := old
	if obj == nil {
		obj = in
	}
	for _, cb := range c.NotifyCbs {
		if cb != nil {
			cb(ctx, obj, modRev)
		}
	}
	if old != nil {
		for _, cb := range c.DeletedCbs {
			cb(ctx, old)
		}
	}
	for _, cb := range c.DeletedKeyCbs {
		cb(ctx, in.GetKey())
	}
	c.TriggerKeyWatchers(ctx, in.GetKey())
}

func (c *ClusterInstInfoCache) Prune(ctx context.Context, validKeys map[ClusterKey]struct{}) {
	log.SpanLog(ctx, log.DebugLevelApi, "Prune ClusterInstInfo", "numValidKeys", len(validKeys))
	notify := make(map[ClusterKey]*ClusterInstInfoCacheData)
	c.Mux.Lock()
	for key, _ := range c.Objs {
		if _, ok := validKeys[key]; !ok {
			if len(c.NotifyCbs) > 0 || len(c.DeletedKeyCbs) > 0 || len(c.DeletedCbs) > 0 {
				notify[key] = c.Objs[key]
			}
			delete(c.Objs, key)
		}
	}
	c.Mux.Unlock()
	for key, old := range notify {
		obj := old.Obj
		if obj == nil {
			obj = &ClusterInstInfo{}
			obj.SetKey(&key)
		}
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, obj, old.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if old.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, old.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (c *ClusterInstInfoCache) GetCount() int {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	return len(c.Objs)
}

func (c *ClusterInstInfoCache) Flush(ctx context.Context, notifyId int64) {
	log.SpanLog(ctx, log.DebugLevelApi, "CacheFlush ClusterInstInfo", "notifyId", notifyId, "FlushAll", c.FlushAll)
	flushed := make(map[ClusterKey]*ClusterInstInfoCacheData)
	c.Mux.Lock()
	for key, val := range c.Objs {
		if !c.FlushAll && val.Obj.NotifyId != notifyId {
			continue
		}
		flushed[key] = c.Objs[key]
		log.SpanLog(ctx, log.DebugLevelApi, "CacheFlush ClusterInstInfo delete", "key", key)
		delete(c.Objs, key)
	}
	c.Mux.Unlock()
	if len(flushed) > 0 {
		for key, old := range flushed {
			obj := old.Obj
			if obj == nil {
				obj = &ClusterInstInfo{}
				obj.SetKey(&key)
			}
			for _, cb := range c.NotifyCbs {
				if cb != nil {
					cb(ctx, obj, old.ModRev)
				}
			}
			for _, cb := range c.DeletedKeyCbs {
				cb(ctx, &key)
			}
			if old.Obj != nil {
				for _, cb := range c.DeletedCbs {
					cb(ctx, old.Obj)
				}
			}
			c.TriggerKeyWatchers(ctx, &key)
		}
	}
}

func (c *ClusterInstInfoCache) Show(filter *ClusterInstInfo, cb func(ret *ClusterInstInfo) error) error {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for _, data := range c.Objs {
		if !data.Obj.Matches(filter, MatchFilter()) {
			continue
		}
		err := cb(data.Obj)
		if err != nil {
			return err
		}
	}
	return nil
}

func ClusterInstInfoGenericNotifyCb(fn func(key *ClusterKey, old *ClusterInstInfo)) func(objstore.ObjKey, objstore.Obj) {
	return func(objkey objstore.ObjKey, obj objstore.Obj) {
		fn(objkey.(*ClusterKey), obj.(*ClusterInstInfo))
	}
}

func (c *ClusterInstInfoCache) SetNotifyCb(fn func(ctx context.Context, obj *ClusterInstInfo, modRev int64)) {
	c.NotifyCbs = []func(ctx context.Context, obj *ClusterInstInfo, modRev int64){fn}
}

func (c *ClusterInstInfoCache) SetUpdatedCb(fn func(ctx context.Context, old *ClusterInstInfo, new *ClusterInstInfo)) {
	c.UpdatedCbs = []func(ctx context.Context, old *ClusterInstInfo, new *ClusterInstInfo){fn}
}

func (c *ClusterInstInfoCache) SetDeletedCb(fn func(ctx context.Context, old *ClusterInstInfo)) {
	c.DeletedCbs = []func(ctx context.Context, old *ClusterInstInfo){fn}
}

func (c *ClusterInstInfoCache) SetUpdatedKeyCb(fn func(ctx context.Context, key *ClusterKey)) {
	c.UpdatedKeyCbs = []func(ctx context.Context, key *ClusterKey){fn}
}

func (c *ClusterInstInfoCache) SetDeletedKeyCb(fn func(ctx context.Context, key *ClusterKey)) {
	c.DeletedKeyCbs = []func(ctx context.Context, key *ClusterKey){fn}
}

func (c *ClusterInstInfoCache) AddUpdatedCb(fn func(ctx context.Context, old *ClusterInstInfo, new *ClusterInstInfo)) {
	c.UpdatedCbs = append(c.UpdatedCbs, fn)
}

func (c *ClusterInstInfoCache) AddDeletedCb(fn func(ctx context.Context, old *ClusterInstInfo)) {
	c.DeletedCbs = append(c.DeletedCbs, fn)
}

func (c *ClusterInstInfoCache) AddNotifyCb(fn func(ctx context.Context, obj *ClusterInstInfo, modRev int64)) {
	c.NotifyCbs = append(c.NotifyCbs, fn)
}

func (c *ClusterInstInfoCache) AddUpdatedKeyCb(fn func(ctx context.Context, key *ClusterKey)) {
	c.UpdatedKeyCbs = append(c.UpdatedKeyCbs, fn)
}

func (c *ClusterInstInfoCache) AddDeletedKeyCb(fn func(ctx context.Context, key *ClusterKey)) {
	c.DeletedKeyCbs = append(c.DeletedKeyCbs, fn)
}

func (c *ClusterInstInfoCache) SetFlushAll() {
	c.FlushAll = true
}

func (c *ClusterInstInfoCache) WatchKey(key *ClusterKey, cb func(ctx context.Context)) context.CancelFunc {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	list, ok := c.KeyWatchers[*key]
	if !ok {
		list = make([]*ClusterInstInfoKeyWatcher, 0)
	}
	watcher := ClusterInstInfoKeyWatcher{cb: cb}
	c.KeyWatchers[*key] = append(list, &watcher)
	log.DebugLog(log.DebugLevelApi, "Watching ClusterInstInfo", "key", key)
	return func() {
		c.Mux.Lock()
		defer c.Mux.Unlock()
		list, ok := c.KeyWatchers[*key]
		if !ok {
			return
		}
		for ii, _ := range list {
			if list[ii] != &watcher {
				continue
			}
			if len(list) == 1 {
				delete(c.KeyWatchers, *key)
				return
			}
			list[ii] = list[len(list)-1]
			list[len(list)-1] = nil
			c.KeyWatchers[*key] = list[:len(list)-1]
			return
		}
	}
}

func (c *ClusterInstInfoCache) TriggerKeyWatchers(ctx context.Context, key *ClusterKey) {
	watchers := make([]*ClusterInstInfoKeyWatcher, 0)
	c.Mux.Lock()
	if list, ok := c.KeyWatchers[*key]; ok {
		watchers = append(watchers, list...)
	}
	c.Mux.Unlock()
	for ii, _ := range watchers {
		watchers[ii].cb(ctx)
	}
}

// Note that we explicitly ignore the global revision number, because of the way
// the notify framework sends updates (by hashing keys and doing lookups, instead
// of sequentially through a history buffer), updates may be done out-of-order
// or multiple updates compressed into one update, so the state of the cache at
// any point in time may not by in sync with a particular database revision number.

func (c *ClusterInstInfoCache) SyncUpdate(ctx context.Context, key, val []byte, rev, modRev int64) {
	obj := ClusterInstInfo{}
	err := json.Unmarshal(val, &obj)
	if err != nil {
		log.WarnLog("Failed to parse ClusterInstInfo data", "val", string(val), "err", err)
		return
	}
	c.Update(ctx, &obj, modRev)
	c.Mux.Lock()
	if c.List != nil {
		c.List[obj.GetKeyVal()] = struct{}{}
	}
	c.Mux.Unlock()
}

func (c *ClusterInstInfoCache) SyncDelete(ctx context.Context, key []byte, rev, modRev int64) {
	obj := ClusterInstInfo{}
	keystr := objstore.DbKeyPrefixRemove(string(key))
	ClusterKeyStringParse(keystr, obj.GetKey())
	c.Delete(ctx, &obj, modRev)
}

func (c *ClusterInstInfoCache) SyncListStart(ctx context.Context) {
	c.List = make(map[ClusterKey]struct{})
}

func (c *ClusterInstInfoCache) SyncListEnd(ctx context.Context) {
	deleted := make(map[ClusterKey]*ClusterInstInfoCacheData)
	c.Mux.Lock()
	for key, val := range c.Objs {
		if _, found := c.List[key]; !found {
			deleted[key] = val
			delete(c.Objs, key)
		}
	}
	c.List = nil
	c.Mux.Unlock()
	for key, val := range deleted {
		obj := val.Obj
		if obj == nil {
			obj = &ClusterInstInfo{}
			obj.SetKey(&key)
		}
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, obj, val.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if val.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, val.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (s *ClusterInstInfoCache) InitCacheWithSync(sync DataSync) {
	InitClusterInstInfoCache(s)
	s.InitSync(sync)
}

func (s *ClusterInstInfoCache) InitSync(sync DataSync) {
	if sync != nil {
		s.Store = NewClusterInstInfoStore(sync.GetKVStore())
		sync.RegisterCache(s)
	}
}

func InitClusterInstInfoCacheWithStore(cache *ClusterInstInfoCache, store ClusterInstInfoStore) {
	InitClusterInstInfoCache(cache)
	cache.Store = store
}

// ClusterInstInfoObjectUpdater defines a way of updating a specific ClusterInstInfo
type ClusterInstInfoObjectUpdater interface {
	// Get the current ClusterInstInfo
	Get() *ClusterInstInfo
	// Update the ClusterInstInfo for the specified Fields flags.
	Update(*ClusterInstInfo) error
}

// ClusterInstInfoSender allows for streaming updates to ClusterInstInfo
type ClusterInstInfoSender interface {
	// SendUpdate sends the updated object, fields without field flags set will be ignored
	SendUpdate(updateFn func(update *ClusterInstInfo) error) error
	// SendState sends an updated state. It will clear any errors unless
	// the WithStateError option is specified.
	SendState(state TrackedState, ops ...SenderOp) error
	// SendStatus appends the status message and sends it.
	SendStatus(updateType CacheUpdateType, message string, ops ...SenderOp) error
	// SendStatusIgnoreErr is the same as SendStatus but without error return
	// and without options to be compatible with older code.
	SendStatusIgnoreErr(updateType CacheUpdateType, message string)
}

// ClusterInstInfoSenderHelper implements ClusterInstInfoSender
type ClusterInstInfoSenderHelper struct {
	updater ClusterInstInfoObjectUpdater
}

func (s *ClusterInstInfoSenderHelper) SetUpdater(updater ClusterInstInfoObjectUpdater) {
	s.updater = updater
}

// SendUpdate sends only the updated fields set by the Fields flags.
func (s *ClusterInstInfoSenderHelper) SendUpdate(updateFn func(update *ClusterInstInfo) error) error {
	obj := s.updater.Get()
	if err := updateFn(obj); err != nil {
		return err
	}
	return s.updater.Update(obj)
}

// SendState sends an updated state
func (s *ClusterInstInfoSenderHelper) SendState(state TrackedState, ops ...SenderOp) error {
	opts := GetSenderOptions(ops...)
	obj := s.updater.Get()
	obj.Fields = []string{
		ClusterInstInfoFieldState,
		ClusterInstInfoFieldErrors,
		ClusterInstInfoFieldStatus,
	}
	s.applyOpts(obj, opts)

	if opts.stateErr != nil {
		obj.Errors = []string{opts.stateErr.Error()}
	}
	obj.State = state
	obj.Status.SetTask(TrackedState_CamelName[int32(state)])
	return s.updater.Update(obj)
}

// SendStatus appends the status message and sends it.
func (s *ClusterInstInfoSenderHelper) SendStatus(updateType CacheUpdateType, message string, ops ...SenderOp) error {
	opts := GetSenderOptions(ops...)
	obj := s.updater.Get()
	obj.Fields = []string{
		ClusterInstInfoFieldStatus,
	}
	s.applyOpts(obj, opts)

	switch updateType {
	case UpdateTask:
		obj.Status.SetTask(message)
	case UpdateStep:
		obj.Status.SetStep(message)
	}
	return s.updater.Update(obj)
}

func (s *ClusterInstInfoSenderHelper) SendStatusIgnoreErr(updateType CacheUpdateType, message string) {
	s.SendStatus(updateType, message)
}

func (s *ClusterInstInfoSenderHelper) applyOpts(obj *ClusterInstInfo, opts *SenderOptions) {
	if opts.resetStatus {
		obj.Fields = append(obj.Fields, ClusterInstInfoFieldStatus)
		obj.Status.StatusReset()
	}
}

// ClusterInstInfoCacheUpdater implements ClusterInstInfoSender via a cache
// that can send data over notify.
type ClusterInstInfoCacheUpdater struct {
	ClusterInstInfoSenderHelper
	ctx   context.Context
	key   ClusterKey
	cache *ClusterInstInfoCache
}

func NewClusterInstInfoCacheUpdater(ctx context.Context, cache *ClusterInstInfoCache, key ClusterKey) *ClusterInstInfoCacheUpdater {
	s := &ClusterInstInfoCacheUpdater{
		ctx:   ctx,
		key:   key,
		cache: cache,
	}
	s.SetUpdater(s)
	return s
}

func (s *ClusterInstInfoCacheUpdater) Get() *ClusterInstInfo {
	obj := ClusterInstInfo{}
	if !s.cache.Get(&s.key, &obj) {
		obj.Key = s.key
	}
	return &obj
}

func (s *ClusterInstInfoCacheUpdater) Update(obj *ClusterInstInfo) error {
	s.cache.Update(s.ctx, obj, 0)
	return nil
}

type ClusterInstInfoSendAPI interface {
	Send(*ClusterInstInfo) error
}

// ClusterInstInfoSendUpdater implements ClusterInstInfoObjectUpdater via a generic
// send API. To allow for building up the list of status messages
// which need to accumulate over time, we keep a local copy of
// the object.
type ClusterInstInfoSendUpdater struct {
	ClusterInstInfoSenderHelper
	ctx    context.Context
	sender ClusterInstInfoSendAPI
	local  ClusterInstInfo
	mux    sync.Mutex
}

func NewClusterInstInfoSendUpdater(ctx context.Context, sender ClusterInstInfoSendAPI, key ClusterKey) *ClusterInstInfoSendUpdater {
	s := &ClusterInstInfoSendUpdater{
		ctx:    ctx,
		sender: sender,
	}
	s.local.Key = key
	s.SetUpdater(s)
	return s
}

func (s *ClusterInstInfoSendUpdater) Get() *ClusterInstInfo {
	s.mux.Lock()
	defer s.mux.Unlock()
	cp := ClusterInstInfo{}
	cp.DeepCopyIn(&s.local)
	return &cp
}

func (s *ClusterInstInfoSendUpdater) Update(obj *ClusterInstInfo) error {
	s.mux.Lock()
	s.local.DeepCopyIn(obj)
	s.mux.Unlock()
	return s.sender.Send(obj)
}

// ClusterInstInfoPrintUpdater just prints the updates
type ClusterInstInfoPrintUpdater struct {
	ClusterInstInfoSenderHelper
}

func NewClusterInstInfoPrintUpdater() *ClusterInstInfoPrintUpdater {
	s := &ClusterInstInfoPrintUpdater{}
	s.SetUpdater(s)
	return s
}

func (s *ClusterInstInfoPrintUpdater) Get() *ClusterInstInfo {
	return &ClusterInstInfo{}
}

func (s *ClusterInstInfoPrintUpdater) Update(obj *ClusterInstInfo) error {
	fmt.Printf("%v\n", obj)
	return nil
}

func WaitForClusterInstInfo(ctx context.Context, key *ClusterKey, store ClusterInstStore, targetState TrackedState, transitionStates map[TrackedState]struct{}, errorState TrackedState, successMsg string, send func(*Result) error, opts ...WaitStateOps) error {
	var lastMsgCnt int
	var err error

	handleTargetState := func() {
		if targetState == TrackedState_NOT_PRESENT {
			send(&Result{Message: TrackedState_CamelName[int32(targetState)]})
		}
		if successMsg != "" && send != nil {
			send(&Result{Message: successMsg})
		}
	}

	// State updates come via Redis, since they are bundled with status updates.
	// However, the Redis channel is set up after the Etcd transaction to commit
	// the state change (i.e. CREATE_REQUESTED) in order to treat Etcd as the
	// source of truth for concurrent changes, so there is a small timing window
	// where the state may be updated by the info (from CRM) before the Redis
	// subscription is set up. So here our initial state needs to come from Etcd
	// in case both it and Redis were updated before the crmMsgCh was set up.
	curState := TrackedState_NOT_PRESENT
	buf := ClusterInst{}
	if store.Get(ctx, key, &buf) {
		curState = buf.State
	}
	if curState == targetState {
		handleTargetState()
		return nil
	}

	var wSpec WaitStateSpec
	for _, op := range opts {
		if err := op(&wSpec); err != nil {
			return err
		}
	}

	if wSpec.CrmMsgCh == nil {
		return nil
	}

	for {
		select {
		case chObj := <-wSpec.CrmMsgCh:
			if chObj == nil {
				// Since msg chan is a receive-only chan, it will return nil if
				// connection to redis server is disrupted. But the object might
				// still be in progress. Hence, just show a message about the failure,
				// so that user can manually look at object's progress
				if send != nil {
					msg := fmt.Sprintf("Failed to get progress messages. Please use ShowClusterInst to check current status")
					send(&Result{Message: msg})
				}
				return nil
			}
			info := ClusterInstInfo{}
			err = json.Unmarshal([]byte(chObj.Payload), &info)
			if err != nil {
				return err
			}
			curState = info.State
			log.SpanLog(ctx, log.DebugLevelApi, "Received crm update for ClusterInstInfo", "key", key, "obj", info)
			if send != nil {
				for ii := lastMsgCnt; ii < len(info.Status.Msgs); ii++ {
					send(&Result{Message: info.Status.Msgs[ii]})
				}
				lastMsgCnt = len(info.Status.Msgs)
			}

			switch info.State {
			case errorState:
				errs := strings.Join(info.Errors, ", ")
				if len(info.Errors) == 1 {
					err = fmt.Errorf("%s", errs)
				} else {
					err = fmt.Errorf("Encountered failures: %s", errs)
				}
				return err
			case targetState:
				handleTargetState()
				return nil
			}
		case <-ctx.Done():
			if _, found := transitionStates[curState]; found {
				// no success response, but state is a valid transition
				// state. That means work is still in progress.
				// Notify user that this is not an error.
				// Do not undo since CRM is still busy.
				if send != nil {
					msg := fmt.Sprintf("Timed out while work still in progress state %s. Please use ShowClusterInst to check current status", TrackedState_CamelName[int32(curState)])
					send(&Result{Message: msg})
				}
				err = nil
			} else {
				err = fmt.Errorf("Timed out; expected state %s but is %s",
					TrackedState_CamelName[int32(targetState)],
					TrackedState_CamelName[int32(curState)])
			}
			return err
		}
	}
}

func (c *ClusterInstInfoCache) UsesOrg(org string) bool {
	return false
}

func (m *ClusterInstInfo) GetObjKey() objstore.ObjKey {
	return m.GetKey()
}

func (m *ClusterInstInfo) GetKey() *ClusterKey {
	return &m.Key
}

func (m *ClusterInstInfo) GetKeyVal() ClusterKey {
	return m.Key
}

func (m *ClusterInstInfo) SetKey(key *ClusterKey) {
	m.Key = *key
}

func CmpSortClusterInstInfo(a ClusterInstInfo, b ClusterInstInfo) bool {
	return a.Key.GetKeyString() < b.Key.GetKeyString()
}

// Helper method to check that enums have valid values
// NOTE: ValidateEnums checks all Fields even if some are not set
func (m *ClusterInstInfo) ValidateEnums() error {
	if err := m.Key.ValidateEnums(); err != nil {
		return err
	}
	if _, ok := TrackedState_name[int32(m.State)]; !ok {
		return errors.New("invalid State")
	}
	if err := m.Status.ValidateEnums(); err != nil {
		return err
	}
	if err := m.Resources.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func (s *ClusterInstInfo) ClearTagged(tags map[string]struct{}) {
	s.Key.ClearTagged(tags)
	if _, found := tags["nocmp"]; found {
		s.NotifyId = 0
	}
	s.Status.ClearTagged(tags)
	s.Resources.ClearTagged(tags)
}

func IgnoreClusterInstInfoFields(taglist string) cmp.Option {
	names := []string{}
	tags := make(map[string]struct{})
	for _, tag := range strings.Split(taglist, ",") {
		tags[tag] = struct{}{}
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "NotifyId")
	}
	return cmpopts.IgnoreFields(ClusterInstInfo{}, names...)
}

func (m *ClusterInst) IsValidArgsForCreateClusterInst() error {
	if m.State != 0 {
		return fmt.Errorf("Invalid field specified: State, this field is only for internal use")
	}
	if m.Errors != nil {
		return fmt.Errorf("Invalid field specified: Errors, this field is only for internal use")
	}
	if m.AllocatedIp != "" {
		return fmt.Errorf("Invalid field specified: AllocatedIp, this field is only for internal use")
	}
	if m.Liveness != 0 {
		return fmt.Errorf("Invalid field specified: Liveness, this field is only for internal use")
	}
	if m.Auto != false {
		return fmt.Errorf("Invalid field specified: Auto, this field is only for internal use")
	}
	if m.NodeFlavor != "" {
		return fmt.Errorf("Invalid field specified: NodeFlavor, this field is only for internal use")
	}
	if m.ExternalVolumeSize != 0 {
		return fmt.Errorf("Invalid field specified: ExternalVolumeSize, this field is only for internal use")
	}
	if m.AvailabilityZone != "" {
		return fmt.Errorf("Invalid field specified: AvailabilityZone, this field is only for internal use")
	}
	if m.ReservedBy != "" {
		return fmt.Errorf("Invalid field specified: ReservedBy, this field is only for internal use")
	}
	if m.MasterNodeFlavor != "" {
		return fmt.Errorf("Invalid field specified: MasterNodeFlavor, this field is only for internal use")
	}
	if m.OptRes != "" {
		return fmt.Errorf("Invalid field specified: OptRes, this field is only for internal use")
	}
	if m.Resources.Vms != nil {
		return fmt.Errorf("Invalid field specified: Resources.Vms, this field is only for internal use")
	}
	if m.CreatedAt.Seconds != 0 {
		return fmt.Errorf("Invalid field specified: CreatedAt.Seconds, this field is only for internal use")
	}
	if m.CreatedAt.Nanos != 0 {
		return fmt.Errorf("Invalid field specified: CreatedAt.Nanos, this field is only for internal use")
	}
	if m.UpdatedAt.Seconds != 0 {
		return fmt.Errorf("Invalid field specified: UpdatedAt.Seconds, this field is only for internal use")
	}
	if m.UpdatedAt.Nanos != 0 {
		return fmt.Errorf("Invalid field specified: UpdatedAt.Nanos, this field is only for internal use")
	}
	if m.ReservationEndedAt.Seconds != 0 {
		return fmt.Errorf("Invalid field specified: ReservationEndedAt.Seconds, this field is only for internal use")
	}
	if m.ReservationEndedAt.Nanos != 0 {
		return fmt.Errorf("Invalid field specified: ReservationEndedAt.Nanos, this field is only for internal use")
	}
	if m.DeletePrepare != false {
		return fmt.Errorf("Invalid field specified: DeletePrepare, this field is only for internal use")
	}
	if m.DnsLabel != "" {
		return fmt.Errorf("Invalid field specified: DnsLabel, this field is only for internal use")
	}
	if m.Fqdn != "" {
		return fmt.Errorf("Invalid field specified: Fqdn, this field is only for internal use")
	}
	if m.StaticFqdn != "" {
		return fmt.Errorf("Invalid field specified: StaticFqdn, this field is only for internal use")
	}
	if m.CompatibilityVersion != 0 {
		return fmt.Errorf("Invalid field specified: CompatibilityVersion, this field is only for internal use")
	}
	if m.CloudletKey.Organization != "" {
		return fmt.Errorf("Invalid field specified: CloudletKey.Organization, this field is only for internal use")
	}
	if m.CloudletKey.Name != "" {
		return fmt.Errorf("Invalid field specified: CloudletKey.Name, this field is only for internal use")
	}
	if m.CloudletKey.FederatedOrganization != "" {
		return fmt.Errorf("Invalid field specified: CloudletKey.FederatedOrganization, this field is only for internal use")
	}
	return nil
}

func (m *ClusterInst) IsValidArgsForDeleteClusterInst() error {
	if m.State != 0 {
		return fmt.Errorf("Invalid field specified: State, this field is only for internal use")
	}
	if m.Errors != nil {
		return fmt.Errorf("Invalid field specified: Errors, this field is only for internal use")
	}
	if m.AllocatedIp != "" {
		return fmt.Errorf("Invalid field specified: AllocatedIp, this field is only for internal use")
	}
	if m.Liveness != 0 {
		return fmt.Errorf("Invalid field specified: Liveness, this field is only for internal use")
	}
	if m.Auto != false {
		return fmt.Errorf("Invalid field specified: Auto, this field is only for internal use")
	}
	if m.NodeFlavor != "" {
		return fmt.Errorf("Invalid field specified: NodeFlavor, this field is only for internal use")
	}
	if m.ExternalVolumeSize != 0 {
		return fmt.Errorf("Invalid field specified: ExternalVolumeSize, this field is only for internal use")
	}
	if m.AvailabilityZone != "" {
		return fmt.Errorf("Invalid field specified: AvailabilityZone, this field is only for internal use")
	}
	if m.ReservedBy != "" {
		return fmt.Errorf("Invalid field specified: ReservedBy, this field is only for internal use")
	}
	if m.MasterNodeFlavor != "" {
		return fmt.Errorf("Invalid field specified: MasterNodeFlavor, this field is only for internal use")
	}
	if m.OptRes != "" {
		return fmt.Errorf("Invalid field specified: OptRes, this field is only for internal use")
	}
	if m.Resources.Vms != nil {
		return fmt.Errorf("Invalid field specified: Resources.Vms, this field is only for internal use")
	}
	if m.CreatedAt.Seconds != 0 {
		return fmt.Errorf("Invalid field specified: CreatedAt.Seconds, this field is only for internal use")
	}
	if m.CreatedAt.Nanos != 0 {
		return fmt.Errorf("Invalid field specified: CreatedAt.Nanos, this field is only for internal use")
	}
	if m.UpdatedAt.Seconds != 0 {
		return fmt.Errorf("Invalid field specified: UpdatedAt.Seconds, this field is only for internal use")
	}
	if m.UpdatedAt.Nanos != 0 {
		return fmt.Errorf("Invalid field specified: UpdatedAt.Nanos, this field is only for internal use")
	}
	if m.ReservationEndedAt.Seconds != 0 {
		return fmt.Errorf("Invalid field specified: ReservationEndedAt.Seconds, this field is only for internal use")
	}
	if m.ReservationEndedAt.Nanos != 0 {
		return fmt.Errorf("Invalid field specified: ReservationEndedAt.Nanos, this field is only for internal use")
	}
	if m.DeletePrepare != false {
		return fmt.Errorf("Invalid field specified: DeletePrepare, this field is only for internal use")
	}
	if m.DnsLabel != "" {
		return fmt.Errorf("Invalid field specified: DnsLabel, this field is only for internal use")
	}
	if m.Fqdn != "" {
		return fmt.Errorf("Invalid field specified: Fqdn, this field is only for internal use")
	}
	if m.StaticFqdn != "" {
		return fmt.Errorf("Invalid field specified: StaticFqdn, this field is only for internal use")
	}
	if m.CompatibilityVersion != 0 {
		return fmt.Errorf("Invalid field specified: CompatibilityVersion, this field is only for internal use")
	}
	if m.CloudletKey.Organization != "" {
		return fmt.Errorf("Invalid field specified: CloudletKey.Organization, this field is only for internal use")
	}
	if m.CloudletKey.Name != "" {
		return fmt.Errorf("Invalid field specified: CloudletKey.Name, this field is only for internal use")
	}
	if m.CloudletKey.FederatedOrganization != "" {
		return fmt.Errorf("Invalid field specified: CloudletKey.FederatedOrganization, this field is only for internal use")
	}
	return nil
}

func (m *ClusterInst) IsValidArgsForUpdateClusterInst() error {
	if m.Flavor.Name != "" {
		return fmt.Errorf("Invalid field specified: Flavor.Name, this field is only for internal use")
	}
	if m.State != 0 {
		return fmt.Errorf("Invalid field specified: State, this field is only for internal use")
	}
	if m.Errors != nil {
		return fmt.Errorf("Invalid field specified: Errors, this field is only for internal use")
	}
	if m.IpAccess != 0 {
		return fmt.Errorf("Invalid field specified: IpAccess, this field is only for internal use")
	}
	if m.AllocatedIp != "" {
		return fmt.Errorf("Invalid field specified: AllocatedIp, this field is only for internal use")
	}
	if m.Liveness != 0 {
		return fmt.Errorf("Invalid field specified: Liveness, this field is only for internal use")
	}
	if m.Auto != false {
		return fmt.Errorf("Invalid field specified: Auto, this field is only for internal use")
	}
	if m.NodeFlavor != "" {
		return fmt.Errorf("Invalid field specified: NodeFlavor, this field is only for internal use")
	}
	if m.NumMasters != 0 {
		return fmt.Errorf("Invalid field specified: NumMasters, this field is only for internal use")
	}
	if m.Deployment != "" {
		return fmt.Errorf("Invalid field specified: Deployment, this field is only for internal use")
	}
	if m.ExternalVolumeSize != 0 {
		return fmt.Errorf("Invalid field specified: ExternalVolumeSize, this field is only for internal use")
	}
	if m.AvailabilityZone != "" {
		return fmt.Errorf("Invalid field specified: AvailabilityZone, this field is only for internal use")
	}
	if m.ImageName != "" {
		return fmt.Errorf("Invalid field specified: ImageName, this field is only for internal use")
	}
	if m.Reservable != false {
		return fmt.Errorf("Invalid field specified: Reservable, this field is only for internal use")
	}
	if m.ReservedBy != "" {
		return fmt.Errorf("Invalid field specified: ReservedBy, this field is only for internal use")
	}
	if m.SharedVolumeSize != 0 {
		return fmt.Errorf("Invalid field specified: SharedVolumeSize, this field is only for internal use")
	}
	if m.MasterNodeFlavor != "" {
		return fmt.Errorf("Invalid field specified: MasterNodeFlavor, this field is only for internal use")
	}
	if m.OptRes != "" {
		return fmt.Errorf("Invalid field specified: OptRes, this field is only for internal use")
	}
	if m.Resources.Vms != nil {
		return fmt.Errorf("Invalid field specified: Resources.Vms, this field is only for internal use")
	}
	if m.CreatedAt.Seconds != 0 {
		return fmt.Errorf("Invalid field specified: CreatedAt.Seconds, this field is only for internal use")
	}
	if m.CreatedAt.Nanos != 0 {
		return fmt.Errorf("Invalid field specified: CreatedAt.Nanos, this field is only for internal use")
	}
	if m.UpdatedAt.Seconds != 0 {
		return fmt.Errorf("Invalid field specified: UpdatedAt.Seconds, this field is only for internal use")
	}
	if m.UpdatedAt.Nanos != 0 {
		return fmt.Errorf("Invalid field specified: UpdatedAt.Nanos, this field is only for internal use")
	}
	if m.ReservationEndedAt.Seconds != 0 {
		return fmt.Errorf("Invalid field specified: ReservationEndedAt.Seconds, this field is only for internal use")
	}
	if m.ReservationEndedAt.Nanos != 0 {
		return fmt.Errorf("Invalid field specified: ReservationEndedAt.Nanos, this field is only for internal use")
	}
	if m.MultiTenant != false {
		return fmt.Errorf("Invalid field specified: MultiTenant, this field is only for internal use")
	}
	if m.Networks != nil {
		return fmt.Errorf("Invalid field specified: Networks, this field is only for internal use")
	}
	if m.DeletePrepare != false {
		return fmt.Errorf("Invalid field specified: DeletePrepare, this field is only for internal use")
	}
	if m.DnsLabel != "" {
		return fmt.Errorf("Invalid field specified: DnsLabel, this field is only for internal use")
	}
	if m.Fqdn != "" {
		return fmt.Errorf("Invalid field specified: Fqdn, this field is only for internal use")
	}
	if m.StaticFqdn != "" {
		return fmt.Errorf("Invalid field specified: StaticFqdn, this field is only for internal use")
	}
	if m.CompatibilityVersion != 0 {
		return fmt.Errorf("Invalid field specified: CompatibilityVersion, this field is only for internal use")
	}
	if m.CloudletKey.Organization != "" {
		return fmt.Errorf("Invalid field specified: CloudletKey.Organization, this field is only for internal use")
	}
	if m.CloudletKey.Name != "" {
		return fmt.Errorf("Invalid field specified: CloudletKey.Name, this field is only for internal use")
	}
	if m.CloudletKey.FederatedOrganization != "" {
		return fmt.Errorf("Invalid field specified: CloudletKey.FederatedOrganization, this field is only for internal use")
	}
	if m.NodeResources != nil {
		return fmt.Errorf("Invalid field specified: NodeResources, this field is only for internal use")
	}
	if m.NodePools != nil {
	}
	if m.KubernetesVersion != "" {
		return fmt.Errorf("Invalid field specified: KubernetesVersion, this field is only for internal use")
	}
	return nil
}

func (m *IdleReservableClusterInsts) IsValidArgsForDeleteIdleReservableClusterInsts() error {
	return nil
}

func (m *ClusterInst) IsValidArgsForShowClusterResourceUsage() error {
	if m.State != 0 {
		return fmt.Errorf("Invalid field specified: State, this field is only for internal use")
	}
	if m.Errors != nil {
		return fmt.Errorf("Invalid field specified: Errors, this field is only for internal use")
	}
	if m.AllocatedIp != "" {
		return fmt.Errorf("Invalid field specified: AllocatedIp, this field is only for internal use")
	}
	if m.Liveness != 0 {
		return fmt.Errorf("Invalid field specified: Liveness, this field is only for internal use")
	}
	if m.Auto != false {
		return fmt.Errorf("Invalid field specified: Auto, this field is only for internal use")
	}
	if m.NodeFlavor != "" {
		return fmt.Errorf("Invalid field specified: NodeFlavor, this field is only for internal use")
	}
	if m.ExternalVolumeSize != 0 {
		return fmt.Errorf("Invalid field specified: ExternalVolumeSize, this field is only for internal use")
	}
	if m.AvailabilityZone != "" {
		return fmt.Errorf("Invalid field specified: AvailabilityZone, this field is only for internal use")
	}
	if m.ReservedBy != "" {
		return fmt.Errorf("Invalid field specified: ReservedBy, this field is only for internal use")
	}
	if m.MasterNodeFlavor != "" {
		return fmt.Errorf("Invalid field specified: MasterNodeFlavor, this field is only for internal use")
	}
	if m.OptRes != "" {
		return fmt.Errorf("Invalid field specified: OptRes, this field is only for internal use")
	}
	if m.Resources.Vms != nil {
		return fmt.Errorf("Invalid field specified: Resources.Vms, this field is only for internal use")
	}
	if m.CreatedAt.Seconds != 0 {
		return fmt.Errorf("Invalid field specified: CreatedAt.Seconds, this field is only for internal use")
	}
	if m.CreatedAt.Nanos != 0 {
		return fmt.Errorf("Invalid field specified: CreatedAt.Nanos, this field is only for internal use")
	}
	if m.UpdatedAt.Seconds != 0 {
		return fmt.Errorf("Invalid field specified: UpdatedAt.Seconds, this field is only for internal use")
	}
	if m.UpdatedAt.Nanos != 0 {
		return fmt.Errorf("Invalid field specified: UpdatedAt.Nanos, this field is only for internal use")
	}
	if m.ReservationEndedAt.Seconds != 0 {
		return fmt.Errorf("Invalid field specified: ReservationEndedAt.Seconds, this field is only for internal use")
	}
	if m.ReservationEndedAt.Nanos != 0 {
		return fmt.Errorf("Invalid field specified: ReservationEndedAt.Nanos, this field is only for internal use")
	}
	if m.DeletePrepare != false {
		return fmt.Errorf("Invalid field specified: DeletePrepare, this field is only for internal use")
	}
	if m.DnsLabel != "" {
		return fmt.Errorf("Invalid field specified: DnsLabel, this field is only for internal use")
	}
	if m.Fqdn != "" {
		return fmt.Errorf("Invalid field specified: Fqdn, this field is only for internal use")
	}
	if m.StaticFqdn != "" {
		return fmt.Errorf("Invalid field specified: StaticFqdn, this field is only for internal use")
	}
	if m.CompatibilityVersion != 0 {
		return fmt.Errorf("Invalid field specified: CompatibilityVersion, this field is only for internal use")
	}
	if m.CloudletKey.Organization != "" {
		return fmt.Errorf("Invalid field specified: CloudletKey.Organization, this field is only for internal use")
	}
	if m.CloudletKey.Name != "" {
		return fmt.Errorf("Invalid field specified: CloudletKey.Name, this field is only for internal use")
	}
	if m.CloudletKey.FederatedOrganization != "" {
		return fmt.Errorf("Invalid field specified: CloudletKey.FederatedOrganization, this field is only for internal use")
	}
	return nil
}

func (m *ClusterInstKeyV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ClusterKey.Size()
	n += 1 + l + sovClusterinst(uint64(l))
	l = m.CloudletKey.Size()
	n += 1 + l + sovClusterinst(uint64(l))
	l = len(m.Organization)
	if l > 0 {
		n += 1 + l + sovClusterinst(uint64(l))
	}
	return n
}

func (m *ClusterInstKeyV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ClusterKey.Size()
	n += 1 + l + sovClusterinst(uint64(l))
	l = m.CloudletKey.Size()
	n += 1 + l + sovClusterinst(uint64(l))
	return n
}

func (m *ClusterInst) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovClusterinst(uint64(l))
		}
	}
	l = m.Key.Size()
	n += 1 + l + sovClusterinst(uint64(l))
	l = m.Flavor.Size()
	n += 1 + l + sovClusterinst(uint64(l))
	if m.State != 0 {
		n += 1 + sovClusterinst(uint64(m.State))
	}
	if len(m.Errors) > 0 {
		for _, s := range m.Errors {
			l = len(s)
			n += 1 + l + sovClusterinst(uint64(l))
		}
	}
	if m.CrmOverride != 0 {
		n += 1 + sovClusterinst(uint64(m.CrmOverride))
	}
	if m.IpAccess != 0 {
		n += 1 + sovClusterinst(uint64(m.IpAccess))
	}
	l = len(m.AllocatedIp)
	if l > 0 {
		n += 1 + l + sovClusterinst(uint64(l))
	}
	if m.Liveness != 0 {
		n += 1 + sovClusterinst(uint64(m.Liveness))
	}
	if m.Auto {
		n += 2
	}
	l = len(m.NodeFlavor)
	if l > 0 {
		n += 1 + l + sovClusterinst(uint64(l))
	}
	if m.NumMasters != 0 {
		n += 1 + sovClusterinst(uint64(m.NumMasters))
	}
	if m.NumNodes != 0 {
		n += 1 + sovClusterinst(uint64(m.NumNodes))
	}
	l = len(m.Deployment)
	if l > 0 {
		n += 1 + l + sovClusterinst(uint64(l))
	}
	if m.ExternalVolumeSize != 0 {
		n += 2 + sovClusterinst(uint64(m.ExternalVolumeSize))
	}
	l = len(m.AutoScalePolicy)
	if l > 0 {
		n += 2 + l + sovClusterinst(uint64(l))
	}
	l = len(m.AvailabilityZone)
	if l > 0 {
		n += 2 + l + sovClusterinst(uint64(l))
	}
	l = len(m.ImageName)
	if l > 0 {
		n += 2 + l + sovClusterinst(uint64(l))
	}
	if m.Reservable {
		n += 3
	}
	l = len(m.ReservedBy)
	if l > 0 {
		n += 2 + l + sovClusterinst(uint64(l))
	}
	if m.SharedVolumeSize != 0 {
		n += 2 + sovClusterinst(uint64(m.SharedVolumeSize))
	}
	l = len(m.MasterNodeFlavor)
	if l > 0 {
		n += 2 + l + sovClusterinst(uint64(l))
	}
	if m.SkipCrmCleanupOnFailure {
		n += 3
	}
	l = len(m.OptRes)
	if l > 0 {
		n += 2 + l + sovClusterinst(uint64(l))
	}
	l = m.Resources.Size()
	n += 2 + l + sovClusterinst(uint64(l))
	l = m.CreatedAt.Size()
	n += 2 + l + sovClusterinst(uint64(l))
	l = m.UpdatedAt.Size()
	n += 2 + l + sovClusterinst(uint64(l))
	l = m.ReservationEndedAt.Size()
	n += 2 + l + sovClusterinst(uint64(l))
	if m.MultiTenant {
		n += 3
	}
	if len(m.Networks) > 0 {
		for _, s := range m.Networks {
			l = len(s)
			n += 2 + l + sovClusterinst(uint64(l))
		}
	}
	if m.DeletePrepare {
		n += 3
	}
	l = len(m.DnsLabel)
	if l > 0 {
		n += 2 + l + sovClusterinst(uint64(l))
	}
	l = len(m.Fqdn)
	if l > 0 {
		n += 2 + l + sovClusterinst(uint64(l))
	}
	if m.EnableIpv6 {
		n += 3
	}
	l = len(m.ObjId)
	if l > 0 {
		n += 2 + l + sovClusterinst(uint64(l))
	}
	l = len(m.StaticFqdn)
	if l > 0 {
		n += 2 + l + sovClusterinst(uint64(l))
	}
	if m.CompatibilityVersion != 0 {
		n += 2 + sovClusterinst(uint64(m.CompatibilityVersion))
	}
	l = m.CloudletKey.Size()
	n += 2 + l + sovClusterinst(uint64(l))
	if len(m.Annotations) > 0 {
		for k, v := range m.Annotations {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovClusterinst(uint64(len(k))) + 1 + len(v) + sovClusterinst(uint64(len(v)))
			n += mapEntrySize + 2 + sovClusterinst(uint64(mapEntrySize))
		}
	}
	l = m.ZoneKey.Size()
	n += 2 + l + sovClusterinst(uint64(l))
	if m.DbModelId != 0 {
		n += 2 + sovClusterinst(uint64(m.DbModelId))
	}
	if m.NodeResources != nil {
		l = m.NodeResources.Size()
		n += 2 + l + sovClusterinst(uint64(l))
	}
	if len(m.NodePools) > 0 {
		for _, e := range m.NodePools {
			l = e.Size()
			n += 2 + l + sovClusterinst(uint64(l))
		}
	}
	if len(m.InfraAnnotations) > 0 {
		for k, v := range m.InfraAnnotations {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovClusterinst(uint64(len(k))) + 1 + len(v) + sovClusterinst(uint64(len(v)))
			n += mapEntrySize + 2 + sovClusterinst(uint64(mapEntrySize))
		}
	}
	l = len(m.KubernetesVersion)
	if l > 0 {
		n += 2 + l + sovClusterinst(uint64(l))
	}
	return n
}

func (m *IdleReservableClusterInsts) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IdleTime != 0 {
		n += 1 + sovClusterinst(uint64(m.IdleTime))
	}
	return n
}

func (m *ClusterResourceUsage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Key.Size()
	n += 1 + l + sovClusterinst(uint64(l))
	l = m.ZoneKey.Size()
	n += 1 + l + sovClusterinst(uint64(l))
	l = m.CloudletKey.Size()
	n += 1 + l + sovClusterinst(uint64(l))
	if len(m.TotalResources) > 0 {
		for _, e := range m.TotalResources {
			l = e.Size()
			n += 1 + l + sovClusterinst(uint64(l))
		}
	}
	if len(m.CpuPoolsResources) > 0 {
		for _, e := range m.CpuPoolsResources {
			l = e.Size()
			n += 1 + l + sovClusterinst(uint64(l))
		}
	}
	if len(m.GpuPoolsResources) > 0 {
		for _, e := range m.GpuPoolsResources {
			l = e.Size()
			n += 1 + l + sovClusterinst(uint64(l))
		}
	}
	if m.ResourceScore != 0 {
		n += 1 + sovClusterinst(uint64(m.ResourceScore))
	}
	if m.CpuPoolsResourceScore != 0 {
		n += 1 + sovClusterinst(uint64(m.CpuPoolsResourceScore))
	}
	if m.GpuPoolsResourceScore != 0 {
		n += 1 + sovClusterinst(uint64(m.GpuPoolsResourceScore))
	}
	return n
}

func (m *ClusterInstInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovClusterinst(uint64(l))
		}
	}
	l = m.Key.Size()
	n += 1 + l + sovClusterinst(uint64(l))
	if m.NotifyId != 0 {
		n += 1 + sovClusterinst(uint64(m.NotifyId))
	}
	if m.State != 0 {
		n += 1 + sovClusterinst(uint64(m.State))
	}
	if len(m.Errors) > 0 {
		for _, s := range m.Errors {
			l = len(s)
			n += 1 + l + sovClusterinst(uint64(l))
		}
	}
	l = m.Status.Size()
	n += 1 + l + sovClusterinst(uint64(l))
	l = m.Resources.Size()
	n += 1 + l + sovClusterinst(uint64(l))
	if len(m.InfraAnnotations) > 0 {
		for k, v := range m.InfraAnnotations {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovClusterinst(uint64(len(k))) + 1 + len(v) + sovClusterinst(uint64(len(v)))
			n += mapEntrySize + 2 + sovClusterinst(uint64(mapEntrySize))
		}
	}
	return n
}

func sovClusterinst(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozClusterinst(x uint64) (n int) {
	return sovClusterinst(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ClusterInstKeyV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClusterinst
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterInstKeyV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterInstKeyV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ClusterKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudletKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CloudletKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Organization", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Organization = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClusterinst(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthClusterinst
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterInstKeyV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClusterinst
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterInstKeyV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterInstKeyV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ClusterKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudletKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CloudletKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClusterinst(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthClusterinst
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterInst) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClusterinst
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterInst: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterInst: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flavor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Flavor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= TrackedState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errors", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Errors = append(m.Errors, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrmOverride", wireType)
			}
			m.CrmOverride = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CrmOverride |= CRMOverride(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAccess", wireType)
			}
			m.IpAccess = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpAccess |= IpAccess(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllocatedIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllocatedIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Liveness", wireType)
			}
			m.Liveness = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Liveness |= Liveness(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Auto", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Auto = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeFlavor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeFlavor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumMasters", wireType)
			}
			m.NumMasters = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumMasters |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumNodes", wireType)
			}
			m.NumNodes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumNodes |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deployment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Deployment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalVolumeSize", wireType)
			}
			m.ExternalVolumeSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExternalVolumeSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoScalePolicy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AutoScalePolicy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailabilityZone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AvailabilityZone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImageName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reservable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Reservable = bool(v != 0)
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReservedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReservedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharedVolumeSize", wireType)
			}
			m.SharedVolumeSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SharedVolumeSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MasterNodeFlavor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MasterNodeFlavor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipCrmCleanupOnFailure", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SkipCrmCleanupOnFailure = bool(v != 0)
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptRes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OptRes = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Resources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CreatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.UpdatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReservationEndedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ReservationEndedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultiTenant", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MultiTenant = bool(v != 0)
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Networks", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Networks = append(m.Networks, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletePrepare", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DeletePrepare = bool(v != 0)
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsLabel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DnsLabel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fqdn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fqdn = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableIpv6", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableIpv6 = bool(v != 0)
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 39:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StaticFqdn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StaticFqdn = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompatibilityVersion", wireType)
			}
			m.CompatibilityVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompatibilityVersion |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudletKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CloudletKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowClusterinst
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowClusterinst
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthClusterinst
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthClusterinst
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowClusterinst
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthClusterinst
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthClusterinst
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipClusterinst(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthClusterinst
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Annotations[mapkey] = mapvalue
			iNdEx = postIndex
		case 43:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZoneKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ZoneKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 44:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbModelId", wireType)
			}
			m.DbModelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DbModelId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeResources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeResources == nil {
				m.NodeResources = &NodeResources{}
			}
			if err := m.NodeResources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 46:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodePools", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodePools = append(m.NodePools, &NodePool{})
			if err := m.NodePools[len(m.NodePools)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 47:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InfraAnnotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InfraAnnotations == nil {
				m.InfraAnnotations = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowClusterinst
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowClusterinst
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthClusterinst
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthClusterinst
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowClusterinst
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthClusterinst
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthClusterinst
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipClusterinst(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthClusterinst
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.InfraAnnotations[mapkey] = mapvalue
			iNdEx = postIndex
		case 48:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KubernetesVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KubernetesVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClusterinst(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthClusterinst
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IdleReservableClusterInsts) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClusterinst
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IdleReservableClusterInsts: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IdleReservableClusterInsts: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdleTime", wireType)
			}
			m.IdleTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IdleTime |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipClusterinst(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthClusterinst
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterResourceUsage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClusterinst
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterResourceUsage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterResourceUsage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZoneKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ZoneKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudletKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CloudletKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalResources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TotalResources = append(m.TotalResources, &InfraResource{})
			if err := m.TotalResources[len(m.TotalResources)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuPoolsResources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CpuPoolsResources = append(m.CpuPoolsResources, &InfraResource{})
			if err := m.CpuPoolsResources[len(m.CpuPoolsResources)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpuPoolsResources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GpuPoolsResources = append(m.GpuPoolsResources, &InfraResource{})
			if err := m.GpuPoolsResources[len(m.GpuPoolsResources)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceScore", wireType)
			}
			m.ResourceScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResourceScore |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuPoolsResourceScore", wireType)
			}
			m.CpuPoolsResourceScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CpuPoolsResourceScore |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpuPoolsResourceScore", wireType)
			}
			m.GpuPoolsResourceScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GpuPoolsResourceScore |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipClusterinst(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthClusterinst
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterInstInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClusterinst
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterInstInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterInstInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotifyId", wireType)
			}
			m.NotifyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NotifyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= TrackedState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errors", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Errors = append(m.Errors, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Resources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InfraAnnotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClusterinst
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthClusterinst
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InfraAnnotations == nil {
				m.InfraAnnotations = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowClusterinst
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowClusterinst
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthClusterinst
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthClusterinst
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowClusterinst
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthClusterinst
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthClusterinst
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipClusterinst(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthClusterinst
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.InfraAnnotations[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClusterinst(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthClusterinst
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipClusterinst(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowClusterinst
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowClusterinst
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthClusterinst
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupClusterinst
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthClusterinst
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthClusterinst        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowClusterinst          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupClusterinst = fmt.Errorf("proto: unexpected end of group")
)
