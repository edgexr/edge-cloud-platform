// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: appinstclient.proto

package edgeproto

import (
	context "context"
	"encoding/json"
	fmt "fmt"
	distributed_match_engine "github.com/edgexr/edge-cloud-platform/api/distributed_match_engine"
	"github.com/edgexr/edge-cloud-platform/pkg/log"
	"github.com/edgexr/edge-cloud-platform/pkg/objstore"
	"github.com/edgexr/edge-cloud-platform/pkg/util"
	_ "github.com/edgexr/edge-cloud-platform/tools/protogen"
	_ "github.com/gogo/googleapis/google/api"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"go.etcd.io/etcd/client/v3/concurrency"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type AppInstClientKey struct {
	// AppInst Key
	AppInstKey AppInstKey `protobuf:"bytes,1,opt,name=app_inst_key,json=appInstKey,proto3" json:"app_inst_key"`
	// AppInstClient Unique Id
	UniqueId string `protobuf:"bytes,2,opt,name=unique_id,json=uniqueId,proto3" json:"unique_id,omitempty"`
	// AppInstClient Unique Id Type
	UniqueIdType string `protobuf:"bytes,3,opt,name=unique_id_type,json=uniqueIdType,proto3" json:"unique_id_type,omitempty"`
	// Client App Key
	AppKey AppKey `protobuf:"bytes,4,opt,name=app_key,json=appKey,proto3" json:"app_key"`
}

func (m *AppInstClientKey) Reset()         { *m = AppInstClientKey{} }
func (m *AppInstClientKey) String() string { return proto.CompactTextString(m) }
func (*AppInstClientKey) ProtoMessage()    {}
func (*AppInstClientKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_a8b03148dc570743, []int{0}
}
func (m *AppInstClientKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppInstClientKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppInstClientKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppInstClientKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppInstClientKey.Merge(m, src)
}
func (m *AppInstClientKey) XXX_Size() int {
	return m.Size()
}
func (m *AppInstClientKey) XXX_DiscardUnknown() {
	xxx_messageInfo_AppInstClientKey.DiscardUnknown(m)
}

var xxx_messageInfo_AppInstClientKey proto.InternalMessageInfo

// Client is an AppInst client that called FindCloudlet DME Api
type AppInstClient struct {
	// Fields are used for the Update API to specify which fields to apply
	Fields []string `protobuf:"bytes,1,rep,name=fields,proto3" json:"fields,omitempty"`
	// Unique identifier key
	ClientKey AppInstClientKey `protobuf:"bytes,2,opt,name=client_key,json=clientKey,proto3" json:"client_key"`
	// Location of the Client
	Location distributed_match_engine.Loc `protobuf:"bytes,3,opt,name=location,proto3" json:"location"`
	// Id of client assigned by server (internal use only)
	NotifyId int64 `protobuf:"varint,4,opt,name=notify_id,json=notifyId,proto3" json:"notify_id,omitempty"`
}

func (m *AppInstClient) Reset()         { *m = AppInstClient{} }
func (m *AppInstClient) String() string { return proto.CompactTextString(m) }
func (*AppInstClient) ProtoMessage()    {}
func (*AppInstClient) Descriptor() ([]byte, []int) {
	return fileDescriptor_a8b03148dc570743, []int{1}
}
func (m *AppInstClient) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppInstClient) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppInstClient.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppInstClient) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppInstClient.Merge(m, src)
}
func (m *AppInstClient) XXX_Size() int {
	return m.Size()
}
func (m *AppInstClient) XXX_DiscardUnknown() {
	xxx_messageInfo_AppInstClient.DiscardUnknown(m)
}

var xxx_messageInfo_AppInstClient proto.InternalMessageInfo

func init() {
	proto.RegisterType((*AppInstClientKey)(nil), "edgeproto.AppInstClientKey")
	proto.RegisterType((*AppInstClient)(nil), "edgeproto.AppInstClient")
}

func init() { proto.RegisterFile("appinstclient.proto", fileDescriptor_a8b03148dc570743) }

var fileDescriptor_a8b03148dc570743 = []byte{
	// 755 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x54, 0xc1, 0x4f, 0x13, 0x4b,
	0x18, 0xef, 0x94, 0xbe, 0xbe, 0x76, 0x69, 0x09, 0x2c, 0xef, 0xbd, 0x0c, 0x3c, 0x28, 0xa4, 0x07,
	0x83, 0xa4, 0x69, 0x09, 0x26, 0x9a, 0x34, 0x21, 0xb1, 0x25, 0x31, 0x92, 0x12, 0x4d, 0x8a, 0x72,
	0x6d, 0x86, 0xdd, 0x8f, 0x65, 0xc2, 0x76, 0x66, 0xdc, 0xdd, 0x4a, 0xd6, 0x13, 0xf1, 0x2f, 0x20,
	0x7a, 0x33, 0x1e, 0x8c, 0x27, 0x6e, 0x22, 0xc7, 0x26, 0x26, 0x78, 0xe3, 0x48, 0xe2, 0xc5, 0x93,
	0x51, 0xf0, 0xa0, 0x9e, 0x48, 0x68, 0x7b, 0x36, 0xbb, 0x9d, 0xae, 0x6d, 0x05, 0xa2, 0xde, 0xbe,
	0xf9, 0xe6, 0xf7, 0xfb, 0xe6, 0xf7, 0x7d, 0x33, 0xbf, 0x51, 0x46, 0x89, 0x10, 0x94, 0xd9, 0x8e,
	0x66, 0x52, 0x60, 0x4e, 0x56, 0x58, 0xdc, 0xe1, 0x6a, 0x1c, 0x74, 0x03, 0xfc, 0x70, 0x7c, 0xc2,
	0xe0, 0xdc, 0x30, 0x21, 0x47, 0x04, 0xcd, 0x11, 0xc6, 0xb8, 0x43, 0x1c, 0xca, 0x99, 0xdd, 0x06,
	0x8e, 0x4f, 0x3a, 0x9c, 0x9b, 0x76, 0xce, 0x5f, 0x18, 0xc0, 0x82, 0x40, 0x6e, 0x5f, 0xf1, 0x58,
	0x3a, 0xb5, 0x1d, 0x8b, 0xae, 0xd5, 0x1c, 0xd0, 0x2b, 0x55, 0xe2, 0x68, 0x1b, 0x15, 0x60, 0x06,
	0x65, 0x90, 0x33, 0xb9, 0x26, 0x71, 0x71, 0x22, 0x84, 0x0c, 0x93, 0x52, 0x8f, 0x5c, 0xfe, 0x63,
	0x70, 0x83, 0xfb, 0x61, 0xce, 0x8b, 0xda, 0xd9, 0xf4, 0xeb, 0xa8, 0x32, 0x5c, 0x10, 0x62, 0x89,
	0xd9, 0xce, 0xa2, 0xaf, 0xbb, 0x04, 0xae, 0x5a, 0x52, 0x12, 0x44, 0x88, 0x8a, 0x47, 0xae, 0x6c,
	0x82, 0x8b, 0xd1, 0x34, 0x9a, 0x19, 0x9c, 0xff, 0x37, 0x1b, 0xf4, 0x92, 0x95, 0x94, 0x12, 0xb8,
	0x45, 0xb5, 0xde, 0xc2, 0x8a, 0x3c, 0x6a, 0x13, 0xdc, 0xc3, 0x0f, 0x53, 0xa1, 0xb2, 0xb7, 0x96,
	0xfb, 0xea, 0x55, 0x25, 0x5e, 0x63, 0xf4, 0x41, 0x0d, 0x2a, 0x54, 0xc7, 0xe1, 0x69, 0x34, 0x13,
	0x2f, 0x26, 0xea, 0x2d, 0x1c, 0x6b, 0x27, 0xa9, 0x5e, 0x96, 0xd1, 0x92, 0xae, 0x5e, 0x57, 0x86,
	0x02, 0x68, 0xc5, 0x71, 0x05, 0xe0, 0x01, 0x1f, 0x3f, 0x5c, 0x6f, 0xe1, 0x44, 0x07, 0xef, 0xe5,
	0xcb, 0x89, 0x0e, 0xe7, 0x9e, 0x2b, 0x40, 0xcd, 0x2b, 0x7f, 0x7b, 0x7a, 0x3d, 0xa9, 0x11, 0x5f,
	0xea, 0x48, 0xaf, 0x54, 0x4f, 0xe6, 0x50, 0xbd, 0x85, 0xa3, 0x44, 0x88, 0x8e, 0x44, 0x2f, 0x2e,
	0x81, 0x9b, 0xdf, 0x8b, 0x7c, 0x39, 0xc3, 0xe8, 0xf4, 0x0c, 0xa3, 0xed, 0x06, 0x46, 0x3b, 0x0d,
	0x8c, 0x0e, 0x1a, 0x18, 0x3d, 0x6b, 0xe2, 0x37, 0xe1, 0xce, 0x89, 0x0b, 0xf7, 0xe5, 0x61, 0x99,
	0x6e, 0x0d, 0x41, 0xd6, 0x93, 0x90, 0x91, 0x03, 0x58, 0xf8, 0x31, 0x98, 0xec, 0x1d, 0x52, 0x0d,
	0xf2, 0xdc, 0x32, 0xba, 0xb7, 0xee, 0x5a, 0x06, 0x61, 0xf4, 0x91, 0xff, 0x00, 0x32, 0x9a, 0xc9,
	0x6b, 0xba, 0x09, 0x3d, 0xdc, 0x45, 0x99, 0x0b, 0xea, 0x74, 0x40, 0x7d, 0x85, 0xba, 0x71, 0xe7,
	0x16, 0x5d, 0x07, 0xfd, 0x12, 0xca, 0x2d, 0xd0, 0xc1, 0x22, 0x0e, 0xe8, 0x3d, 0x5c, 0x22, 0x04,
	0x23, 0x55, 0x58, 0x68, 0x4f, 0x2e, 0xe8, 0xe3, 0x21, 0x58, 0x76, 0x27, 0xb7, 0x0a, 0x96, 0x2d,
	0xa1, 0xb2, 0x7c, 0xbf, 0x82, 0x97, 0x4d, 0xfc, 0x16, 0xf5, 0x4f, 0xe3, 0xb2, 0x0e, 0x7f, 0xa5,
	0xab, 0xdf, 0x6a, 0xa3, 0x5b, 0x7e, 0x9f, 0xec, 0x73, 0xf4, 0x66, 0x82, 0x4b, 0xee, 0xbe, 0xd7,
	0x83, 0x26, 0x46, 0xfb, 0x2d, 0x1c, 0x61, 0x9c, 0xc1, 0x69, 0x0b, 0xa3, 0xbd, 0x17, 0x53, 0x28,
	0xfd, 0x15, 0x29, 0xc9, 0x1e, 0xcf, 0xa8, 0xff, 0x29, 0xd1, 0x75, 0x0a, 0xa6, 0x6e, 0x63, 0x34,
	0x3d, 0x30, 0x13, 0x2f, 0xcb, 0x95, 0x7a, 0x53, 0x51, 0xda, 0xbf, 0x81, 0xff, 0x36, 0xc3, 0xfe,
	0xdb, 0xfc, 0xff, 0x67, 0x1b, 0x05, 0xce, 0x2b, 0x46, 0xfc, 0xb7, 0x19, 0xd7, 0x02, 0x2b, 0xde,
	0x56, 0x62, 0x26, 0xd7, 0x7c, 0x85, 0xbe, 0x19, 0x06, 0xe7, 0x27, 0xb3, 0x17, 0x7d, 0x03, 0xd9,
	0x65, 0xae, 0x15, 0x93, 0x4f, 0xf6, 0xc7, 0xfe, 0x62, 0x5c, 0xab, 0x0a, 0xbf, 0x54, 0xc0, 0x56,
	0x67, 0x95, 0x38, 0xe3, 0x0e, 0x5d, 0x77, 0x3d, 0x1f, 0x7a, 0x36, 0x19, 0x28, 0x26, 0x77, 0x1b,
	0x18, 0x05, 0xf8, 0x72, 0xac, 0xbd, 0xbf, 0xa4, 0xe7, 0x63, 0x9e, 0x07, 0x4e, 0x1b, 0x38, 0x34,
	0xff, 0x3c, 0xdc, 0xf7, 0x3f, 0x14, 0x04, 0x55, 0x5f, 0x21, 0x65, 0x64, 0x65, 0x83, 0x6f, 0xf5,
	0x0e, 0xe1, 0xb2, 0xc6, 0xc6, 0xf1, 0x45, 0x9b, 0x69, 0xf2, 0xad, 0x81, 0x6f, 0x94, 0xc1, 0xe6,
	0x35, 0x4b, 0x83, 0x82, 0x10, 0x05, 0x46, 0x4c, 0xd7, 0xa1, 0x9a, 0x9d, 0x29, 0x68, 0x9e, 0xf0,
	0x55, 0x0a, 0x5b, 0x99, 0x0b, 0xbc, 0xb3, 0xdb, 0xc4, 0x68, 0xbb, 0x85, 0xd1, 0xe3, 0x77, 0x9f,
	0x9f, 0x86, 0x71, 0x7a, 0x34, 0x67, 0x6f, 0xf0, 0xad, 0x5c, 0xcf, 0x3f, 0x9c, 0x47, 0xb3, 0x73,
	0x48, 0x5d, 0x55, 0xc6, 0x56, 0x1c, 0x0b, 0x48, 0xb5, 0xe7, 0x6c, 0x7b, 0x99, 0x6b, 0xc4, 0xfc,
	0x53, 0xe1, 0xa1, 0x39, 0x54, 0x9c, 0x38, 0xfc, 0x94, 0x0a, 0x1d, 0x1e, 0xa7, 0xd0, 0xd1, 0x71,
	0x0a, 0x7d, 0x3c, 0x4e, 0xa1, 0x9d, 0x93, 0x54, 0xe8, 0xe8, 0x24, 0x15, 0x7a, 0x7f, 0x92, 0x0a,
	0xad, 0x45, 0x7d, 0xda, 0xb5, 0xef, 0x01, 0x00, 0x00, 0xff, 0xff, 0x4e, 0x4c, 0xb8, 0xf5, 0x1a,
	0x06, 0x00, 0x00,
}

func (this *AppInstClientKey) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&edgeproto.AppInstClientKey{")
	s = append(s, "AppInstKey: "+strings.Replace(this.AppInstKey.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "UniqueId: "+fmt.Sprintf("%#v", this.UniqueId)+",\n")
	s = append(s, "UniqueIdType: "+fmt.Sprintf("%#v", this.UniqueIdType)+",\n")
	s = append(s, "AppKey: "+strings.Replace(this.AppKey.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringAppinstclient(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// AppInstClientApiClient is the client API for AppInstClientApi service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AppInstClientApiClient interface {
	// Show application instance clients.
	ShowAppInstClient(ctx context.Context, in *AppInstClientKey, opts ...grpc.CallOption) (AppInstClientApi_ShowAppInstClientClient, error)
	// This is used unternally to forward AppInstClients to other Controllers
	StreamAppInstClientsLocal(ctx context.Context, in *AppInstClientKey, opts ...grpc.CallOption) (AppInstClientApi_StreamAppInstClientsLocalClient, error)
}

type appInstClientApiClient struct {
	cc *grpc.ClientConn
}

func NewAppInstClientApiClient(cc *grpc.ClientConn) AppInstClientApiClient {
	return &appInstClientApiClient{cc}
}

func (c *appInstClientApiClient) ShowAppInstClient(ctx context.Context, in *AppInstClientKey, opts ...grpc.CallOption) (AppInstClientApi_ShowAppInstClientClient, error) {
	stream, err := c.cc.NewStream(ctx, &_AppInstClientApi_serviceDesc.Streams[0], "/edgeproto.AppInstClientApi/ShowAppInstClient", opts...)
	if err != nil {
		return nil, err
	}
	x := &appInstClientApiShowAppInstClientClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AppInstClientApi_ShowAppInstClientClient interface {
	Recv() (*AppInstClient, error)
	grpc.ClientStream
}

type appInstClientApiShowAppInstClientClient struct {
	grpc.ClientStream
}

func (x *appInstClientApiShowAppInstClientClient) Recv() (*AppInstClient, error) {
	m := new(AppInstClient)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *appInstClientApiClient) StreamAppInstClientsLocal(ctx context.Context, in *AppInstClientKey, opts ...grpc.CallOption) (AppInstClientApi_StreamAppInstClientsLocalClient, error) {
	stream, err := c.cc.NewStream(ctx, &_AppInstClientApi_serviceDesc.Streams[1], "/edgeproto.AppInstClientApi/StreamAppInstClientsLocal", opts...)
	if err != nil {
		return nil, err
	}
	x := &appInstClientApiStreamAppInstClientsLocalClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AppInstClientApi_StreamAppInstClientsLocalClient interface {
	Recv() (*AppInstClient, error)
	grpc.ClientStream
}

type appInstClientApiStreamAppInstClientsLocalClient struct {
	grpc.ClientStream
}

func (x *appInstClientApiStreamAppInstClientsLocalClient) Recv() (*AppInstClient, error) {
	m := new(AppInstClient)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// AppInstClientApiServer is the server API for AppInstClientApi service.
type AppInstClientApiServer interface {
	// Show application instance clients.
	ShowAppInstClient(*AppInstClientKey, AppInstClientApi_ShowAppInstClientServer) error
	// This is used unternally to forward AppInstClients to other Controllers
	StreamAppInstClientsLocal(*AppInstClientKey, AppInstClientApi_StreamAppInstClientsLocalServer) error
}

// UnimplementedAppInstClientApiServer can be embedded to have forward compatible implementations.
type UnimplementedAppInstClientApiServer struct {
}

func (*UnimplementedAppInstClientApiServer) ShowAppInstClient(req *AppInstClientKey, srv AppInstClientApi_ShowAppInstClientServer) error {
	return status.Errorf(codes.Unimplemented, "method ShowAppInstClient not implemented")
}
func (*UnimplementedAppInstClientApiServer) StreamAppInstClientsLocal(req *AppInstClientKey, srv AppInstClientApi_StreamAppInstClientsLocalServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamAppInstClientsLocal not implemented")
}

func RegisterAppInstClientApiServer(s *grpc.Server, srv AppInstClientApiServer) {
	s.RegisterService(&_AppInstClientApi_serviceDesc, srv)
}

func _AppInstClientApi_ShowAppInstClient_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AppInstClientKey)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AppInstClientApiServer).ShowAppInstClient(m, &appInstClientApiShowAppInstClientServer{stream})
}

type AppInstClientApi_ShowAppInstClientServer interface {
	Send(*AppInstClient) error
	grpc.ServerStream
}

type appInstClientApiShowAppInstClientServer struct {
	grpc.ServerStream
}

func (x *appInstClientApiShowAppInstClientServer) Send(m *AppInstClient) error {
	return x.ServerStream.SendMsg(m)
}

func _AppInstClientApi_StreamAppInstClientsLocal_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AppInstClientKey)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AppInstClientApiServer).StreamAppInstClientsLocal(m, &appInstClientApiStreamAppInstClientsLocalServer{stream})
}

type AppInstClientApi_StreamAppInstClientsLocalServer interface {
	Send(*AppInstClient) error
	grpc.ServerStream
}

type appInstClientApiStreamAppInstClientsLocalServer struct {
	grpc.ServerStream
}

func (x *appInstClientApiStreamAppInstClientsLocalServer) Send(m *AppInstClient) error {
	return x.ServerStream.SendMsg(m)
}

var _AppInstClientApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "edgeproto.AppInstClientApi",
	HandlerType: (*AppInstClientApiServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ShowAppInstClient",
			Handler:       _AppInstClientApi_ShowAppInstClient_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamAppInstClientsLocal",
			Handler:       _AppInstClientApi_StreamAppInstClientsLocal_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "appinstclient.proto",
}

func (m *AppInstClientKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppInstClientKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppInstClientKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.AppKey.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppinstclient(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.UniqueIdType) > 0 {
		i -= len(m.UniqueIdType)
		copy(dAtA[i:], m.UniqueIdType)
		i = encodeVarintAppinstclient(dAtA, i, uint64(len(m.UniqueIdType)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.UniqueId) > 0 {
		i -= len(m.UniqueId)
		copy(dAtA[i:], m.UniqueId)
		i = encodeVarintAppinstclient(dAtA, i, uint64(len(m.UniqueId)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.AppInstKey.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppinstclient(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AppInstClient) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppInstClient) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppInstClient) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NotifyId != 0 {
		i = encodeVarintAppinstclient(dAtA, i, uint64(m.NotifyId))
		i--
		dAtA[i] = 0x20
	}
	{
		size, err := m.Location.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppinstclient(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.ClientKey.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppinstclient(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Fields) > 0 {
		for iNdEx := len(m.Fields) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Fields[iNdEx])
			copy(dAtA[i:], m.Fields[iNdEx])
			i = encodeVarintAppinstclient(dAtA, i, uint64(len(m.Fields[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintAppinstclient(dAtA []byte, offset int, v uint64) int {
	offset -= sovAppinstclient(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *AppInstClientKey) Matches(o *AppInstClientKey, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !m.AppInstKey.Matches(&o.AppInstKey, fopts...) {
		return false
	}
	if !opts.Filter || o.UniqueId != "" {
		if o.UniqueId != m.UniqueId {
			return false
		}
	}
	if !opts.Filter || o.UniqueIdType != "" {
		if o.UniqueIdType != m.UniqueIdType {
			return false
		}
	}
	if !m.AppKey.Matches(&o.AppKey, fopts...) {
		return false
	}
	return true
}

func (m *AppInstClientKey) Clone() *AppInstClientKey {
	cp := &AppInstClientKey{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *AppInstClientKey) CopyInFields(src *AppInstClientKey) int {
	changed := 0
	if m.AppInstKey.Name != src.AppInstKey.Name {
		m.AppInstKey.Name = src.AppInstKey.Name
		changed++
	}
	if m.AppInstKey.Organization != src.AppInstKey.Organization {
		m.AppInstKey.Organization = src.AppInstKey.Organization
		changed++
	}
	if m.AppInstKey.CloudletKey.Organization != src.AppInstKey.CloudletKey.Organization {
		m.AppInstKey.CloudletKey.Organization = src.AppInstKey.CloudletKey.Organization
		changed++
	}
	if m.AppInstKey.CloudletKey.Name != src.AppInstKey.CloudletKey.Name {
		m.AppInstKey.CloudletKey.Name = src.AppInstKey.CloudletKey.Name
		changed++
	}
	if m.AppInstKey.CloudletKey.FederatedOrganization != src.AppInstKey.CloudletKey.FederatedOrganization {
		m.AppInstKey.CloudletKey.FederatedOrganization = src.AppInstKey.CloudletKey.FederatedOrganization
		changed++
	}
	if m.UniqueId != src.UniqueId {
		m.UniqueId = src.UniqueId
		changed++
	}
	if m.UniqueIdType != src.UniqueIdType {
		m.UniqueIdType = src.UniqueIdType
		changed++
	}
	if m.AppKey.Organization != src.AppKey.Organization {
		m.AppKey.Organization = src.AppKey.Organization
		changed++
	}
	if m.AppKey.Name != src.AppKey.Name {
		m.AppKey.Name = src.AppKey.Name
		changed++
	}
	if m.AppKey.Version != src.AppKey.Version {
		m.AppKey.Version = src.AppKey.Version
		changed++
	}
	return changed
}

func (m *AppInstClientKey) DeepCopyIn(src *AppInstClientKey) {
	m.AppInstKey.DeepCopyIn(&src.AppInstKey)
	m.UniqueId = src.UniqueId
	m.UniqueIdType = src.UniqueIdType
	m.AppKey.DeepCopyIn(&src.AppKey)
}

func (s *AppInstClientKey) HasFields() bool {
	return false
}

type AppInstClientKeyStore interface {
	Create(ctx context.Context, m *AppInstClientKey, wait func(int64)) (*Result, error)
	Update(ctx context.Context, m *AppInstClientKey, wait func(int64)) (*Result, error)
	Delete(ctx context.Context, m *AppInstClientKey, wait func(int64)) (*Result, error)
	Put(ctx context.Context, m *AppInstClientKey, wait func(int64), ops ...objstore.KVOp) (*Result, error)
	LoadOne(key string) (*AppInstClientKey, int64, error)
	Get(ctx context.Context, key *AppInstClientKey, buf *AppInstClientKey) bool
	STMGet(stm concurrency.STM, key *AppInstClientKey, buf *AppInstClientKey) bool
	STMPut(stm concurrency.STM, obj *AppInstClientKey, ops ...objstore.KVOp)
	STMDel(stm concurrency.STM, key *AppInstClientKey)
	STMHas(stm concurrency.STM, key *AppInstClientKey) bool
}

type AppInstClientKeyStoreImpl struct {
	kvstore objstore.KVStore
}

func NewAppInstClientKeyStore(kvstore objstore.KVStore) *AppInstClientKeyStoreImpl {
	return &AppInstClientKeyStoreImpl{kvstore: kvstore}
}

func (s *AppInstClientKeyStoreImpl) Create(ctx context.Context, m *AppInstClientKey, wait func(int64)) (*Result, error) {
	err := m.ValidateKey()
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("AppInstClientKey", m.GetKey())
	val, err := json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Create(ctx, key, string(val))
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *AppInstClientKeyStoreImpl) Update(ctx context.Context, m *AppInstClientKey, wait func(int64)) (*Result, error) {
	err := m.ValidateKey()
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("AppInstClientKey", m.GetKey())
	var vers int64 = 0
	val, err := json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Update(ctx, key, string(val), vers)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *AppInstClientKeyStoreImpl) Put(ctx context.Context, m *AppInstClientKey, wait func(int64), ops ...objstore.KVOp) (*Result, error) {
	err := m.ValidateKey()
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("AppInstClientKey", m.GetKey())
	var val []byte
	val, err = json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Put(ctx, key, string(val), ops...)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *AppInstClientKeyStoreImpl) Delete(ctx context.Context, m *AppInstClientKey, wait func(int64)) (*Result, error) {
	err := m.GetKey().ValidateKey()
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("AppInstClientKey", m.GetKey())
	rev, err := s.kvstore.Delete(ctx, key)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *AppInstClientKeyStoreImpl) LoadOne(key string) (*AppInstClientKey, int64, error) {
	val, rev, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, 0, err
	}
	var obj AppInstClientKey
	err = json.Unmarshal(val, &obj)
	if err != nil {
		log.DebugLog(log.DebugLevelApi, "Failed to parse AppInstClientKey data", "val", string(val), "err", err)
		return nil, 0, err
	}
	return &obj, rev, nil
}

func (s *AppInstClientKeyStoreImpl) Get(ctx context.Context, key *AppInstClientKey, buf *AppInstClientKey) bool {
	keystr := objstore.DbKeyString("AppInstClientKey", key)
	val, _, _, err := s.kvstore.Get(keystr)
	if err != nil {
		return false
	}
	return s.parseGetData(val, buf)
}

func (s *AppInstClientKeyStoreImpl) STMGet(stm concurrency.STM, key *AppInstClientKey, buf *AppInstClientKey) bool {
	keystr := objstore.DbKeyString("AppInstClientKey", key)
	valstr := stm.Get(keystr)
	return s.parseGetData([]byte(valstr), buf)
}

func (s *AppInstClientKeyStoreImpl) STMHas(stm concurrency.STM, key *AppInstClientKey) bool {
	keystr := objstore.DbKeyString("AppInstClientKey", key)
	return stm.Get(keystr) != ""
}

func (s *AppInstClientKeyStoreImpl) parseGetData(val []byte, buf *AppInstClientKey) bool {
	if len(val) == 0 {
		return false
	}
	if buf != nil {
		// clear buf, because empty values in val won't
		// overwrite non-empty values in buf.
		*buf = AppInstClientKey{}
		err := json.Unmarshal(val, buf)
		if err != nil {
			return false
		}
	}
	return true
}

func (s *AppInstClientKeyStoreImpl) STMPut(stm concurrency.STM, obj *AppInstClientKey, ops ...objstore.KVOp) {
	keystr := objstore.DbKeyString("AppInstClientKey", obj.GetKey())

	val, err := json.Marshal(obj)
	if err != nil {
		log.InfoLog("AppInstClientKey json marshal failed", "obj", obj, "err", err)
	}
	v3opts := GetSTMOpts(ops...)
	stm.Put(keystr, string(val), v3opts...)
}

func (s *AppInstClientKeyStoreImpl) STMDel(stm concurrency.STM, key *AppInstClientKey) {
	keystr := objstore.DbKeyString("AppInstClientKey", key)
	stm.Del(keystr)
}

type AppInstClientKeyKeyWatcher struct {
	cb func(ctx context.Context)
}

type AppInstClientKeyCacheData struct {
	Obj    *AppInstClientKey
	ModRev int64
}

func (s *AppInstClientKeyCacheData) Clone() *AppInstClientKeyCacheData {
	cp := AppInstClientKeyCacheData{}
	if s.Obj != nil {
		cp.Obj = &AppInstClientKey{}
		cp.Obj.DeepCopyIn(s.Obj)
	}
	cp.ModRev = s.ModRev
	return &cp
}

// AppInstClientKeyCache caches AppInstClientKey objects in memory in a hash table
// and keeps them in sync with the database.
type AppInstClientKeyCache struct {
	Objs          map[AppInstClientKey]*AppInstClientKeyCacheData
	Mux           util.Mutex
	List          map[AppInstClientKey]struct{}
	FlushAll      bool
	NotifyCbs     []func(ctx context.Context, obj *AppInstClientKey, modRev int64)
	UpdatedCbs    []func(ctx context.Context, old *AppInstClientKey, new *AppInstClientKey)
	DeletedCbs    []func(ctx context.Context, old *AppInstClientKey)
	KeyWatchers   map[AppInstClientKey][]*AppInstClientKeyKeyWatcher
	UpdatedKeyCbs []func(ctx context.Context, key *AppInstClientKey)
	DeletedKeyCbs []func(ctx context.Context, key *AppInstClientKey)
}

func NewAppInstClientKeyCache() *AppInstClientKeyCache {
	cache := AppInstClientKeyCache{}
	InitAppInstClientKeyCache(&cache)
	return &cache
}

func InitAppInstClientKeyCache(cache *AppInstClientKeyCache) {
	cache.Objs = make(map[AppInstClientKey]*AppInstClientKeyCacheData)
	cache.KeyWatchers = make(map[AppInstClientKey][]*AppInstClientKeyKeyWatcher)
	cache.NotifyCbs = nil
	cache.UpdatedCbs = nil
	cache.DeletedCbs = nil
	cache.UpdatedKeyCbs = nil
	cache.DeletedKeyCbs = nil
}

func (c *AppInstClientKeyCache) GetTypeString() string {
	return "AppInstClientKey"
}

func (c *AppInstClientKeyCache) Get(key *AppInstClientKey, valbuf *AppInstClientKey) bool {
	var modRev int64
	return c.GetWithRev(key, valbuf, &modRev)
}

func (c *AppInstClientKeyCache) GetWithRev(key *AppInstClientKey, valbuf *AppInstClientKey, modRev *int64) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	inst, found := c.Objs[*key]
	if found {
		valbuf.DeepCopyIn(inst.Obj)
		*modRev = inst.ModRev
	}
	return found
}

func (c *AppInstClientKeyCache) HasKey(key *AppInstClientKey) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	_, found := c.Objs[*key]
	return found
}

func (c *AppInstClientKeyCache) GetAllKeys(ctx context.Context, cb func(key *AppInstClientKey, modRev int64)) {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for key, data := range c.Objs {
		cb(&key, data.ModRev)
	}
}

func (c *AppInstClientKeyCache) GetAllLocked(ctx context.Context, cb func(obj *AppInstClientKey, modRev int64)) {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for _, data := range c.Objs {
		cb(data.Obj, data.ModRev)
	}
}

func (c *AppInstClientKeyCache) Update(ctx context.Context, in *AppInstClientKey, modRev int64) {
	c.UpdateModFunc(ctx, in.GetKey(), modRev, func(old *AppInstClientKey) (*AppInstClientKey, bool) {
		return in, true
	})
}

func (c *AppInstClientKeyCache) UpdateModFunc(ctx context.Context, key *AppInstClientKey, modRev int64, modFunc func(old *AppInstClientKey) (new *AppInstClientKey, changed bool)) {
	c.Mux.Lock()
	var old *AppInstClientKey
	if oldData, found := c.Objs[*key]; found {
		old = oldData.Obj
	}
	new, changed := modFunc(old)
	if !changed {
		c.Mux.Unlock()
		return
	}
	if len(c.UpdatedCbs) > 0 || len(c.NotifyCbs) > 0 {
		newCopy := &AppInstClientKey{}
		newCopy.DeepCopyIn(new)
		for _, cb := range c.UpdatedCbs {
			defer cb(ctx, old, newCopy)
		}
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				defer cb(ctx, newCopy, modRev)
			}
		}
	}
	for _, cb := range c.UpdatedKeyCbs {
		defer cb(ctx, key)
	}
	store := &AppInstClientKey{}
	store.DeepCopyIn(new)
	c.Objs[new.GetKeyVal()] = &AppInstClientKeyCacheData{
		Obj:    store,
		ModRev: modRev,
	}
	log.SpanLog(ctx, log.DebugLevelApi, "cache update", "new", store)
	c.Mux.Unlock()
	c.TriggerKeyWatchers(ctx, new.GetKey())
}

func (c *AppInstClientKeyCache) Delete(ctx context.Context, in *AppInstClientKey, modRev int64) {
	c.DeleteCondFunc(ctx, in, modRev, func(old *AppInstClientKey) bool {
		return true
	})
}

func (c *AppInstClientKeyCache) DeleteCondFunc(ctx context.Context, in *AppInstClientKey, modRev int64, condFunc func(old *AppInstClientKey) bool) {
	c.Mux.Lock()
	var old *AppInstClientKey
	oldData, found := c.Objs[in.GetKeyVal()]
	if found {
		old = oldData.Obj
		if !condFunc(old) {
			c.Mux.Unlock()
			return
		}
	}
	delete(c.Objs, in.GetKeyVal())
	log.SpanLog(ctx, log.DebugLevelApi, "cache delete", "key", in.GetKeyVal())
	c.Mux.Unlock()
	obj := old
	if obj == nil {
		obj = in
	}
	for _, cb := range c.NotifyCbs {
		if cb != nil {
			cb(ctx, obj, modRev)
		}
	}
	if old != nil {
		for _, cb := range c.DeletedCbs {
			cb(ctx, old)
		}
	}
	for _, cb := range c.DeletedKeyCbs {
		cb(ctx, in.GetKey())
	}
	c.TriggerKeyWatchers(ctx, in.GetKey())
}

func (c *AppInstClientKeyCache) Prune(ctx context.Context, validKeys map[AppInstClientKey]struct{}) {
	log.SpanLog(ctx, log.DebugLevelApi, "Prune AppInstClientKey", "numValidKeys", len(validKeys))
	notify := make(map[AppInstClientKey]*AppInstClientKeyCacheData)
	c.Mux.Lock()
	for key, _ := range c.Objs {
		if _, ok := validKeys[key]; !ok {
			if len(c.NotifyCbs) > 0 || len(c.DeletedKeyCbs) > 0 || len(c.DeletedCbs) > 0 {
				notify[key] = c.Objs[key]
			}
			delete(c.Objs, key)
		}
	}
	c.Mux.Unlock()
	for key, old := range notify {
		obj := old.Obj
		if obj == nil {
			obj = &AppInstClientKey{}
			obj.SetKey(&key)
		}
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, obj, old.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if old.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, old.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (c *AppInstClientKeyCache) GetCount() int {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	return len(c.Objs)
}

func (c *AppInstClientKeyCache) Flush(ctx context.Context, notifyId int64) {
}

func (c *AppInstClientKeyCache) Show(filter *AppInstClientKey, cb func(ret *AppInstClientKey) error) error {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for _, data := range c.Objs {
		if !data.Obj.Matches(filter, MatchFilter()) {
			continue
		}
		err := cb(data.Obj)
		if err != nil {
			return err
		}
	}
	return nil
}

func AppInstClientKeyGenericNotifyCb(fn func(key *AppInstClientKey, old *AppInstClientKey)) func(objstore.ObjKey, objstore.Obj) {
	return func(objkey objstore.ObjKey, obj objstore.Obj) {
		fn(objkey.(*AppInstClientKey), obj.(*AppInstClientKey))
	}
}

func (c *AppInstClientKeyCache) SetNotifyCb(fn func(ctx context.Context, obj *AppInstClientKey, modRev int64)) {
	c.NotifyCbs = []func(ctx context.Context, obj *AppInstClientKey, modRev int64){fn}
}

func (c *AppInstClientKeyCache) SetUpdatedCb(fn func(ctx context.Context, old *AppInstClientKey, new *AppInstClientKey)) {
	c.UpdatedCbs = []func(ctx context.Context, old *AppInstClientKey, new *AppInstClientKey){fn}
}

func (c *AppInstClientKeyCache) SetDeletedCb(fn func(ctx context.Context, old *AppInstClientKey)) {
	c.DeletedCbs = []func(ctx context.Context, old *AppInstClientKey){fn}
}

func (c *AppInstClientKeyCache) SetUpdatedKeyCb(fn func(ctx context.Context, key *AppInstClientKey)) {
	c.UpdatedKeyCbs = []func(ctx context.Context, key *AppInstClientKey){fn}
}

func (c *AppInstClientKeyCache) SetDeletedKeyCb(fn func(ctx context.Context, key *AppInstClientKey)) {
	c.DeletedKeyCbs = []func(ctx context.Context, key *AppInstClientKey){fn}
}

func (c *AppInstClientKeyCache) AddUpdatedCb(fn func(ctx context.Context, old *AppInstClientKey, new *AppInstClientKey)) {
	c.UpdatedCbs = append(c.UpdatedCbs, fn)
}

func (c *AppInstClientKeyCache) AddDeletedCb(fn func(ctx context.Context, old *AppInstClientKey)) {
	c.DeletedCbs = append(c.DeletedCbs, fn)
}

func (c *AppInstClientKeyCache) AddNotifyCb(fn func(ctx context.Context, obj *AppInstClientKey, modRev int64)) {
	c.NotifyCbs = append(c.NotifyCbs, fn)
}

func (c *AppInstClientKeyCache) AddUpdatedKeyCb(fn func(ctx context.Context, key *AppInstClientKey)) {
	c.UpdatedKeyCbs = append(c.UpdatedKeyCbs, fn)
}

func (c *AppInstClientKeyCache) AddDeletedKeyCb(fn func(ctx context.Context, key *AppInstClientKey)) {
	c.DeletedKeyCbs = append(c.DeletedKeyCbs, fn)
}

func (c *AppInstClientKeyCache) SetFlushAll() {
	c.FlushAll = true
}

func (c *AppInstClientKeyCache) WatchKey(key *AppInstClientKey, cb func(ctx context.Context)) context.CancelFunc {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	list, ok := c.KeyWatchers[*key]
	if !ok {
		list = make([]*AppInstClientKeyKeyWatcher, 0)
	}
	watcher := AppInstClientKeyKeyWatcher{cb: cb}
	c.KeyWatchers[*key] = append(list, &watcher)
	log.DebugLog(log.DebugLevelApi, "Watching AppInstClientKey", "key", key)
	return func() {
		c.Mux.Lock()
		defer c.Mux.Unlock()
		list, ok := c.KeyWatchers[*key]
		if !ok {
			return
		}
		for ii, _ := range list {
			if list[ii] != &watcher {
				continue
			}
			if len(list) == 1 {
				delete(c.KeyWatchers, *key)
				return
			}
			list[ii] = list[len(list)-1]
			list[len(list)-1] = nil
			c.KeyWatchers[*key] = list[:len(list)-1]
			return
		}
	}
}

func (c *AppInstClientKeyCache) TriggerKeyWatchers(ctx context.Context, key *AppInstClientKey) {
	watchers := make([]*AppInstClientKeyKeyWatcher, 0)
	c.Mux.Lock()
	if list, ok := c.KeyWatchers[*key]; ok {
		watchers = append(watchers, list...)
	}
	c.Mux.Unlock()
	for ii, _ := range watchers {
		watchers[ii].cb(ctx)
	}
}

// Note that we explicitly ignore the global revision number, because of the way
// the notify framework sends updates (by hashing keys and doing lookups, instead
// of sequentially through a history buffer), updates may be done out-of-order
// or multiple updates compressed into one update, so the state of the cache at
// any point in time may not by in sync with a particular database revision number.

func (c *AppInstClientKeyCache) SyncUpdate(ctx context.Context, key, val []byte, rev, modRev int64) {
	obj := AppInstClientKey{}
	err := json.Unmarshal(val, &obj)
	if err != nil {
		log.WarnLog("Failed to parse AppInstClientKey data", "val", string(val), "err", err)
		return
	}
	c.Update(ctx, &obj, modRev)
	c.Mux.Lock()
	if c.List != nil {
		c.List[obj.GetKeyVal()] = struct{}{}
	}
	c.Mux.Unlock()
}

func (c *AppInstClientKeyCache) SyncDelete(ctx context.Context, key []byte, rev, modRev int64) {
	obj := AppInstClientKey{}
	keystr := objstore.DbKeyPrefixRemove(string(key))
	AppInstClientKeyStringParse(keystr, obj.GetKey())
	c.Delete(ctx, &obj, modRev)
}

func (c *AppInstClientKeyCache) SyncListStart(ctx context.Context) {
	c.List = make(map[AppInstClientKey]struct{})
}

func (c *AppInstClientKeyCache) SyncListEnd(ctx context.Context) {
	deleted := make(map[AppInstClientKey]*AppInstClientKeyCacheData)
	c.Mux.Lock()
	for key, val := range c.Objs {
		if _, found := c.List[key]; !found {
			deleted[key] = val
			delete(c.Objs, key)
		}
	}
	c.List = nil
	c.Mux.Unlock()
	for key, val := range deleted {
		obj := val.Obj
		if obj == nil {
			obj = &AppInstClientKey{}
			obj.SetKey(&key)
		}
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, obj, val.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if val.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, val.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (c *AppInstClientKeyCache) UsesOrg(org string) bool {
	return false
}
func (m *AppInstClientKey) GetKeyString() string {
	key, err := json.Marshal(m)
	if err != nil {
		log.FatalLog("Failed to marshal AppInstClientKey key string", "obj", m)
	}
	return string(key)
}

func AppInstClientKeyStringParse(str string, key *AppInstClientKey) {
	err := json.Unmarshal([]byte(str), key)
	if err != nil {
		log.FatalLog("Failed to unmarshal AppInstClientKey key string", "str", str)
	}
}

func (m *AppInstClientKey) NotFoundError() error {
	return fmt.Errorf("AppInstClient key %s not found", m.GetKeyString())
}

func (m *AppInstClientKey) ExistsError() error {
	return fmt.Errorf("AppInstClient key %s already exists", m.GetKeyString())
}

func (m *AppInstClientKey) BeingDeletedError() error {
	return fmt.Errorf("AppInstClient %s is being deleted", m.GetKeyString())
}

var AppInstClientKeyTagUniqueId = "uniqueid"
var AppInstClientKeyTagUniqueIdType = "uniqueidtype"

func (m *AppInstClientKey) GetTags() map[string]string {
	tags := make(map[string]string)
	m.AddTags(tags)
	return tags
}

func (m *AppInstClientKey) AddTagsByFunc(addTag AddTagFunc) {
	addTag("appinst", m.AppInstKey.Name)
	addTag("appinstorg", m.AppInstKey.Organization)
	addTag("cloudletorg", m.AppInstKey.CloudletKey.Organization)
	addTag("cloudlet", m.AppInstKey.CloudletKey.Name)
	addTag("cloudletfedorg", m.AppInstKey.CloudletKey.FederatedOrganization)
	addTag("uniqueid", m.UniqueId)
	addTag("uniqueidtype", m.UniqueIdType)
	addTag("apporg", m.AppKey.Organization)
	addTag("app", m.AppKey.Name)
	addTag("appver", m.AppKey.Version)
}

func (m *AppInstClientKey) AddTags(tags map[string]string) {
	tagMap := TagMap(tags)
	m.AddTagsByFunc(tagMap.AddTag)
}

func (m *AppInstClientKey) GetObjKey() objstore.ObjKey {
	return m.GetKey()
}

func (m *AppInstClientKey) GetKey() *AppInstClientKey {
	return m
}

func (m *AppInstClientKey) GetKeyVal() AppInstClientKey {
	return *m
}

func (m *AppInstClientKey) SetKey(key *AppInstClientKey) {
	*m = *key
}

func CmpSortAppInstClientKey(a AppInstClientKey, b AppInstClientKey) bool {
	return a.GetKeyString() < b.GetKeyString()
}

// MessageKey can be used as a channel name which includes the
// key value for pubsub, to listen for this specific object type
// plus key value.
func (m *AppInstClientKey) MessageKey() string {
	return fmt.Sprintf("msg/key/AppInstClientKey/%s", m.GetKey().GetKeyString())
}

func (m *AppInstClientKey) MessageTypeKey() string {
	return "msg/type/AppInstClientKey"
}

// Helper method to check that enums have valid values
func (m *AppInstClientKey) ValidateEnums() error {
	if err := m.AppInstKey.ValidateEnums(); err != nil {
		return err
	}
	if err := m.AppKey.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func (s *AppInstClientKey) ClearTagged(tags map[string]struct{}) {
	s.AppInstKey.ClearTagged(tags)
	s.AppKey.ClearTagged(tags)
}

const AppInstClientFieldClientKey = "2"
const AppInstClientFieldClientKeyAppInstKey = "2.1"
const AppInstClientFieldClientKeyAppInstKeyName = "2.1.1"
const AppInstClientFieldClientKeyAppInstKeyOrganization = "2.1.2"
const AppInstClientFieldClientKeyAppInstKeyCloudletKey = "2.1.3"
const AppInstClientFieldClientKeyAppInstKeyCloudletKeyOrganization = "2.1.3.1"
const AppInstClientFieldClientKeyAppInstKeyCloudletKeyName = "2.1.3.2"
const AppInstClientFieldClientKeyAppInstKeyCloudletKeyFederatedOrganization = "2.1.3.3"
const AppInstClientFieldClientKeyUniqueId = "2.2"
const AppInstClientFieldClientKeyUniqueIdType = "2.3"
const AppInstClientFieldClientKeyAppKey = "2.4"
const AppInstClientFieldClientKeyAppKeyOrganization = "2.4.1"
const AppInstClientFieldClientKeyAppKeyName = "2.4.2"
const AppInstClientFieldClientKeyAppKeyVersion = "2.4.3"
const AppInstClientFieldLocation = "3"
const AppInstClientFieldLocationLatitude = "3.1"
const AppInstClientFieldLocationLongitude = "3.2"
const AppInstClientFieldLocationHorizontalAccuracy = "3.3"
const AppInstClientFieldLocationVerticalAccuracy = "3.4"
const AppInstClientFieldLocationAltitude = "3.5"
const AppInstClientFieldLocationCourse = "3.6"
const AppInstClientFieldLocationSpeed = "3.7"
const AppInstClientFieldLocationTimestamp = "3.8"
const AppInstClientFieldLocationTimestampSeconds = "3.8.1"
const AppInstClientFieldLocationTimestampNanos = "3.8.2"
const AppInstClientFieldNotifyId = "4"

var AppInstClientAllFields = []string{
	AppInstClientFieldClientKeyAppInstKeyName,
	AppInstClientFieldClientKeyAppInstKeyOrganization,
	AppInstClientFieldClientKeyAppInstKeyCloudletKeyOrganization,
	AppInstClientFieldClientKeyAppInstKeyCloudletKeyName,
	AppInstClientFieldClientKeyAppInstKeyCloudletKeyFederatedOrganization,
	AppInstClientFieldClientKeyUniqueId,
	AppInstClientFieldClientKeyUniqueIdType,
	AppInstClientFieldClientKeyAppKeyOrganization,
	AppInstClientFieldClientKeyAppKeyName,
	AppInstClientFieldClientKeyAppKeyVersion,
	AppInstClientFieldLocationLatitude,
	AppInstClientFieldLocationLongitude,
	AppInstClientFieldLocationHorizontalAccuracy,
	AppInstClientFieldLocationVerticalAccuracy,
	AppInstClientFieldLocationAltitude,
	AppInstClientFieldLocationCourse,
	AppInstClientFieldLocationSpeed,
	AppInstClientFieldLocationTimestampSeconds,
	AppInstClientFieldLocationTimestampNanos,
	AppInstClientFieldNotifyId,
}

var AppInstClientAllFieldsMap = map[string]struct{}{
	AppInstClientFieldClientKeyAppInstKeyName:                             struct{}{},
	AppInstClientFieldClientKeyAppInstKeyOrganization:                     struct{}{},
	AppInstClientFieldClientKeyAppInstKeyCloudletKeyOrganization:          struct{}{},
	AppInstClientFieldClientKeyAppInstKeyCloudletKeyName:                  struct{}{},
	AppInstClientFieldClientKeyAppInstKeyCloudletKeyFederatedOrganization: struct{}{},
	AppInstClientFieldClientKeyUniqueId:                                   struct{}{},
	AppInstClientFieldClientKeyUniqueIdType:                               struct{}{},
	AppInstClientFieldClientKeyAppKeyOrganization:                         struct{}{},
	AppInstClientFieldClientKeyAppKeyName:                                 struct{}{},
	AppInstClientFieldClientKeyAppKeyVersion:                              struct{}{},
	AppInstClientFieldLocationLatitude:                                    struct{}{},
	AppInstClientFieldLocationLongitude:                                   struct{}{},
	AppInstClientFieldLocationHorizontalAccuracy:                          struct{}{},
	AppInstClientFieldLocationVerticalAccuracy:                            struct{}{},
	AppInstClientFieldLocationAltitude:                                    struct{}{},
	AppInstClientFieldLocationCourse:                                      struct{}{},
	AppInstClientFieldLocationSpeed:                                       struct{}{},
	AppInstClientFieldLocationTimestampSeconds:                            struct{}{},
	AppInstClientFieldLocationTimestampNanos:                              struct{}{},
	AppInstClientFieldNotifyId:                                            struct{}{},
}

var AppInstClientAllFieldsStringMap = map[string]string{
	AppInstClientFieldClientKeyAppInstKeyName:                             "Client Key App Inst Key Name",
	AppInstClientFieldClientKeyAppInstKeyOrganization:                     "Client Key App Inst Key Organization",
	AppInstClientFieldClientKeyAppInstKeyCloudletKeyOrganization:          "Client Key App Inst Key Cloudlet Key Organization",
	AppInstClientFieldClientKeyAppInstKeyCloudletKeyName:                  "Client Key App Inst Key Cloudlet Key Name",
	AppInstClientFieldClientKeyAppInstKeyCloudletKeyFederatedOrganization: "Client Key App Inst Key Cloudlet Key Federated Organization",
	AppInstClientFieldClientKeyUniqueId:                                   "Client Key Unique Id",
	AppInstClientFieldClientKeyUniqueIdType:                               "Client Key Unique Id Type",
	AppInstClientFieldClientKeyAppKeyOrganization:                         "Client Key App Key Organization",
	AppInstClientFieldClientKeyAppKeyName:                                 "Client Key App Key Name",
	AppInstClientFieldClientKeyAppKeyVersion:                              "Client Key App Key Version",
	AppInstClientFieldLocationLatitude:                                    "Location Latitude",
	AppInstClientFieldLocationLongitude:                                   "Location Longitude",
	AppInstClientFieldLocationHorizontalAccuracy:                          "Location Horizontal Accuracy",
	AppInstClientFieldLocationVerticalAccuracy:                            "Location Vertical Accuracy",
	AppInstClientFieldLocationAltitude:                                    "Location Altitude",
	AppInstClientFieldLocationCourse:                                      "Location Course",
	AppInstClientFieldLocationSpeed:                                       "Location Speed",
	AppInstClientFieldLocationTimestampSeconds:                            "Location Timestamp Seconds",
	AppInstClientFieldLocationTimestampNanos:                              "Location Timestamp Nanos",
	AppInstClientFieldNotifyId:                                            "Notify Id",
}

func (m *AppInstClient) IsKeyField(s string) bool {
	return strings.HasPrefix(s, AppInstClientFieldClientKey+".") || s == AppInstClientFieldClientKey
}

func (m *AppInstClient) DiffFields(o *AppInstClient, fields map[string]struct{}) {
	if m.ClientKey.AppInstKey.Name != o.ClientKey.AppInstKey.Name {
		fields[AppInstClientFieldClientKeyAppInstKeyName] = struct{}{}
		fields[AppInstClientFieldClientKeyAppInstKey] = struct{}{}
		fields[AppInstClientFieldClientKey] = struct{}{}
	}
	if m.ClientKey.AppInstKey.Organization != o.ClientKey.AppInstKey.Organization {
		fields[AppInstClientFieldClientKeyAppInstKeyOrganization] = struct{}{}
		fields[AppInstClientFieldClientKeyAppInstKey] = struct{}{}
		fields[AppInstClientFieldClientKey] = struct{}{}
	}
	if m.ClientKey.AppInstKey.CloudletKey.Organization != o.ClientKey.AppInstKey.CloudletKey.Organization {
		fields[AppInstClientFieldClientKeyAppInstKeyCloudletKeyOrganization] = struct{}{}
		fields[AppInstClientFieldClientKeyAppInstKeyCloudletKey] = struct{}{}
		fields[AppInstClientFieldClientKeyAppInstKey] = struct{}{}
		fields[AppInstClientFieldClientKey] = struct{}{}
	}
	if m.ClientKey.AppInstKey.CloudletKey.Name != o.ClientKey.AppInstKey.CloudletKey.Name {
		fields[AppInstClientFieldClientKeyAppInstKeyCloudletKeyName] = struct{}{}
		fields[AppInstClientFieldClientKeyAppInstKeyCloudletKey] = struct{}{}
		fields[AppInstClientFieldClientKeyAppInstKey] = struct{}{}
		fields[AppInstClientFieldClientKey] = struct{}{}
	}
	if m.ClientKey.AppInstKey.CloudletKey.FederatedOrganization != o.ClientKey.AppInstKey.CloudletKey.FederatedOrganization {
		fields[AppInstClientFieldClientKeyAppInstKeyCloudletKeyFederatedOrganization] = struct{}{}
		fields[AppInstClientFieldClientKeyAppInstKeyCloudletKey] = struct{}{}
		fields[AppInstClientFieldClientKeyAppInstKey] = struct{}{}
		fields[AppInstClientFieldClientKey] = struct{}{}
	}
	if m.ClientKey.UniqueId != o.ClientKey.UniqueId {
		fields[AppInstClientFieldClientKeyUniqueId] = struct{}{}
		fields[AppInstClientFieldClientKey] = struct{}{}
	}
	if m.ClientKey.UniqueIdType != o.ClientKey.UniqueIdType {
		fields[AppInstClientFieldClientKeyUniqueIdType] = struct{}{}
		fields[AppInstClientFieldClientKey] = struct{}{}
	}
	if m.ClientKey.AppKey.Organization != o.ClientKey.AppKey.Organization {
		fields[AppInstClientFieldClientKeyAppKeyOrganization] = struct{}{}
		fields[AppInstClientFieldClientKeyAppKey] = struct{}{}
		fields[AppInstClientFieldClientKey] = struct{}{}
	}
	if m.ClientKey.AppKey.Name != o.ClientKey.AppKey.Name {
		fields[AppInstClientFieldClientKeyAppKeyName] = struct{}{}
		fields[AppInstClientFieldClientKeyAppKey] = struct{}{}
		fields[AppInstClientFieldClientKey] = struct{}{}
	}
	if m.ClientKey.AppKey.Version != o.ClientKey.AppKey.Version {
		fields[AppInstClientFieldClientKeyAppKeyVersion] = struct{}{}
		fields[AppInstClientFieldClientKeyAppKey] = struct{}{}
		fields[AppInstClientFieldClientKey] = struct{}{}
	}
	if m.Location.Latitude != o.Location.Latitude {
		fields[AppInstClientFieldLocationLatitude] = struct{}{}
		fields[AppInstClientFieldLocation] = struct{}{}
	}
	if m.Location.Longitude != o.Location.Longitude {
		fields[AppInstClientFieldLocationLongitude] = struct{}{}
		fields[AppInstClientFieldLocation] = struct{}{}
	}
	if m.Location.HorizontalAccuracy != o.Location.HorizontalAccuracy {
		fields[AppInstClientFieldLocationHorizontalAccuracy] = struct{}{}
		fields[AppInstClientFieldLocation] = struct{}{}
	}
	if m.Location.VerticalAccuracy != o.Location.VerticalAccuracy {
		fields[AppInstClientFieldLocationVerticalAccuracy] = struct{}{}
		fields[AppInstClientFieldLocation] = struct{}{}
	}
	if m.Location.Altitude != o.Location.Altitude {
		fields[AppInstClientFieldLocationAltitude] = struct{}{}
		fields[AppInstClientFieldLocation] = struct{}{}
	}
	if m.Location.Course != o.Location.Course {
		fields[AppInstClientFieldLocationCourse] = struct{}{}
		fields[AppInstClientFieldLocation] = struct{}{}
	}
	if m.Location.Speed != o.Location.Speed {
		fields[AppInstClientFieldLocationSpeed] = struct{}{}
		fields[AppInstClientFieldLocation] = struct{}{}
	}
	if m.Location.Timestamp != nil && o.Location.Timestamp != nil {
		if m.Location.Timestamp.Seconds != o.Location.Timestamp.Seconds {
			fields[AppInstClientFieldLocationTimestampSeconds] = struct{}{}
			fields[AppInstClientFieldLocationTimestamp] = struct{}{}
			fields[AppInstClientFieldLocation] = struct{}{}
		}
		if m.Location.Timestamp.Nanos != o.Location.Timestamp.Nanos {
			fields[AppInstClientFieldLocationTimestampNanos] = struct{}{}
			fields[AppInstClientFieldLocationTimestamp] = struct{}{}
			fields[AppInstClientFieldLocation] = struct{}{}
		}
	} else if (m.Location.Timestamp != nil && o.Location.Timestamp == nil) || (m.Location.Timestamp == nil && o.Location.Timestamp != nil) {
		fields[AppInstClientFieldLocationTimestamp] = struct{}{}
		fields[AppInstClientFieldLocation] = struct{}{}
	}
	if m.NotifyId != o.NotifyId {
		fields[AppInstClientFieldNotifyId] = struct{}{}
	}
}

func (m *AppInstClient) Clone() *AppInstClient {
	cp := &AppInstClient{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *AppInstClient) CopyInFields(src *AppInstClient) int {
	changed := 0
	fmap := MakeFieldMap(src.Fields)
	if _, set := fmap["2"]; set {
		if _, set := fmap["2.1"]; set {
			if _, set := fmap["2.1.1"]; set {
				if m.ClientKey.AppInstKey.Name != src.ClientKey.AppInstKey.Name {
					m.ClientKey.AppInstKey.Name = src.ClientKey.AppInstKey.Name
					changed++
				}
			}
			if _, set := fmap["2.1.2"]; set {
				if m.ClientKey.AppInstKey.Organization != src.ClientKey.AppInstKey.Organization {
					m.ClientKey.AppInstKey.Organization = src.ClientKey.AppInstKey.Organization
					changed++
				}
			}
			if _, set := fmap["2.1.3"]; set {
				if _, set := fmap["2.1.3.1"]; set {
					if m.ClientKey.AppInstKey.CloudletKey.Organization != src.ClientKey.AppInstKey.CloudletKey.Organization {
						m.ClientKey.AppInstKey.CloudletKey.Organization = src.ClientKey.AppInstKey.CloudletKey.Organization
						changed++
					}
				}
				if _, set := fmap["2.1.3.2"]; set {
					if m.ClientKey.AppInstKey.CloudletKey.Name != src.ClientKey.AppInstKey.CloudletKey.Name {
						m.ClientKey.AppInstKey.CloudletKey.Name = src.ClientKey.AppInstKey.CloudletKey.Name
						changed++
					}
				}
				if _, set := fmap["2.1.3.3"]; set {
					if m.ClientKey.AppInstKey.CloudletKey.FederatedOrganization != src.ClientKey.AppInstKey.CloudletKey.FederatedOrganization {
						m.ClientKey.AppInstKey.CloudletKey.FederatedOrganization = src.ClientKey.AppInstKey.CloudletKey.FederatedOrganization
						changed++
					}
				}
			}
		}
		if _, set := fmap["2.2"]; set {
			if m.ClientKey.UniqueId != src.ClientKey.UniqueId {
				m.ClientKey.UniqueId = src.ClientKey.UniqueId
				changed++
			}
		}
		if _, set := fmap["2.3"]; set {
			if m.ClientKey.UniqueIdType != src.ClientKey.UniqueIdType {
				m.ClientKey.UniqueIdType = src.ClientKey.UniqueIdType
				changed++
			}
		}
		if _, set := fmap["2.4"]; set {
			if _, set := fmap["2.4.1"]; set {
				if m.ClientKey.AppKey.Organization != src.ClientKey.AppKey.Organization {
					m.ClientKey.AppKey.Organization = src.ClientKey.AppKey.Organization
					changed++
				}
			}
			if _, set := fmap["2.4.2"]; set {
				if m.ClientKey.AppKey.Name != src.ClientKey.AppKey.Name {
					m.ClientKey.AppKey.Name = src.ClientKey.AppKey.Name
					changed++
				}
			}
			if _, set := fmap["2.4.3"]; set {
				if m.ClientKey.AppKey.Version != src.ClientKey.AppKey.Version {
					m.ClientKey.AppKey.Version = src.ClientKey.AppKey.Version
					changed++
				}
			}
		}
	}
	if _, set := fmap["3"]; set {
		if _, set := fmap["3.1"]; set {
			if m.Location.Latitude != src.Location.Latitude {
				m.Location.Latitude = src.Location.Latitude
				changed++
			}
		}
		if _, set := fmap["3.2"]; set {
			if m.Location.Longitude != src.Location.Longitude {
				m.Location.Longitude = src.Location.Longitude
				changed++
			}
		}
		if _, set := fmap["3.3"]; set {
			if m.Location.HorizontalAccuracy != src.Location.HorizontalAccuracy {
				m.Location.HorizontalAccuracy = src.Location.HorizontalAccuracy
				changed++
			}
		}
		if _, set := fmap["3.4"]; set {
			if m.Location.VerticalAccuracy != src.Location.VerticalAccuracy {
				m.Location.VerticalAccuracy = src.Location.VerticalAccuracy
				changed++
			}
		}
		if _, set := fmap["3.5"]; set {
			if m.Location.Altitude != src.Location.Altitude {
				m.Location.Altitude = src.Location.Altitude
				changed++
			}
		}
		if _, set := fmap["3.6"]; set {
			if m.Location.Course != src.Location.Course {
				m.Location.Course = src.Location.Course
				changed++
			}
		}
		if _, set := fmap["3.7"]; set {
			if m.Location.Speed != src.Location.Speed {
				m.Location.Speed = src.Location.Speed
				changed++
			}
		}
		if _, set := fmap["3.8"]; set {
			if src.Location.Timestamp != nil {
				if m.Location.Timestamp == nil {
					m.Location.Timestamp = &distributed_match_engine.Timestamp{}
				}
				if _, set := fmap["3.8.1"]; set {
					if m.Location.Timestamp.Seconds != src.Location.Timestamp.Seconds {
						m.Location.Timestamp.Seconds = src.Location.Timestamp.Seconds
						changed++
					}
				}
				if _, set := fmap["3.8.2"]; set {
					if m.Location.Timestamp.Nanos != src.Location.Timestamp.Nanos {
						m.Location.Timestamp.Nanos = src.Location.Timestamp.Nanos
						changed++
					}
				}
			} else if m.Location.Timestamp != nil {
				m.Location.Timestamp = nil
				changed++
			}
		}
	}
	if _, set := fmap["4"]; set {
		if m.NotifyId != src.NotifyId {
			m.NotifyId = src.NotifyId
			changed++
		}
	}
	return changed
}

func (m *AppInstClient) DeepCopyIn(src *AppInstClient) {
	m.ClientKey.DeepCopyIn(&src.ClientKey)
	m.Location = src.Location
	m.NotifyId = src.NotifyId
}

func (m *AppInstClient) MessageTypeKey() string {
	return "msg/type/AppInstClient"
}

// Helper method to check that enums have valid values
// NOTE: ValidateEnums checks all Fields even if some are not set
func (m *AppInstClient) ValidateEnums() error {
	if err := m.ClientKey.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func (s *AppInstClient) ClearTagged(tags map[string]struct{}) {
	s.ClientKey.ClearTagged(tags)
	if _, found := tags["nocmp"]; found {
		s.Location = distributed_match_engine.Loc{}
	}
	if _, found := tags["nocmp"]; found {
		s.NotifyId = 0
	}
}

func IgnoreAppInstClientFields(taglist string) cmp.Option {
	names := []string{}
	tags := make(map[string]struct{})
	for _, tag := range strings.Split(taglist, ",") {
		tags[tag] = struct{}{}
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "Location")
	}
	if _, found := tags["nocmp"]; found {
		names = append(names, "NotifyId")
	}
	return cmpopts.IgnoreFields(AppInstClient{}, names...)
}

func (m *AppInstClientKey) IsValidArgsForShowAppInstClient() error {
	return nil
}

func (m *AppInstClientKey) IsValidArgsForStreamAppInstClientsLocal() error {
	return nil
}

func (m *AppInstClientKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.AppInstKey.Size()
	n += 1 + l + sovAppinstclient(uint64(l))
	l = len(m.UniqueId)
	if l > 0 {
		n += 1 + l + sovAppinstclient(uint64(l))
	}
	l = len(m.UniqueIdType)
	if l > 0 {
		n += 1 + l + sovAppinstclient(uint64(l))
	}
	l = m.AppKey.Size()
	n += 1 + l + sovAppinstclient(uint64(l))
	return n
}

func (m *AppInstClient) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovAppinstclient(uint64(l))
		}
	}
	l = m.ClientKey.Size()
	n += 1 + l + sovAppinstclient(uint64(l))
	l = m.Location.Size()
	n += 1 + l + sovAppinstclient(uint64(l))
	if m.NotifyId != 0 {
		n += 1 + sovAppinstclient(uint64(m.NotifyId))
	}
	return n
}

func sovAppinstclient(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozAppinstclient(x uint64) (n int) {
	return sovAppinstclient(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AppInstClientKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppinstclient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppInstClientKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppInstClientKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppInstKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinstclient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppinstclient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppinstclient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AppInstKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinstclient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppinstclient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppinstclient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UniqueId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueIdType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinstclient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppinstclient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppinstclient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UniqueIdType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinstclient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppinstclient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppinstclient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AppKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppinstclient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAppinstclient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppInstClient) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppinstclient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppInstClient: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppInstClient: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinstclient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppinstclient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppinstclient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinstclient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppinstclient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppinstclient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ClientKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinstclient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppinstclient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppinstclient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotifyId", wireType)
			}
			m.NotifyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppinstclient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NotifyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAppinstclient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAppinstclient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAppinstclient(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAppinstclient
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAppinstclient
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAppinstclient
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAppinstclient
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupAppinstclient
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthAppinstclient
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthAppinstclient        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAppinstclient          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupAppinstclient = fmt.Errorf("proto: unexpected end of group")
)
