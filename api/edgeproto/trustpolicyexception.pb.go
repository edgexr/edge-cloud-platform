// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: trustpolicyexception.proto

package edgeproto

import (
	context "context"
	"encoding/json"
	"errors"
	fmt "fmt"
	distributed_match_engine "github.com/edgexr/edge-cloud-platform/api/distributed_match_engine"
	"github.com/edgexr/edge-cloud-platform/pkg/log"
	"github.com/edgexr/edge-cloud-platform/pkg/objstore"
	"github.com/edgexr/edge-cloud-platform/pkg/util"
	_ "github.com/edgexr/edge-cloud-platform/tools/protogen"
	_ "github.com/gogo/googleapis/google/api"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	"go.etcd.io/etcd/client/v3/concurrency"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	"strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type TrustPolicyExceptionState int32

const (
	// Unknown state
	TrustPolicyExceptionState_TRUST_POLICY_EXCEPTION_STATE_UNKNOWN TrustPolicyExceptionState = 0
	// Created, Awaiting approval
	TrustPolicyExceptionState_TRUST_POLICY_EXCEPTION_STATE_APPROVAL_REQUESTED TrustPolicyExceptionState = 1
	// Approved by Operator and active
	TrustPolicyExceptionState_TRUST_POLICY_EXCEPTION_STATE_ACTIVE TrustPolicyExceptionState = 2
	// Rejected by Operator
	TrustPolicyExceptionState_TRUST_POLICY_EXCEPTION_STATE_REJECTED TrustPolicyExceptionState = 3
)

var TrustPolicyExceptionState_name = map[int32]string{
	0: "TRUST_POLICY_EXCEPTION_STATE_UNKNOWN",
	1: "TRUST_POLICY_EXCEPTION_STATE_APPROVAL_REQUESTED",
	2: "TRUST_POLICY_EXCEPTION_STATE_ACTIVE",
	3: "TRUST_POLICY_EXCEPTION_STATE_REJECTED",
}

var TrustPolicyExceptionState_value = map[string]int32{
	"TRUST_POLICY_EXCEPTION_STATE_UNKNOWN":            0,
	"TRUST_POLICY_EXCEPTION_STATE_APPROVAL_REQUESTED": 1,
	"TRUST_POLICY_EXCEPTION_STATE_ACTIVE":             2,
	"TRUST_POLICY_EXCEPTION_STATE_REJECTED":           3,
}

func (x TrustPolicyExceptionState) String() string {
	return proto.EnumName(TrustPolicyExceptionState_name, int32(x))
}

func (TrustPolicyExceptionState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3880f2ee88dcf17f, []int{0}
}

type TrustPolicyExceptionKey struct {
	// App Key
	AppKey AppKey `protobuf:"bytes,1,opt,name=app_key,json=appKey,proto3" json:"app_key"`
	// ZonePool Key
	ZonePoolKey ZonePoolKey `protobuf:"bytes,2,opt,name=zone_pool_key,json=zonePoolKey,proto3" json:"zone_pool_key"`
	// TrustPolicyExceptionKey name
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *TrustPolicyExceptionKey) Reset()         { *m = TrustPolicyExceptionKey{} }
func (m *TrustPolicyExceptionKey) String() string { return proto.CompactTextString(m) }
func (*TrustPolicyExceptionKey) ProtoMessage()    {}
func (*TrustPolicyExceptionKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_3880f2ee88dcf17f, []int{0}
}
func (m *TrustPolicyExceptionKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TrustPolicyExceptionKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TrustPolicyExceptionKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TrustPolicyExceptionKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TrustPolicyExceptionKey.Merge(m, src)
}
func (m *TrustPolicyExceptionKey) XXX_Size() int {
	return m.Size()
}
func (m *TrustPolicyExceptionKey) XXX_DiscardUnknown() {
	xxx_messageInfo_TrustPolicyExceptionKey.DiscardUnknown(m)
}

var xxx_messageInfo_TrustPolicyExceptionKey proto.InternalMessageInfo

type TrustPolicyException struct {
	// Fields are used for the Update API to specify which fields to apply
	Fields []string `protobuf:"bytes,1,rep,name=fields,proto3" json:"fields,omitempty"`
	// Unique Key composed of App and ZonePool key
	Key TrustPolicyExceptionKey `protobuf:"bytes,2,opt,name=key,proto3" json:"key"`
	// State of the exception within the approval process
	State TrustPolicyExceptionState `protobuf:"varint,3,opt,name=state,proto3,enum=edgeproto.TrustPolicyExceptionState" json:"state,omitempty"`
	// List of outbound security rules for whitelisting traffic
	OutboundSecurityRules []SecurityRule `protobuf:"bytes,4,rep,name=outbound_security_rules,json=outboundSecurityRules,proto3" json:"outbound_security_rules"`
}

func (m *TrustPolicyException) Reset()         { *m = TrustPolicyException{} }
func (m *TrustPolicyException) String() string { return proto.CompactTextString(m) }
func (*TrustPolicyException) ProtoMessage()    {}
func (*TrustPolicyException) Descriptor() ([]byte, []int) {
	return fileDescriptor_3880f2ee88dcf17f, []int{1}
}
func (m *TrustPolicyException) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TrustPolicyException) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TrustPolicyException.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TrustPolicyException) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TrustPolicyException.Merge(m, src)
}
func (m *TrustPolicyException) XXX_Size() int {
	return m.Size()
}
func (m *TrustPolicyException) XXX_DiscardUnknown() {
	xxx_messageInfo_TrustPolicyException.DiscardUnknown(m)
}

var xxx_messageInfo_TrustPolicyException proto.InternalMessageInfo

type TPEInstanceKey struct {
	TpeKey      TrustPolicyExceptionKey `protobuf:"bytes,1,opt,name=tpe_key,json=tpeKey,proto3" json:"tpe_key"`
	AppInstKey  AppInstKey              `protobuf:"bytes,2,opt,name=app_inst_key,json=appInstKey,proto3" json:"app_inst_key"`
	ClusterKey  ClusterKey              `protobuf:"bytes,3,opt,name=cluster_key,json=clusterKey,proto3" json:"cluster_key"`
	CloudletKey CloudletKey             `protobuf:"bytes,4,opt,name=cloudlet_key,json=cloudletKey,proto3" json:"cloudlet_key"`
}

func (m *TPEInstanceKey) Reset()         { *m = TPEInstanceKey{} }
func (m *TPEInstanceKey) String() string { return proto.CompactTextString(m) }
func (*TPEInstanceKey) ProtoMessage()    {}
func (*TPEInstanceKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_3880f2ee88dcf17f, []int{2}
}
func (m *TPEInstanceKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TPEInstanceKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TPEInstanceKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TPEInstanceKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TPEInstanceKey.Merge(m, src)
}
func (m *TPEInstanceKey) XXX_Size() int {
	return m.Size()
}
func (m *TPEInstanceKey) XXX_DiscardUnknown() {
	xxx_messageInfo_TPEInstanceKey.DiscardUnknown(m)
}

var xxx_messageInfo_TPEInstanceKey proto.InternalMessageInfo

// TPEState shows the state of an applied TPE instance
type TPEInstanceState struct {
	Key           TPEInstanceKey                     `protobuf:"bytes,1,opt,name=key,proto3" json:"key"`
	Owner         string                             `protobuf:"bytes,2,opt,name=owner,proto3" json:"owner,omitempty"`
	RunRequested  bool                               `protobuf:"varint,3,opt,name=run_requested,json=runRequested,proto3" json:"run_requested,omitempty"`
	RunCount      int32                              `protobuf:"varint,4,opt,name=run_count,json=runCount,proto3" json:"run_count,omitempty"`
	TpeEnable     bool                               `protobuf:"varint,5,opt,name=tpe_enable,json=tpeEnable,proto3" json:"tpe_enable,omitempty"`
	DisableReason string                             `protobuf:"bytes,6,opt,name=disable_reason,json=disableReason,proto3" json:"disable_reason,omitempty"`
	Error         string                             `protobuf:"bytes,7,opt,name=error,proto3" json:"error,omitempty"`
	StartedAt     distributed_match_engine.Timestamp `protobuf:"bytes,99,opt,name=started_at,json=startedAt,proto3" json:"started_at"`
}

func (m *TPEInstanceState) Reset()         { *m = TPEInstanceState{} }
func (m *TPEInstanceState) String() string { return proto.CompactTextString(m) }
func (*TPEInstanceState) ProtoMessage()    {}
func (*TPEInstanceState) Descriptor() ([]byte, []int) {
	return fileDescriptor_3880f2ee88dcf17f, []int{3}
}
func (m *TPEInstanceState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TPEInstanceState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TPEInstanceState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TPEInstanceState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TPEInstanceState.Merge(m, src)
}
func (m *TPEInstanceState) XXX_Size() int {
	return m.Size()
}
func (m *TPEInstanceState) XXX_DiscardUnknown() {
	xxx_messageInfo_TPEInstanceState.DiscardUnknown(m)
}

var xxx_messageInfo_TPEInstanceState proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("edgeproto.TrustPolicyExceptionState", TrustPolicyExceptionState_name, TrustPolicyExceptionState_value)
	proto.RegisterType((*TrustPolicyExceptionKey)(nil), "edgeproto.TrustPolicyExceptionKey")
	proto.RegisterType((*TrustPolicyException)(nil), "edgeproto.TrustPolicyException")
	proto.RegisterType((*TPEInstanceKey)(nil), "edgeproto.TPEInstanceKey")
	proto.RegisterType((*TPEInstanceState)(nil), "edgeproto.TPEInstanceState")
}

func init() { proto.RegisterFile("trustpolicyexception.proto", fileDescriptor_3880f2ee88dcf17f) }

var fileDescriptor_3880f2ee88dcf17f = []byte{
	// 1215 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x56, 0xcf, 0x6f, 0x1b, 0xc5,
	0x17, 0xf7, 0xc4, 0x49, 0x1a, 0x4f, 0x7e, 0x28, 0xdd, 0x6f, 0xdb, 0x4c, 0xdd, 0x7c, 0x9d, 0xd4,
	0x2d, 0x22, 0x2d, 0x95, 0x4d, 0xd3, 0x9b, 0xab, 0x1e, 0x1c, 0x77, 0x25, 0x42, 0x4a, 0x62, 0xd6,
	0x4e, 0xf8, 0x29, 0xad, 0x36, 0xeb, 0x87, 0xbb, 0xca, 0x7a, 0x67, 0xd8, 0x9d, 0x25, 0xb8, 0xa7,
	0x8a, 0x23, 0xa7, 0x4a, 0x5c, 0x10, 0x27, 0x0e, 0x1c, 0x50, 0x4f, 0xa8, 0x17, 0x24, 0x8b, 0x3f,
	0x20, 0x27, 0x54, 0xa9, 0x97, 0x0a, 0x09, 0x04, 0x09, 0x54, 0x28, 0xa7, 0x4a, 0x71, 0x56, 0x1c,
	0xd1, 0x8c, 0x77, 0x9d, 0x4d, 0x63, 0x27, 0x08, 0x7a, 0x89, 0x66, 0xde, 0xfb, 0xbc, 0x8f, 0x3f,
	0xef, 0xcd, 0x7c, 0x66, 0x83, 0xd3, 0xdc, 0xf5, 0x3d, 0xce, 0xa8, 0x6d, 0x99, 0x4d, 0xf8, 0xd4,
	0x04, 0xc6, 0x2d, 0xea, 0xe4, 0x98, 0x4b, 0x39, 0x55, 0x52, 0x50, 0xab, 0x83, 0x5c, 0xa6, 0xa7,
	0xeb, 0x94, 0xd6, 0x6d, 0xc8, 0x1b, 0xcc, 0xca, 0x1b, 0x8e, 0x43, 0xb9, 0x21, 0x70, 0x5e, 0x07,
	0x98, 0x1e, 0x73, 0xc1, 0xf3, 0x6d, 0x1e, 0xee, 0xfe, 0xcf, 0x29, 0xb5, 0xbd, 0xbc, 0xdc, 0xd4,
	0xc1, 0xe9, 0x2e, 0xc2, 0xf4, 0x99, 0x3a, 0xad, 0x53, 0xb9, 0xcc, 0x8b, 0x55, 0x18, 0x4d, 0x19,
	0x8c, 0x85, 0xcb, 0x89, 0x7b, 0xd4, 0x01, 0x46, 0xa9, 0x1d, 0xee, 0x4f, 0xc7, 0x24, 0x86, 0xa1,
	0x71, 0x83, 0x31, 0xcb, 0xf1, 0xa2, 0x5f, 0x1c, 0x37, 0x6d, 0xdf, 0xe3, 0xe0, 0x46, 0xdb, 0x5a,
	0x03, 0xf2, 0x36, 0x35, 0xa3, 0x7a, 0xd3, 0xa6, 0x7e, 0xcd, 0x06, 0xbe, 0x01, 0x61, 0x7d, 0xf6,
	0x0f, 0x84, 0xa7, 0xaa, 0x82, 0xb5, 0x2c, 0x59, 0xd5, 0xa8, 0xf1, 0x25, 0x68, 0x2a, 0x45, 0x7c,
	0xca, 0x60, 0x4c, 0xdf, 0x80, 0x26, 0x41, 0xb3, 0x68, 0x6e, 0x74, 0xfe, 0x74, 0xae, 0x3b, 0x87,
	0x5c, 0x91, 0xb1, 0x25, 0x68, 0x2e, 0x9c, 0x6d, 0x05, 0x64, 0xd8, 0x60, 0x6c, 0x03, 0x9a, 0xbb,
	0x01, 0x49, 0x16, 0x19, 0xdb, 0xfa, 0x65, 0x26, 0xa1, 0x89, 0x90, 0xa0, 0xf8, 0x00, 0x8f, 0x8b,
	0x1e, 0x74, 0xd1, 0x84, 0x24, 0x1a, 0x90, 0x44, 0xe7, 0x62, 0x44, 0xef, 0x53, 0x07, 0xca, 0x94,
	0xda, 0x82, 0x6d, 0xa6, 0x15, 0x90, 0xd1, 0xa8, 0xe9, 0x0e, 0xe5, 0x48, 0x94, 0x97, 0xbc, 0x32,
	0x19, 0xa2, 0x95, 0x69, 0x3c, 0xe8, 0x18, 0x0d, 0x20, 0xc9, 0x59, 0x34, 0x97, 0x5a, 0x18, 0x69,
	0x05, 0x44, 0xee, 0x35, 0xf9, 0xb7, 0x30, 0xf6, 0xe7, 0x1e, 0x41, 0x7f, 0xed, 0x11, 0xf4, 0xdd,
	0xd7, 0x33, 0x28, 0xfb, 0x2c, 0x89, 0xcf, 0xf4, 0xea, 0x53, 0x39, 0x87, 0x87, 0x3f, 0xb2, 0xc0,
	0xae, 0x79, 0x04, 0xcd, 0x26, 0xe7, 0x52, 0x5a, 0xb8, 0x53, 0x0a, 0x38, 0x79, 0xa0, 0x37, 0x1b,
	0xd3, 0xdb, 0x67, 0x5a, 0x0b, 0x83, 0x52, 0xa0, 0x28, 0x52, 0x0a, 0x78, 0xc8, 0xe3, 0x06, 0xef,
	0x28, 0x9b, 0x98, 0xbf, 0x7c, 0x42, 0x75, 0x45, 0x60, 0xb5, 0x4e, 0x89, 0xb2, 0x8a, 0xa7, 0xa8,
	0xcf, 0xd7, 0xa9, 0xef, 0xd4, 0x74, 0x0f, 0x4c, 0xdf, 0xb5, 0x78, 0x53, 0x77, 0x7d, 0x1b, 0x3c,
	0x32, 0x38, 0x9b, 0x9c, 0x1b, 0x9d, 0x9f, 0x8a, 0xb1, 0x55, 0x42, 0x80, 0xe6, 0xdb, 0x10, 0x0a,
	0x38, 0x1b, 0x55, 0xc7, 0x73, 0x5e, 0xe1, 0x19, 0x12, 0xe3, 0x78, 0xbe, 0x47, 0xd0, 0xfd, 0x36,
	0x41, 0x0f, 0xda, 0x04, 0x7d, 0xd9, 0x26, 0x68, 0xab, 0x4d, 0xd0, 0xd3, 0x36, 0x41, 0x5f, 0xed,
	0x93, 0x87, 0x48, 0x4c, 0xed, 0xd6, 0x12, 0x34, 0x73, 0xcb, 0x46, 0x03, 0xae, 0x19, 0x8c, 0x75,
	0x03, 0x9d, 0xb3, 0xee, 0xc6, 0xa9, 0x5b, 0x8f, 0x87, 0x57, 0xdc, 0xba, 0xe1, 0x58, 0xf7, 0xa4,
	0x0f, 0x44, 0xfa, 0x13, 0x70, 0xbd, 0x78, 0x7e, 0x0d, 0x5c, 0x4f, 0xa4, 0xa2, 0x73, 0x8d, 0xca,
	0x63, 0x07, 0x7f, 0x98, 0x23, 0x02, 0x76, 0x7f, 0x3f, 0x8e, 0x14, 0x22, 0x1e, 0x05, 0x64, 0x6a,
	0x03, 0x9a, 0xb7, 0x7a, 0x08, 0xc8, 0xb6, 0x07, 0xf0, 0x44, 0xb5, 0xac, 0x2e, 0x3a, 0x1e, 0x37,
	0x1c, 0x13, 0xc4, 0x3d, 0xa9, 0xe0, 0x53, 0x9c, 0x41, 0xec, 0x1e, 0xff, 0x93, 0xe3, 0x3c, 0xd7,
	0x0a, 0xc8, 0x04, 0x67, 0x20, 0x4f, 0x85, 0x33, 0xd8, 0x80, 0x66, 0xe7, 0x66, 0x73, 0x16, 0x92,
	0x8e, 0x09, 0x73, 0x08, 0xef, 0xc5, 0x2e, 0xf6, 0xd9, 0xc3, 0x0e, 0x11, 0x2a, 0x04, 0x59, 0xba,
	0x15, 0x10, 0x25, 0x22, 0x0b, 0x1d, 0x1b, 0x11, 0x62, 0xa3, 0x8b, 0x53, 0x34, 0x3c, 0x1a, 0x1a,
	0x58, 0x72, 0x26, 0x8f, 0x70, 0x96, 0x3a, 0xd9, 0x23, 0x9c, 0x61, 0x55, 0x97, 0xd3, 0xec, 0xe2,
	0x94, 0x35, 0x3c, 0x16, 0xd9, 0x5e, 0x92, 0x0e, 0x1e, 0x71, 0x60, 0x29, 0x4c, 0x0b, 0xd6, 0x0b,
	0xad, 0x80, 0xfc, 0xef, 0x80, 0xb5, 0xfb, 0x5c, 0x74, 0xdc, 0x67, 0x1e, 0x20, 0x5f, 0xf0, 0xd7,
	0x37, 0x49, 0x3c, 0x19, 0x1b, 0xbb, 0xbc, 0xd2, 0xca, 0xf5, 0x8e, 0x87, 0x3a, 0x43, 0x3f, 0x1f,
	0x1f, 0xfa, 0xa1, 0x03, 0x8a, 0x5b, 0x27, 0x8d, 0x87, 0xe8, 0xa6, 0x03, 0xae, 0x9c, 0x67, 0x6a,
	0x61, 0xf0, 0xdb, 0x36, 0x41, 0x5a, 0x27, 0xa4, 0x5c, 0xc1, 0xe3, 0xae, 0xef, 0xe8, 0x2e, 0x7c,
	0xec, 0x83, 0xc7, 0xa1, 0x26, 0xe7, 0x33, 0x12, 0x62, 0xc6, 0x5c, 0xdf, 0xd1, 0xa2, 0x8c, 0x72,
	0x11, 0xa7, 0x04, 0xd4, 0xa4, 0xbe, 0xc3, 0x65, 0xc7, 0x43, 0x21, 0x6c, 0xc4, 0xf5, 0x9d, 0x92,
	0x88, 0x2a, 0x97, 0x30, 0x16, 0xb7, 0x02, 0x1c, 0x63, 0xdd, 0x06, 0x32, 0x14, 0xa3, 0x4a, 0x71,
	0x06, 0xaa, 0x0c, 0x2b, 0xaf, 0xe1, 0x89, 0x9a, 0xe5, 0x89, 0xa5, 0xee, 0x82, 0xe1, 0x51, 0x87,
	0x0c, 0xc7, 0x74, 0x8d, 0x87, 0x39, 0x4d, 0xa6, 0x84, 0x76, 0x70, 0x5d, 0xea, 0x92, 0x53, 0x71,
	0xed, 0x32, 0xa4, 0xbc, 0x81, 0xb1, 0xc7, 0x0d, 0x97, 0x43, 0x4d, 0x37, 0x38, 0x31, 0xe5, 0x44,
	0x2e, 0xe5, 0x6a, 0x96, 0xc7, 0x5d, 0x6b, 0xdd, 0x17, 0xe1, 0x86, 0xc1, 0xcd, 0xbb, 0x3a, 0x38,
	0x75, 0xcb, 0x81, 0x5c, 0xd5, 0x6a, 0x88, 0x23, 0x68, 0xb0, 0x70, 0x36, 0xa9, 0xb0, 0xb8, 0xc8,
	0x0b, 0x37, 0x5f, 0x34, 0x72, 0x64, 0xe2, 0x47, 0x01, 0xb9, 0x10, 0xba, 0x22, 0xbc, 0x4f, 0x87,
	0x9c, 0xf1, 0x3c, 0x20, 0xe8, 0xea, 0x8f, 0x08, 0x9f, 0xef, 0xfb, 0x04, 0x29, 0x73, 0xf8, 0x72,
	0x55, 0x5b, 0xad, 0x54, 0xf5, 0xf2, 0xca, 0x9d, 0xc5, 0xd2, 0x7b, 0xba, 0xfa, 0x6e, 0x49, 0x2d,
	0x57, 0x17, 0x57, 0x96, 0xf5, 0x4a, 0xb5, 0x58, 0x55, 0xf5, 0xd5, 0xe5, 0xa5, 0xe5, 0x95, 0x77,
	0x96, 0x27, 0x13, 0xca, 0x0d, 0x9c, 0x3f, 0x16, 0x59, 0x2c, 0x97, 0xb5, 0x95, 0xb5, 0xe2, 0x1d,
	0x5d, 0x53, 0xdf, 0x5e, 0x55, 0x2b, 0x55, 0xf5, 0xf6, 0x24, 0x52, 0x5e, 0xc5, 0x97, 0x8e, 0x2f,
	0x2a, 0x55, 0x17, 0xd7, 0xd4, 0xc9, 0x01, 0xe5, 0x0a, 0x7e, 0xe5, 0x58, 0xa0, 0xa6, 0xbe, 0xa9,
	0x96, 0x04, 0x67, 0x72, 0x7e, 0x6b, 0xb8, 0xf7, 0xf7, 0xab, 0xc8, 0x2c, 0xe5, 0x09, 0xc2, 0xe9,
	0x92, 0x0b, 0x06, 0x87, 0x9e, 0x2f, 0xff, 0xcc, 0x09, 0xaf, 0x40, 0x3a, 0xfe, 0xb9, 0xd3, 0xe4,
	0x77, 0x3d, 0x7b, 0x1f, 0xed, 0xb6, 0xc9, 0x75, 0x0d, 0x3c, 0xea, 0xbb, 0x26, 0x14, 0x19, 0xf3,
	0xae, 0x15, 0x4d, 0x01, 0x7e, 0xcb, 0x70, 0x8c, 0x3a, 0x5c, 0xeb, 0xf3, 0x2c, 0xfe, 0xb4, 0x4f,
	0x86, 0xe4, 0x88, 0x1f, 0x06, 0x64, 0xaa, 0x0f, 0xe6, 0xb3, 0x27, 0xbf, 0x7f, 0x31, 0x70, 0x31,
	0x3b, 0x9d, 0x37, 0xa5, 0xe4, 0x7c, 0xaf, 0x7f, 0x47, 0x0a, 0xe8, 0xaa, 0xf2, 0x33, 0xc2, 0xe9,
	0x55, 0x56, 0x7b, 0x99, 0x5d, 0x7d, 0x2e, 0xba, 0xba, 0x19, 0x75, 0x15, 0xbd, 0xb6, 0x3d, 0x5a,
	0xeb, 0xf7, 0x64, 0x3f, 0xde, 0x27, 0xe8, 0x61, 0x40, 0xa6, 0x8f, 0xc3, 0x74, 0xfb, 0xf3, 0xa5,
	0xf8, 0xbe, 0xfd, 0x7d, 0x8f, 0x70, 0xfa, 0x36, 0xd8, 0xf0, 0x12, 0xfb, 0x83, 0xff, 0x76, 0x68,
	0x5d, 0xe5, 0x35, 0x29, 0xab, 0xaf, 0xf2, 0x1f, 0x10, 0x26, 0x95, 0xbb, 0x74, 0xf3, 0xdf, 0xe9,
	0x3e, 0x09, 0x90, 0xfd, 0x70, 0xb7, 0x4d, 0xf2, 0x3d, 0xba, 0x58, 0xb3, 0x60, 0xb3, 0x5f, 0x0f,
	0xe2, 0x60, 0xa4, 0xfc, 0x99, 0x6c, 0x3a, 0xef, 0xdd, 0xa5, 0x9b, 0xfd, 0xc4, 0xbf, 0x8e, 0x16,
	0xa6, 0xb7, 0x7e, 0xcb, 0x24, 0xb6, 0xb6, 0x33, 0xe8, 0xf1, 0x76, 0x06, 0xfd, 0xba, 0x9d, 0x41,
	0x0f, 0x76, 0x32, 0x89, 0xc7, 0x3b, 0x99, 0xc4, 0xd3, 0x9d, 0x4c, 0x62, 0x7d, 0x58, 0x2a, 0xbb,
	0xf1, 0x77, 0x00, 0x00, 0x00, 0xff, 0xff, 0x5f, 0x8b, 0x88, 0xc3, 0x27, 0x0b, 0x00, 0x00,
}

func (this *TrustPolicyExceptionKey) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&edgeproto.TrustPolicyExceptionKey{")
	s = append(s, "AppKey: "+strings.Replace(this.AppKey.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "ZonePoolKey: "+strings.Replace(this.ZonePoolKey.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TPEInstanceKey) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&edgeproto.TPEInstanceKey{")
	s = append(s, "TpeKey: "+strings.Replace(this.TpeKey.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "AppInstKey: "+strings.Replace(this.AppInstKey.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "ClusterKey: "+strings.Replace(this.ClusterKey.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "CloudletKey: "+strings.Replace(this.CloudletKey.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTrustpolicyexception(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// TrustPolicyExceptionApiClient is the client API for TrustPolicyExceptionApi service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type TrustPolicyExceptionApiClient interface {
	// Create a Trust Policy Exception, by App Developer Organization
	CreateTrustPolicyException(ctx context.Context, in *TrustPolicyException, opts ...grpc.CallOption) (*Result, error)
	// Update a Trust Policy Exception, by Operator Organization
	UpdateTrustPolicyException(ctx context.Context, in *TrustPolicyException, opts ...grpc.CallOption) (*Result, error)
	// Delete a Trust Policy Exception, by App Developer Organization
	DeleteTrustPolicyException(ctx context.Context, in *TrustPolicyException, opts ...grpc.CallOption) (*Result, error)
	// Show Trust Policy Exceptions. Any fields specified will be used to filter results.
	ShowTrustPolicyException(ctx context.Context, in *TrustPolicyException, opts ...grpc.CallOption) (TrustPolicyExceptionApi_ShowTrustPolicyExceptionClient, error)
}

type trustPolicyExceptionApiClient struct {
	cc *grpc.ClientConn
}

func NewTrustPolicyExceptionApiClient(cc *grpc.ClientConn) TrustPolicyExceptionApiClient {
	return &trustPolicyExceptionApiClient{cc}
}

func (c *trustPolicyExceptionApiClient) CreateTrustPolicyException(ctx context.Context, in *TrustPolicyException, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/edgeproto.TrustPolicyExceptionApi/CreateTrustPolicyException", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trustPolicyExceptionApiClient) UpdateTrustPolicyException(ctx context.Context, in *TrustPolicyException, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/edgeproto.TrustPolicyExceptionApi/UpdateTrustPolicyException", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trustPolicyExceptionApiClient) DeleteTrustPolicyException(ctx context.Context, in *TrustPolicyException, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/edgeproto.TrustPolicyExceptionApi/DeleteTrustPolicyException", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trustPolicyExceptionApiClient) ShowTrustPolicyException(ctx context.Context, in *TrustPolicyException, opts ...grpc.CallOption) (TrustPolicyExceptionApi_ShowTrustPolicyExceptionClient, error) {
	stream, err := c.cc.NewStream(ctx, &_TrustPolicyExceptionApi_serviceDesc.Streams[0], "/edgeproto.TrustPolicyExceptionApi/ShowTrustPolicyException", opts...)
	if err != nil {
		return nil, err
	}
	x := &trustPolicyExceptionApiShowTrustPolicyExceptionClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type TrustPolicyExceptionApi_ShowTrustPolicyExceptionClient interface {
	Recv() (*TrustPolicyException, error)
	grpc.ClientStream
}

type trustPolicyExceptionApiShowTrustPolicyExceptionClient struct {
	grpc.ClientStream
}

func (x *trustPolicyExceptionApiShowTrustPolicyExceptionClient) Recv() (*TrustPolicyException, error) {
	m := new(TrustPolicyException)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// TrustPolicyExceptionApiServer is the server API for TrustPolicyExceptionApi service.
type TrustPolicyExceptionApiServer interface {
	// Create a Trust Policy Exception, by App Developer Organization
	CreateTrustPolicyException(context.Context, *TrustPolicyException) (*Result, error)
	// Update a Trust Policy Exception, by Operator Organization
	UpdateTrustPolicyException(context.Context, *TrustPolicyException) (*Result, error)
	// Delete a Trust Policy Exception, by App Developer Organization
	DeleteTrustPolicyException(context.Context, *TrustPolicyException) (*Result, error)
	// Show Trust Policy Exceptions. Any fields specified will be used to filter results.
	ShowTrustPolicyException(*TrustPolicyException, TrustPolicyExceptionApi_ShowTrustPolicyExceptionServer) error
}

// UnimplementedTrustPolicyExceptionApiServer can be embedded to have forward compatible implementations.
type UnimplementedTrustPolicyExceptionApiServer struct {
}

func (*UnimplementedTrustPolicyExceptionApiServer) CreateTrustPolicyException(ctx context.Context, req *TrustPolicyException) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTrustPolicyException not implemented")
}
func (*UnimplementedTrustPolicyExceptionApiServer) UpdateTrustPolicyException(ctx context.Context, req *TrustPolicyException) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTrustPolicyException not implemented")
}
func (*UnimplementedTrustPolicyExceptionApiServer) DeleteTrustPolicyException(ctx context.Context, req *TrustPolicyException) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTrustPolicyException not implemented")
}
func (*UnimplementedTrustPolicyExceptionApiServer) ShowTrustPolicyException(req *TrustPolicyException, srv TrustPolicyExceptionApi_ShowTrustPolicyExceptionServer) error {
	return status.Errorf(codes.Unimplemented, "method ShowTrustPolicyException not implemented")
}

func RegisterTrustPolicyExceptionApiServer(s *grpc.Server, srv TrustPolicyExceptionApiServer) {
	s.RegisterService(&_TrustPolicyExceptionApi_serviceDesc, srv)
}

func _TrustPolicyExceptionApi_CreateTrustPolicyException_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TrustPolicyException)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrustPolicyExceptionApiServer).CreateTrustPolicyException(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.TrustPolicyExceptionApi/CreateTrustPolicyException",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrustPolicyExceptionApiServer).CreateTrustPolicyException(ctx, req.(*TrustPolicyException))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrustPolicyExceptionApi_UpdateTrustPolicyException_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TrustPolicyException)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrustPolicyExceptionApiServer).UpdateTrustPolicyException(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.TrustPolicyExceptionApi/UpdateTrustPolicyException",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrustPolicyExceptionApiServer).UpdateTrustPolicyException(ctx, req.(*TrustPolicyException))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrustPolicyExceptionApi_DeleteTrustPolicyException_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TrustPolicyException)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrustPolicyExceptionApiServer).DeleteTrustPolicyException(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/edgeproto.TrustPolicyExceptionApi/DeleteTrustPolicyException",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrustPolicyExceptionApiServer).DeleteTrustPolicyException(ctx, req.(*TrustPolicyException))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrustPolicyExceptionApi_ShowTrustPolicyException_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TrustPolicyException)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TrustPolicyExceptionApiServer).ShowTrustPolicyException(m, &trustPolicyExceptionApiShowTrustPolicyExceptionServer{stream})
}

type TrustPolicyExceptionApi_ShowTrustPolicyExceptionServer interface {
	Send(*TrustPolicyException) error
	grpc.ServerStream
}

type trustPolicyExceptionApiShowTrustPolicyExceptionServer struct {
	grpc.ServerStream
}

func (x *trustPolicyExceptionApiShowTrustPolicyExceptionServer) Send(m *TrustPolicyException) error {
	return x.ServerStream.SendMsg(m)
}

var _TrustPolicyExceptionApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "edgeproto.TrustPolicyExceptionApi",
	HandlerType: (*TrustPolicyExceptionApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateTrustPolicyException",
			Handler:    _TrustPolicyExceptionApi_CreateTrustPolicyException_Handler,
		},
		{
			MethodName: "UpdateTrustPolicyException",
			Handler:    _TrustPolicyExceptionApi_UpdateTrustPolicyException_Handler,
		},
		{
			MethodName: "DeleteTrustPolicyException",
			Handler:    _TrustPolicyExceptionApi_DeleteTrustPolicyException_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ShowTrustPolicyException",
			Handler:       _TrustPolicyExceptionApi_ShowTrustPolicyException_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "trustpolicyexception.proto",
}

func (m *TrustPolicyExceptionKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrustPolicyExceptionKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TrustPolicyExceptionKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTrustpolicyexception(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.ZonePoolKey.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTrustpolicyexception(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.AppKey.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTrustpolicyexception(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *TrustPolicyException) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrustPolicyException) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TrustPolicyException) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OutboundSecurityRules) > 0 {
		for iNdEx := len(m.OutboundSecurityRules) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OutboundSecurityRules[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTrustpolicyexception(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.State != 0 {
		i = encodeVarintTrustpolicyexception(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTrustpolicyexception(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Fields) > 0 {
		for iNdEx := len(m.Fields) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Fields[iNdEx])
			copy(dAtA[i:], m.Fields[iNdEx])
			i = encodeVarintTrustpolicyexception(dAtA, i, uint64(len(m.Fields[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TPEInstanceKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TPEInstanceKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TPEInstanceKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.CloudletKey.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTrustpolicyexception(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.ClusterKey.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTrustpolicyexception(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.AppInstKey.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTrustpolicyexception(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.TpeKey.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTrustpolicyexception(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *TPEInstanceState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TPEInstanceState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TPEInstanceState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.StartedAt.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTrustpolicyexception(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x6
	i--
	dAtA[i] = 0x9a
	if len(m.Error) > 0 {
		i -= len(m.Error)
		copy(dAtA[i:], m.Error)
		i = encodeVarintTrustpolicyexception(dAtA, i, uint64(len(m.Error)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.DisableReason) > 0 {
		i -= len(m.DisableReason)
		copy(dAtA[i:], m.DisableReason)
		i = encodeVarintTrustpolicyexception(dAtA, i, uint64(len(m.DisableReason)))
		i--
		dAtA[i] = 0x32
	}
	if m.TpeEnable {
		i--
		if m.TpeEnable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.RunCount != 0 {
		i = encodeVarintTrustpolicyexception(dAtA, i, uint64(m.RunCount))
		i--
		dAtA[i] = 0x20
	}
	if m.RunRequested {
		i--
		if m.RunRequested {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTrustpolicyexception(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTrustpolicyexception(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintTrustpolicyexception(dAtA []byte, offset int, v uint64) int {
	offset -= sovTrustpolicyexception(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *TrustPolicyExceptionKey) Matches(o *TrustPolicyExceptionKey, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !m.AppKey.Matches(&o.AppKey, fopts...) {
		return false
	}
	if !m.ZonePoolKey.Matches(&o.ZonePoolKey, fopts...) {
		return false
	}
	if !opts.Filter || o.Name != "" {
		if o.Name != m.Name {
			return false
		}
	}
	return true
}

func (m *TrustPolicyExceptionKey) Clone() *TrustPolicyExceptionKey {
	cp := &TrustPolicyExceptionKey{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *TrustPolicyExceptionKey) CopyInFields(src *TrustPolicyExceptionKey) int {
	changed := 0
	if m.AppKey.Organization != src.AppKey.Organization {
		m.AppKey.Organization = src.AppKey.Organization
		changed++
	}
	if m.AppKey.Name != src.AppKey.Name {
		m.AppKey.Name = src.AppKey.Name
		changed++
	}
	if m.AppKey.Version != src.AppKey.Version {
		m.AppKey.Version = src.AppKey.Version
		changed++
	}
	if m.ZonePoolKey.Organization != src.ZonePoolKey.Organization {
		m.ZonePoolKey.Organization = src.ZonePoolKey.Organization
		changed++
	}
	if m.ZonePoolKey.Name != src.ZonePoolKey.Name {
		m.ZonePoolKey.Name = src.ZonePoolKey.Name
		changed++
	}
	if m.Name != src.Name {
		m.Name = src.Name
		changed++
	}
	return changed
}

func (m *TrustPolicyExceptionKey) DeepCopyIn(src *TrustPolicyExceptionKey) {
	m.AppKey.DeepCopyIn(&src.AppKey)
	m.ZonePoolKey.DeepCopyIn(&src.ZonePoolKey)
	m.Name = src.Name
}

func (m *TrustPolicyExceptionKey) GetKeyString() string {
	key, err := json.Marshal(m)
	if err != nil {
		log.FatalLog("Failed to marshal TrustPolicyExceptionKey key string", "obj", m)
	}
	return string(key)
}

func TrustPolicyExceptionKeyStringParse(str string, key *TrustPolicyExceptionKey) {
	err := json.Unmarshal([]byte(str), key)
	if err != nil {
		log.FatalLog("Failed to unmarshal TrustPolicyExceptionKey key string", "str", str)
	}
}

func (m *TrustPolicyExceptionKey) NotFoundError() error {
	return fmt.Errorf("TrustPolicyException key %s not found", m.GetKeyString())
}

func (m *TrustPolicyExceptionKey) ExistsError() error {
	return fmt.Errorf("TrustPolicyException key %s already exists", m.GetKeyString())
}

func (m *TrustPolicyExceptionKey) BeingDeletedError() error {
	return fmt.Errorf("TrustPolicyException %s is being deleted", m.GetKeyString())
}

var TrustPolicyExceptionKeyTagName = "name"

func (m *TrustPolicyExceptionKey) GetTags() map[string]string {
	tags := make(map[string]string)
	m.AddTags(tags)
	return tags
}

func (m *TrustPolicyExceptionKey) AddTagsByFunc(addTag AddTagFunc) {
	addTag("apporg", m.AppKey.Organization)
	addTag("app", m.AppKey.Name)
	addTag("appver", m.AppKey.Version)
	addTag("zonepoolorg", m.ZonePoolKey.Organization)
	addTag("zonepool", m.ZonePoolKey.Name)
	addTag("name", m.Name)
}

func (m *TrustPolicyExceptionKey) AddTags(tags map[string]string) {
	tagMap := TagMap(tags)
	m.AddTagsByFunc(tagMap.AddTag)
}

// Helper method to check that enums have valid values
func (m *TrustPolicyExceptionKey) ValidateEnums() error {
	if err := m.AppKey.ValidateEnums(); err != nil {
		return err
	}
	if err := m.ZonePoolKey.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func (s *TrustPolicyExceptionKey) ClearTagged(tags map[string]struct{}) {
	s.AppKey.ClearTagged(tags)
	s.ZonePoolKey.ClearTagged(tags)
}

func (m *TrustPolicyException) Matches(o *TrustPolicyException, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !m.Key.Matches(&o.Key, fopts...) {
		return false
	}
	if !opts.Filter || o.State != 0 {
		if o.State != m.State {
			return false
		}
	}
	if !opts.Filter || o.OutboundSecurityRules != nil {
		if len(m.OutboundSecurityRules) == 0 && len(o.OutboundSecurityRules) > 0 || len(m.OutboundSecurityRules) > 0 && len(o.OutboundSecurityRules) == 0 {
			return false
		} else if m.OutboundSecurityRules != nil && o.OutboundSecurityRules != nil {
			if !opts.Filter && len(m.OutboundSecurityRules) != len(o.OutboundSecurityRules) {
				return false
			}
		}
	}
	return true
}

const TrustPolicyExceptionFieldKey = "2"
const TrustPolicyExceptionFieldKeyAppKey = "2.1"
const TrustPolicyExceptionFieldKeyAppKeyOrganization = "2.1.1"
const TrustPolicyExceptionFieldKeyAppKeyName = "2.1.2"
const TrustPolicyExceptionFieldKeyAppKeyVersion = "2.1.3"
const TrustPolicyExceptionFieldKeyZonePoolKey = "2.2"
const TrustPolicyExceptionFieldKeyZonePoolKeyOrganization = "2.2.1"
const TrustPolicyExceptionFieldKeyZonePoolKeyName = "2.2.2"
const TrustPolicyExceptionFieldKeyName = "2.3"
const TrustPolicyExceptionFieldState = "3"
const TrustPolicyExceptionFieldOutboundSecurityRules = "4"
const TrustPolicyExceptionFieldOutboundSecurityRulesProtocol = "4.1"
const TrustPolicyExceptionFieldOutboundSecurityRulesPortRangeMin = "4.2"
const TrustPolicyExceptionFieldOutboundSecurityRulesPortRangeMax = "4.3"
const TrustPolicyExceptionFieldOutboundSecurityRulesRemoteCidr = "4.4"

var TrustPolicyExceptionAllFields = []string{
	TrustPolicyExceptionFieldKeyAppKeyOrganization,
	TrustPolicyExceptionFieldKeyAppKeyName,
	TrustPolicyExceptionFieldKeyAppKeyVersion,
	TrustPolicyExceptionFieldKeyZonePoolKeyOrganization,
	TrustPolicyExceptionFieldKeyZonePoolKeyName,
	TrustPolicyExceptionFieldKeyName,
	TrustPolicyExceptionFieldState,
	TrustPolicyExceptionFieldOutboundSecurityRulesProtocol,
	TrustPolicyExceptionFieldOutboundSecurityRulesPortRangeMin,
	TrustPolicyExceptionFieldOutboundSecurityRulesPortRangeMax,
	TrustPolicyExceptionFieldOutboundSecurityRulesRemoteCidr,
}

var TrustPolicyExceptionAllFieldsMap = NewFieldMap(map[string]struct{}{
	TrustPolicyExceptionFieldKeyAppKeyOrganization:             struct{}{},
	TrustPolicyExceptionFieldKeyAppKeyName:                     struct{}{},
	TrustPolicyExceptionFieldKeyAppKeyVersion:                  struct{}{},
	TrustPolicyExceptionFieldKeyZonePoolKeyOrganization:        struct{}{},
	TrustPolicyExceptionFieldKeyZonePoolKeyName:                struct{}{},
	TrustPolicyExceptionFieldKeyName:                           struct{}{},
	TrustPolicyExceptionFieldState:                             struct{}{},
	TrustPolicyExceptionFieldOutboundSecurityRulesProtocol:     struct{}{},
	TrustPolicyExceptionFieldOutboundSecurityRulesPortRangeMin: struct{}{},
	TrustPolicyExceptionFieldOutboundSecurityRulesPortRangeMax: struct{}{},
	TrustPolicyExceptionFieldOutboundSecurityRulesRemoteCidr:   struct{}{},
})

var TrustPolicyExceptionAllFieldsStringMap = map[string]string{
	TrustPolicyExceptionFieldKeyAppKeyOrganization:             "Key App Key Organization",
	TrustPolicyExceptionFieldKeyAppKeyName:                     "Key App Key Name",
	TrustPolicyExceptionFieldKeyAppKeyVersion:                  "Key App Key Version",
	TrustPolicyExceptionFieldKeyZonePoolKeyOrganization:        "Key Zone Pool Key Organization",
	TrustPolicyExceptionFieldKeyZonePoolKeyName:                "Key Zone Pool Key Name",
	TrustPolicyExceptionFieldKeyName:                           "Key Name",
	TrustPolicyExceptionFieldState:                             "State",
	TrustPolicyExceptionFieldOutboundSecurityRulesProtocol:     "Outbound Security Rules Protocol",
	TrustPolicyExceptionFieldOutboundSecurityRulesPortRangeMin: "Outbound Security Rules Port Range Min",
	TrustPolicyExceptionFieldOutboundSecurityRulesPortRangeMax: "Outbound Security Rules Port Range Max",
	TrustPolicyExceptionFieldOutboundSecurityRulesRemoteCidr:   "Outbound Security Rules Remote Cidr",
}

func (m *TrustPolicyException) IsKeyField(s string) bool {
	return strings.HasPrefix(s, TrustPolicyExceptionFieldKey+".") || s == TrustPolicyExceptionFieldKey
}

func (m *TrustPolicyException) DiffFields(o *TrustPolicyException, fields *FieldMap) {
	if m.Key.AppKey.Organization != o.Key.AppKey.Organization {
		fields.Set(TrustPolicyExceptionFieldKeyAppKeyOrganization)
		fields.Set(TrustPolicyExceptionFieldKeyAppKey)
		fields.Set(TrustPolicyExceptionFieldKey)
	}
	if m.Key.AppKey.Name != o.Key.AppKey.Name {
		fields.Set(TrustPolicyExceptionFieldKeyAppKeyName)
		fields.Set(TrustPolicyExceptionFieldKeyAppKey)
		fields.Set(TrustPolicyExceptionFieldKey)
	}
	if m.Key.AppKey.Version != o.Key.AppKey.Version {
		fields.Set(TrustPolicyExceptionFieldKeyAppKeyVersion)
		fields.Set(TrustPolicyExceptionFieldKeyAppKey)
		fields.Set(TrustPolicyExceptionFieldKey)
	}
	if m.Key.ZonePoolKey.Organization != o.Key.ZonePoolKey.Organization {
		fields.Set(TrustPolicyExceptionFieldKeyZonePoolKeyOrganization)
		fields.Set(TrustPolicyExceptionFieldKeyZonePoolKey)
		fields.Set(TrustPolicyExceptionFieldKey)
	}
	if m.Key.ZonePoolKey.Name != o.Key.ZonePoolKey.Name {
		fields.Set(TrustPolicyExceptionFieldKeyZonePoolKeyName)
		fields.Set(TrustPolicyExceptionFieldKeyZonePoolKey)
		fields.Set(TrustPolicyExceptionFieldKey)
	}
	if m.Key.Name != o.Key.Name {
		fields.Set(TrustPolicyExceptionFieldKeyName)
		fields.Set(TrustPolicyExceptionFieldKey)
	}
	if m.State != o.State {
		fields.Set(TrustPolicyExceptionFieldState)
	}
	if len(m.OutboundSecurityRules) != len(o.OutboundSecurityRules) {
		fields.Set(TrustPolicyExceptionFieldOutboundSecurityRules)
	} else {
		for i0 := 0; i0 < len(m.OutboundSecurityRules); i0++ {
			if m.OutboundSecurityRules[i0].Protocol != o.OutboundSecurityRules[i0].Protocol {
				fields.Set(TrustPolicyExceptionFieldOutboundSecurityRulesProtocol)
				fields.Set(TrustPolicyExceptionFieldOutboundSecurityRules)
			}
			if m.OutboundSecurityRules[i0].PortRangeMin != o.OutboundSecurityRules[i0].PortRangeMin {
				fields.Set(TrustPolicyExceptionFieldOutboundSecurityRulesPortRangeMin)
				fields.Set(TrustPolicyExceptionFieldOutboundSecurityRules)
			}
			if m.OutboundSecurityRules[i0].PortRangeMax != o.OutboundSecurityRules[i0].PortRangeMax {
				fields.Set(TrustPolicyExceptionFieldOutboundSecurityRulesPortRangeMax)
				fields.Set(TrustPolicyExceptionFieldOutboundSecurityRules)
			}
			if m.OutboundSecurityRules[i0].RemoteCidr != o.OutboundSecurityRules[i0].RemoteCidr {
				fields.Set(TrustPolicyExceptionFieldOutboundSecurityRulesRemoteCidr)
				fields.Set(TrustPolicyExceptionFieldOutboundSecurityRules)
			}
		}
	}
}

func (m *TrustPolicyException) GetDiffFields(o *TrustPolicyException) *FieldMap {
	diffFields := NewFieldMap(nil)
	m.DiffFields(o, diffFields)
	return diffFields
}

var UpdateTrustPolicyExceptionFieldsMap = NewFieldMap(map[string]struct{}{
	TrustPolicyExceptionFieldState:                             struct{}{},
	TrustPolicyExceptionFieldOutboundSecurityRules:             struct{}{},
	TrustPolicyExceptionFieldOutboundSecurityRulesProtocol:     struct{}{},
	TrustPolicyExceptionFieldOutboundSecurityRulesPortRangeMin: struct{}{},
	TrustPolicyExceptionFieldOutboundSecurityRulesPortRangeMax: struct{}{},
	TrustPolicyExceptionFieldOutboundSecurityRulesRemoteCidr:   struct{}{},
})

func (m *TrustPolicyException) ValidateUpdateFields() error {
	if m.Fields == nil {
		return fmt.Errorf("nothing specified to update")
	}
	fmap := MakeFieldMap(m.Fields)
	badFieldStrs := []string{}
	for _, field := range fmap.Fields() {
		if m.IsKeyField(field) {
			continue
		}
		if !UpdateTrustPolicyExceptionFieldsMap.Has(field) {
			if _, ok := TrustPolicyExceptionAllFieldsStringMap[field]; !ok {
				continue
			}
			badFieldStrs = append(badFieldStrs, TrustPolicyExceptionAllFieldsStringMap[field])
		}
	}
	if len(badFieldStrs) > 0 {
		return fmt.Errorf("specified field(s) %s cannot be modified", strings.Join(badFieldStrs, ","))
	}
	return nil
}

func (m *TrustPolicyException) Clone() *TrustPolicyException {
	cp := &TrustPolicyException{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *TrustPolicyException) AddOutboundSecurityRules(vals ...SecurityRule) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.OutboundSecurityRules {
		cur[v.String()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.String()]; found {
			continue // duplicate
		}
		m.OutboundSecurityRules = append(m.OutboundSecurityRules, v)
		changes++
	}
	return changes
}

func (m *TrustPolicyException) RemoveOutboundSecurityRules(vals ...SecurityRule) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.String()] = struct{}{}
	}
	for i := len(m.OutboundSecurityRules); i >= 0; i-- {
		if _, found := remove[m.OutboundSecurityRules[i].String()]; found {
			m.OutboundSecurityRules = append(m.OutboundSecurityRules[:i], m.OutboundSecurityRules[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *TrustPolicyException) CopyInFields(src *TrustPolicyException) int {
	updateListAction := "replace"
	changed := 0
	fmap := MakeFieldMap(src.Fields)
	if fmap.HasOrHasChild("2") {
		if fmap.HasOrHasChild("2.1") {
			if fmap.Has("2.1.1") {
				if m.Key.AppKey.Organization != src.Key.AppKey.Organization {
					m.Key.AppKey.Organization = src.Key.AppKey.Organization
					changed++
				}
			}
			if fmap.Has("2.1.2") {
				if m.Key.AppKey.Name != src.Key.AppKey.Name {
					m.Key.AppKey.Name = src.Key.AppKey.Name
					changed++
				}
			}
			if fmap.Has("2.1.3") {
				if m.Key.AppKey.Version != src.Key.AppKey.Version {
					m.Key.AppKey.Version = src.Key.AppKey.Version
					changed++
				}
			}
		}
		if fmap.HasOrHasChild("2.2") {
			if fmap.Has("2.2.1") {
				if m.Key.ZonePoolKey.Organization != src.Key.ZonePoolKey.Organization {
					m.Key.ZonePoolKey.Organization = src.Key.ZonePoolKey.Organization
					changed++
				}
			}
			if fmap.Has("2.2.2") {
				if m.Key.ZonePoolKey.Name != src.Key.ZonePoolKey.Name {
					m.Key.ZonePoolKey.Name = src.Key.ZonePoolKey.Name
					changed++
				}
			}
		}
		if fmap.Has("2.3") {
			if m.Key.Name != src.Key.Name {
				m.Key.Name = src.Key.Name
				changed++
			}
		}
	}
	if fmap.Has("3") {
		if m.State != src.State {
			m.State = src.State
			changed++
		}
	}
	if fmap.HasOrHasChild("4") {
		if src.OutboundSecurityRules != nil {
			if updateListAction == "add" {
				changed += m.AddOutboundSecurityRules(src.OutboundSecurityRules...)
			} else if updateListAction == "remove" {
				changed += m.RemoveOutboundSecurityRules(src.OutboundSecurityRules...)
			} else {
				m.OutboundSecurityRules = make([]SecurityRule, 0)
				for k0, _ := range src.OutboundSecurityRules {
					m.OutboundSecurityRules = append(m.OutboundSecurityRules, *src.OutboundSecurityRules[k0].Clone())
				}
				changed++
			}
		} else if m.OutboundSecurityRules != nil {
			m.OutboundSecurityRules = nil
			changed++
		}
	}
	return changed
}

func (m *TrustPolicyException) DeepCopyIn(src *TrustPolicyException) {
	m.Key.DeepCopyIn(&src.Key)
	m.State = src.State
	if src.OutboundSecurityRules != nil {
		m.OutboundSecurityRules = make([]SecurityRule, len(src.OutboundSecurityRules), len(src.OutboundSecurityRules))
		for ii, s := range src.OutboundSecurityRules {
			m.OutboundSecurityRules[ii].DeepCopyIn(&s)
		}
	} else {
		m.OutboundSecurityRules = nil
	}
}

func (s *TrustPolicyException) HasFields() bool {
	return true
}

type TrustPolicyExceptionStore interface {
	Create(ctx context.Context, m *TrustPolicyException, wait func(int64)) (*Result, error)
	Update(ctx context.Context, m *TrustPolicyException, wait func(int64)) (*Result, error)
	Delete(ctx context.Context, m *TrustPolicyException, wait func(int64)) (*Result, error)
	Put(ctx context.Context, m *TrustPolicyException, wait func(int64), ops ...objstore.KVOp) (*Result, error)
	LoadOne(key string) (*TrustPolicyException, int64, error)
	Get(ctx context.Context, key *TrustPolicyExceptionKey, buf *TrustPolicyException) bool
	STMGet(stm concurrency.STM, key *TrustPolicyExceptionKey, buf *TrustPolicyException) bool
	STMPut(stm concurrency.STM, obj *TrustPolicyException, ops ...objstore.KVOp)
	STMDel(stm concurrency.STM, key *TrustPolicyExceptionKey)
	STMHas(stm concurrency.STM, key *TrustPolicyExceptionKey) bool
}

type TrustPolicyExceptionStoreImpl struct {
	kvstore objstore.KVStore
}

func NewTrustPolicyExceptionStore(kvstore objstore.KVStore) *TrustPolicyExceptionStoreImpl {
	return &TrustPolicyExceptionStoreImpl{kvstore: kvstore}
}

func (s *TrustPolicyExceptionStoreImpl) Create(ctx context.Context, m *TrustPolicyException, wait func(int64)) (*Result, error) {
	err := m.Validate(TrustPolicyExceptionAllFieldsMap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("TrustPolicyException", m.GetKey())
	val, err := json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Create(ctx, key, string(val))
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *TrustPolicyExceptionStoreImpl) Update(ctx context.Context, m *TrustPolicyException, wait func(int64)) (*Result, error) {
	fmap := MakeFieldMap(m.Fields)
	err := m.Validate(fmap)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("TrustPolicyException", m.GetKey())
	var vers int64 = 0
	curBytes, vers, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, err
	}
	var cur TrustPolicyException
	err = json.Unmarshal(curBytes, &cur)
	if err != nil {
		return nil, err
	}
	cur.CopyInFields(m)
	// never save fields
	cur.Fields = nil
	val, err := json.Marshal(cur)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Update(ctx, key, string(val), vers)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *TrustPolicyExceptionStoreImpl) Put(ctx context.Context, m *TrustPolicyException, wait func(int64), ops ...objstore.KVOp) (*Result, error) {
	err := m.Validate(TrustPolicyExceptionAllFieldsMap)
	m.Fields = nil
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("TrustPolicyException", m.GetKey())
	var val []byte
	val, err = json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Put(ctx, key, string(val), ops...)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *TrustPolicyExceptionStoreImpl) Delete(ctx context.Context, m *TrustPolicyException, wait func(int64)) (*Result, error) {
	err := m.GetKey().ValidateKey()
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("TrustPolicyException", m.GetKey())
	rev, err := s.kvstore.Delete(ctx, key)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *TrustPolicyExceptionStoreImpl) LoadOne(key string) (*TrustPolicyException, int64, error) {
	val, rev, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, 0, err
	}
	var obj TrustPolicyException
	err = json.Unmarshal(val, &obj)
	if err != nil {
		log.DebugLog(log.DebugLevelApi, "Failed to parse TrustPolicyException data", "val", string(val), "err", err)
		return nil, 0, err
	}
	return &obj, rev, nil
}

func (s *TrustPolicyExceptionStoreImpl) Get(ctx context.Context, key *TrustPolicyExceptionKey, buf *TrustPolicyException) bool {
	keystr := objstore.DbKeyString("TrustPolicyException", key)
	val, _, _, err := s.kvstore.Get(keystr)
	if err != nil {
		return false
	}
	return s.parseGetData(val, buf)
}

func (s *TrustPolicyExceptionStoreImpl) STMGet(stm concurrency.STM, key *TrustPolicyExceptionKey, buf *TrustPolicyException) bool {
	keystr := objstore.DbKeyString("TrustPolicyException", key)
	valstr := stm.Get(keystr)
	return s.parseGetData([]byte(valstr), buf)
}

func (s *TrustPolicyExceptionStoreImpl) STMHas(stm concurrency.STM, key *TrustPolicyExceptionKey) bool {
	keystr := objstore.DbKeyString("TrustPolicyException", key)
	return stm.Get(keystr) != ""
}

func (s *TrustPolicyExceptionStoreImpl) parseGetData(val []byte, buf *TrustPolicyException) bool {
	if len(val) == 0 {
		return false
	}
	if buf != nil {
		// clear buf, because empty values in val won't
		// overwrite non-empty values in buf.
		*buf = TrustPolicyException{}
		err := json.Unmarshal(val, buf)
		if err != nil {
			return false
		}
	}
	return true
}

func (s *TrustPolicyExceptionStoreImpl) STMPut(stm concurrency.STM, obj *TrustPolicyException, ops ...objstore.KVOp) {
	keystr := objstore.DbKeyString("TrustPolicyException", obj.GetKey())

	val, err := json.Marshal(obj)
	if err != nil {
		log.InfoLog("TrustPolicyException json marshal failed", "obj", obj, "err", err)
	}
	v3opts := GetSTMOpts(ops...)
	stm.Put(keystr, string(val), v3opts...)
}

func (s *TrustPolicyExceptionStoreImpl) STMDel(stm concurrency.STM, key *TrustPolicyExceptionKey) {
	keystr := objstore.DbKeyString("TrustPolicyException", key)
	stm.Del(keystr)
}

func StoreListTrustPolicyException(ctx context.Context, kvstore objstore.KVStore) ([]TrustPolicyException, error) {
	keyPrefix := objstore.DbKeyPrefixString("TrustPolicyException") + "/"
	objs := []TrustPolicyException{}
	err := kvstore.List(keyPrefix, func(key, val []byte, rev, modRev int64) error {
		obj := TrustPolicyException{}
		err := json.Unmarshal(val, &obj)
		if err != nil {
			return fmt.Errorf("failed to unmarshal TrustPolicyException json %s, %s", string(val), err)
		}
		objs = append(objs, obj)
		return nil
	})
	return objs, err
}

type TrustPolicyExceptionKeyWatcher struct {
	cb func(ctx context.Context)
}

type TrustPolicyExceptionCacheData struct {
	Obj    *TrustPolicyException
	ModRev int64
}

func (s *TrustPolicyExceptionCacheData) Clone() *TrustPolicyExceptionCacheData {
	cp := TrustPolicyExceptionCacheData{}
	if s.Obj != nil {
		cp.Obj = &TrustPolicyException{}
		cp.Obj.DeepCopyIn(s.Obj)
	}
	cp.ModRev = s.ModRev
	return &cp
}

// TrustPolicyExceptionCache caches TrustPolicyException objects in memory in a hash table
// and keeps them in sync with the database.
type TrustPolicyExceptionCache struct {
	Objs          map[TrustPolicyExceptionKey]*TrustPolicyExceptionCacheData
	Mux           util.Mutex
	List          map[TrustPolicyExceptionKey]struct{}
	FlushAll      bool
	NotifyCbs     []func(ctx context.Context, obj *TrustPolicyException, modRev int64)
	UpdatedCbs    []func(ctx context.Context, old *TrustPolicyException, new *TrustPolicyException)
	DeletedCbs    []func(ctx context.Context, old *TrustPolicyException)
	KeyWatchers   map[TrustPolicyExceptionKey][]*TrustPolicyExceptionKeyWatcher
	UpdatedKeyCbs []func(ctx context.Context, key *TrustPolicyExceptionKey)
	DeletedKeyCbs []func(ctx context.Context, key *TrustPolicyExceptionKey)
	Store         TrustPolicyExceptionStore
}

func NewTrustPolicyExceptionCache() *TrustPolicyExceptionCache {
	cache := TrustPolicyExceptionCache{}
	InitTrustPolicyExceptionCache(&cache)
	return &cache
}

func InitTrustPolicyExceptionCache(cache *TrustPolicyExceptionCache) {
	cache.Objs = make(map[TrustPolicyExceptionKey]*TrustPolicyExceptionCacheData)
	cache.KeyWatchers = make(map[TrustPolicyExceptionKey][]*TrustPolicyExceptionKeyWatcher)
	cache.NotifyCbs = nil
	cache.UpdatedCbs = nil
	cache.DeletedCbs = nil
	cache.UpdatedKeyCbs = nil
	cache.DeletedKeyCbs = nil
}

func (c *TrustPolicyExceptionCache) GetTypeString() string {
	return "TrustPolicyException"
}

func (c *TrustPolicyExceptionCache) Get(key *TrustPolicyExceptionKey, valbuf *TrustPolicyException) bool {
	var modRev int64
	return c.GetWithRev(key, valbuf, &modRev)
}

func (c *TrustPolicyExceptionCache) GetWithRev(key *TrustPolicyExceptionKey, valbuf *TrustPolicyException, modRev *int64) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	inst, found := c.Objs[*key]
	if found {
		valbuf.DeepCopyIn(inst.Obj)
		*modRev = inst.ModRev
	}
	return found
}

func (c *TrustPolicyExceptionCache) HasKey(key *TrustPolicyExceptionKey) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	_, found := c.Objs[*key]
	return found
}

func (c *TrustPolicyExceptionCache) GetAllKeys(ctx context.Context, cb func(key *TrustPolicyExceptionKey, modRev int64)) {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for key, data := range c.Objs {
		cb(&key, data.ModRev)
	}
}

func (c *TrustPolicyExceptionCache) GetAllLocked(ctx context.Context, cb func(obj *TrustPolicyException, modRev int64)) {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for _, data := range c.Objs {
		cb(data.Obj, data.ModRev)
	}
}

func (c *TrustPolicyExceptionCache) Update(ctx context.Context, in *TrustPolicyException, modRev int64) {
	c.UpdateModFunc(ctx, in.GetKey(), modRev, func(old *TrustPolicyException) (*TrustPolicyException, bool) {
		return in, true
	})
}

func (c *TrustPolicyExceptionCache) UpdateModFunc(ctx context.Context, key *TrustPolicyExceptionKey, modRev int64, modFunc func(old *TrustPolicyException) (new *TrustPolicyException, changed bool)) {
	c.Mux.Lock()
	var old *TrustPolicyException
	if oldData, found := c.Objs[*key]; found {
		old = oldData.Obj
	}
	new, changed := modFunc(old)
	if !changed {
		c.Mux.Unlock()
		return
	}
	if len(c.UpdatedCbs) > 0 || len(c.NotifyCbs) > 0 {
		newCopy := &TrustPolicyException{}
		newCopy.DeepCopyIn(new)
		for _, cb := range c.UpdatedCbs {
			defer cb(ctx, old, newCopy)
		}
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				defer cb(ctx, newCopy, modRev)
			}
		}
	}
	for _, cb := range c.UpdatedKeyCbs {
		defer cb(ctx, key)
	}
	store := &TrustPolicyException{}
	store.DeepCopyIn(new)
	c.Objs[new.GetKeyVal()] = &TrustPolicyExceptionCacheData{
		Obj:    store,
		ModRev: modRev,
	}
	log.SpanLog(ctx, log.DebugLevelApi, "cache update", "new", store)
	c.Mux.Unlock()
	c.TriggerKeyWatchers(ctx, new.GetKey())
}

func (c *TrustPolicyExceptionCache) Delete(ctx context.Context, in *TrustPolicyException, modRev int64) {
	c.DeleteCondFunc(ctx, in, modRev, func(old *TrustPolicyException) bool {
		return true
	})
}

func (c *TrustPolicyExceptionCache) DeleteCondFunc(ctx context.Context, in *TrustPolicyException, modRev int64, condFunc func(old *TrustPolicyException) bool) {
	c.Mux.Lock()
	var old *TrustPolicyException
	oldData, found := c.Objs[in.GetKeyVal()]
	if found {
		old = oldData.Obj
		if !condFunc(old) {
			c.Mux.Unlock()
			return
		}
	}
	delete(c.Objs, in.GetKeyVal())
	log.SpanLog(ctx, log.DebugLevelApi, "cache delete", "key", in.GetKeyVal())
	c.Mux.Unlock()
	obj := old
	if obj == nil {
		obj = in
	}
	for _, cb := range c.NotifyCbs {
		if cb != nil {
			cb(ctx, obj, modRev)
		}
	}
	if old != nil {
		for _, cb := range c.DeletedCbs {
			cb(ctx, old)
		}
	}
	for _, cb := range c.DeletedKeyCbs {
		cb(ctx, in.GetKey())
	}
	c.TriggerKeyWatchers(ctx, in.GetKey())
}

func (c *TrustPolicyExceptionCache) Prune(ctx context.Context, validKeys map[TrustPolicyExceptionKey]struct{}) {
	log.SpanLog(ctx, log.DebugLevelApi, "Prune TrustPolicyException", "numValidKeys", len(validKeys))
	notify := make(map[TrustPolicyExceptionKey]*TrustPolicyExceptionCacheData)
	c.Mux.Lock()
	for key, _ := range c.Objs {
		if _, ok := validKeys[key]; !ok {
			if len(c.NotifyCbs) > 0 || len(c.DeletedKeyCbs) > 0 || len(c.DeletedCbs) > 0 {
				notify[key] = c.Objs[key]
			}
			delete(c.Objs, key)
		}
	}
	c.Mux.Unlock()
	for key, old := range notify {
		obj := old.Obj
		if obj == nil {
			obj = &TrustPolicyException{}
			obj.SetKey(&key)
		}
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, obj, old.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if old.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, old.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (c *TrustPolicyExceptionCache) GetCount() int {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	return len(c.Objs)
}

func (c *TrustPolicyExceptionCache) Flush(ctx context.Context, notifyId int64) {
}

func (c *TrustPolicyExceptionCache) Show(filter *TrustPolicyException, cb func(ret *TrustPolicyException) error) error {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for _, data := range c.Objs {
		if !data.Obj.Matches(filter, MatchFilter()) {
			continue
		}
		err := cb(data.Obj)
		if err != nil {
			return err
		}
	}
	return nil
}

func TrustPolicyExceptionGenericNotifyCb(fn func(key *TrustPolicyExceptionKey, old *TrustPolicyException)) func(objstore.ObjKey, objstore.Obj) {
	return func(objkey objstore.ObjKey, obj objstore.Obj) {
		fn(objkey.(*TrustPolicyExceptionKey), obj.(*TrustPolicyException))
	}
}

func (c *TrustPolicyExceptionCache) SetNotifyCb(fn func(ctx context.Context, obj *TrustPolicyException, modRev int64)) {
	c.NotifyCbs = []func(ctx context.Context, obj *TrustPolicyException, modRev int64){fn}
}

func (c *TrustPolicyExceptionCache) SetUpdatedCb(fn func(ctx context.Context, old *TrustPolicyException, new *TrustPolicyException)) {
	c.UpdatedCbs = []func(ctx context.Context, old *TrustPolicyException, new *TrustPolicyException){fn}
}

func (c *TrustPolicyExceptionCache) SetDeletedCb(fn func(ctx context.Context, old *TrustPolicyException)) {
	c.DeletedCbs = []func(ctx context.Context, old *TrustPolicyException){fn}
}

func (c *TrustPolicyExceptionCache) SetUpdatedKeyCb(fn func(ctx context.Context, key *TrustPolicyExceptionKey)) {
	c.UpdatedKeyCbs = []func(ctx context.Context, key *TrustPolicyExceptionKey){fn}
}

func (c *TrustPolicyExceptionCache) SetDeletedKeyCb(fn func(ctx context.Context, key *TrustPolicyExceptionKey)) {
	c.DeletedKeyCbs = []func(ctx context.Context, key *TrustPolicyExceptionKey){fn}
}

func (c *TrustPolicyExceptionCache) AddUpdatedCb(fn func(ctx context.Context, old *TrustPolicyException, new *TrustPolicyException)) {
	c.UpdatedCbs = append(c.UpdatedCbs, fn)
}

func (c *TrustPolicyExceptionCache) AddDeletedCb(fn func(ctx context.Context, old *TrustPolicyException)) {
	c.DeletedCbs = append(c.DeletedCbs, fn)
}

func (c *TrustPolicyExceptionCache) AddNotifyCb(fn func(ctx context.Context, obj *TrustPolicyException, modRev int64)) {
	c.NotifyCbs = append(c.NotifyCbs, fn)
}

func (c *TrustPolicyExceptionCache) AddUpdatedKeyCb(fn func(ctx context.Context, key *TrustPolicyExceptionKey)) {
	c.UpdatedKeyCbs = append(c.UpdatedKeyCbs, fn)
}

func (c *TrustPolicyExceptionCache) AddDeletedKeyCb(fn func(ctx context.Context, key *TrustPolicyExceptionKey)) {
	c.DeletedKeyCbs = append(c.DeletedKeyCbs, fn)
}

func (c *TrustPolicyExceptionCache) SetFlushAll() {
	c.FlushAll = true
}

func (c *TrustPolicyExceptionCache) WatchKey(key *TrustPolicyExceptionKey, cb func(ctx context.Context)) context.CancelFunc {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	list, ok := c.KeyWatchers[*key]
	if !ok {
		list = make([]*TrustPolicyExceptionKeyWatcher, 0)
	}
	watcher := TrustPolicyExceptionKeyWatcher{cb: cb}
	c.KeyWatchers[*key] = append(list, &watcher)
	log.DebugLog(log.DebugLevelApi, "Watching TrustPolicyException", "key", key)
	return func() {
		c.Mux.Lock()
		defer c.Mux.Unlock()
		list, ok := c.KeyWatchers[*key]
		if !ok {
			return
		}
		for ii, _ := range list {
			if list[ii] != &watcher {
				continue
			}
			if len(list) == 1 {
				delete(c.KeyWatchers, *key)
				return
			}
			list[ii] = list[len(list)-1]
			list[len(list)-1] = nil
			c.KeyWatchers[*key] = list[:len(list)-1]
			return
		}
	}
}

func (c *TrustPolicyExceptionCache) TriggerKeyWatchers(ctx context.Context, key *TrustPolicyExceptionKey) {
	watchers := make([]*TrustPolicyExceptionKeyWatcher, 0)
	c.Mux.Lock()
	if list, ok := c.KeyWatchers[*key]; ok {
		watchers = append(watchers, list...)
	}
	c.Mux.Unlock()
	for ii, _ := range watchers {
		watchers[ii].cb(ctx)
	}
}

// Note that we explicitly ignore the global revision number, because of the way
// the notify framework sends updates (by hashing keys and doing lookups, instead
// of sequentially through a history buffer), updates may be done out-of-order
// or multiple updates compressed into one update, so the state of the cache at
// any point in time may not by in sync with a particular database revision number.

func (c *TrustPolicyExceptionCache) SyncUpdate(ctx context.Context, key, val []byte, rev, modRev int64) {
	obj := TrustPolicyException{}
	err := json.Unmarshal(val, &obj)
	if err != nil {
		log.WarnLog("Failed to parse TrustPolicyException data", "val", string(val), "err", err)
		return
	}
	c.Update(ctx, &obj, modRev)
	c.Mux.Lock()
	if c.List != nil {
		c.List[obj.GetKeyVal()] = struct{}{}
	}
	c.Mux.Unlock()
}

func (c *TrustPolicyExceptionCache) SyncDelete(ctx context.Context, key []byte, rev, modRev int64) {
	obj := TrustPolicyException{}
	keystr := objstore.DbKeyPrefixRemove(string(key))
	TrustPolicyExceptionKeyStringParse(keystr, obj.GetKey())
	c.Delete(ctx, &obj, modRev)
}

func (c *TrustPolicyExceptionCache) SyncListStart(ctx context.Context) {
	c.List = make(map[TrustPolicyExceptionKey]struct{})
}

func (c *TrustPolicyExceptionCache) SyncListEnd(ctx context.Context) {
	deleted := make(map[TrustPolicyExceptionKey]*TrustPolicyExceptionCacheData)
	c.Mux.Lock()
	for key, val := range c.Objs {
		if _, found := c.List[key]; !found {
			deleted[key] = val
			delete(c.Objs, key)
		}
	}
	c.List = nil
	c.Mux.Unlock()
	for key, val := range deleted {
		obj := val.Obj
		if obj == nil {
			obj = &TrustPolicyException{}
			obj.SetKey(&key)
		}
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, obj, val.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if val.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, val.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (s *TrustPolicyExceptionCache) InitCacheWithSync(sync DataSync) {
	InitTrustPolicyExceptionCache(s)
	s.InitSync(sync)
}

func (s *TrustPolicyExceptionCache) InitSync(sync DataSync) {
	if sync != nil {
		s.Store = NewTrustPolicyExceptionStore(sync.GetKVStore())
		sync.RegisterCache(s)
	}
}

func (c *TrustPolicyExceptionCache) UsesOrg(org string) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for key, _ := range c.Objs {
		if key.AppKey.Organization == org {
			return true
		}
	}
	return false
}

func (m *TrustPolicyException) GetObjKey() objstore.ObjKey {
	return m.GetKey()
}

func (m *TrustPolicyException) GetKey() *TrustPolicyExceptionKey {
	return &m.Key
}

func (m *TrustPolicyException) GetKeyVal() TrustPolicyExceptionKey {
	return m.Key
}

func (m *TrustPolicyException) SetKey(key *TrustPolicyExceptionKey) {
	m.Key = *key
}

func CmpSortTrustPolicyException(a TrustPolicyException, b TrustPolicyException) bool {
	return a.Key.GetKeyString() < b.Key.GetKeyString()
}

// Helper method to check that enums have valid values
// NOTE: ValidateEnums checks all Fields even if some are not set
func (m *TrustPolicyException) ValidateEnums() error {
	if err := m.Key.ValidateEnums(); err != nil {
		return err
	}
	if _, ok := TrustPolicyExceptionState_name[int32(m.State)]; !ok {
		return errors.New("invalid State")
	}
	for _, e := range m.OutboundSecurityRules {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (s *TrustPolicyException) ClearTagged(tags map[string]struct{}) {
	s.Key.ClearTagged(tags)
	if s.OutboundSecurityRules != nil {
		for ii := 0; ii < len(s.OutboundSecurityRules); ii++ {
			s.OutboundSecurityRules[ii].ClearTagged(tags)
		}
	}
}

func (m *TPEInstanceKey) Matches(o *TPEInstanceKey, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !m.TpeKey.Matches(&o.TpeKey, fopts...) {
		return false
	}
	if !m.AppInstKey.Matches(&o.AppInstKey, fopts...) {
		return false
	}
	if !m.ClusterKey.Matches(&o.ClusterKey, fopts...) {
		return false
	}
	if !m.CloudletKey.Matches(&o.CloudletKey, fopts...) {
		return false
	}
	return true
}

func (m *TPEInstanceKey) Clone() *TPEInstanceKey {
	cp := &TPEInstanceKey{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *TPEInstanceKey) CopyInFields(src *TPEInstanceKey) int {
	changed := 0
	if m.TpeKey.AppKey.Organization != src.TpeKey.AppKey.Organization {
		m.TpeKey.AppKey.Organization = src.TpeKey.AppKey.Organization
		changed++
	}
	if m.TpeKey.AppKey.Name != src.TpeKey.AppKey.Name {
		m.TpeKey.AppKey.Name = src.TpeKey.AppKey.Name
		changed++
	}
	if m.TpeKey.AppKey.Version != src.TpeKey.AppKey.Version {
		m.TpeKey.AppKey.Version = src.TpeKey.AppKey.Version
		changed++
	}
	if m.TpeKey.ZonePoolKey.Organization != src.TpeKey.ZonePoolKey.Organization {
		m.TpeKey.ZonePoolKey.Organization = src.TpeKey.ZonePoolKey.Organization
		changed++
	}
	if m.TpeKey.ZonePoolKey.Name != src.TpeKey.ZonePoolKey.Name {
		m.TpeKey.ZonePoolKey.Name = src.TpeKey.ZonePoolKey.Name
		changed++
	}
	if m.TpeKey.Name != src.TpeKey.Name {
		m.TpeKey.Name = src.TpeKey.Name
		changed++
	}
	if m.AppInstKey.Name != src.AppInstKey.Name {
		m.AppInstKey.Name = src.AppInstKey.Name
		changed++
	}
	if m.AppInstKey.Organization != src.AppInstKey.Organization {
		m.AppInstKey.Organization = src.AppInstKey.Organization
		changed++
	}
	if m.ClusterKey.Name != src.ClusterKey.Name {
		m.ClusterKey.Name = src.ClusterKey.Name
		changed++
	}
	if m.ClusterKey.Organization != src.ClusterKey.Organization {
		m.ClusterKey.Organization = src.ClusterKey.Organization
		changed++
	}
	if m.CloudletKey.Organization != src.CloudletKey.Organization {
		m.CloudletKey.Organization = src.CloudletKey.Organization
		changed++
	}
	if m.CloudletKey.Name != src.CloudletKey.Name {
		m.CloudletKey.Name = src.CloudletKey.Name
		changed++
	}
	if m.CloudletKey.FederatedOrganization != src.CloudletKey.FederatedOrganization {
		m.CloudletKey.FederatedOrganization = src.CloudletKey.FederatedOrganization
		changed++
	}
	return changed
}

func (m *TPEInstanceKey) DeepCopyIn(src *TPEInstanceKey) {
	m.TpeKey.DeepCopyIn(&src.TpeKey)
	m.AppInstKey.DeepCopyIn(&src.AppInstKey)
	m.ClusterKey.DeepCopyIn(&src.ClusterKey)
	m.CloudletKey.DeepCopyIn(&src.CloudletKey)
}

func (m *TPEInstanceKey) GetKeyString() string {
	key, err := json.Marshal(m)
	if err != nil {
		log.FatalLog("Failed to marshal TPEInstanceKey key string", "obj", m)
	}
	return string(key)
}

func TPEInstanceKeyStringParse(str string, key *TPEInstanceKey) {
	err := json.Unmarshal([]byte(str), key)
	if err != nil {
		log.FatalLog("Failed to unmarshal TPEInstanceKey key string", "str", str)
	}
}

func (m *TPEInstanceKey) NotFoundError() error {
	return fmt.Errorf("TPEInstance key %s not found", m.GetKeyString())
}

func (m *TPEInstanceKey) ExistsError() error {
	return fmt.Errorf("TPEInstance key %s already exists", m.GetKeyString())
}

func (m *TPEInstanceKey) BeingDeletedError() error {
	return fmt.Errorf("TPEInstance %s is being deleted", m.GetKeyString())
}

func (m *TPEInstanceKey) GetTags() map[string]string {
	tags := make(map[string]string)
	m.AddTags(tags)
	return tags
}

func (m *TPEInstanceKey) AddTagsByFunc(addTag AddTagFunc) {
	addTag("apporg", m.TpeKey.AppKey.Organization)
	addTag("app", m.TpeKey.AppKey.Name)
	addTag("appver", m.TpeKey.AppKey.Version)
	addTag("zonepoolorg", m.TpeKey.ZonePoolKey.Organization)
	addTag("zonepool", m.TpeKey.ZonePoolKey.Name)
	addTag("name", m.TpeKey.Name)
	addTag("appinst", m.AppInstKey.Name)
	addTag("appinstorg", m.AppInstKey.Organization)
	addTag("cluster", m.ClusterKey.Name)
	addTag("clusterorg", m.ClusterKey.Organization)
	addTag("cloudletorg", m.CloudletKey.Organization)
	addTag("cloudlet", m.CloudletKey.Name)
	addTag("cloudletfedorg", m.CloudletKey.FederatedOrganization)
}

func (m *TPEInstanceKey) AddTags(tags map[string]string) {
	tagMap := TagMap(tags)
	m.AddTagsByFunc(tagMap.AddTag)
}

// Helper method to check that enums have valid values
func (m *TPEInstanceKey) ValidateEnums() error {
	if err := m.TpeKey.ValidateEnums(); err != nil {
		return err
	}
	if err := m.AppInstKey.ValidateEnums(); err != nil {
		return err
	}
	if err := m.ClusterKey.ValidateEnums(); err != nil {
		return err
	}
	if err := m.CloudletKey.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func (s *TPEInstanceKey) ClearTagged(tags map[string]struct{}) {
	s.TpeKey.ClearTagged(tags)
	s.AppInstKey.ClearTagged(tags)
	s.ClusterKey.ClearTagged(tags)
	s.CloudletKey.ClearTagged(tags)
}

func (m *TPEInstanceState) Matches(o *TPEInstanceState, fopts ...MatchOpt) bool {
	opts := MatchOptions{}
	applyMatchOptions(&opts, fopts...)
	if o == nil {
		if opts.Filter {
			return true
		}
		return false
	}
	if !m.Key.Matches(&o.Key, fopts...) {
		return false
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.Owner != "" {
			if o.Owner != m.Owner {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.RunRequested != false {
			if o.RunRequested != m.RunRequested {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.RunCount != 0 {
			if o.RunCount != m.RunCount {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.TpeEnable != false {
			if o.TpeEnable != m.TpeEnable {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.DisableReason != "" {
			if o.DisableReason != m.DisableReason {
				return false
			}
		}
	}
	if !opts.IgnoreBackend {
		if !opts.Filter || o.Error != "" {
			if o.Error != m.Error {
				return false
			}
		}
	}
	return true
}

func (m *TPEInstanceState) Clone() *TPEInstanceState {
	cp := &TPEInstanceState{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *TPEInstanceState) CopyInFields(src *TPEInstanceState) int {
	changed := 0
	if m.Key.TpeKey.AppKey.Organization != src.Key.TpeKey.AppKey.Organization {
		m.Key.TpeKey.AppKey.Organization = src.Key.TpeKey.AppKey.Organization
		changed++
	}
	if m.Key.TpeKey.AppKey.Name != src.Key.TpeKey.AppKey.Name {
		m.Key.TpeKey.AppKey.Name = src.Key.TpeKey.AppKey.Name
		changed++
	}
	if m.Key.TpeKey.AppKey.Version != src.Key.TpeKey.AppKey.Version {
		m.Key.TpeKey.AppKey.Version = src.Key.TpeKey.AppKey.Version
		changed++
	}
	if m.Key.TpeKey.ZonePoolKey.Organization != src.Key.TpeKey.ZonePoolKey.Organization {
		m.Key.TpeKey.ZonePoolKey.Organization = src.Key.TpeKey.ZonePoolKey.Organization
		changed++
	}
	if m.Key.TpeKey.ZonePoolKey.Name != src.Key.TpeKey.ZonePoolKey.Name {
		m.Key.TpeKey.ZonePoolKey.Name = src.Key.TpeKey.ZonePoolKey.Name
		changed++
	}
	if m.Key.TpeKey.Name != src.Key.TpeKey.Name {
		m.Key.TpeKey.Name = src.Key.TpeKey.Name
		changed++
	}
	if m.Key.AppInstKey.Name != src.Key.AppInstKey.Name {
		m.Key.AppInstKey.Name = src.Key.AppInstKey.Name
		changed++
	}
	if m.Key.AppInstKey.Organization != src.Key.AppInstKey.Organization {
		m.Key.AppInstKey.Organization = src.Key.AppInstKey.Organization
		changed++
	}
	if m.Key.ClusterKey.Name != src.Key.ClusterKey.Name {
		m.Key.ClusterKey.Name = src.Key.ClusterKey.Name
		changed++
	}
	if m.Key.ClusterKey.Organization != src.Key.ClusterKey.Organization {
		m.Key.ClusterKey.Organization = src.Key.ClusterKey.Organization
		changed++
	}
	if m.Key.CloudletKey.Organization != src.Key.CloudletKey.Organization {
		m.Key.CloudletKey.Organization = src.Key.CloudletKey.Organization
		changed++
	}
	if m.Key.CloudletKey.Name != src.Key.CloudletKey.Name {
		m.Key.CloudletKey.Name = src.Key.CloudletKey.Name
		changed++
	}
	if m.Key.CloudletKey.FederatedOrganization != src.Key.CloudletKey.FederatedOrganization {
		m.Key.CloudletKey.FederatedOrganization = src.Key.CloudletKey.FederatedOrganization
		changed++
	}
	if m.Owner != src.Owner {
		m.Owner = src.Owner
		changed++
	}
	if m.RunRequested != src.RunRequested {
		m.RunRequested = src.RunRequested
		changed++
	}
	if m.RunCount != src.RunCount {
		m.RunCount = src.RunCount
		changed++
	}
	if m.TpeEnable != src.TpeEnable {
		m.TpeEnable = src.TpeEnable
		changed++
	}
	if m.DisableReason != src.DisableReason {
		m.DisableReason = src.DisableReason
		changed++
	}
	if m.Error != src.Error {
		m.Error = src.Error
		changed++
	}
	if m.StartedAt.Seconds != src.StartedAt.Seconds {
		m.StartedAt.Seconds = src.StartedAt.Seconds
		changed++
	}
	if m.StartedAt.Nanos != src.StartedAt.Nanos {
		m.StartedAt.Nanos = src.StartedAt.Nanos
		changed++
	}
	return changed
}

func (m *TPEInstanceState) DeepCopyIn(src *TPEInstanceState) {
	m.Key.DeepCopyIn(&src.Key)
	m.Owner = src.Owner
	m.RunRequested = src.RunRequested
	m.RunCount = src.RunCount
	m.TpeEnable = src.TpeEnable
	m.DisableReason = src.DisableReason
	m.Error = src.Error
	m.StartedAt = src.StartedAt
}

func (s *TPEInstanceState) HasFields() bool {
	return false
}

type TPEInstanceStateStore interface {
	Create(ctx context.Context, m *TPEInstanceState, wait func(int64)) (*Result, error)
	Update(ctx context.Context, m *TPEInstanceState, wait func(int64)) (*Result, error)
	Delete(ctx context.Context, m *TPEInstanceState, wait func(int64)) (*Result, error)
	Put(ctx context.Context, m *TPEInstanceState, wait func(int64), ops ...objstore.KVOp) (*Result, error)
	LoadOne(key string) (*TPEInstanceState, int64, error)
	Get(ctx context.Context, key *TPEInstanceKey, buf *TPEInstanceState) bool
	STMGet(stm concurrency.STM, key *TPEInstanceKey, buf *TPEInstanceState) bool
	STMPut(stm concurrency.STM, obj *TPEInstanceState, ops ...objstore.KVOp)
	STMDel(stm concurrency.STM, key *TPEInstanceKey)
	STMHas(stm concurrency.STM, key *TPEInstanceKey) bool
}

type TPEInstanceStateStoreImpl struct {
	kvstore objstore.KVStore
}

func NewTPEInstanceStateStore(kvstore objstore.KVStore) *TPEInstanceStateStoreImpl {
	return &TPEInstanceStateStoreImpl{kvstore: kvstore}
}

func (s *TPEInstanceStateStoreImpl) Create(ctx context.Context, m *TPEInstanceState, wait func(int64)) (*Result, error) {
	err := m.Validate(nil)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("TPEInstanceState", m.GetKey())
	val, err := json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Create(ctx, key, string(val))
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *TPEInstanceStateStoreImpl) Update(ctx context.Context, m *TPEInstanceState, wait func(int64)) (*Result, error) {
	err := m.Validate(nil)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("TPEInstanceState", m.GetKey())
	var vers int64 = 0
	val, err := json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Update(ctx, key, string(val), vers)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *TPEInstanceStateStoreImpl) Put(ctx context.Context, m *TPEInstanceState, wait func(int64), ops ...objstore.KVOp) (*Result, error) {
	err := m.Validate(nil)
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("TPEInstanceState", m.GetKey())
	var val []byte
	val, err = json.Marshal(m)
	if err != nil {
		return nil, err
	}
	rev, err := s.kvstore.Put(ctx, key, string(val), ops...)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *TPEInstanceStateStoreImpl) Delete(ctx context.Context, m *TPEInstanceState, wait func(int64)) (*Result, error) {
	err := m.GetKey().ValidateKey()
	if err != nil {
		return nil, err
	}
	key := objstore.DbKeyString("TPEInstanceState", m.GetKey())
	rev, err := s.kvstore.Delete(ctx, key)
	if err != nil {
		return nil, err
	}
	if wait != nil {
		wait(rev)
	}
	return &Result{}, err
}

func (s *TPEInstanceStateStoreImpl) LoadOne(key string) (*TPEInstanceState, int64, error) {
	val, rev, _, err := s.kvstore.Get(key)
	if err != nil {
		return nil, 0, err
	}
	var obj TPEInstanceState
	err = json.Unmarshal(val, &obj)
	if err != nil {
		log.DebugLog(log.DebugLevelApi, "Failed to parse TPEInstanceState data", "val", string(val), "err", err)
		return nil, 0, err
	}
	return &obj, rev, nil
}

func (s *TPEInstanceStateStoreImpl) Get(ctx context.Context, key *TPEInstanceKey, buf *TPEInstanceState) bool {
	keystr := objstore.DbKeyString("TPEInstanceState", key)
	val, _, _, err := s.kvstore.Get(keystr)
	if err != nil {
		return false
	}
	return s.parseGetData(val, buf)
}

func (s *TPEInstanceStateStoreImpl) STMGet(stm concurrency.STM, key *TPEInstanceKey, buf *TPEInstanceState) bool {
	keystr := objstore.DbKeyString("TPEInstanceState", key)
	valstr := stm.Get(keystr)
	return s.parseGetData([]byte(valstr), buf)
}

func (s *TPEInstanceStateStoreImpl) STMHas(stm concurrency.STM, key *TPEInstanceKey) bool {
	keystr := objstore.DbKeyString("TPEInstanceState", key)
	return stm.Get(keystr) != ""
}

func (s *TPEInstanceStateStoreImpl) parseGetData(val []byte, buf *TPEInstanceState) bool {
	if len(val) == 0 {
		return false
	}
	if buf != nil {
		// clear buf, because empty values in val won't
		// overwrite non-empty values in buf.
		*buf = TPEInstanceState{}
		err := json.Unmarshal(val, buf)
		if err != nil {
			return false
		}
	}
	return true
}

func (s *TPEInstanceStateStoreImpl) STMPut(stm concurrency.STM, obj *TPEInstanceState, ops ...objstore.KVOp) {
	keystr := objstore.DbKeyString("TPEInstanceState", obj.GetKey())

	val, err := json.Marshal(obj)
	if err != nil {
		log.InfoLog("TPEInstanceState json marshal failed", "obj", obj, "err", err)
	}
	v3opts := GetSTMOpts(ops...)
	stm.Put(keystr, string(val), v3opts...)
}

func (s *TPEInstanceStateStoreImpl) STMDel(stm concurrency.STM, key *TPEInstanceKey) {
	keystr := objstore.DbKeyString("TPEInstanceState", key)
	stm.Del(keystr)
}

func StoreListTPEInstanceState(ctx context.Context, kvstore objstore.KVStore) ([]TPEInstanceState, error) {
	keyPrefix := objstore.DbKeyPrefixString("TPEInstanceState") + "/"
	objs := []TPEInstanceState{}
	err := kvstore.List(keyPrefix, func(key, val []byte, rev, modRev int64) error {
		obj := TPEInstanceState{}
		err := json.Unmarshal(val, &obj)
		if err != nil {
			return fmt.Errorf("failed to unmarshal TPEInstanceState json %s, %s", string(val), err)
		}
		objs = append(objs, obj)
		return nil
	})
	return objs, err
}

type TPEInstanceStateKeyWatcher struct {
	cb func(ctx context.Context)
}

type TPEInstanceStateCacheData struct {
	Obj    *TPEInstanceState
	ModRev int64
}

func (s *TPEInstanceStateCacheData) Clone() *TPEInstanceStateCacheData {
	cp := TPEInstanceStateCacheData{}
	if s.Obj != nil {
		cp.Obj = &TPEInstanceState{}
		cp.Obj.DeepCopyIn(s.Obj)
	}
	cp.ModRev = s.ModRev
	return &cp
}

// TPEInstanceStateCache caches TPEInstanceState objects in memory in a hash table
// and keeps them in sync with the database.
type TPEInstanceStateCache struct {
	Objs          map[TPEInstanceKey]*TPEInstanceStateCacheData
	Mux           util.Mutex
	List          map[TPEInstanceKey]struct{}
	FlushAll      bool
	NotifyCbs     []func(ctx context.Context, obj *TPEInstanceState, modRev int64)
	UpdatedCbs    []func(ctx context.Context, old *TPEInstanceState, new *TPEInstanceState)
	DeletedCbs    []func(ctx context.Context, old *TPEInstanceState)
	KeyWatchers   map[TPEInstanceKey][]*TPEInstanceStateKeyWatcher
	UpdatedKeyCbs []func(ctx context.Context, key *TPEInstanceKey)
	DeletedKeyCbs []func(ctx context.Context, key *TPEInstanceKey)
	Store         TPEInstanceStateStore
}

func NewTPEInstanceStateCache() *TPEInstanceStateCache {
	cache := TPEInstanceStateCache{}
	InitTPEInstanceStateCache(&cache)
	return &cache
}

func InitTPEInstanceStateCache(cache *TPEInstanceStateCache) {
	cache.Objs = make(map[TPEInstanceKey]*TPEInstanceStateCacheData)
	cache.KeyWatchers = make(map[TPEInstanceKey][]*TPEInstanceStateKeyWatcher)
	cache.NotifyCbs = nil
	cache.UpdatedCbs = nil
	cache.DeletedCbs = nil
	cache.UpdatedKeyCbs = nil
	cache.DeletedKeyCbs = nil
}

func (c *TPEInstanceStateCache) GetTypeString() string {
	return "TPEInstanceState"
}

func (c *TPEInstanceStateCache) Get(key *TPEInstanceKey, valbuf *TPEInstanceState) bool {
	var modRev int64
	return c.GetWithRev(key, valbuf, &modRev)
}

func (c *TPEInstanceStateCache) GetWithRev(key *TPEInstanceKey, valbuf *TPEInstanceState, modRev *int64) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	inst, found := c.Objs[*key]
	if found {
		valbuf.DeepCopyIn(inst.Obj)
		*modRev = inst.ModRev
	}
	return found
}

func (c *TPEInstanceStateCache) HasKey(key *TPEInstanceKey) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	_, found := c.Objs[*key]
	return found
}

func (c *TPEInstanceStateCache) GetAllKeys(ctx context.Context, cb func(key *TPEInstanceKey, modRev int64)) {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for key, data := range c.Objs {
		cb(&key, data.ModRev)
	}
}

func (c *TPEInstanceStateCache) GetAllLocked(ctx context.Context, cb func(obj *TPEInstanceState, modRev int64)) {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for _, data := range c.Objs {
		cb(data.Obj, data.ModRev)
	}
}

func (c *TPEInstanceStateCache) Update(ctx context.Context, in *TPEInstanceState, modRev int64) {
	c.UpdateModFunc(ctx, in.GetKey(), modRev, func(old *TPEInstanceState) (*TPEInstanceState, bool) {
		return in, true
	})
}

func (c *TPEInstanceStateCache) UpdateModFunc(ctx context.Context, key *TPEInstanceKey, modRev int64, modFunc func(old *TPEInstanceState) (new *TPEInstanceState, changed bool)) {
	c.Mux.Lock()
	var old *TPEInstanceState
	if oldData, found := c.Objs[*key]; found {
		old = oldData.Obj
	}
	new, changed := modFunc(old)
	if !changed {
		c.Mux.Unlock()
		return
	}
	if len(c.UpdatedCbs) > 0 || len(c.NotifyCbs) > 0 {
		newCopy := &TPEInstanceState{}
		newCopy.DeepCopyIn(new)
		for _, cb := range c.UpdatedCbs {
			defer cb(ctx, old, newCopy)
		}
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				defer cb(ctx, newCopy, modRev)
			}
		}
	}
	for _, cb := range c.UpdatedKeyCbs {
		defer cb(ctx, key)
	}
	store := &TPEInstanceState{}
	store.DeepCopyIn(new)
	c.Objs[new.GetKeyVal()] = &TPEInstanceStateCacheData{
		Obj:    store,
		ModRev: modRev,
	}
	log.SpanLog(ctx, log.DebugLevelApi, "cache update", "new", store)
	c.Mux.Unlock()
	c.TriggerKeyWatchers(ctx, new.GetKey())
}

func (c *TPEInstanceStateCache) Delete(ctx context.Context, in *TPEInstanceState, modRev int64) {
	c.DeleteCondFunc(ctx, in, modRev, func(old *TPEInstanceState) bool {
		return true
	})
}

func (c *TPEInstanceStateCache) DeleteCondFunc(ctx context.Context, in *TPEInstanceState, modRev int64, condFunc func(old *TPEInstanceState) bool) {
	c.Mux.Lock()
	var old *TPEInstanceState
	oldData, found := c.Objs[in.GetKeyVal()]
	if found {
		old = oldData.Obj
		if !condFunc(old) {
			c.Mux.Unlock()
			return
		}
	}
	delete(c.Objs, in.GetKeyVal())
	log.SpanLog(ctx, log.DebugLevelApi, "cache delete", "key", in.GetKeyVal())
	c.Mux.Unlock()
	obj := old
	if obj == nil {
		obj = in
	}
	for _, cb := range c.NotifyCbs {
		if cb != nil {
			cb(ctx, obj, modRev)
		}
	}
	if old != nil {
		for _, cb := range c.DeletedCbs {
			cb(ctx, old)
		}
	}
	for _, cb := range c.DeletedKeyCbs {
		cb(ctx, in.GetKey())
	}
	c.TriggerKeyWatchers(ctx, in.GetKey())
}

func (c *TPEInstanceStateCache) Prune(ctx context.Context, validKeys map[TPEInstanceKey]struct{}) {
	log.SpanLog(ctx, log.DebugLevelApi, "Prune TPEInstanceState", "numValidKeys", len(validKeys))
	notify := make(map[TPEInstanceKey]*TPEInstanceStateCacheData)
	c.Mux.Lock()
	for key, _ := range c.Objs {
		if _, ok := validKeys[key]; !ok {
			if len(c.NotifyCbs) > 0 || len(c.DeletedKeyCbs) > 0 || len(c.DeletedCbs) > 0 {
				notify[key] = c.Objs[key]
			}
			delete(c.Objs, key)
		}
	}
	c.Mux.Unlock()
	for key, old := range notify {
		obj := old.Obj
		if obj == nil {
			obj = &TPEInstanceState{}
			obj.SetKey(&key)
		}
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, obj, old.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if old.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, old.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (c *TPEInstanceStateCache) GetCount() int {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	return len(c.Objs)
}

func (c *TPEInstanceStateCache) Flush(ctx context.Context, notifyId int64) {
}

func (c *TPEInstanceStateCache) Show(filter *TPEInstanceState, cb func(ret *TPEInstanceState) error) error {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for _, data := range c.Objs {
		if !data.Obj.Matches(filter, MatchFilter()) {
			continue
		}
		err := cb(data.Obj)
		if err != nil {
			return err
		}
	}
	return nil
}

func TPEInstanceStateGenericNotifyCb(fn func(key *TPEInstanceKey, old *TPEInstanceState)) func(objstore.ObjKey, objstore.Obj) {
	return func(objkey objstore.ObjKey, obj objstore.Obj) {
		fn(objkey.(*TPEInstanceKey), obj.(*TPEInstanceState))
	}
}

func (c *TPEInstanceStateCache) SetNotifyCb(fn func(ctx context.Context, obj *TPEInstanceState, modRev int64)) {
	c.NotifyCbs = []func(ctx context.Context, obj *TPEInstanceState, modRev int64){fn}
}

func (c *TPEInstanceStateCache) SetUpdatedCb(fn func(ctx context.Context, old *TPEInstanceState, new *TPEInstanceState)) {
	c.UpdatedCbs = []func(ctx context.Context, old *TPEInstanceState, new *TPEInstanceState){fn}
}

func (c *TPEInstanceStateCache) SetDeletedCb(fn func(ctx context.Context, old *TPEInstanceState)) {
	c.DeletedCbs = []func(ctx context.Context, old *TPEInstanceState){fn}
}

func (c *TPEInstanceStateCache) SetUpdatedKeyCb(fn func(ctx context.Context, key *TPEInstanceKey)) {
	c.UpdatedKeyCbs = []func(ctx context.Context, key *TPEInstanceKey){fn}
}

func (c *TPEInstanceStateCache) SetDeletedKeyCb(fn func(ctx context.Context, key *TPEInstanceKey)) {
	c.DeletedKeyCbs = []func(ctx context.Context, key *TPEInstanceKey){fn}
}

func (c *TPEInstanceStateCache) AddUpdatedCb(fn func(ctx context.Context, old *TPEInstanceState, new *TPEInstanceState)) {
	c.UpdatedCbs = append(c.UpdatedCbs, fn)
}

func (c *TPEInstanceStateCache) AddDeletedCb(fn func(ctx context.Context, old *TPEInstanceState)) {
	c.DeletedCbs = append(c.DeletedCbs, fn)
}

func (c *TPEInstanceStateCache) AddNotifyCb(fn func(ctx context.Context, obj *TPEInstanceState, modRev int64)) {
	c.NotifyCbs = append(c.NotifyCbs, fn)
}

func (c *TPEInstanceStateCache) AddUpdatedKeyCb(fn func(ctx context.Context, key *TPEInstanceKey)) {
	c.UpdatedKeyCbs = append(c.UpdatedKeyCbs, fn)
}

func (c *TPEInstanceStateCache) AddDeletedKeyCb(fn func(ctx context.Context, key *TPEInstanceKey)) {
	c.DeletedKeyCbs = append(c.DeletedKeyCbs, fn)
}

func (c *TPEInstanceStateCache) SetFlushAll() {
	c.FlushAll = true
}

func (c *TPEInstanceStateCache) WatchKey(key *TPEInstanceKey, cb func(ctx context.Context)) context.CancelFunc {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	list, ok := c.KeyWatchers[*key]
	if !ok {
		list = make([]*TPEInstanceStateKeyWatcher, 0)
	}
	watcher := TPEInstanceStateKeyWatcher{cb: cb}
	c.KeyWatchers[*key] = append(list, &watcher)
	log.DebugLog(log.DebugLevelApi, "Watching TPEInstanceState", "key", key)
	return func() {
		c.Mux.Lock()
		defer c.Mux.Unlock()
		list, ok := c.KeyWatchers[*key]
		if !ok {
			return
		}
		for ii, _ := range list {
			if list[ii] != &watcher {
				continue
			}
			if len(list) == 1 {
				delete(c.KeyWatchers, *key)
				return
			}
			list[ii] = list[len(list)-1]
			list[len(list)-1] = nil
			c.KeyWatchers[*key] = list[:len(list)-1]
			return
		}
	}
}

func (c *TPEInstanceStateCache) TriggerKeyWatchers(ctx context.Context, key *TPEInstanceKey) {
	watchers := make([]*TPEInstanceStateKeyWatcher, 0)
	c.Mux.Lock()
	if list, ok := c.KeyWatchers[*key]; ok {
		watchers = append(watchers, list...)
	}
	c.Mux.Unlock()
	for ii, _ := range watchers {
		watchers[ii].cb(ctx)
	}
}

// Note that we explicitly ignore the global revision number, because of the way
// the notify framework sends updates (by hashing keys and doing lookups, instead
// of sequentially through a history buffer), updates may be done out-of-order
// or multiple updates compressed into one update, so the state of the cache at
// any point in time may not by in sync with a particular database revision number.

func (c *TPEInstanceStateCache) SyncUpdate(ctx context.Context, key, val []byte, rev, modRev int64) {
	obj := TPEInstanceState{}
	err := json.Unmarshal(val, &obj)
	if err != nil {
		log.WarnLog("Failed to parse TPEInstanceState data", "val", string(val), "err", err)
		return
	}
	c.Update(ctx, &obj, modRev)
	c.Mux.Lock()
	if c.List != nil {
		c.List[obj.GetKeyVal()] = struct{}{}
	}
	c.Mux.Unlock()
}

func (c *TPEInstanceStateCache) SyncDelete(ctx context.Context, key []byte, rev, modRev int64) {
	obj := TPEInstanceState{}
	keystr := objstore.DbKeyPrefixRemove(string(key))
	TPEInstanceKeyStringParse(keystr, obj.GetKey())
	c.Delete(ctx, &obj, modRev)
}

func (c *TPEInstanceStateCache) SyncListStart(ctx context.Context) {
	c.List = make(map[TPEInstanceKey]struct{})
}

func (c *TPEInstanceStateCache) SyncListEnd(ctx context.Context) {
	deleted := make(map[TPEInstanceKey]*TPEInstanceStateCacheData)
	c.Mux.Lock()
	for key, val := range c.Objs {
		if _, found := c.List[key]; !found {
			deleted[key] = val
			delete(c.Objs, key)
		}
	}
	c.List = nil
	c.Mux.Unlock()
	for key, val := range deleted {
		obj := val.Obj
		if obj == nil {
			obj = &TPEInstanceState{}
			obj.SetKey(&key)
		}
		for _, cb := range c.NotifyCbs {
			if cb != nil {
				cb(ctx, obj, val.ModRev)
			}
		}
		for _, cb := range c.DeletedKeyCbs {
			cb(ctx, &key)
		}
		if val.Obj != nil {
			for _, cb := range c.DeletedCbs {
				cb(ctx, val.Obj)
			}
		}
		c.TriggerKeyWatchers(ctx, &key)
	}
}

func (s *TPEInstanceStateCache) InitCacheWithSync(sync DataSync) {
	InitTPEInstanceStateCache(s)
	s.InitSync(sync)
}

func (s *TPEInstanceStateCache) InitSync(sync DataSync) {
	if sync != nil {
		s.Store = NewTPEInstanceStateStore(sync.GetKVStore())
		sync.RegisterCache(s)
	}
}

func (c *TPEInstanceStateCache) UsesOrg(org string) bool {
	c.Mux.Lock()
	defer c.Mux.Unlock()
	for key, _ := range c.Objs {
		if key.AppInstKey.Organization == org {
			return true
		}
	}
	return false
}

func (m *TPEInstanceState) GetObjKey() objstore.ObjKey {
	return m.GetKey()
}

func (m *TPEInstanceState) GetKey() *TPEInstanceKey {
	return &m.Key
}

func (m *TPEInstanceState) GetKeyVal() TPEInstanceKey {
	return m.Key
}

func (m *TPEInstanceState) SetKey(key *TPEInstanceKey) {
	m.Key = *key
}

func CmpSortTPEInstanceState(a TPEInstanceState, b TPEInstanceState) bool {
	return a.Key.GetKeyString() < b.Key.GetKeyString()
}

// Helper method to check that enums have valid values
func (m *TPEInstanceState) ValidateEnums() error {
	if err := m.Key.ValidateEnums(); err != nil {
		return err
	}
	return nil
}

func (s *TPEInstanceState) ClearTagged(tags map[string]struct{}) {
	s.Key.ClearTagged(tags)
}

var TrustPolicyExceptionStateStrings = []string{
	"TRUST_POLICY_EXCEPTION_STATE_UNKNOWN",
	"TRUST_POLICY_EXCEPTION_STATE_APPROVAL_REQUESTED",
	"TRUST_POLICY_EXCEPTION_STATE_ACTIVE",
	"TRUST_POLICY_EXCEPTION_STATE_REJECTED",
}

const (
	TrustPolicyExceptionStateTRUST_POLICY_EXCEPTION_STATE_UNKNOWN            uint64 = 1 << 0
	TrustPolicyExceptionStateTRUST_POLICY_EXCEPTION_STATE_APPROVAL_REQUESTED uint64 = 1 << 1
	TrustPolicyExceptionStateTRUST_POLICY_EXCEPTION_STATE_ACTIVE             uint64 = 1 << 2
	TrustPolicyExceptionStateTRUST_POLICY_EXCEPTION_STATE_REJECTED           uint64 = 1 << 3
)

var TrustPolicyExceptionState_CamelName = map[int32]string{
	// TRUST_POLICY_EXCEPTION_STATE_UNKNOWN -> TrustPolicyExceptionStateUnknown
	0: "TrustPolicyExceptionStateUnknown",
	// TRUST_POLICY_EXCEPTION_STATE_APPROVAL_REQUESTED -> TrustPolicyExceptionStateApprovalRequested
	1: "TrustPolicyExceptionStateApprovalRequested",
	// TRUST_POLICY_EXCEPTION_STATE_ACTIVE -> TrustPolicyExceptionStateActive
	2: "TrustPolicyExceptionStateActive",
	// TRUST_POLICY_EXCEPTION_STATE_REJECTED -> TrustPolicyExceptionStateRejected
	3: "TrustPolicyExceptionStateRejected",
}
var TrustPolicyExceptionState_CamelValue = map[string]int32{
	"TrustPolicyExceptionStateUnknown":           0,
	"TrustPolicyExceptionStateApprovalRequested": 1,
	"TrustPolicyExceptionStateActive":            2,
	"TrustPolicyExceptionStateRejected":          3,
}

func ParseTrustPolicyExceptionState(data interface{}) (TrustPolicyExceptionState, error) {
	if val, ok := data.(TrustPolicyExceptionState); ok {
		return val, nil
	} else if str, ok := data.(string); ok {
		val, ok := TrustPolicyExceptionState_CamelValue[util.CamelCase(str)]
		if !ok {
			// may have omitted common prefix
			val, ok = TrustPolicyExceptionState_CamelValue["TrustPolicyExceptionState"+util.CamelCase(str)]
		}
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = TrustPolicyExceptionState_CamelName[val]
			}
		}
		if !ok {
			return TrustPolicyExceptionState(0), fmt.Errorf("Invalid TrustPolicyExceptionState value %q", str)
		}
		return TrustPolicyExceptionState(val), nil
	} else if ival, ok := data.(int32); ok {
		if _, ok := TrustPolicyExceptionState_CamelName[ival]; ok {
			return TrustPolicyExceptionState(ival), nil
		} else {
			return TrustPolicyExceptionState(0), fmt.Errorf("Invalid TrustPolicyExceptionState value %d", ival)
		}
	}
	return TrustPolicyExceptionState(0), fmt.Errorf("Invalid TrustPolicyExceptionState value %v", data)
}

func (e *TrustPolicyExceptionState) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, err := ParseTrustPolicyExceptionState(str)
	if err != nil {
		return err
	}
	*e = val
	return nil
}

func (e TrustPolicyExceptionState) MarshalYAML() (interface{}, error) {
	str := proto.EnumName(TrustPolicyExceptionState_CamelName, int32(e))
	str = strings.TrimPrefix(str, "TrustPolicyExceptionState")
	return str, nil
}

// custom JSON encoding/decoding
func (e *TrustPolicyExceptionState) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, err := ParseTrustPolicyExceptionState(str)
		if err != nil {
			return &json.UnmarshalTypeError{
				Value: "string " + str,
				Type:  reflect.TypeOf(TrustPolicyExceptionState(0)),
			}
		}
		*e = TrustPolicyExceptionState(val)
		return nil
	}
	var ival int32
	err = json.Unmarshal(b, &ival)
	if err == nil {
		val, err := ParseTrustPolicyExceptionState(ival)
		if err == nil {
			*e = val
			return nil
		}
	}
	return &json.UnmarshalTypeError{
		Value: "value " + string(b),
		Type:  reflect.TypeOf(TrustPolicyExceptionState(0)),
	}
}

func (e TrustPolicyExceptionState) MarshalJSON() ([]byte, error) {
	str := proto.EnumName(TrustPolicyExceptionState_CamelName, int32(e))
	str = strings.TrimPrefix(str, "TrustPolicyExceptionState")
	return json.Marshal(str)
}

var TrustPolicyExceptionStateCommonPrefix = "TrustPolicyExceptionState"

func (m *TrustPolicyException) IsValidArgsForCreateTrustPolicyException() error {
	if m.State != 0 {
		return fmt.Errorf("Invalid field specified: State, this field is only for internal use")
	}
	return nil
}

func (m *TrustPolicyException) IsValidArgsForUpdateTrustPolicyException() error {
	return nil
}

func (m *TrustPolicyException) IsValidArgsForDeleteTrustPolicyException() error {
	if m.State != 0 {
		return fmt.Errorf("Invalid field specified: State, this field is only for internal use")
	}
	return nil
}

func (m *TrustPolicyExceptionKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.AppKey.Size()
	n += 1 + l + sovTrustpolicyexception(uint64(l))
	l = m.ZonePoolKey.Size()
	n += 1 + l + sovTrustpolicyexception(uint64(l))
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTrustpolicyexception(uint64(l))
	}
	return n
}

func (m *TrustPolicyException) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovTrustpolicyexception(uint64(l))
		}
	}
	l = m.Key.Size()
	n += 1 + l + sovTrustpolicyexception(uint64(l))
	if m.State != 0 {
		n += 1 + sovTrustpolicyexception(uint64(m.State))
	}
	if len(m.OutboundSecurityRules) > 0 {
		for _, e := range m.OutboundSecurityRules {
			l = e.Size()
			n += 1 + l + sovTrustpolicyexception(uint64(l))
		}
	}
	return n
}

func (m *TPEInstanceKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TpeKey.Size()
	n += 1 + l + sovTrustpolicyexception(uint64(l))
	l = m.AppInstKey.Size()
	n += 1 + l + sovTrustpolicyexception(uint64(l))
	l = m.ClusterKey.Size()
	n += 1 + l + sovTrustpolicyexception(uint64(l))
	l = m.CloudletKey.Size()
	n += 1 + l + sovTrustpolicyexception(uint64(l))
	return n
}

func (m *TPEInstanceState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Key.Size()
	n += 1 + l + sovTrustpolicyexception(uint64(l))
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTrustpolicyexception(uint64(l))
	}
	if m.RunRequested {
		n += 2
	}
	if m.RunCount != 0 {
		n += 1 + sovTrustpolicyexception(uint64(m.RunCount))
	}
	if m.TpeEnable {
		n += 2
	}
	l = len(m.DisableReason)
	if l > 0 {
		n += 1 + l + sovTrustpolicyexception(uint64(l))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovTrustpolicyexception(uint64(l))
	}
	l = m.StartedAt.Size()
	n += 2 + l + sovTrustpolicyexception(uint64(l))
	return n
}

func sovTrustpolicyexception(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTrustpolicyexception(x uint64) (n int) {
	return sovTrustpolicyexception(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *TrustPolicyExceptionKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTrustpolicyexception
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrustPolicyExceptionKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrustPolicyExceptionKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrustpolicyexception
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTrustpolicyexception
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTrustpolicyexception
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AppKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZonePoolKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrustpolicyexception
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTrustpolicyexception
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTrustpolicyexception
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ZonePoolKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrustpolicyexception
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTrustpolicyexception
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTrustpolicyexception
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTrustpolicyexception(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTrustpolicyexception
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrustPolicyException) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTrustpolicyexception
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrustPolicyException: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrustPolicyException: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrustpolicyexception
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTrustpolicyexception
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTrustpolicyexception
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrustpolicyexception
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTrustpolicyexception
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTrustpolicyexception
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrustpolicyexception
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= TrustPolicyExceptionState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutboundSecurityRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrustpolicyexception
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTrustpolicyexception
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTrustpolicyexception
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutboundSecurityRules = append(m.OutboundSecurityRules, SecurityRule{})
			if err := m.OutboundSecurityRules[len(m.OutboundSecurityRules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTrustpolicyexception(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTrustpolicyexception
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TPEInstanceKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTrustpolicyexception
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TPEInstanceKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TPEInstanceKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TpeKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrustpolicyexception
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTrustpolicyexception
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTrustpolicyexception
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TpeKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppInstKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrustpolicyexception
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTrustpolicyexception
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTrustpolicyexception
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AppInstKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrustpolicyexception
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTrustpolicyexception
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTrustpolicyexception
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ClusterKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudletKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrustpolicyexception
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTrustpolicyexception
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTrustpolicyexception
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CloudletKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTrustpolicyexception(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTrustpolicyexception
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TPEInstanceState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTrustpolicyexception
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TPEInstanceState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TPEInstanceState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrustpolicyexception
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTrustpolicyexception
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTrustpolicyexception
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrustpolicyexception
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTrustpolicyexception
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTrustpolicyexception
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunRequested", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrustpolicyexception
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RunRequested = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunCount", wireType)
			}
			m.RunCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrustpolicyexception
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RunCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TpeEnable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrustpolicyexception
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TpeEnable = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrustpolicyexception
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTrustpolicyexception
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTrustpolicyexception
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisableReason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrustpolicyexception
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTrustpolicyexception
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTrustpolicyexception
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 99:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrustpolicyexception
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTrustpolicyexception
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTrustpolicyexception
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StartedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTrustpolicyexception(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTrustpolicyexception
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTrustpolicyexception(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTrustpolicyexception
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTrustpolicyexception
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTrustpolicyexception
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTrustpolicyexception
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTrustpolicyexception
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTrustpolicyexception
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTrustpolicyexception        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTrustpolicyexception          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTrustpolicyexception = fmt.Errorf("proto: unexpected end of group")
)
