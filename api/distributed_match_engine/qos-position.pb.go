// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: qos-position.proto

package distributed_match_engine

import (
	context "context"
	encoding_binary "encoding/binary"
	"errors"
	fmt "fmt"
	_ "github.com/gogo/googleapis/google/api"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type QosPosition struct {
	// as set by the client, must be unique within QosRequest
	Positionid int64 `protobuf:"varint,1,opt,name=positionid,proto3" json:"positionid,omitempty"`
	//location
	GpsLocation          *Loc     `protobuf:"bytes,2,opt,name=gps_location,json=gpsLocation,proto3" json:"gps_location,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *QosPosition) Reset()         { *m = QosPosition{} }
func (m *QosPosition) String() string { return proto.CompactTextString(m) }
func (*QosPosition) ProtoMessage()    {}
func (*QosPosition) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91876d5f15e63b8, []int{0}
}
func (m *QosPosition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QosPosition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QosPosition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QosPosition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QosPosition.Merge(m, src)
}
func (m *QosPosition) XXX_Size() int {
	return m.Size()
}
func (m *QosPosition) XXX_DiscardUnknown() {
	xxx_messageInfo_QosPosition.DiscardUnknown(m)
}

var xxx_messageInfo_QosPosition proto.InternalMessageInfo

// supported band values
type BandSelection struct {
	// Radio Access Technologies
	Rat2G                []string `protobuf:"bytes,1,rep,name=rat2g,proto3" json:"rat2g,omitempty"`
	Rat3G                []string `protobuf:"bytes,2,rep,name=rat3g,proto3" json:"rat3g,omitempty"`
	Rat4G                []string `protobuf:"bytes,3,rep,name=rat4g,proto3" json:"rat4g,omitempty"`
	Rat5G                []string `protobuf:"bytes,4,rep,name=rat5g,proto3" json:"rat5g,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BandSelection) Reset()         { *m = BandSelection{} }
func (m *BandSelection) String() string { return proto.CompactTextString(m) }
func (*BandSelection) ProtoMessage()    {}
func (*BandSelection) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91876d5f15e63b8, []int{1}
}
func (m *BandSelection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BandSelection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BandSelection.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BandSelection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BandSelection.Merge(m, src)
}
func (m *BandSelection) XXX_Size() int {
	return m.Size()
}
func (m *BandSelection) XXX_DiscardUnknown() {
	xxx_messageInfo_BandSelection.DiscardUnknown(m)
}

var xxx_messageInfo_BandSelection proto.InternalMessageInfo

// QosPositionRequest is used for both GetQosPositionKpi
type QosPositionRequest struct {
	//
	// API version
	//
	// _(hidden)_ Reserved for future use
	Ver uint32 `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	// Session Cookie from RegisterClientRequest
	SessionCookie string `protobuf:"bytes,2,opt,name=session_cookie,json=sessionCookie,proto3" json:"session_cookie,omitempty"`
	// list of positions
	Positions []*QosPosition `protobuf:"bytes,3,rep,name=positions,proto3" json:"positions,omitempty"`
	// _(optional)_ Client's device LTE category number.
	LteCategory int32 `protobuf:"varint,4,opt,name=lte_category,json=lteCategory,proto3" json:"lte_category,omitempty"`
	// _(optional)_ Band list used by the client.
	BandSelection *BandSelection `protobuf:"bytes,5,opt,name=band_selection,json=bandSelection,proto3" json:"band_selection,omitempty"`
	// _(optional)_ Vendor specific data
	Tags                 map[string]string `protobuf:"bytes,100,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *QosPositionRequest) Reset()         { *m = QosPositionRequest{} }
func (m *QosPositionRequest) String() string { return proto.CompactTextString(m) }
func (*QosPositionRequest) ProtoMessage()    {}
func (*QosPositionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91876d5f15e63b8, []int{2}
}
func (m *QosPositionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QosPositionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QosPositionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QosPositionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QosPositionRequest.Merge(m, src)
}
func (m *QosPositionRequest) XXX_Size() int {
	return m.Size()
}
func (m *QosPositionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QosPositionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QosPositionRequest proto.InternalMessageInfo

type QosPositionKpiResult struct {
	// as set by the client, must be unique within one QosPositionRequest
	Positionid int64 `protobuf:"varint,1,opt,name=positionid,proto3" json:"positionid,omitempty"`
	// the location which was requested
	GpsLocation *Loc `protobuf:"bytes,2,opt,name=gps_location,json=gpsLocation,proto3" json:"gps_location,omitempty"`
	// throughput
	DluserthroughputMin  float32  `protobuf:"fixed32,3,opt,name=dluserthroughput_min,json=dluserthroughputMin,proto3" json:"dluserthroughput_min,omitempty"`
	DluserthroughputAvg  float32  `protobuf:"fixed32,4,opt,name=dluserthroughput_avg,json=dluserthroughputAvg,proto3" json:"dluserthroughput_avg,omitempty"`
	DluserthroughputMax  float32  `protobuf:"fixed32,5,opt,name=dluserthroughput_max,json=dluserthroughputMax,proto3" json:"dluserthroughput_max,omitempty"`
	UluserthroughputMin  float32  `protobuf:"fixed32,6,opt,name=uluserthroughput_min,json=uluserthroughputMin,proto3" json:"uluserthroughput_min,omitempty"`
	UluserthroughputAvg  float32  `protobuf:"fixed32,7,opt,name=uluserthroughput_avg,json=uluserthroughputAvg,proto3" json:"uluserthroughput_avg,omitempty"`
	UluserthroughputMax  float32  `protobuf:"fixed32,8,opt,name=uluserthroughput_max,json=uluserthroughputMax,proto3" json:"uluserthroughput_max,omitempty"`
	LatencyMin           float32  `protobuf:"fixed32,9,opt,name=latency_min,json=latencyMin,proto3" json:"latency_min,omitempty"`
	LatencyAvg           float32  `protobuf:"fixed32,10,opt,name=latency_avg,json=latencyAvg,proto3" json:"latency_avg,omitempty"`
	LatencyMax           float32  `protobuf:"fixed32,11,opt,name=latency_max,json=latencyMax,proto3" json:"latency_max,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *QosPositionKpiResult) Reset()         { *m = QosPositionKpiResult{} }
func (m *QosPositionKpiResult) String() string { return proto.CompactTextString(m) }
func (*QosPositionKpiResult) ProtoMessage()    {}
func (*QosPositionKpiResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91876d5f15e63b8, []int{3}
}
func (m *QosPositionKpiResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QosPositionKpiResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QosPositionKpiResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QosPositionKpiResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QosPositionKpiResult.Merge(m, src)
}
func (m *QosPositionKpiResult) XXX_Size() int {
	return m.Size()
}
func (m *QosPositionKpiResult) XXX_DiscardUnknown() {
	xxx_messageInfo_QosPositionKpiResult.DiscardUnknown(m)
}

var xxx_messageInfo_QosPositionKpiResult proto.InternalMessageInfo

type QosPositionKpiReply struct {
	//
	// API version
	//
	// _(hidden)_ Reserved for future use
	Ver uint32 `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	// Status of the reply
	Status ReplyStatus `protobuf:"varint,2,opt,name=status,proto3,enum=distributed_match_engine.ReplyStatus" json:"status,omitempty"`
	// kpi details
	PositionResults []*QosPositionKpiResult `protobuf:"bytes,3,rep,name=position_results,json=positionResults,proto3" json:"position_results,omitempty"`
	// _(optional)_ Vendor specific data
	Tags                 map[string]string `protobuf:"bytes,100,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *QosPositionKpiReply) Reset()         { *m = QosPositionKpiReply{} }
func (m *QosPositionKpiReply) String() string { return proto.CompactTextString(m) }
func (*QosPositionKpiReply) ProtoMessage()    {}
func (*QosPositionKpiReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91876d5f15e63b8, []int{4}
}
func (m *QosPositionKpiReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QosPositionKpiReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QosPositionKpiReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QosPositionKpiReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QosPositionKpiReply.Merge(m, src)
}
func (m *QosPositionKpiReply) XXX_Size() int {
	return m.Size()
}
func (m *QosPositionKpiReply) XXX_DiscardUnknown() {
	xxx_messageInfo_QosPositionKpiReply.DiscardUnknown(m)
}

var xxx_messageInfo_QosPositionKpiReply proto.InternalMessageInfo

func init() {
	proto.RegisterType((*QosPosition)(nil), "distributed_match_engine.QosPosition")
	proto.RegisterType((*BandSelection)(nil), "distributed_match_engine.BandSelection")
	proto.RegisterType((*QosPositionRequest)(nil), "distributed_match_engine.QosPositionRequest")
	proto.RegisterMapType((map[string]string)(nil), "distributed_match_engine.QosPositionRequest.TagsEntry")
	proto.RegisterType((*QosPositionKpiResult)(nil), "distributed_match_engine.QosPositionKpiResult")
	proto.RegisterType((*QosPositionKpiReply)(nil), "distributed_match_engine.QosPositionKpiReply")
	proto.RegisterMapType((map[string]string)(nil), "distributed_match_engine.QosPositionKpiReply.TagsEntry")
}

func init() { proto.RegisterFile("qos-position.proto", fileDescriptor_f91876d5f15e63b8) }

var fileDescriptor_f91876d5f15e63b8 = []byte{
	// 702 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x55, 0xc1, 0x6e, 0x13, 0x3b,
	0x14, 0x7d, 0x4e, 0xd2, 0xb4, 0x71, 0x9a, 0x34, 0xcf, 0xed, 0x93, 0x46, 0xd1, 0x7b, 0x79, 0x61,
	0xa4, 0x8a, 0x08, 0xd1, 0x84, 0xa6, 0x2d, 0x45, 0x95, 0x90, 0xa0, 0x15, 0x42, 0x6a, 0x0b, 0x02,
	0x97, 0x0d, 0xab, 0x91, 0x33, 0x63, 0xb9, 0x56, 0x9d, 0xf1, 0x74, 0xec, 0x89, 0x92, 0x2d, 0x7b,
	0x56, 0xb0, 0xe1, 0x0b, 0xf8, 0x14, 0xba, 0x44, 0xe2, 0x07, 0xa0, 0xe2, 0x43, 0xd0, 0x38, 0x33,
	0x21, 0xa9, 0x26, 0xa8, 0x95, 0x60, 0xe7, 0x39, 0xf5, 0xb9, 0xe7, 0xdc, 0xe3, 0x7b, 0x1b, 0x88,
	0xce, 0xa5, 0xda, 0x08, 0xa4, 0xe2, 0x9a, 0x4b, 0xbf, 0x1d, 0x84, 0x52, 0x4b, 0x64, 0x79, 0x5c,
	0xe9, 0x90, 0xf7, 0x22, 0x4d, 0x3d, 0xa7, 0x4f, 0xb4, 0x7b, 0xea, 0x50, 0x9f, 0x71, 0x9f, 0xd6,
	0xff, 0x65, 0x52, 0x32, 0x41, 0x3b, 0x24, 0xe0, 0x1d, 0xe2, 0xfb, 0x52, 0x93, 0x98, 0xa6, 0xc6,
	0xbc, 0xfa, 0x0a, 0x09, 0x02, 0x57, 0xf6, 0xfb, 0x69, 0xa1, 0x7a, 0x49, 0x48, 0x77, 0x7c, 0xb4,
	0x25, 0x2c, 0xbf, 0x94, 0xea, 0x45, 0x22, 0x84, 0x1a, 0x10, 0xa6, 0xa2, 0xdc, 0xb3, 0x40, 0x13,
	0xb4, 0xf2, 0x78, 0x0a, 0x41, 0x8f, 0xe0, 0x32, 0x0b, 0x94, 0x23, 0xa4, 0x6b, 0x14, 0xac, 0x5c,
	0x13, 0xb4, 0xca, 0xdd, 0xff, 0xda, 0xf3, 0x9c, 0xb5, 0x8f, 0xa5, 0x8b, 0xcb, 0x2c, 0x50, 0xc7,
	0x09, 0xc3, 0x66, 0xb0, 0xb2, 0x4f, 0x7c, 0xef, 0x84, 0x0a, 0xea, 0x1a, 0xc9, 0x35, 0xb8, 0x10,
	0x12, 0xdd, 0x65, 0x16, 0x68, 0xe6, 0x5b, 0x25, 0x3c, 0xfe, 0x48, 0xd0, 0x2d, 0x66, 0xe5, 0x26,
	0xe8, 0x56, 0x8a, 0x6e, 0x33, 0x2b, 0x3f, 0x41, 0xb7, 0x53, 0x74, 0x87, 0x59, 0x85, 0x09, 0xba,
	0xc3, 0xec, 0x0f, 0x79, 0x88, 0xa6, 0x5a, 0xc3, 0xf4, 0x3c, 0xa2, 0x4a, 0xa3, 0x1a, 0xcc, 0x0f,
	0x68, 0x68, 0x5a, 0xab, 0xe0, 0xf8, 0x88, 0xd6, 0x61, 0x55, 0x51, 0xa5, 0xb8, 0xf4, 0x1d, 0x57,
	0xca, 0x33, 0x4e, 0x4d, 0x57, 0x25, 0x5c, 0x49, 0xd0, 0x03, 0x03, 0xa2, 0x03, 0x58, 0x4a, 0x83,
	0x50, 0x46, 0xbf, 0xdc, 0x5d, 0x9f, 0xdf, 0xf7, 0xb4, 0xf2, 0x4f, 0x1e, 0xba, 0x05, 0x97, 0x85,
	0xa6, 0x8e, 0x4b, 0x34, 0x65, 0x32, 0x1c, 0x59, 0x85, 0x26, 0x68, 0x2d, 0xe0, 0xb2, 0xd0, 0xf4,
	0x20, 0x81, 0xd0, 0x73, 0x58, 0xed, 0x11, 0xdf, 0x73, 0x54, 0x9a, 0x90, 0xb5, 0x60, 0x42, 0xbe,
	0x3d, 0x5f, 0x6c, 0x26, 0x50, 0x5c, 0xe9, 0xcd, 0xe4, 0x7b, 0x08, 0x0b, 0x9a, 0x30, 0x65, 0x79,
	0xc6, 0xf2, 0xfd, 0xeb, 0x59, 0x1e, 0x87, 0xd5, 0x7e, 0x45, 0x98, 0x7a, 0xe2, 0xeb, 0x70, 0x84,
	0x4d, 0x8d, 0xfa, 0x2e, 0x2c, 0x4d, 0xa0, 0x38, 0xc9, 0x33, 0x3a, 0x32, 0x49, 0x96, 0x70, 0x7c,
	0x8c, 0x1f, 0x62, 0x40, 0x44, 0x94, 0x06, 0x38, 0xfe, 0xd8, 0xcb, 0x3d, 0x00, 0x87, 0x85, 0xa5,
	0x62, 0x6d, 0x11, 0x2f, 0xba, 0x54, 0x08, 0x87, 0x7b, 0xf6, 0xdb, 0x02, 0x5c, 0x9b, 0x92, 0x3b,
	0x0a, 0x38, 0xa6, 0x2a, 0x12, 0xfa, 0xcf, 0xcf, 0x1f, 0xda, 0x84, 0x6b, 0x9e, 0x88, 0x14, 0x0d,
	0xf5, 0x69, 0x28, 0x23, 0x76, 0x1a, 0x44, 0xda, 0xe9, 0x73, 0xdf, 0xca, 0x37, 0x41, 0x2b, 0x87,
	0x57, 0xaf, 0xfe, 0xed, 0x19, 0xcf, 0xa6, 0x90, 0x01, 0x33, 0x8f, 0x97, 0x41, 0x79, 0x3c, 0x60,
	0xd9, 0x2a, 0x64, 0x68, 0x9e, 0x32, 0x4b, 0x85, 0x0c, 0x63, 0x4a, 0x94, 0x65, 0xac, 0x38, 0xa6,
	0x44, 0xd9, 0xc6, 0xa2, 0x2c, 0x63, 0x8b, 0xd9, 0x94, 0xc4, 0x58, 0x94, 0x65, 0x6c, 0x69, 0x8e,
	0x0a, 0x19, 0xa2, 0xff, 0x61, 0x59, 0x10, 0x4d, 0x7d, 0x77, 0x64, 0xfc, 0x94, 0xcc, 0x4d, 0x98,
	0x40, 0xb1, 0x8d, 0xa9, 0x0b, 0xb1, 0x3a, 0x9c, 0xb9, 0x10, 0x8b, 0x4e, 0x57, 0x20, 0x43, 0xab,
	0x3c, 0x5b, 0x81, 0x0c, 0xed, 0x4f, 0x39, 0xb8, 0x7a, 0x75, 0x1e, 0x02, 0x31, 0xca, 0x58, 0xd6,
	0x87, 0xb0, 0xa8, 0x34, 0xd1, 0x91, 0x32, 0x4f, 0x5f, 0xfd, 0xd5, 0x0a, 0x9a, 0x12, 0x27, 0xe6,
	0x32, 0x4e, 0x48, 0xe8, 0x35, 0xac, 0xa5, 0xd3, 0xe4, 0x84, 0x66, 0xe4, 0xd2, 0x5d, 0x6e, 0x5f,
	0x6b, 0x31, 0x26, 0x93, 0x8a, 0x57, 0x82, 0xc9, 0xae, 0x98, 0x32, 0xe8, 0x68, 0x66, 0xcf, 0x76,
	0xaf, 0x5f, 0x2e, 0x10, 0xa3, 0xdf, 0xb6, 0x68, 0xdd, 0x8f, 0x00, 0x56, 0x67, 0x05, 0xd0, 0x7b,
	0x00, 0xff, 0x7e, 0x4a, 0xf5, 0x15, 0xf4, 0xee, 0x4d, 0xfe, 0x11, 0xd4, 0x37, 0x6e, 0xd4, 0x8e,
	0xdd, 0x7c, 0xf3, 0xe5, 0xfb, 0xbb, 0x5c, 0xdd, 0xfe, 0xa7, 0x33, 0xd8, 0xec, 0x30, 0xaa, 0xcf,
	0xa5, 0x4a, 0xe3, 0x3a, 0x0b, 0xf8, 0x1e, 0xb8, 0x73, 0x0f, 0xec, 0xd7, 0x2e, 0xbe, 0x35, 0xfe,
	0xba, 0xb8, 0x6c, 0x80, 0xcf, 0x97, 0x0d, 0xf0, 0xf5, 0xb2, 0x01, 0x7a, 0x45, 0xf3, 0x93, 0xb4,
	0xf5, 0x23, 0x00, 0x00, 0xff, 0xff, 0x73, 0xcd, 0x11, 0x1d, 0xfc, 0x06, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// QosPositionKpiClient is the client API for QosPositionKpi service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type QosPositionKpiClient interface {
	GetQosPositionKpi(ctx context.Context, in *QosPositionRequest, opts ...grpc.CallOption) (QosPositionKpi_GetQosPositionKpiClient, error)
}

type qosPositionKpiClient struct {
	cc *grpc.ClientConn
}

func NewQosPositionKpiClient(cc *grpc.ClientConn) QosPositionKpiClient {
	return &qosPositionKpiClient{cc}
}

func (c *qosPositionKpiClient) GetQosPositionKpi(ctx context.Context, in *QosPositionRequest, opts ...grpc.CallOption) (QosPositionKpi_GetQosPositionKpiClient, error) {
	stream, err := c.cc.NewStream(ctx, &_QosPositionKpi_serviceDesc.Streams[0], "/distributed_match_engine.QosPositionKpi/GetQosPositionKpi", opts...)
	if err != nil {
		return nil, err
	}
	x := &qosPositionKpiGetQosPositionKpiClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type QosPositionKpi_GetQosPositionKpiClient interface {
	Recv() (*QosPositionKpiReply, error)
	grpc.ClientStream
}

type qosPositionKpiGetQosPositionKpiClient struct {
	grpc.ClientStream
}

func (x *qosPositionKpiGetQosPositionKpiClient) Recv() (*QosPositionKpiReply, error) {
	m := new(QosPositionKpiReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// QosPositionKpiServer is the server API for QosPositionKpi service.
type QosPositionKpiServer interface {
	GetQosPositionKpi(*QosPositionRequest, QosPositionKpi_GetQosPositionKpiServer) error
}

// UnimplementedQosPositionKpiServer can be embedded to have forward compatible implementations.
type UnimplementedQosPositionKpiServer struct {
}

func (*UnimplementedQosPositionKpiServer) GetQosPositionKpi(req *QosPositionRequest, srv QosPositionKpi_GetQosPositionKpiServer) error {
	return status.Errorf(codes.Unimplemented, "method GetQosPositionKpi not implemented")
}

func RegisterQosPositionKpiServer(s *grpc.Server, srv QosPositionKpiServer) {
	s.RegisterService(&_QosPositionKpi_serviceDesc, srv)
}

func _QosPositionKpi_GetQosPositionKpi_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(QosPositionRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QosPositionKpiServer).GetQosPositionKpi(m, &qosPositionKpiGetQosPositionKpiServer{stream})
}

type QosPositionKpi_GetQosPositionKpiServer interface {
	Send(*QosPositionKpiReply) error
	grpc.ServerStream
}

type qosPositionKpiGetQosPositionKpiServer struct {
	grpc.ServerStream
}

func (x *qosPositionKpiGetQosPositionKpiServer) Send(m *QosPositionKpiReply) error {
	return x.ServerStream.SendMsg(m)
}

var _QosPositionKpi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "distributed_match_engine.QosPositionKpi",
	HandlerType: (*QosPositionKpiServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetQosPositionKpi",
			Handler:       _QosPositionKpi_GetQosPositionKpi_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "qos-position.proto",
}

func (m *QosPosition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosPosition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QosPosition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GpsLocation != nil {
		{
			size, err := m.GpsLocation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQosPosition(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Positionid != 0 {
		i = encodeVarintQosPosition(dAtA, i, uint64(m.Positionid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BandSelection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BandSelection) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BandSelection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Rat5G) > 0 {
		for iNdEx := len(m.Rat5G) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Rat5G[iNdEx])
			copy(dAtA[i:], m.Rat5G[iNdEx])
			i = encodeVarintQosPosition(dAtA, i, uint64(len(m.Rat5G[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Rat4G) > 0 {
		for iNdEx := len(m.Rat4G) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Rat4G[iNdEx])
			copy(dAtA[i:], m.Rat4G[iNdEx])
			i = encodeVarintQosPosition(dAtA, i, uint64(len(m.Rat4G[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Rat3G) > 0 {
		for iNdEx := len(m.Rat3G) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Rat3G[iNdEx])
			copy(dAtA[i:], m.Rat3G[iNdEx])
			i = encodeVarintQosPosition(dAtA, i, uint64(len(m.Rat3G[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Rat2G) > 0 {
		for iNdEx := len(m.Rat2G) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Rat2G[iNdEx])
			copy(dAtA[i:], m.Rat2G[iNdEx])
			i = encodeVarintQosPosition(dAtA, i, uint64(len(m.Rat2G[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QosPositionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosPositionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QosPositionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Tags) > 0 {
		for k := range m.Tags {
			v := m.Tags[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintQosPosition(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintQosPosition(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintQosPosition(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa2
		}
	}
	if m.BandSelection != nil {
		{
			size, err := m.BandSelection.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQosPosition(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.LteCategory != 0 {
		i = encodeVarintQosPosition(dAtA, i, uint64(m.LteCategory))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Positions) > 0 {
		for iNdEx := len(m.Positions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Positions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQosPosition(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.SessionCookie) > 0 {
		i -= len(m.SessionCookie)
		copy(dAtA[i:], m.SessionCookie)
		i = encodeVarintQosPosition(dAtA, i, uint64(len(m.SessionCookie)))
		i--
		dAtA[i] = 0x12
	}
	if m.Ver != 0 {
		i = encodeVarintQosPosition(dAtA, i, uint64(m.Ver))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QosPositionKpiResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosPositionKpiResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QosPositionKpiResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LatencyMax != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.LatencyMax))))
		i--
		dAtA[i] = 0x5d
	}
	if m.LatencyAvg != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.LatencyAvg))))
		i--
		dAtA[i] = 0x55
	}
	if m.LatencyMin != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.LatencyMin))))
		i--
		dAtA[i] = 0x4d
	}
	if m.UluserthroughputMax != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.UluserthroughputMax))))
		i--
		dAtA[i] = 0x45
	}
	if m.UluserthroughputAvg != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.UluserthroughputAvg))))
		i--
		dAtA[i] = 0x3d
	}
	if m.UluserthroughputMin != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.UluserthroughputMin))))
		i--
		dAtA[i] = 0x35
	}
	if m.DluserthroughputMax != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.DluserthroughputMax))))
		i--
		dAtA[i] = 0x2d
	}
	if m.DluserthroughputAvg != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.DluserthroughputAvg))))
		i--
		dAtA[i] = 0x25
	}
	if m.DluserthroughputMin != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.DluserthroughputMin))))
		i--
		dAtA[i] = 0x1d
	}
	if m.GpsLocation != nil {
		{
			size, err := m.GpsLocation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQosPosition(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Positionid != 0 {
		i = encodeVarintQosPosition(dAtA, i, uint64(m.Positionid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QosPositionKpiReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosPositionKpiReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QosPositionKpiReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Tags) > 0 {
		for k := range m.Tags {
			v := m.Tags[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintQosPosition(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintQosPosition(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintQosPosition(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.PositionResults) > 0 {
		for iNdEx := len(m.PositionResults) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PositionResults[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQosPosition(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Status != 0 {
		i = encodeVarintQosPosition(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if m.Ver != 0 {
		i = encodeVarintQosPosition(dAtA, i, uint64(m.Ver))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintQosPosition(dAtA []byte, offset int, v uint64) int {
	offset -= sovQosPosition(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *QosPosition) CopyInFields(src *QosPosition) int {
	changed := 0
	if m.Positionid != src.Positionid {
		m.Positionid = src.Positionid
		changed++
	}
	if src.GpsLocation != nil {
		if m.GpsLocation == nil {
			m.GpsLocation = &Loc{}
		}
		if m.GpsLocation.Latitude != src.GpsLocation.Latitude {
			m.GpsLocation.Latitude = src.GpsLocation.Latitude
			changed++
		}
		if m.GpsLocation.Longitude != src.GpsLocation.Longitude {
			m.GpsLocation.Longitude = src.GpsLocation.Longitude
			changed++
		}
		if m.GpsLocation.HorizontalAccuracy != src.GpsLocation.HorizontalAccuracy {
			m.GpsLocation.HorizontalAccuracy = src.GpsLocation.HorizontalAccuracy
			changed++
		}
		if m.GpsLocation.VerticalAccuracy != src.GpsLocation.VerticalAccuracy {
			m.GpsLocation.VerticalAccuracy = src.GpsLocation.VerticalAccuracy
			changed++
		}
		if m.GpsLocation.Altitude != src.GpsLocation.Altitude {
			m.GpsLocation.Altitude = src.GpsLocation.Altitude
			changed++
		}
		if m.GpsLocation.Course != src.GpsLocation.Course {
			m.GpsLocation.Course = src.GpsLocation.Course
			changed++
		}
		if m.GpsLocation.Speed != src.GpsLocation.Speed {
			m.GpsLocation.Speed = src.GpsLocation.Speed
			changed++
		}
		if src.GpsLocation.Timestamp != nil {
			if m.GpsLocation.Timestamp == nil {
				m.GpsLocation.Timestamp = &Timestamp{}
			}
			if m.GpsLocation.Timestamp.Seconds != src.GpsLocation.Timestamp.Seconds {
				m.GpsLocation.Timestamp.Seconds = src.GpsLocation.Timestamp.Seconds
				changed++
			}
			if m.GpsLocation.Timestamp.Nanos != src.GpsLocation.Timestamp.Nanos {
				m.GpsLocation.Timestamp.Nanos = src.GpsLocation.Timestamp.Nanos
				changed++
			}
		} else if m.GpsLocation.Timestamp != nil {
			m.GpsLocation.Timestamp = nil
			changed++
		}
	} else if m.GpsLocation != nil {
		m.GpsLocation = nil
		changed++
	}
	return changed
}

func (m *QosPosition) DeepCopyIn(src *QosPosition) {
	m.Positionid = src.Positionid
	if src.GpsLocation != nil {
		var tmp_GpsLocation Loc
		tmp_GpsLocation.DeepCopyIn(src.GpsLocation)
		m.GpsLocation = &tmp_GpsLocation
	} else {
		m.GpsLocation = nil
	}
}

// Helper method to check that enums have valid values
func (m *QosPosition) ValidateEnums() error {
	if m.GpsLocation != nil {
		if err := m.GpsLocation.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (s *QosPosition) ClearTagged(tags map[string]struct{}) {
	if s.GpsLocation != nil {
		s.GpsLocation.ClearTagged(tags)
	}
}

func (m *BandSelection) CopyInFields(src *BandSelection) int {
	changed := 0
	if src.Rat2G != nil {
		m.Rat2G = src.Rat2G
		changed++
	} else if m.Rat2G != nil {
		m.Rat2G = nil
		changed++
	}
	if src.Rat3G != nil {
		m.Rat3G = src.Rat3G
		changed++
	} else if m.Rat3G != nil {
		m.Rat3G = nil
		changed++
	}
	if src.Rat4G != nil {
		m.Rat4G = src.Rat4G
		changed++
	} else if m.Rat4G != nil {
		m.Rat4G = nil
		changed++
	}
	if src.Rat5G != nil {
		m.Rat5G = src.Rat5G
		changed++
	} else if m.Rat5G != nil {
		m.Rat5G = nil
		changed++
	}
	return changed
}

func (m *BandSelection) DeepCopyIn(src *BandSelection) {
	if src.Rat2G != nil {
		m.Rat2G = make([]string, len(src.Rat2G), len(src.Rat2G))
		for ii, s := range src.Rat2G {
			m.Rat2G[ii] = s
		}
	} else {
		m.Rat2G = nil
	}
	if src.Rat3G != nil {
		m.Rat3G = make([]string, len(src.Rat3G), len(src.Rat3G))
		for ii, s := range src.Rat3G {
			m.Rat3G[ii] = s
		}
	} else {
		m.Rat3G = nil
	}
	if src.Rat4G != nil {
		m.Rat4G = make([]string, len(src.Rat4G), len(src.Rat4G))
		for ii, s := range src.Rat4G {
			m.Rat4G[ii] = s
		}
	} else {
		m.Rat4G = nil
	}
	if src.Rat5G != nil {
		m.Rat5G = make([]string, len(src.Rat5G), len(src.Rat5G))
		for ii, s := range src.Rat5G {
			m.Rat5G[ii] = s
		}
	} else {
		m.Rat5G = nil
	}
}

// Helper method to check that enums have valid values
func (m *BandSelection) ValidateEnums() error {
	return nil
}

func (s *BandSelection) ClearTagged(tags map[string]struct{}) {
}

func (m *QosPositionRequest) CopyInFields(src *QosPositionRequest) int {
	changed := 0
	if m.Ver != src.Ver {
		m.Ver = src.Ver
		changed++
	}
	if m.SessionCookie != src.SessionCookie {
		m.SessionCookie = src.SessionCookie
		changed++
	}
	if src.Positions != nil {
		m.Positions = src.Positions
		changed++
	} else if m.Positions != nil {
		m.Positions = nil
		changed++
	}
	if m.LteCategory != src.LteCategory {
		m.LteCategory = src.LteCategory
		changed++
	}
	if src.BandSelection != nil {
		if m.BandSelection == nil {
			m.BandSelection = &BandSelection{}
		}
		if src.BandSelection.Rat2G != nil {
			m.BandSelection.Rat2G = src.BandSelection.Rat2G
			changed++
		} else if m.BandSelection.Rat2G != nil {
			m.BandSelection.Rat2G = nil
			changed++
		}
		if src.BandSelection.Rat3G != nil {
			m.BandSelection.Rat3G = src.BandSelection.Rat3G
			changed++
		} else if m.BandSelection.Rat3G != nil {
			m.BandSelection.Rat3G = nil
			changed++
		}
		if src.BandSelection.Rat4G != nil {
			m.BandSelection.Rat4G = src.BandSelection.Rat4G
			changed++
		} else if m.BandSelection.Rat4G != nil {
			m.BandSelection.Rat4G = nil
			changed++
		}
		if src.BandSelection.Rat5G != nil {
			m.BandSelection.Rat5G = src.BandSelection.Rat5G
			changed++
		} else if m.BandSelection.Rat5G != nil {
			m.BandSelection.Rat5G = nil
			changed++
		}
	} else if m.BandSelection != nil {
		m.BandSelection = nil
		changed++
	}
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k0, _ := range src.Tags {
			m.Tags[k0] = src.Tags[k0]
			changed++
		}
	} else if m.Tags != nil {
		m.Tags = nil
		changed++
	}
	return changed
}

func (m *QosPositionRequest) DeepCopyIn(src *QosPositionRequest) {
	m.Ver = src.Ver
	m.SessionCookie = src.SessionCookie
	if src.Positions != nil {
		m.Positions = make([]*QosPosition, len(src.Positions), len(src.Positions))
		for ii, s := range src.Positions {
			var tmp_s QosPosition
			tmp_s.DeepCopyIn(s)
			m.Positions[ii] = &tmp_s
		}
	} else {
		m.Positions = nil
	}
	m.LteCategory = src.LteCategory
	if src.BandSelection != nil {
		var tmp_BandSelection BandSelection
		tmp_BandSelection.DeepCopyIn(src.BandSelection)
		m.BandSelection = &tmp_BandSelection
	} else {
		m.BandSelection = nil
	}
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k, v := range src.Tags {
			m.Tags[k] = v
		}
	} else {
		m.Tags = nil
	}
}

// Helper method to check that enums have valid values
func (m *QosPositionRequest) ValidateEnums() error {
	for _, e := range m.Positions {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	if m.BandSelection != nil {
		if err := m.BandSelection.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (s *QosPositionRequest) ClearTagged(tags map[string]struct{}) {
	if s.Positions != nil {
		for ii := 0; ii < len(s.Positions); ii++ {
			s.Positions[ii].ClearTagged(tags)
		}
	}
	if s.BandSelection != nil {
		s.BandSelection.ClearTagged(tags)
	}
}

func (m *QosPositionKpiResult) CopyInFields(src *QosPositionKpiResult) int {
	changed := 0
	if m.Positionid != src.Positionid {
		m.Positionid = src.Positionid
		changed++
	}
	if src.GpsLocation != nil {
		if m.GpsLocation == nil {
			m.GpsLocation = &Loc{}
		}
		if m.GpsLocation.Latitude != src.GpsLocation.Latitude {
			m.GpsLocation.Latitude = src.GpsLocation.Latitude
			changed++
		}
		if m.GpsLocation.Longitude != src.GpsLocation.Longitude {
			m.GpsLocation.Longitude = src.GpsLocation.Longitude
			changed++
		}
		if m.GpsLocation.HorizontalAccuracy != src.GpsLocation.HorizontalAccuracy {
			m.GpsLocation.HorizontalAccuracy = src.GpsLocation.HorizontalAccuracy
			changed++
		}
		if m.GpsLocation.VerticalAccuracy != src.GpsLocation.VerticalAccuracy {
			m.GpsLocation.VerticalAccuracy = src.GpsLocation.VerticalAccuracy
			changed++
		}
		if m.GpsLocation.Altitude != src.GpsLocation.Altitude {
			m.GpsLocation.Altitude = src.GpsLocation.Altitude
			changed++
		}
		if m.GpsLocation.Course != src.GpsLocation.Course {
			m.GpsLocation.Course = src.GpsLocation.Course
			changed++
		}
		if m.GpsLocation.Speed != src.GpsLocation.Speed {
			m.GpsLocation.Speed = src.GpsLocation.Speed
			changed++
		}
		if src.GpsLocation.Timestamp != nil {
			if m.GpsLocation.Timestamp == nil {
				m.GpsLocation.Timestamp = &Timestamp{}
			}
			if m.GpsLocation.Timestamp.Seconds != src.GpsLocation.Timestamp.Seconds {
				m.GpsLocation.Timestamp.Seconds = src.GpsLocation.Timestamp.Seconds
				changed++
			}
			if m.GpsLocation.Timestamp.Nanos != src.GpsLocation.Timestamp.Nanos {
				m.GpsLocation.Timestamp.Nanos = src.GpsLocation.Timestamp.Nanos
				changed++
			}
		} else if m.GpsLocation.Timestamp != nil {
			m.GpsLocation.Timestamp = nil
			changed++
		}
	} else if m.GpsLocation != nil {
		m.GpsLocation = nil
		changed++
	}
	if m.DluserthroughputMin != src.DluserthroughputMin {
		m.DluserthroughputMin = src.DluserthroughputMin
		changed++
	}
	if m.DluserthroughputAvg != src.DluserthroughputAvg {
		m.DluserthroughputAvg = src.DluserthroughputAvg
		changed++
	}
	if m.DluserthroughputMax != src.DluserthroughputMax {
		m.DluserthroughputMax = src.DluserthroughputMax
		changed++
	}
	if m.UluserthroughputMin != src.UluserthroughputMin {
		m.UluserthroughputMin = src.UluserthroughputMin
		changed++
	}
	if m.UluserthroughputAvg != src.UluserthroughputAvg {
		m.UluserthroughputAvg = src.UluserthroughputAvg
		changed++
	}
	if m.UluserthroughputMax != src.UluserthroughputMax {
		m.UluserthroughputMax = src.UluserthroughputMax
		changed++
	}
	if m.LatencyMin != src.LatencyMin {
		m.LatencyMin = src.LatencyMin
		changed++
	}
	if m.LatencyAvg != src.LatencyAvg {
		m.LatencyAvg = src.LatencyAvg
		changed++
	}
	if m.LatencyMax != src.LatencyMax {
		m.LatencyMax = src.LatencyMax
		changed++
	}
	return changed
}

func (m *QosPositionKpiResult) DeepCopyIn(src *QosPositionKpiResult) {
	m.Positionid = src.Positionid
	if src.GpsLocation != nil {
		var tmp_GpsLocation Loc
		tmp_GpsLocation.DeepCopyIn(src.GpsLocation)
		m.GpsLocation = &tmp_GpsLocation
	} else {
		m.GpsLocation = nil
	}
	m.DluserthroughputMin = src.DluserthroughputMin
	m.DluserthroughputAvg = src.DluserthroughputAvg
	m.DluserthroughputMax = src.DluserthroughputMax
	m.UluserthroughputMin = src.UluserthroughputMin
	m.UluserthroughputAvg = src.UluserthroughputAvg
	m.UluserthroughputMax = src.UluserthroughputMax
	m.LatencyMin = src.LatencyMin
	m.LatencyAvg = src.LatencyAvg
	m.LatencyMax = src.LatencyMax
}

// Helper method to check that enums have valid values
func (m *QosPositionKpiResult) ValidateEnums() error {
	if m.GpsLocation != nil {
		if err := m.GpsLocation.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (s *QosPositionKpiResult) ClearTagged(tags map[string]struct{}) {
	if s.GpsLocation != nil {
		s.GpsLocation.ClearTagged(tags)
	}
}

func (m *QosPositionKpiReply) CopyInFields(src *QosPositionKpiReply) int {
	changed := 0
	if m.Ver != src.Ver {
		m.Ver = src.Ver
		changed++
	}
	if m.Status != src.Status {
		m.Status = src.Status
		changed++
	}
	if src.PositionResults != nil {
		m.PositionResults = src.PositionResults
		changed++
	} else if m.PositionResults != nil {
		m.PositionResults = nil
		changed++
	}
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k0, _ := range src.Tags {
			m.Tags[k0] = src.Tags[k0]
			changed++
		}
	} else if m.Tags != nil {
		m.Tags = nil
		changed++
	}
	return changed
}

func (m *QosPositionKpiReply) DeepCopyIn(src *QosPositionKpiReply) {
	m.Ver = src.Ver
	m.Status = src.Status
	if src.PositionResults != nil {
		m.PositionResults = make([]*QosPositionKpiResult, len(src.PositionResults), len(src.PositionResults))
		for ii, s := range src.PositionResults {
			var tmp_s QosPositionKpiResult
			tmp_s.DeepCopyIn(s)
			m.PositionResults[ii] = &tmp_s
		}
	} else {
		m.PositionResults = nil
	}
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k, v := range src.Tags {
			m.Tags[k] = v
		}
	} else {
		m.Tags = nil
	}
}

// Helper method to check that enums have valid values
func (m *QosPositionKpiReply) ValidateEnums() error {
	if _, ok := ReplyStatus_name[int32(m.Status)]; !ok {
		return errors.New("invalid Status")
	}
	for _, e := range m.PositionResults {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (s *QosPositionKpiReply) ClearTagged(tags map[string]struct{}) {
	if s.PositionResults != nil {
		for ii := 0; ii < len(s.PositionResults); ii++ {
			s.PositionResults[ii].ClearTagged(tags)
		}
	}
}

func (m *QosPositionRequest) IsValidArgsForGetQosPositionKpi() error {
	return nil
}

func (m *QosPosition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Positionid != 0 {
		n += 1 + sovQosPosition(uint64(m.Positionid))
	}
	if m.GpsLocation != nil {
		l = m.GpsLocation.Size()
		n += 1 + l + sovQosPosition(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BandSelection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Rat2G) > 0 {
		for _, s := range m.Rat2G {
			l = len(s)
			n += 1 + l + sovQosPosition(uint64(l))
		}
	}
	if len(m.Rat3G) > 0 {
		for _, s := range m.Rat3G {
			l = len(s)
			n += 1 + l + sovQosPosition(uint64(l))
		}
	}
	if len(m.Rat4G) > 0 {
		for _, s := range m.Rat4G {
			l = len(s)
			n += 1 + l + sovQosPosition(uint64(l))
		}
	}
	if len(m.Rat5G) > 0 {
		for _, s := range m.Rat5G {
			l = len(s)
			n += 1 + l + sovQosPosition(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QosPositionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovQosPosition(uint64(m.Ver))
	}
	l = len(m.SessionCookie)
	if l > 0 {
		n += 1 + l + sovQosPosition(uint64(l))
	}
	if len(m.Positions) > 0 {
		for _, e := range m.Positions {
			l = e.Size()
			n += 1 + l + sovQosPosition(uint64(l))
		}
	}
	if m.LteCategory != 0 {
		n += 1 + sovQosPosition(uint64(m.LteCategory))
	}
	if m.BandSelection != nil {
		l = m.BandSelection.Size()
		n += 1 + l + sovQosPosition(uint64(l))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovQosPosition(uint64(len(k))) + 1 + len(v) + sovQosPosition(uint64(len(v)))
			n += mapEntrySize + 2 + sovQosPosition(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QosPositionKpiResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Positionid != 0 {
		n += 1 + sovQosPosition(uint64(m.Positionid))
	}
	if m.GpsLocation != nil {
		l = m.GpsLocation.Size()
		n += 1 + l + sovQosPosition(uint64(l))
	}
	if m.DluserthroughputMin != 0 {
		n += 5
	}
	if m.DluserthroughputAvg != 0 {
		n += 5
	}
	if m.DluserthroughputMax != 0 {
		n += 5
	}
	if m.UluserthroughputMin != 0 {
		n += 5
	}
	if m.UluserthroughputAvg != 0 {
		n += 5
	}
	if m.UluserthroughputMax != 0 {
		n += 5
	}
	if m.LatencyMin != 0 {
		n += 5
	}
	if m.LatencyAvg != 0 {
		n += 5
	}
	if m.LatencyMax != 0 {
		n += 5
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QosPositionKpiReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovQosPosition(uint64(m.Ver))
	}
	if m.Status != 0 {
		n += 1 + sovQosPosition(uint64(m.Status))
	}
	if len(m.PositionResults) > 0 {
		for _, e := range m.PositionResults {
			l = e.Size()
			n += 1 + l + sovQosPosition(uint64(l))
		}
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovQosPosition(uint64(len(k))) + 1 + len(v) + sovQosPosition(uint64(len(v)))
			n += mapEntrySize + 2 + sovQosPosition(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovQosPosition(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozQosPosition(x uint64) (n int) {
	return sovQosPosition(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *QosPosition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQosPosition
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosPosition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosPosition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Positionid", wireType)
			}
			m.Positionid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQosPosition
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Positionid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpsLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQosPosition
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQosPosition
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQosPosition
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GpsLocation == nil {
				m.GpsLocation = &Loc{}
			}
			if err := m.GpsLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQosPosition(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQosPosition
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BandSelection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQosPosition
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BandSelection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BandSelection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rat2G", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQosPosition
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQosPosition
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQosPosition
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rat2G = append(m.Rat2G, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rat3G", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQosPosition
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQosPosition
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQosPosition
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rat3G = append(m.Rat3G, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rat4G", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQosPosition
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQosPosition
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQosPosition
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rat4G = append(m.Rat4G, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rat5G", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQosPosition
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQosPosition
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQosPosition
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rat5G = append(m.Rat5G, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQosPosition(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQosPosition
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosPositionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQosPosition
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosPositionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosPositionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQosPosition
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionCookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQosPosition
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQosPosition
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQosPosition
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionCookie = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Positions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQosPosition
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQosPosition
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQosPosition
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Positions = append(m.Positions, &QosPosition{})
			if err := m.Positions[len(m.Positions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LteCategory", wireType)
			}
			m.LteCategory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQosPosition
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LteCategory |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BandSelection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQosPosition
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQosPosition
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQosPosition
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BandSelection == nil {
				m.BandSelection = &BandSelection{}
			}
			if err := m.BandSelection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQosPosition
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQosPosition
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQosPosition
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowQosPosition
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowQosPosition
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthQosPosition
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthQosPosition
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowQosPosition
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthQosPosition
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthQosPosition
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipQosPosition(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthQosPosition
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQosPosition(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQosPosition
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosPositionKpiResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQosPosition
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosPositionKpiResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosPositionKpiResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Positionid", wireType)
			}
			m.Positionid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQosPosition
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Positionid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpsLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQosPosition
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQosPosition
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQosPosition
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GpsLocation == nil {
				m.GpsLocation = &Loc{}
			}
			if err := m.GpsLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DluserthroughputMin", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.DluserthroughputMin = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DluserthroughputAvg", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.DluserthroughputAvg = float32(math.Float32frombits(v))
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DluserthroughputMax", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.DluserthroughputMax = float32(math.Float32frombits(v))
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field UluserthroughputMin", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.UluserthroughputMin = float32(math.Float32frombits(v))
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field UluserthroughputAvg", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.UluserthroughputAvg = float32(math.Float32frombits(v))
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field UluserthroughputMax", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.UluserthroughputMax = float32(math.Float32frombits(v))
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatencyMin", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.LatencyMin = float32(math.Float32frombits(v))
		case 10:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatencyAvg", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.LatencyAvg = float32(math.Float32frombits(v))
		case 11:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatencyMax", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.LatencyMax = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipQosPosition(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQosPosition
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosPositionKpiReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQosPosition
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosPositionKpiReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosPositionKpiReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQosPosition
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQosPosition
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= ReplyStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionResults", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQosPosition
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQosPosition
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQosPosition
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PositionResults = append(m.PositionResults, &QosPositionKpiResult{})
			if err := m.PositionResults[len(m.PositionResults)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQosPosition
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQosPosition
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQosPosition
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowQosPosition
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowQosPosition
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthQosPosition
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthQosPosition
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowQosPosition
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthQosPosition
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthQosPosition
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipQosPosition(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthQosPosition
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQosPosition(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQosPosition
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipQosPosition(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowQosPosition
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQosPosition
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQosPosition
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthQosPosition
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupQosPosition
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthQosPosition
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthQosPosition        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowQosPosition          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupQosPosition = fmt.Errorf("proto: unexpected end of group")
)
