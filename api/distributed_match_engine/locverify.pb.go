// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: locverify.proto

package distributed_match_engine

import (
	context "context"
	encoding_binary "encoding/binary"
	"encoding/json"
	"errors"
	fmt "fmt"
	"github.com/edgexr/edge-cloud-platform/pkg/util"
	_ "github.com/gogo/googleapis/google/api"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	"strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Status of the reply
type VerifyLocationReply_TowerStatus int32

const (
	VerifyLocationReply_TOWER_UNKNOWN                    VerifyLocationReply_TowerStatus = 0
	VerifyLocationReply_CONNECTED_TO_SPECIFIED_TOWER     VerifyLocationReply_TowerStatus = 1
	VerifyLocationReply_NOT_CONNECTED_TO_SPECIFIED_TOWER VerifyLocationReply_TowerStatus = 2
)

var VerifyLocationReply_TowerStatus_name = map[int32]string{
	0: "TOWER_UNKNOWN",
	1: "CONNECTED_TO_SPECIFIED_TOWER",
	2: "NOT_CONNECTED_TO_SPECIFIED_TOWER",
}

var VerifyLocationReply_TowerStatus_value = map[string]int32{
	"TOWER_UNKNOWN":                    0,
	"CONNECTED_TO_SPECIFIED_TOWER":     1,
	"NOT_CONNECTED_TO_SPECIFIED_TOWER": 2,
}

func (x VerifyLocationReply_TowerStatus) String() string {
	return proto.EnumName(VerifyLocationReply_TowerStatus_name, int32(x))
}

func (VerifyLocationReply_TowerStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_898d2680f201362d, []int{1, 0}
}

type VerifyLocationReply_GPSLocationStatus int32

const (
	VerifyLocationReply_LOC_UNKNOWN                  VerifyLocationReply_GPSLocationStatus = 0
	VerifyLocationReply_LOC_VERIFIED                 VerifyLocationReply_GPSLocationStatus = 1
	VerifyLocationReply_LOC_MISMATCH_SAME_COUNTRY    VerifyLocationReply_GPSLocationStatus = 2
	VerifyLocationReply_LOC_MISMATCH_OTHER_COUNTRY   VerifyLocationReply_GPSLocationStatus = 3
	VerifyLocationReply_LOC_ROAMING_COUNTRY_MATCH    VerifyLocationReply_GPSLocationStatus = 4
	VerifyLocationReply_LOC_ROAMING_COUNTRY_MISMATCH VerifyLocationReply_GPSLocationStatus = 5
	VerifyLocationReply_LOC_ERROR_UNAUTHORIZED       VerifyLocationReply_GPSLocationStatus = 6
	VerifyLocationReply_LOC_ERROR_OTHER              VerifyLocationReply_GPSLocationStatus = 7
)

var VerifyLocationReply_GPSLocationStatus_name = map[int32]string{
	0: "LOC_UNKNOWN",
	1: "LOC_VERIFIED",
	2: "LOC_MISMATCH_SAME_COUNTRY",
	3: "LOC_MISMATCH_OTHER_COUNTRY",
	4: "LOC_ROAMING_COUNTRY_MATCH",
	5: "LOC_ROAMING_COUNTRY_MISMATCH",
	6: "LOC_ERROR_UNAUTHORIZED",
	7: "LOC_ERROR_OTHER",
}

var VerifyLocationReply_GPSLocationStatus_value = map[string]int32{
	"LOC_UNKNOWN":                  0,
	"LOC_VERIFIED":                 1,
	"LOC_MISMATCH_SAME_COUNTRY":    2,
	"LOC_MISMATCH_OTHER_COUNTRY":   3,
	"LOC_ROAMING_COUNTRY_MATCH":    4,
	"LOC_ROAMING_COUNTRY_MISMATCH": 5,
	"LOC_ERROR_UNAUTHORIZED":       6,
	"LOC_ERROR_OTHER":              7,
}

func (x VerifyLocationReply_GPSLocationStatus) String() string {
	return proto.EnumName(VerifyLocationReply_GPSLocationStatus_name, int32(x))
}

func (VerifyLocationReply_GPSLocationStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_898d2680f201362d, []int{1, 1}
}

// Status of the reply
type GetLocationReply_LocStatus int32

const (
	GetLocationReply_LOC_UNKNOWN GetLocationReply_LocStatus = 0
	GetLocationReply_LOC_FOUND   GetLocationReply_LocStatus = 1
	// The user does not allow his location to be tracked
	GetLocationReply_LOC_DENIED GetLocationReply_LocStatus = 2
)

var GetLocationReply_LocStatus_name = map[int32]string{
	0: "LOC_UNKNOWN",
	1: "LOC_FOUND",
	2: "LOC_DENIED",
}

var GetLocationReply_LocStatus_value = map[string]int32{
	"LOC_UNKNOWN": 0,
	"LOC_FOUND":   1,
	"LOC_DENIED":  2,
}

func (x GetLocationReply_LocStatus) String() string {
	return proto.EnumName(GetLocationReply_LocStatus_name, int32(x))
}

func (GetLocationReply_LocStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_898d2680f201362d, []int{3, 0}
}

type VerifyLocationRequest struct {
	//
	// API version
	//
	// _(hidden)_ Reserved for future use
	Ver uint32 `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	//
	// Session Cookie
	//
	// Session Cookie from RegisterClientRequest
	SessionCookie string `protobuf:"bytes,2,opt,name=session_cookie,json=sessionCookie,proto3" json:"session_cookie,omitempty"`
	//
	// Carrier Name
	//
	// Unique carrier identification (typically MCC + MNC)
	CarrierName string `protobuf:"bytes,3,opt,name=carrier_name,json=carrierName,proto3" json:"carrier_name,omitempty"`
	//
	// GPS Location
	//
	// The GPS location to verify
	GpsLocation *Loc `protobuf:"bytes,4,opt,name=gps_location,json=gpsLocation,proto3" json:"gps_location,omitempty"`
	//
	// Verify Location Token
	//
	// Must be retrieved from TokenServerURI
	VerifyLocToken string `protobuf:"bytes,5,opt,name=verify_loc_token,json=verifyLocToken,proto3" json:"verify_loc_token,omitempty"`
	//
	// Tags
	//
	// _(optional)_ Vendor specific data
	Tags                 map[string]string `protobuf:"bytes,100,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *VerifyLocationRequest) Reset()         { *m = VerifyLocationRequest{} }
func (m *VerifyLocationRequest) String() string { return proto.CompactTextString(m) }
func (*VerifyLocationRequest) ProtoMessage()    {}
func (*VerifyLocationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_898d2680f201362d, []int{0}
}
func (m *VerifyLocationRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VerifyLocationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VerifyLocationRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VerifyLocationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VerifyLocationRequest.Merge(m, src)
}
func (m *VerifyLocationRequest) XXX_Size() int {
	return m.Size()
}
func (m *VerifyLocationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_VerifyLocationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_VerifyLocationRequest proto.InternalMessageInfo

type VerifyLocationReply struct {
	//
	// API version
	//
	// _(hidden)_ Reserved for future use
	Ver               uint32                                `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	TowerStatus       VerifyLocationReply_TowerStatus       `protobuf:"varint,2,opt,name=tower_status,json=towerStatus,proto3,enum=distributed_match_engine.VerifyLocationReply_TowerStatus" json:"tower_status,omitempty"`
	GpsLocationStatus VerifyLocationReply_GPSLocationStatus `protobuf:"varint,3,opt,name=gps_location_status,json=gpsLocationStatus,proto3,enum=distributed_match_engine.VerifyLocationReply_GPSLocationStatus" json:"gps_location_status,omitempty"`
	// location accuracy, the location is verified to
	// be within this number of kilometers.  Negative value
	// means no verification was performed
	GpsLocationAccuracyKm float64 `protobuf:"fixed64,4,opt,name=gps_location_accuracy_km,json=gpsLocationAccuracyKm,proto3" json:"gps_location_accuracy_km,omitempty"`
	// _(optional)_ Vendor specific data
	Tags                 map[string]string `protobuf:"bytes,100,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *VerifyLocationReply) Reset()         { *m = VerifyLocationReply{} }
func (m *VerifyLocationReply) String() string { return proto.CompactTextString(m) }
func (*VerifyLocationReply) ProtoMessage()    {}
func (*VerifyLocationReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_898d2680f201362d, []int{1}
}
func (m *VerifyLocationReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VerifyLocationReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VerifyLocationReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VerifyLocationReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VerifyLocationReply.Merge(m, src)
}
func (m *VerifyLocationReply) XXX_Size() int {
	return m.Size()
}
func (m *VerifyLocationReply) XXX_DiscardUnknown() {
	xxx_messageInfo_VerifyLocationReply.DiscardUnknown(m)
}

var xxx_messageInfo_VerifyLocationReply proto.InternalMessageInfo

type GetLocationRequest struct {
	//
	// API version
	//
	// _(hidden)_ Reserved for future use
	Ver uint32 `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	// Session Cookie from RegisterClientRequest
	SessionCookie string `protobuf:"bytes,2,opt,name=session_cookie,json=sessionCookie,proto3" json:"session_cookie,omitempty"`
	// Unique carrier identification (typically MCC + MNC)
	CarrierName string `protobuf:"bytes,3,opt,name=carrier_name,json=carrierName,proto3" json:"carrier_name,omitempty"`
	// _(optional)_ Vendor specific data
	Tags                 map[string]string `protobuf:"bytes,100,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *GetLocationRequest) Reset()         { *m = GetLocationRequest{} }
func (m *GetLocationRequest) String() string { return proto.CompactTextString(m) }
func (*GetLocationRequest) ProtoMessage()    {}
func (*GetLocationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_898d2680f201362d, []int{2}
}
func (m *GetLocationRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetLocationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetLocationRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetLocationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetLocationRequest.Merge(m, src)
}
func (m *GetLocationRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetLocationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetLocationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetLocationRequest proto.InternalMessageInfo

type GetLocationReply struct {
	//
	// API version
	//
	// _(hidden)_ Reserved for future use
	Ver    uint32                     `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	Status GetLocationReply_LocStatus `protobuf:"varint,2,opt,name=status,proto3,enum=distributed_match_engine.GetLocationReply_LocStatus" json:"status,omitempty"`
	// Unique carrier identification (typically MCC + MNC)
	CarrierName string `protobuf:"bytes,3,opt,name=carrier_name,json=carrierName,proto3" json:"carrier_name,omitempty"`
	// The tower that the user is currently connected to
	Tower uint64 `protobuf:"varint,4,opt,name=tower,proto3" json:"tower,omitempty"`
	// The GPS location of the user
	NetworkLocation *Loc `protobuf:"bytes,5,opt,name=network_location,json=networkLocation,proto3" json:"network_location,omitempty"`
	// _(optional)_ Vendor specific data
	Tags                 map[string]string `protobuf:"bytes,100,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *GetLocationReply) Reset()         { *m = GetLocationReply{} }
func (m *GetLocationReply) String() string { return proto.CompactTextString(m) }
func (*GetLocationReply) ProtoMessage()    {}
func (*GetLocationReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_898d2680f201362d, []int{3}
}
func (m *GetLocationReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetLocationReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetLocationReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetLocationReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetLocationReply.Merge(m, src)
}
func (m *GetLocationReply) XXX_Size() int {
	return m.Size()
}
func (m *GetLocationReply) XXX_DiscardUnknown() {
	xxx_messageInfo_GetLocationReply.DiscardUnknown(m)
}

var xxx_messageInfo_GetLocationReply proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("distributed_match_engine.VerifyLocationReply_TowerStatus", VerifyLocationReply_TowerStatus_name, VerifyLocationReply_TowerStatus_value)
	proto.RegisterEnum("distributed_match_engine.VerifyLocationReply_GPSLocationStatus", VerifyLocationReply_GPSLocationStatus_name, VerifyLocationReply_GPSLocationStatus_value)
	proto.RegisterEnum("distributed_match_engine.GetLocationReply_LocStatus", GetLocationReply_LocStatus_name, GetLocationReply_LocStatus_value)
	proto.RegisterType((*VerifyLocationRequest)(nil), "distributed_match_engine.VerifyLocationRequest")
	proto.RegisterMapType((map[string]string)(nil), "distributed_match_engine.VerifyLocationRequest.TagsEntry")
	proto.RegisterType((*VerifyLocationReply)(nil), "distributed_match_engine.VerifyLocationReply")
	proto.RegisterMapType((map[string]string)(nil), "distributed_match_engine.VerifyLocationReply.TagsEntry")
	proto.RegisterType((*GetLocationRequest)(nil), "distributed_match_engine.GetLocationRequest")
	proto.RegisterMapType((map[string]string)(nil), "distributed_match_engine.GetLocationRequest.TagsEntry")
	proto.RegisterType((*GetLocationReply)(nil), "distributed_match_engine.GetLocationReply")
	proto.RegisterMapType((map[string]string)(nil), "distributed_match_engine.GetLocationReply.TagsEntry")
}

func init() { proto.RegisterFile("locverify.proto", fileDescriptor_898d2680f201362d) }

var fileDescriptor_898d2680f201362d = []byte{
	// 845 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x56, 0xdd, 0x6e, 0xe3, 0x44,
	0x14, 0x5e, 0x3b, 0x3f, 0xdd, 0x9c, 0xb4, 0x89, 0x3b, 0xed, 0x42, 0x88, 0xb6, 0x51, 0xb0, 0x40,
	0x8a, 0x56, 0x90, 0x88, 0x82, 0x28, 0x2c, 0x17, 0x10, 0x52, 0x6f, 0x93, 0x6d, 0x62, 0xaf, 0x26,
	0xee, 0x56, 0x20, 0xa4, 0x91, 0xd7, 0x1d, 0xb2, 0x56, 0x1c, 0x4f, 0xb0, 0x27, 0x59, 0xe5, 0x16,
	0xb8, 0xe1, 0x8a, 0x0b, 0xde, 0x80, 0x77, 0xe0, 0x1d, 0x7a, 0x89, 0xc4, 0x0b, 0x40, 0x85, 0xc4,
	0x1b, 0x70, 0x8d, 0x66, 0xe2, 0xa4, 0x31, 0x6d, 0x51, 0x23, 0x55, 0xdc, 0xcd, 0x9c, 0x33, 0x73,
	0xbe, 0x73, 0xbe, 0x33, 0xe7, 0xb3, 0xa1, 0xe8, 0x33, 0x77, 0x4a, 0x43, 0xef, 0xeb, 0x59, 0x7d,
	0x1c, 0x32, 0xce, 0x50, 0xe9, 0xcc, 0x8b, 0x78, 0xe8, 0xbd, 0x98, 0x70, 0x7a, 0x46, 0x46, 0x0e,
	0x77, 0x5f, 0x12, 0x1a, 0x0c, 0xbc, 0x80, 0x96, 0x1f, 0x0e, 0x18, 0x1b, 0xf8, 0xb4, 0xe1, 0x8c,
	0xbd, 0x86, 0x13, 0x04, 0x8c, 0x3b, 0xdc, 0x63, 0x41, 0x34, 0xbf, 0x57, 0xce, 0xf9, 0xcc, 0x9d,
	0x2f, 0xf5, 0xbf, 0x55, 0x78, 0xf0, 0x5c, 0xc6, 0xec, 0x32, 0x57, 0x1e, 0xc2, 0xf4, 0x9b, 0x09,
	0x8d, 0x38, 0xd2, 0x20, 0x35, 0xa5, 0x61, 0x49, 0xa9, 0x2a, 0xb5, 0x2d, 0x2c, 0x96, 0xe8, 0x6d,
	0x28, 0x44, 0x34, 0x8a, 0x3c, 0x16, 0x10, 0x97, 0xb1, 0xa1, 0x47, 0x4b, 0x6a, 0x55, 0xa9, 0xe5,
	0xf0, 0x56, 0x6c, 0x6d, 0x49, 0x23, 0x7a, 0x13, 0x36, 0x5d, 0x27, 0x0c, 0x3d, 0x1a, 0x92, 0xc0,
	0x19, 0xd1, 0x52, 0x4a, 0x1e, 0xca, 0xc7, 0x36, 0xd3, 0x19, 0x51, 0xf4, 0x19, 0x6c, 0x0e, 0xc6,
	0x11, 0xf1, 0x63, 0xc8, 0x52, 0xba, 0xaa, 0xd4, 0xf2, 0xfb, 0x7b, 0xf5, 0x9b, 0xea, 0xa9, 0x77,
	0x99, 0x8b, 0xf3, 0x83, 0x71, 0xb4, 0x48, 0x12, 0xd5, 0x40, 0x9b, 0x53, 0x21, 0x82, 0x10, 0xce,
	0x86, 0x34, 0x28, 0x65, 0x24, 0x50, 0x61, 0xba, 0x28, 0xc7, 0x16, 0x56, 0xd4, 0x83, 0x34, 0x77,
	0x06, 0x51, 0xe9, 0xac, 0x9a, 0xaa, 0xe5, 0xf7, 0x3f, 0xbe, 0x19, 0xe3, 0x5a, 0x1a, 0xea, 0xb6,
	0x33, 0x88, 0x8c, 0x80, 0x87, 0x33, 0x2c, 0xc3, 0x94, 0x0f, 0x20, 0xb7, 0x34, 0x09, 0x8e, 0x86,
	0x74, 0x26, 0x39, 0xca, 0x61, 0xb1, 0x44, 0xbb, 0x90, 0x99, 0x3a, 0xfe, 0x64, 0x41, 0xcd, 0x7c,
	0xf3, 0x58, 0xfd, 0x48, 0x79, 0x9a, 0xbe, 0x9f, 0xd5, 0x36, 0xf0, 0x86, 0x4b, 0x7d, 0x9f, 0x78,
	0x67, 0xfa, 0x0f, 0x59, 0xd8, 0xf9, 0x37, 0xe2, 0xd8, 0x9f, 0x5d, 0x43, 0xfb, 0x57, 0xb0, 0xc9,
	0xd9, 0x2b, 0x1a, 0x92, 0x88, 0x3b, 0x7c, 0x12, 0xc9, 0xc8, 0x85, 0x75, 0x0a, 0x19, 0xfb, 0xb3,
	0xba, 0x2d, 0x22, 0xf4, 0x65, 0x00, 0x9c, 0xe7, 0x97, 0x1b, 0xc4, 0x60, 0x67, 0xb5, 0x15, 0x0b,
	0x90, 0x94, 0x04, 0xf9, 0x74, 0x3d, 0x90, 0xa3, 0x67, 0xfd, 0x85, 0x21, 0x86, 0xda, 0x5e, 0xe9,
	0x59, 0x0c, 0x78, 0x00, 0xa5, 0x04, 0xa0, 0xe3, 0xba, 0x93, 0xd0, 0x71, 0x67, 0x64, 0x38, 0x92,
	0xef, 0x40, 0xc1, 0x0f, 0x56, 0x2e, 0x35, 0x63, 0xef, 0xf1, 0x08, 0x1d, 0x27, 0x1a, 0x79, 0xb0,
	0x66, 0xfd, 0x77, 0xd4, 0x46, 0xfd, 0x25, 0xe4, 0x57, 0xb8, 0x44, 0xdb, 0xb0, 0x65, 0x5b, 0xa7,
	0x06, 0x26, 0x27, 0xe6, 0xb1, 0x69, 0x9d, 0x9a, 0xda, 0x3d, 0x54, 0x85, 0x87, 0x2d, 0xcb, 0x34,
	0x8d, 0x96, 0x6d, 0x1c, 0x12, 0xdb, 0x22, 0xfd, 0x67, 0x46, 0xab, 0xf3, 0xa4, 0x23, 0x37, 0xa7,
	0x06, 0xd6, 0x14, 0xf4, 0x16, 0x54, 0x4d, 0xcb, 0x26, 0xff, 0x79, 0x4a, 0xd5, 0xff, 0x52, 0x60,
	0xfb, 0x0a, 0xa3, 0xa8, 0x08, 0xf9, 0xae, 0xd5, 0x5a, 0x81, 0xd3, 0x60, 0x53, 0x18, 0x9e, 0x1b,
	0x58, 0x5e, 0xd7, 0x14, 0xb4, 0x07, 0x6f, 0x08, 0x4b, 0xaf, 0xd3, 0xef, 0x35, 0xed, 0x56, 0x9b,
	0xf4, 0x9b, 0x3d, 0x83, 0xb4, 0xac, 0x13, 0xd3, 0xc6, 0x5f, 0x68, 0x2a, 0xaa, 0x40, 0x39, 0xe1,
	0xb6, 0xec, 0xb6, 0x81, 0x97, 0xfe, 0xd4, 0xe2, 0x3a, 0xb6, 0x9a, 0xbd, 0x8e, 0x79, 0xb4, 0x70,
	0x10, 0x79, 0x58, 0x4b, 0x8b, 0xf2, 0xae, 0x75, 0xc7, 0xe1, 0xb4, 0x0c, 0x2a, 0xc3, 0x6b, 0xe2,
	0x84, 0x81, 0xb1, 0x25, 0x78, 0x69, 0x9e, 0xd8, 0x6d, 0x0b, 0x77, 0xbe, 0x34, 0x0e, 0xb5, 0x2c,
	0xda, 0x81, 0xe2, 0xa5, 0x4f, 0x22, 0x6b, 0x1b, 0xfa, 0xf7, 0x2a, 0xa0, 0x23, 0xca, 0xff, 0x4f,
	0x05, 0x7a, 0x9a, 0x78, 0x4c, 0x1f, 0xde, 0xfc, 0x98, 0xae, 0xe6, 0x75, 0x97, 0x92, 0x90, 0xd6,
	0x32, 0x97, 0x92, 0xf0, 0x4b, 0x0a, 0xb4, 0x04, 0xdc, 0xf5, 0x7a, 0xd0, 0x85, 0x6c, 0x42, 0x09,
	0x3e, 0xb8, 0x65, 0xf2, 0x62, 0x0c, 0xba, 0xcc, 0x8d, 0x27, 0x33, 0x8e, 0x71, 0x1b, 0xae, 0x76,
	0x21, 0x23, 0x15, 0x43, 0x8e, 0x67, 0x1a, 0xcf, 0x37, 0xa8, 0x0d, 0x5a, 0x40, 0xf9, 0x2b, 0x16,
	0x0e, 0x2f, 0x75, 0x3c, 0x73, 0x1b, 0x1d, 0x2f, 0xc6, 0xd7, 0x96, 0x5a, 0xde, 0x4e, 0xf4, 0x62,
	0x9d, 0x72, 0xee, 0x6c, 0xaa, 0x3f, 0x81, 0xdc, 0x92, 0x9a, 0xab, 0x23, 0xb6, 0x05, 0x39, 0x61,
	0x78, 0x62, 0x9d, 0x98, 0x62, 0xbe, 0x0a, 0x00, 0x62, 0x7b, 0x68, 0x98, 0x62, 0xde, 0xd4, 0xfd,
	0x9f, 0x55, 0xb8, 0xbf, 0x2c, 0xe6, 0x47, 0x05, 0x0a, 0x49, 0x01, 0x42, 0x8d, 0x35, 0xbf, 0x39,
	0xe5, 0x77, 0xd7, 0xd2, 0x36, 0x7d, 0xef, 0xdb, 0xdf, 0xfe, 0xfc, 0x49, 0x7d, 0x5d, 0x47, 0x8d,
	0xe9, 0x7b, 0x8d, 0xf9, 0xd7, 0x6f, 0xd1, 0x91, 0xc7, 0xca, 0x23, 0xf4, 0x9d, 0x02, 0xf9, 0x15,
	0xe6, 0xd0, 0x3b, 0xeb, 0x3c, 0xf6, 0xf2, 0xa3, 0xdb, 0xb7, 0x43, 0x2f, 0xcb, 0x44, 0x76, 0xf5,
	0xa2, 0x48, 0x64, 0x40, 0xf9, 0x4a, 0x16, 0x9f, 0x6b, 0xe7, 0x7f, 0x54, 0xee, 0x9d, 0x5f, 0x54,
	0x94, 0x5f, 0x2f, 0x2a, 0xca, 0xef, 0x17, 0x15, 0xe5, 0x45, 0x56, 0xfe, 0x81, 0xbc, 0xff, 0x4f,
	0x00, 0x00, 0x00, 0xff, 0xff, 0xe6, 0x54, 0x6f, 0xd3, 0xd7, 0x08, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// LocationClient is the client API for Location service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type LocationClient interface {
	//
	// VerifyLocation
	//
	// Verifies that the GPS coordinates accurately report the actual location of the device.
	VerifyLocation(ctx context.Context, in *VerifyLocationRequest, opts ...grpc.CallOption) (*VerifyLocationReply, error)
	GetLocation(ctx context.Context, in *GetLocationRequest, opts ...grpc.CallOption) (*GetLocationReply, error)
}

type locationClient struct {
	cc *grpc.ClientConn
}

func NewLocationClient(cc *grpc.ClientConn) LocationClient {
	return &locationClient{cc}
}

func (c *locationClient) VerifyLocation(ctx context.Context, in *VerifyLocationRequest, opts ...grpc.CallOption) (*VerifyLocationReply, error) {
	out := new(VerifyLocationReply)
	err := c.cc.Invoke(ctx, "/distributed_match_engine.Location/VerifyLocation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *locationClient) GetLocation(ctx context.Context, in *GetLocationRequest, opts ...grpc.CallOption) (*GetLocationReply, error) {
	out := new(GetLocationReply)
	err := c.cc.Invoke(ctx, "/distributed_match_engine.Location/GetLocation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LocationServer is the server API for Location service.
type LocationServer interface {
	//
	// VerifyLocation
	//
	// Verifies that the GPS coordinates accurately report the actual location of the device.
	VerifyLocation(context.Context, *VerifyLocationRequest) (*VerifyLocationReply, error)
	GetLocation(context.Context, *GetLocationRequest) (*GetLocationReply, error)
}

// UnimplementedLocationServer can be embedded to have forward compatible implementations.
type UnimplementedLocationServer struct {
}

func (*UnimplementedLocationServer) VerifyLocation(ctx context.Context, req *VerifyLocationRequest) (*VerifyLocationReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyLocation not implemented")
}
func (*UnimplementedLocationServer) GetLocation(ctx context.Context, req *GetLocationRequest) (*GetLocationReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLocation not implemented")
}

func RegisterLocationServer(s *grpc.Server, srv LocationServer) {
	s.RegisterService(&_Location_serviceDesc, srv)
}

func _Location_VerifyLocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyLocationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocationServer).VerifyLocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/distributed_match_engine.Location/VerifyLocation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocationServer).VerifyLocation(ctx, req.(*VerifyLocationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Location_GetLocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLocationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocationServer).GetLocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/distributed_match_engine.Location/GetLocation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocationServer).GetLocation(ctx, req.(*GetLocationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Location_serviceDesc = grpc.ServiceDesc{
	ServiceName: "distributed_match_engine.Location",
	HandlerType: (*LocationServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "VerifyLocation",
			Handler:    _Location_VerifyLocation_Handler,
		},
		{
			MethodName: "GetLocation",
			Handler:    _Location_GetLocation_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "locverify.proto",
}

func (m *VerifyLocationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerifyLocationRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VerifyLocationRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Tags) > 0 {
		for k := range m.Tags {
			v := m.Tags[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintLocverify(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintLocverify(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintLocverify(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.VerifyLocToken) > 0 {
		i -= len(m.VerifyLocToken)
		copy(dAtA[i:], m.VerifyLocToken)
		i = encodeVarintLocverify(dAtA, i, uint64(len(m.VerifyLocToken)))
		i--
		dAtA[i] = 0x2a
	}
	if m.GpsLocation != nil {
		{
			size, err := m.GpsLocation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLocverify(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.CarrierName) > 0 {
		i -= len(m.CarrierName)
		copy(dAtA[i:], m.CarrierName)
		i = encodeVarintLocverify(dAtA, i, uint64(len(m.CarrierName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SessionCookie) > 0 {
		i -= len(m.SessionCookie)
		copy(dAtA[i:], m.SessionCookie)
		i = encodeVarintLocverify(dAtA, i, uint64(len(m.SessionCookie)))
		i--
		dAtA[i] = 0x12
	}
	if m.Ver != 0 {
		i = encodeVarintLocverify(dAtA, i, uint64(m.Ver))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *VerifyLocationReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerifyLocationReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VerifyLocationReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Tags) > 0 {
		for k := range m.Tags {
			v := m.Tags[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintLocverify(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintLocverify(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintLocverify(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa2
		}
	}
	if m.GpsLocationAccuracyKm != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.GpsLocationAccuracyKm))))
		i--
		dAtA[i] = 0x21
	}
	if m.GpsLocationStatus != 0 {
		i = encodeVarintLocverify(dAtA, i, uint64(m.GpsLocationStatus))
		i--
		dAtA[i] = 0x18
	}
	if m.TowerStatus != 0 {
		i = encodeVarintLocverify(dAtA, i, uint64(m.TowerStatus))
		i--
		dAtA[i] = 0x10
	}
	if m.Ver != 0 {
		i = encodeVarintLocverify(dAtA, i, uint64(m.Ver))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetLocationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetLocationRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetLocationRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Tags) > 0 {
		for k := range m.Tags {
			v := m.Tags[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintLocverify(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintLocverify(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintLocverify(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.CarrierName) > 0 {
		i -= len(m.CarrierName)
		copy(dAtA[i:], m.CarrierName)
		i = encodeVarintLocverify(dAtA, i, uint64(len(m.CarrierName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SessionCookie) > 0 {
		i -= len(m.SessionCookie)
		copy(dAtA[i:], m.SessionCookie)
		i = encodeVarintLocverify(dAtA, i, uint64(len(m.SessionCookie)))
		i--
		dAtA[i] = 0x12
	}
	if m.Ver != 0 {
		i = encodeVarintLocverify(dAtA, i, uint64(m.Ver))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetLocationReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetLocationReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetLocationReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Tags) > 0 {
		for k := range m.Tags {
			v := m.Tags[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintLocverify(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintLocverify(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintLocverify(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa2
		}
	}
	if m.NetworkLocation != nil {
		{
			size, err := m.NetworkLocation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLocverify(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Tower != 0 {
		i = encodeVarintLocverify(dAtA, i, uint64(m.Tower))
		i--
		dAtA[i] = 0x20
	}
	if len(m.CarrierName) > 0 {
		i -= len(m.CarrierName)
		copy(dAtA[i:], m.CarrierName)
		i = encodeVarintLocverify(dAtA, i, uint64(len(m.CarrierName)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Status != 0 {
		i = encodeVarintLocverify(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if m.Ver != 0 {
		i = encodeVarintLocverify(dAtA, i, uint64(m.Ver))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintLocverify(dAtA []byte, offset int, v uint64) int {
	offset -= sovLocverify(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *VerifyLocationRequest) CopyInFields(src *VerifyLocationRequest) int {
	changed := 0
	if m.Ver != src.Ver {
		m.Ver = src.Ver
		changed++
	}
	if m.SessionCookie != src.SessionCookie {
		m.SessionCookie = src.SessionCookie
		changed++
	}
	if m.CarrierName != src.CarrierName {
		m.CarrierName = src.CarrierName
		changed++
	}
	if src.GpsLocation != nil {
		if m.GpsLocation == nil {
			m.GpsLocation = &Loc{}
		}
		if m.GpsLocation.Latitude != src.GpsLocation.Latitude {
			m.GpsLocation.Latitude = src.GpsLocation.Latitude
			changed++
		}
		if m.GpsLocation.Longitude != src.GpsLocation.Longitude {
			m.GpsLocation.Longitude = src.GpsLocation.Longitude
			changed++
		}
		if m.GpsLocation.HorizontalAccuracy != src.GpsLocation.HorizontalAccuracy {
			m.GpsLocation.HorizontalAccuracy = src.GpsLocation.HorizontalAccuracy
			changed++
		}
		if m.GpsLocation.VerticalAccuracy != src.GpsLocation.VerticalAccuracy {
			m.GpsLocation.VerticalAccuracy = src.GpsLocation.VerticalAccuracy
			changed++
		}
		if m.GpsLocation.Altitude != src.GpsLocation.Altitude {
			m.GpsLocation.Altitude = src.GpsLocation.Altitude
			changed++
		}
		if m.GpsLocation.Course != src.GpsLocation.Course {
			m.GpsLocation.Course = src.GpsLocation.Course
			changed++
		}
		if m.GpsLocation.Speed != src.GpsLocation.Speed {
			m.GpsLocation.Speed = src.GpsLocation.Speed
			changed++
		}
		if src.GpsLocation.Timestamp != nil {
			if m.GpsLocation.Timestamp == nil {
				m.GpsLocation.Timestamp = &Timestamp{}
			}
			if m.GpsLocation.Timestamp.Seconds != src.GpsLocation.Timestamp.Seconds {
				m.GpsLocation.Timestamp.Seconds = src.GpsLocation.Timestamp.Seconds
				changed++
			}
			if m.GpsLocation.Timestamp.Nanos != src.GpsLocation.Timestamp.Nanos {
				m.GpsLocation.Timestamp.Nanos = src.GpsLocation.Timestamp.Nanos
				changed++
			}
		} else if m.GpsLocation.Timestamp != nil {
			m.GpsLocation.Timestamp = nil
			changed++
		}
	} else if m.GpsLocation != nil {
		m.GpsLocation = nil
		changed++
	}
	if m.VerifyLocToken != src.VerifyLocToken {
		m.VerifyLocToken = src.VerifyLocToken
		changed++
	}
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k0, _ := range src.Tags {
			m.Tags[k0] = src.Tags[k0]
			changed++
		}
	} else if m.Tags != nil {
		m.Tags = nil
		changed++
	}
	return changed
}

func (m *VerifyLocationRequest) DeepCopyIn(src *VerifyLocationRequest) {
	m.Ver = src.Ver
	m.SessionCookie = src.SessionCookie
	m.CarrierName = src.CarrierName
	if src.GpsLocation != nil {
		var tmp_GpsLocation Loc
		tmp_GpsLocation.DeepCopyIn(src.GpsLocation)
		m.GpsLocation = &tmp_GpsLocation
	} else {
		m.GpsLocation = nil
	}
	m.VerifyLocToken = src.VerifyLocToken
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k, v := range src.Tags {
			m.Tags[k] = v
		}
	} else {
		m.Tags = nil
	}
}

// Helper method to check that enums have valid values
func (m *VerifyLocationRequest) ValidateEnums() error {
	if m.GpsLocation != nil {
		if err := m.GpsLocation.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (s *VerifyLocationRequest) ClearTagged(tags map[string]struct{}) {
	if s.GpsLocation != nil {
		s.GpsLocation.ClearTagged(tags)
	}
}

func (m *VerifyLocationReply) CopyInFields(src *VerifyLocationReply) int {
	changed := 0
	if m.Ver != src.Ver {
		m.Ver = src.Ver
		changed++
	}
	if m.TowerStatus != src.TowerStatus {
		m.TowerStatus = src.TowerStatus
		changed++
	}
	if m.GpsLocationStatus != src.GpsLocationStatus {
		m.GpsLocationStatus = src.GpsLocationStatus
		changed++
	}
	if m.GpsLocationAccuracyKm != src.GpsLocationAccuracyKm {
		m.GpsLocationAccuracyKm = src.GpsLocationAccuracyKm
		changed++
	}
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k0, _ := range src.Tags {
			m.Tags[k0] = src.Tags[k0]
			changed++
		}
	} else if m.Tags != nil {
		m.Tags = nil
		changed++
	}
	return changed
}

func (m *VerifyLocationReply) DeepCopyIn(src *VerifyLocationReply) {
	m.Ver = src.Ver
	m.TowerStatus = src.TowerStatus
	m.GpsLocationStatus = src.GpsLocationStatus
	m.GpsLocationAccuracyKm = src.GpsLocationAccuracyKm
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k, v := range src.Tags {
			m.Tags[k] = v
		}
	} else {
		m.Tags = nil
	}
}

// Helper method to check that enums have valid values
func (m *VerifyLocationReply) ValidateEnums() error {
	if _, ok := VerifyLocationReply_TowerStatus_name[int32(m.TowerStatus)]; !ok {
		return errors.New("invalid TowerStatus")
	}
	if _, ok := VerifyLocationReply_GPSLocationStatus_name[int32(m.GpsLocationStatus)]; !ok {
		return errors.New("invalid GpsLocationStatus")
	}
	return nil
}

func (s *VerifyLocationReply) ClearTagged(tags map[string]struct{}) {
}

func (m *GetLocationRequest) CopyInFields(src *GetLocationRequest) int {
	changed := 0
	if m.Ver != src.Ver {
		m.Ver = src.Ver
		changed++
	}
	if m.SessionCookie != src.SessionCookie {
		m.SessionCookie = src.SessionCookie
		changed++
	}
	if m.CarrierName != src.CarrierName {
		m.CarrierName = src.CarrierName
		changed++
	}
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k0, _ := range src.Tags {
			m.Tags[k0] = src.Tags[k0]
			changed++
		}
	} else if m.Tags != nil {
		m.Tags = nil
		changed++
	}
	return changed
}

func (m *GetLocationRequest) DeepCopyIn(src *GetLocationRequest) {
	m.Ver = src.Ver
	m.SessionCookie = src.SessionCookie
	m.CarrierName = src.CarrierName
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k, v := range src.Tags {
			m.Tags[k] = v
		}
	} else {
		m.Tags = nil
	}
}

// Helper method to check that enums have valid values
func (m *GetLocationRequest) ValidateEnums() error {
	return nil
}

func (s *GetLocationRequest) ClearTagged(tags map[string]struct{}) {
}

func (m *GetLocationReply) CopyInFields(src *GetLocationReply) int {
	changed := 0
	if m.Ver != src.Ver {
		m.Ver = src.Ver
		changed++
	}
	if m.Status != src.Status {
		m.Status = src.Status
		changed++
	}
	if m.CarrierName != src.CarrierName {
		m.CarrierName = src.CarrierName
		changed++
	}
	if m.Tower != src.Tower {
		m.Tower = src.Tower
		changed++
	}
	if src.NetworkLocation != nil {
		if m.NetworkLocation == nil {
			m.NetworkLocation = &Loc{}
		}
		if m.NetworkLocation.Latitude != src.NetworkLocation.Latitude {
			m.NetworkLocation.Latitude = src.NetworkLocation.Latitude
			changed++
		}
		if m.NetworkLocation.Longitude != src.NetworkLocation.Longitude {
			m.NetworkLocation.Longitude = src.NetworkLocation.Longitude
			changed++
		}
		if m.NetworkLocation.HorizontalAccuracy != src.NetworkLocation.HorizontalAccuracy {
			m.NetworkLocation.HorizontalAccuracy = src.NetworkLocation.HorizontalAccuracy
			changed++
		}
		if m.NetworkLocation.VerticalAccuracy != src.NetworkLocation.VerticalAccuracy {
			m.NetworkLocation.VerticalAccuracy = src.NetworkLocation.VerticalAccuracy
			changed++
		}
		if m.NetworkLocation.Altitude != src.NetworkLocation.Altitude {
			m.NetworkLocation.Altitude = src.NetworkLocation.Altitude
			changed++
		}
		if m.NetworkLocation.Course != src.NetworkLocation.Course {
			m.NetworkLocation.Course = src.NetworkLocation.Course
			changed++
		}
		if m.NetworkLocation.Speed != src.NetworkLocation.Speed {
			m.NetworkLocation.Speed = src.NetworkLocation.Speed
			changed++
		}
		if src.NetworkLocation.Timestamp != nil {
			if m.NetworkLocation.Timestamp == nil {
				m.NetworkLocation.Timestamp = &Timestamp{}
			}
			if m.NetworkLocation.Timestamp.Seconds != src.NetworkLocation.Timestamp.Seconds {
				m.NetworkLocation.Timestamp.Seconds = src.NetworkLocation.Timestamp.Seconds
				changed++
			}
			if m.NetworkLocation.Timestamp.Nanos != src.NetworkLocation.Timestamp.Nanos {
				m.NetworkLocation.Timestamp.Nanos = src.NetworkLocation.Timestamp.Nanos
				changed++
			}
		} else if m.NetworkLocation.Timestamp != nil {
			m.NetworkLocation.Timestamp = nil
			changed++
		}
	} else if m.NetworkLocation != nil {
		m.NetworkLocation = nil
		changed++
	}
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k0, _ := range src.Tags {
			m.Tags[k0] = src.Tags[k0]
			changed++
		}
	} else if m.Tags != nil {
		m.Tags = nil
		changed++
	}
	return changed
}

func (m *GetLocationReply) DeepCopyIn(src *GetLocationReply) {
	m.Ver = src.Ver
	m.Status = src.Status
	m.CarrierName = src.CarrierName
	m.Tower = src.Tower
	if src.NetworkLocation != nil {
		var tmp_NetworkLocation Loc
		tmp_NetworkLocation.DeepCopyIn(src.NetworkLocation)
		m.NetworkLocation = &tmp_NetworkLocation
	} else {
		m.NetworkLocation = nil
	}
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k, v := range src.Tags {
			m.Tags[k] = v
		}
	} else {
		m.Tags = nil
	}
}

// Helper method to check that enums have valid values
func (m *GetLocationReply) ValidateEnums() error {
	if _, ok := GetLocationReply_LocStatus_name[int32(m.Status)]; !ok {
		return errors.New("invalid Status")
	}
	if m.NetworkLocation != nil {
		if err := m.NetworkLocation.ValidateEnums(); err != nil {
			return err
		}
	}
	return nil
}

func (s *GetLocationReply) ClearTagged(tags map[string]struct{}) {
	if s.NetworkLocation != nil {
		s.NetworkLocation.ClearTagged(tags)
	}
}

var TowerStatusStrings = []string{
	"TOWER_UNKNOWN",
	"CONNECTED_TO_SPECIFIED_TOWER",
	"NOT_CONNECTED_TO_SPECIFIED_TOWER",
}

const (
	TowerStatusTOWER_UNKNOWN                    uint64 = 1 << 0
	TowerStatusCONNECTED_TO_SPECIFIED_TOWER     uint64 = 1 << 1
	TowerStatusNOT_CONNECTED_TO_SPECIFIED_TOWER uint64 = 1 << 2
)

var VerifyLocationReply_TowerStatus_CamelName = map[int32]string{
	// TOWER_UNKNOWN -> TowerUnknown
	0: "TowerUnknown",
	// CONNECTED_TO_SPECIFIED_TOWER -> ConnectedToSpecifiedTower
	1: "ConnectedToSpecifiedTower",
	// NOT_CONNECTED_TO_SPECIFIED_TOWER -> NotConnectedToSpecifiedTower
	2: "NotConnectedToSpecifiedTower",
}
var VerifyLocationReply_TowerStatus_CamelValue = map[string]int32{
	"TowerUnknown":                 0,
	"ConnectedToSpecifiedTower":    1,
	"NotConnectedToSpecifiedTower": 2,
}

func ParseVerifyLocationReply_TowerStatus(data interface{}) (VerifyLocationReply_TowerStatus, error) {
	if val, ok := data.(VerifyLocationReply_TowerStatus); ok {
		return val, nil
	} else if str, ok := data.(string); ok {
		val, ok := VerifyLocationReply_TowerStatus_CamelValue[util.CamelCase(str)]
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = VerifyLocationReply_TowerStatus_CamelName[val]
			}
		}
		if !ok {
			return VerifyLocationReply_TowerStatus(0), fmt.Errorf("Invalid VerifyLocationReply_TowerStatus value %q", str)
		}
		return VerifyLocationReply_TowerStatus(val), nil
	} else if ival, ok := data.(int32); ok {
		if _, ok := VerifyLocationReply_TowerStatus_CamelName[ival]; ok {
			return VerifyLocationReply_TowerStatus(ival), nil
		} else {
			return VerifyLocationReply_TowerStatus(0), fmt.Errorf("Invalid VerifyLocationReply_TowerStatus value %d", ival)
		}
	}
	return VerifyLocationReply_TowerStatus(0), fmt.Errorf("Invalid VerifyLocationReply_TowerStatus value %v", data)
}

func (e *VerifyLocationReply_TowerStatus) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, err := ParseVerifyLocationReply_TowerStatus(str)
	if err != nil {
		return err
	}
	*e = val
	return nil
}

func (e VerifyLocationReply_TowerStatus) MarshalYAML() (interface{}, error) {
	str := proto.EnumName(VerifyLocationReply_TowerStatus_CamelName, int32(e))
	return str, nil
}

// custom JSON encoding/decoding
func (e *VerifyLocationReply_TowerStatus) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, err := ParseVerifyLocationReply_TowerStatus(str)
		if err != nil {
			return &json.UnmarshalTypeError{
				Value: "string " + str,
				Type:  reflect.TypeOf(VerifyLocationReply_TowerStatus(0)),
			}
		}
		*e = VerifyLocationReply_TowerStatus(val)
		return nil
	}
	var ival int32
	err = json.Unmarshal(b, &ival)
	if err == nil {
		val, err := ParseVerifyLocationReply_TowerStatus(ival)
		if err == nil {
			*e = val
			return nil
		}
	}
	return &json.UnmarshalTypeError{
		Value: "value " + string(b),
		Type:  reflect.TypeOf(VerifyLocationReply_TowerStatus(0)),
	}
}

func (e VerifyLocationReply_TowerStatus) MarshalJSON() ([]byte, error) {
	str := proto.EnumName(VerifyLocationReply_TowerStatus_CamelName, int32(e))
	return json.Marshal(str)
}

var GPSLocationStatusStrings = []string{
	"LOC_UNKNOWN",
	"LOC_VERIFIED",
	"LOC_MISMATCH_SAME_COUNTRY",
	"LOC_MISMATCH_OTHER_COUNTRY",
	"LOC_ROAMING_COUNTRY_MATCH",
	"LOC_ROAMING_COUNTRY_MISMATCH",
	"LOC_ERROR_UNAUTHORIZED",
	"LOC_ERROR_OTHER",
}

const (
	GPSLocationStatusLOC_UNKNOWN                  uint64 = 1 << 0
	GPSLocationStatusLOC_VERIFIED                 uint64 = 1 << 1
	GPSLocationStatusLOC_MISMATCH_SAME_COUNTRY    uint64 = 1 << 2
	GPSLocationStatusLOC_MISMATCH_OTHER_COUNTRY   uint64 = 1 << 3
	GPSLocationStatusLOC_ROAMING_COUNTRY_MATCH    uint64 = 1 << 4
	GPSLocationStatusLOC_ROAMING_COUNTRY_MISMATCH uint64 = 1 << 5
	GPSLocationStatusLOC_ERROR_UNAUTHORIZED       uint64 = 1 << 6
	GPSLocationStatusLOC_ERROR_OTHER              uint64 = 1 << 7
)

var VerifyLocationReply_GPSLocationStatus_CamelName = map[int32]string{
	// LOC_UNKNOWN -> LocUnknown
	0: "LocUnknown",
	// LOC_VERIFIED -> LocVerified
	1: "LocVerified",
	// LOC_MISMATCH_SAME_COUNTRY -> LocMismatchSameCountry
	2: "LocMismatchSameCountry",
	// LOC_MISMATCH_OTHER_COUNTRY -> LocMismatchOtherCountry
	3: "LocMismatchOtherCountry",
	// LOC_ROAMING_COUNTRY_MATCH -> LocRoamingCountryMatch
	4: "LocRoamingCountryMatch",
	// LOC_ROAMING_COUNTRY_MISMATCH -> LocRoamingCountryMismatch
	5: "LocRoamingCountryMismatch",
	// LOC_ERROR_UNAUTHORIZED -> LocErrorUnauthorized
	6: "LocErrorUnauthorized",
	// LOC_ERROR_OTHER -> LocErrorOther
	7: "LocErrorOther",
}
var VerifyLocationReply_GPSLocationStatus_CamelValue = map[string]int32{
	"LocUnknown":                0,
	"LocVerified":               1,
	"LocMismatchSameCountry":    2,
	"LocMismatchOtherCountry":   3,
	"LocRoamingCountryMatch":    4,
	"LocRoamingCountryMismatch": 5,
	"LocErrorUnauthorized":      6,
	"LocErrorOther":             7,
}

func ParseVerifyLocationReply_GPSLocationStatus(data interface{}) (VerifyLocationReply_GPSLocationStatus, error) {
	if val, ok := data.(VerifyLocationReply_GPSLocationStatus); ok {
		return val, nil
	} else if str, ok := data.(string); ok {
		val, ok := VerifyLocationReply_GPSLocationStatus_CamelValue[util.CamelCase(str)]
		if !ok {
			// may have omitted common prefix
			val, ok = VerifyLocationReply_GPSLocationStatus_CamelValue["Loc"+util.CamelCase(str)]
		}
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = VerifyLocationReply_GPSLocationStatus_CamelName[val]
			}
		}
		if !ok {
			return VerifyLocationReply_GPSLocationStatus(0), fmt.Errorf("Invalid VerifyLocationReply_GPSLocationStatus value %q", str)
		}
		return VerifyLocationReply_GPSLocationStatus(val), nil
	} else if ival, ok := data.(int32); ok {
		if _, ok := VerifyLocationReply_GPSLocationStatus_CamelName[ival]; ok {
			return VerifyLocationReply_GPSLocationStatus(ival), nil
		} else {
			return VerifyLocationReply_GPSLocationStatus(0), fmt.Errorf("Invalid VerifyLocationReply_GPSLocationStatus value %d", ival)
		}
	}
	return VerifyLocationReply_GPSLocationStatus(0), fmt.Errorf("Invalid VerifyLocationReply_GPSLocationStatus value %v", data)
}

func (e *VerifyLocationReply_GPSLocationStatus) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, err := ParseVerifyLocationReply_GPSLocationStatus(str)
	if err != nil {
		return err
	}
	*e = val
	return nil
}

func (e VerifyLocationReply_GPSLocationStatus) MarshalYAML() (interface{}, error) {
	str := proto.EnumName(VerifyLocationReply_GPSLocationStatus_CamelName, int32(e))
	str = strings.TrimPrefix(str, "Loc")
	return str, nil
}

// custom JSON encoding/decoding
func (e *VerifyLocationReply_GPSLocationStatus) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, err := ParseVerifyLocationReply_GPSLocationStatus(str)
		if err != nil {
			return &json.UnmarshalTypeError{
				Value: "string " + str,
				Type:  reflect.TypeOf(VerifyLocationReply_GPSLocationStatus(0)),
			}
		}
		*e = VerifyLocationReply_GPSLocationStatus(val)
		return nil
	}
	var ival int32
	err = json.Unmarshal(b, &ival)
	if err == nil {
		val, err := ParseVerifyLocationReply_GPSLocationStatus(ival)
		if err == nil {
			*e = val
			return nil
		}
	}
	return &json.UnmarshalTypeError{
		Value: "value " + string(b),
		Type:  reflect.TypeOf(VerifyLocationReply_GPSLocationStatus(0)),
	}
}

func (e VerifyLocationReply_GPSLocationStatus) MarshalJSON() ([]byte, error) {
	str := proto.EnumName(VerifyLocationReply_GPSLocationStatus_CamelName, int32(e))
	str = strings.TrimPrefix(str, "Loc")
	return json.Marshal(str)
}

var GPSLocationStatusCommonPrefix = "Loc"

var LocStatusStrings = []string{
	"LOC_UNKNOWN",
	"LOC_FOUND",
	"LOC_DENIED",
}

const (
	LocStatusLOC_UNKNOWN uint64 = 1 << 0
	LocStatusLOC_FOUND   uint64 = 1 << 1
	LocStatusLOC_DENIED  uint64 = 1 << 2
)

var GetLocationReply_LocStatus_CamelName = map[int32]string{
	// LOC_UNKNOWN -> LocUnknown
	0: "LocUnknown",
	// LOC_FOUND -> LocFound
	1: "LocFound",
	// LOC_DENIED -> LocDenied
	2: "LocDenied",
}
var GetLocationReply_LocStatus_CamelValue = map[string]int32{
	"LocUnknown": 0,
	"LocFound":   1,
	"LocDenied":  2,
}

func ParseGetLocationReply_LocStatus(data interface{}) (GetLocationReply_LocStatus, error) {
	if val, ok := data.(GetLocationReply_LocStatus); ok {
		return val, nil
	} else if str, ok := data.(string); ok {
		val, ok := GetLocationReply_LocStatus_CamelValue[util.CamelCase(str)]
		if !ok {
			// may have omitted common prefix
			val, ok = GetLocationReply_LocStatus_CamelValue["Loc"+util.CamelCase(str)]
		}
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = GetLocationReply_LocStatus_CamelName[val]
			}
		}
		if !ok {
			return GetLocationReply_LocStatus(0), fmt.Errorf("Invalid GetLocationReply_LocStatus value %q", str)
		}
		return GetLocationReply_LocStatus(val), nil
	} else if ival, ok := data.(int32); ok {
		if _, ok := GetLocationReply_LocStatus_CamelName[ival]; ok {
			return GetLocationReply_LocStatus(ival), nil
		} else {
			return GetLocationReply_LocStatus(0), fmt.Errorf("Invalid GetLocationReply_LocStatus value %d", ival)
		}
	}
	return GetLocationReply_LocStatus(0), fmt.Errorf("Invalid GetLocationReply_LocStatus value %v", data)
}

func (e *GetLocationReply_LocStatus) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, err := ParseGetLocationReply_LocStatus(str)
	if err != nil {
		return err
	}
	*e = val
	return nil
}

func (e GetLocationReply_LocStatus) MarshalYAML() (interface{}, error) {
	str := proto.EnumName(GetLocationReply_LocStatus_CamelName, int32(e))
	str = strings.TrimPrefix(str, "Loc")
	return str, nil
}

// custom JSON encoding/decoding
func (e *GetLocationReply_LocStatus) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, err := ParseGetLocationReply_LocStatus(str)
		if err != nil {
			return &json.UnmarshalTypeError{
				Value: "string " + str,
				Type:  reflect.TypeOf(GetLocationReply_LocStatus(0)),
			}
		}
		*e = GetLocationReply_LocStatus(val)
		return nil
	}
	var ival int32
	err = json.Unmarshal(b, &ival)
	if err == nil {
		val, err := ParseGetLocationReply_LocStatus(ival)
		if err == nil {
			*e = val
			return nil
		}
	}
	return &json.UnmarshalTypeError{
		Value: "value " + string(b),
		Type:  reflect.TypeOf(GetLocationReply_LocStatus(0)),
	}
}

func (e GetLocationReply_LocStatus) MarshalJSON() ([]byte, error) {
	str := proto.EnumName(GetLocationReply_LocStatus_CamelName, int32(e))
	str = strings.TrimPrefix(str, "Loc")
	return json.Marshal(str)
}

var LocStatusCommonPrefix = "Loc"

func (m *VerifyLocationRequest) IsValidArgsForVerifyLocation() error {
	return nil
}

func (m *GetLocationRequest) IsValidArgsForGetLocation() error {
	return nil
}

func (m *VerifyLocationRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovLocverify(uint64(m.Ver))
	}
	l = len(m.SessionCookie)
	if l > 0 {
		n += 1 + l + sovLocverify(uint64(l))
	}
	l = len(m.CarrierName)
	if l > 0 {
		n += 1 + l + sovLocverify(uint64(l))
	}
	if m.GpsLocation != nil {
		l = m.GpsLocation.Size()
		n += 1 + l + sovLocverify(uint64(l))
	}
	l = len(m.VerifyLocToken)
	if l > 0 {
		n += 1 + l + sovLocverify(uint64(l))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovLocverify(uint64(len(k))) + 1 + len(v) + sovLocverify(uint64(len(v)))
			n += mapEntrySize + 2 + sovLocverify(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VerifyLocationReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovLocverify(uint64(m.Ver))
	}
	if m.TowerStatus != 0 {
		n += 1 + sovLocverify(uint64(m.TowerStatus))
	}
	if m.GpsLocationStatus != 0 {
		n += 1 + sovLocverify(uint64(m.GpsLocationStatus))
	}
	if m.GpsLocationAccuracyKm != 0 {
		n += 9
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovLocverify(uint64(len(k))) + 1 + len(v) + sovLocverify(uint64(len(v)))
			n += mapEntrySize + 2 + sovLocverify(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetLocationRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovLocverify(uint64(m.Ver))
	}
	l = len(m.SessionCookie)
	if l > 0 {
		n += 1 + l + sovLocverify(uint64(l))
	}
	l = len(m.CarrierName)
	if l > 0 {
		n += 1 + l + sovLocverify(uint64(l))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovLocverify(uint64(len(k))) + 1 + len(v) + sovLocverify(uint64(len(v)))
			n += mapEntrySize + 2 + sovLocverify(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetLocationReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovLocverify(uint64(m.Ver))
	}
	if m.Status != 0 {
		n += 1 + sovLocverify(uint64(m.Status))
	}
	l = len(m.CarrierName)
	if l > 0 {
		n += 1 + l + sovLocverify(uint64(l))
	}
	if m.Tower != 0 {
		n += 1 + sovLocverify(uint64(m.Tower))
	}
	if m.NetworkLocation != nil {
		l = m.NetworkLocation.Size()
		n += 1 + l + sovLocverify(uint64(l))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovLocverify(uint64(len(k))) + 1 + len(v) + sovLocverify(uint64(len(v)))
			n += mapEntrySize + 2 + sovLocverify(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovLocverify(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozLocverify(x uint64) (n int) {
	return sovLocverify(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *VerifyLocationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocverify
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerifyLocationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerifyLocationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionCookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocverify
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLocverify
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionCookie = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CarrierName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocverify
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLocverify
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CarrierName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpsLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLocverify
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLocverify
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GpsLocation == nil {
				m.GpsLocation = &Loc{}
			}
			if err := m.GpsLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerifyLocToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocverify
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLocverify
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VerifyLocToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLocverify
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLocverify
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLocverify
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLocverify
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthLocverify
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthLocverify
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLocverify
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthLocverify
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthLocverify
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipLocverify(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthLocverify
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLocverify(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLocverify
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerifyLocationReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocverify
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerifyLocationReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerifyLocationReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TowerStatus", wireType)
			}
			m.TowerStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TowerStatus |= VerifyLocationReply_TowerStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpsLocationStatus", wireType)
			}
			m.GpsLocationStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GpsLocationStatus |= VerifyLocationReply_GPSLocationStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpsLocationAccuracyKm", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.GpsLocationAccuracyKm = float64(math.Float64frombits(v))
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLocverify
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLocverify
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLocverify
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLocverify
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthLocverify
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthLocverify
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLocverify
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthLocverify
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthLocverify
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipLocverify(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthLocverify
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLocverify(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLocverify
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetLocationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocverify
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetLocationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetLocationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionCookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocverify
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLocverify
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionCookie = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CarrierName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocverify
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLocverify
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CarrierName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLocverify
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLocverify
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLocverify
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLocverify
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthLocverify
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthLocverify
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLocverify
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthLocverify
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthLocverify
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipLocverify(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthLocverify
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLocverify(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLocverify
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetLocationReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocverify
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetLocationReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetLocationReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= GetLocationReply_LocStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CarrierName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocverify
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLocverify
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CarrierName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tower", wireType)
			}
			m.Tower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tower |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLocverify
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLocverify
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NetworkLocation == nil {
				m.NetworkLocation = &Loc{}
			}
			if err := m.NetworkLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLocverify
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLocverify
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLocverify
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLocverify
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthLocverify
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthLocverify
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLocverify
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthLocverify
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthLocverify
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipLocverify(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthLocverify
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLocverify(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLocverify
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipLocverify(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowLocverify
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLocverify
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLocverify
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthLocverify
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupLocverify
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthLocverify
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthLocverify        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowLocverify          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupLocverify = fmt.Errorf("proto: unexpected end of group")
)
