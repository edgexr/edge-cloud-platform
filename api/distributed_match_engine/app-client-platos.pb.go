// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: app-client-platos.proto

package distributed_match_engine

import (
	context "context"
	"encoding/json"
	"errors"
	fmt "fmt"
	"github.com/edgexr/edge-cloud-platform/pkg/util"
	_ "github.com/gogo/googleapis/google/api"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	"strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Status of the reply
type FqdnListReply_FLStatus int32

const (
	FqdnListReply_FL_UNDEFINED FqdnListReply_FLStatus = 0
	FqdnListReply_FL_SUCCESS   FqdnListReply_FLStatus = 1
	FqdnListReply_FL_FAIL      FqdnListReply_FLStatus = 2
)

var FqdnListReply_FLStatus_name = map[int32]string{
	0: "FL_UNDEFINED",
	1: "FL_SUCCESS",
	2: "FL_FAIL",
}

var FqdnListReply_FLStatus_value = map[string]int32{
	"FL_UNDEFINED": 0,
	"FL_SUCCESS":   1,
	"FL_FAIL":      2,
}

func (x FqdnListReply_FLStatus) String() string {
	return proto.EnumName(FqdnListReply_FLStatus_name, int32(x))
}

func (FqdnListReply_FLStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a94ce1e4d4bb2e49, []int{3, 0}
}

type PlatformFindCloudletRequest struct {
	//
	// API version
	//
	// _(hidden)_ Reserved for future use
	Ver uint32 `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	//
	// Session Cookie
	//
	// Session Cookie from RegisterClientRequest
	SessionCookie string `protobuf:"bytes,2,opt,name=session_cookie,json=sessionCookie,proto3" json:"session_cookie,omitempty"`
	//
	// Carrier Name
	//
	// _(optional)_ By default, all SDKs will automatically fill in this parameter with the MCC+MNC of your current provider. Only override this parameter if you need to filter for a specific carrier on the DME. The DME will filter for App instances that are associated with the specified carrier.
	// If you wish to search for any app instance on the DME regardless of carrier name, you can input “” to consider all carriers as “Any”.
	CarrierName string `protobuf:"bytes,3,opt,name=carrier_name,json=carrierName,proto3" json:"carrier_name,omitempty"`
	//
	// Client Token
	//
	// Token with encoded client data
	ClientToken string `protobuf:"bytes,4,opt,name=client_token,json=clientToken,proto3" json:"client_token,omitempty"`
	//
	// Tags
	//
	// _(optional)_ Vendor specific data
	Tags                 map[string]string `protobuf:"bytes,100,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *PlatformFindCloudletRequest) Reset()         { *m = PlatformFindCloudletRequest{} }
func (m *PlatformFindCloudletRequest) String() string { return proto.CompactTextString(m) }
func (*PlatformFindCloudletRequest) ProtoMessage()    {}
func (*PlatformFindCloudletRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_a94ce1e4d4bb2e49, []int{0}
}
func (m *PlatformFindCloudletRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlatformFindCloudletRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlatformFindCloudletRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlatformFindCloudletRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlatformFindCloudletRequest.Merge(m, src)
}
func (m *PlatformFindCloudletRequest) XXX_Size() int {
	return m.Size()
}
func (m *PlatformFindCloudletRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PlatformFindCloudletRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PlatformFindCloudletRequest proto.InternalMessageInfo

type FqdnListRequest struct {
	//
	// API version
	//
	// _(hidden)_ Reserved for future use
	Ver uint32 `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	// Session Cookie from RegisterClientRequest
	SessionCookie string `protobuf:"bytes,2,opt,name=session_cookie,json=sessionCookie,proto3" json:"session_cookie,omitempty"`
	// _(optional)_ Vendor specific data
	Tags                 map[string]string `protobuf:"bytes,100,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *FqdnListRequest) Reset()         { *m = FqdnListRequest{} }
func (m *FqdnListRequest) String() string { return proto.CompactTextString(m) }
func (*FqdnListRequest) ProtoMessage()    {}
func (*FqdnListRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_a94ce1e4d4bb2e49, []int{1}
}
func (m *FqdnListRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FqdnListRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FqdnListRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FqdnListRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FqdnListRequest.Merge(m, src)
}
func (m *FqdnListRequest) XXX_Size() int {
	return m.Size()
}
func (m *FqdnListRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FqdnListRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FqdnListRequest proto.InternalMessageInfo

type AppFqdn struct {
	// App  Name
	AppName string `protobuf:"bytes,1,opt,name=app_name,json=appName,proto3" json:"app_name,omitempty"`
	// App Version
	AppVers string `protobuf:"bytes,2,opt,name=app_vers,json=appVers,proto3" json:"app_vers,omitempty"`
	// App organization name
	OrgName string `protobuf:"bytes,3,opt,name=org_name,json=orgName,proto3" json:"org_name,omitempty"`
	// App FQDN
	Fqdns []string `protobuf:"bytes,4,rep,name=fqdns,proto3" json:"fqdns,omitempty"`
	// _(optional)_ Android package name
	AndroidPackageName   string   `protobuf:"bytes,5,opt,name=android_package_name,json=androidPackageName,proto3" json:"android_package_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AppFqdn) Reset()         { *m = AppFqdn{} }
func (m *AppFqdn) String() string { return proto.CompactTextString(m) }
func (*AppFqdn) ProtoMessage()    {}
func (*AppFqdn) Descriptor() ([]byte, []int) {
	return fileDescriptor_a94ce1e4d4bb2e49, []int{2}
}
func (m *AppFqdn) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppFqdn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppFqdn.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppFqdn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppFqdn.Merge(m, src)
}
func (m *AppFqdn) XXX_Size() int {
	return m.Size()
}
func (m *AppFqdn) XXX_DiscardUnknown() {
	xxx_messageInfo_AppFqdn.DiscardUnknown(m)
}

var xxx_messageInfo_AppFqdn proto.InternalMessageInfo

type FqdnListReply struct {
	//
	// API version
	//
	// _(hidden)_ Reserved for future use
	Ver      uint32                 `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	AppFqdns []*AppFqdn             `protobuf:"bytes,3,rep,name=app_fqdns,json=appFqdns,proto3" json:"app_fqdns,omitempty"`
	Status   FqdnListReply_FLStatus `protobuf:"varint,4,opt,name=status,proto3,enum=distributed_match_engine.FqdnListReply_FLStatus" json:"status,omitempty"`
	// _(optional)_ Vendor specific data
	Tags                 map[string]string `protobuf:"bytes,100,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *FqdnListReply) Reset()         { *m = FqdnListReply{} }
func (m *FqdnListReply) String() string { return proto.CompactTextString(m) }
func (*FqdnListReply) ProtoMessage()    {}
func (*FqdnListReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_a94ce1e4d4bb2e49, []int{3}
}
func (m *FqdnListReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FqdnListReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FqdnListReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FqdnListReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FqdnListReply.Merge(m, src)
}
func (m *FqdnListReply) XXX_Size() int {
	return m.Size()
}
func (m *FqdnListReply) XXX_DiscardUnknown() {
	xxx_messageInfo_FqdnListReply.DiscardUnknown(m)
}

var xxx_messageInfo_FqdnListReply proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("distributed_match_engine.FqdnListReply_FLStatus", FqdnListReply_FLStatus_name, FqdnListReply_FLStatus_value)
	proto.RegisterType((*PlatformFindCloudletRequest)(nil), "distributed_match_engine.PlatformFindCloudletRequest")
	proto.RegisterMapType((map[string]string)(nil), "distributed_match_engine.PlatformFindCloudletRequest.TagsEntry")
	proto.RegisterType((*FqdnListRequest)(nil), "distributed_match_engine.FqdnListRequest")
	proto.RegisterMapType((map[string]string)(nil), "distributed_match_engine.FqdnListRequest.TagsEntry")
	proto.RegisterType((*AppFqdn)(nil), "distributed_match_engine.AppFqdn")
	proto.RegisterType((*FqdnListReply)(nil), "distributed_match_engine.FqdnListReply")
	proto.RegisterMapType((map[string]string)(nil), "distributed_match_engine.FqdnListReply.TagsEntry")
}

func init() { proto.RegisterFile("app-client-platos.proto", fileDescriptor_a94ce1e4d4bb2e49) }

var fileDescriptor_a94ce1e4d4bb2e49 = []byte{
	// 656 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x54, 0xcb, 0x6e, 0xd3, 0x4c,
	0x18, 0xad, 0x9d, 0xb4, 0x69, 0x26, 0xbd, 0x58, 0xa3, 0x48, 0xbf, 0xff, 0x00, 0x51, 0x6a, 0x84,
	0x28, 0xa0, 0x26, 0xbd, 0x08, 0x01, 0x5d, 0x80, 0x4a, 0x1a, 0x97, 0xa2, 0xa8, 0x54, 0x4e, 0xcb,
	0xd6, 0x9a, 0xda, 0x53, 0x33, 0x8a, 0x33, 0x33, 0xf5, 0x4c, 0x22, 0x65, 0xc1, 0x86, 0x57, 0xe0,
	0x01, 0x90, 0x58, 0x22, 0xf1, 0x1e, 0x5d, 0x22, 0xb1, 0x64, 0x03, 0x15, 0xe2, 0x39, 0xd0, 0x8c,
	0x1d, 0x4a, 0x51, 0x5b, 0x45, 0xd0, 0x9d, 0xe7, 0xbb, 0x9c, 0x39, 0xe7, 0x3b, 0xf3, 0x19, 0xfc,
	0x87, 0x38, 0x5f, 0x0a, 0x62, 0x82, 0xa9, 0x5c, 0xe2, 0x31, 0x92, 0x4c, 0xd4, 0x79, 0xc2, 0x24,
	0x83, 0x76, 0x48, 0x84, 0x4c, 0xc8, 0x41, 0x5f, 0xe2, 0xd0, 0xef, 0x21, 0x19, 0xbc, 0xf2, 0x31,
	0x8d, 0x08, 0xc5, 0x95, 0xeb, 0x11, 0x63, 0x51, 0x8c, 0x1b, 0x88, 0x93, 0x06, 0xa2, 0x94, 0x49,
	0x24, 0x09, 0xa3, 0x59, 0x5f, 0xc5, 0x3a, 0x05, 0x4c, 0x23, 0xce, 0x07, 0x13, 0x5c, 0xdb, 0x8d,
	0x91, 0x3c, 0x64, 0x49, 0xcf, 0x25, 0x34, 0x6c, 0xc6, 0xac, 0x1f, 0xc6, 0x58, 0x7a, 0xf8, 0xa8,
	0x8f, 0x85, 0x84, 0x16, 0xc8, 0x0d, 0x70, 0x62, 0x1b, 0x35, 0x63, 0x71, 0xd6, 0x53, 0x9f, 0xf0,
	0x16, 0x98, 0x13, 0x58, 0x08, 0xc2, 0xa8, 0x1f, 0x30, 0xd6, 0x25, 0xd8, 0x36, 0x6b, 0xc6, 0x62,
	0xd1, 0x9b, 0xcd, 0xa2, 0x4d, 0x1d, 0x84, 0x0b, 0x60, 0x26, 0x40, 0x49, 0x42, 0x70, 0xe2, 0x53,
	0xd4, 0xc3, 0x76, 0x4e, 0x17, 0x95, 0xb2, 0xd8, 0x0e, 0xea, 0xa5, 0x25, 0x9a, 0x8b, 0x2f, 0x59,
	0x17, 0x53, 0x3b, 0x9f, 0x95, 0xe8, 0xd8, 0x9e, 0x0a, 0xc1, 0x0e, 0xc8, 0x4b, 0x14, 0x09, 0x3b,
	0xac, 0xe5, 0x16, 0x4b, 0xab, 0x4f, 0xea, 0x17, 0xe9, 0xae, 0x5f, 0xa2, 0xa1, 0xbe, 0x87, 0x22,
	0xd1, 0xa2, 0x32, 0x19, 0x7a, 0x1a, 0xac, 0xf2, 0x00, 0x14, 0x7f, 0x85, 0x94, 0xc0, 0x2e, 0x1e,
	0x6a, 0x81, 0x45, 0x4f, 0x7d, 0xc2, 0x32, 0x98, 0x1c, 0xa0, 0xb8, 0x3f, 0xd2, 0x95, 0x1e, 0xd6,
	0xcd, 0x87, 0x86, 0xf3, 0xc5, 0x00, 0xf3, 0xee, 0x51, 0x48, 0xdb, 0x44, 0xfc, 0xfb, 0x80, 0xb6,
	0xce, 0x48, 0x5b, 0xbb, 0x58, 0xda, 0x1f, 0x37, 0x5e, 0x99, 0x9c, 0xe7, 0xf9, 0xe9, 0x9c, 0x95,
	0xf7, 0x0a, 0x01, 0x8e, 0x63, 0x9f, 0x84, 0xce, 0x7b, 0x03, 0x14, 0x36, 0x38, 0x57, 0xd7, 0xc1,
	0xff, 0xc1, 0x34, 0xe2, 0x3c, 0x75, 0x2e, 0xc5, 0x2a, 0x20, 0xce, 0xb5, 0x6b, 0x59, 0x6a, 0x80,
	0x13, 0x91, 0x41, 0xaa, 0xd4, 0x4b, 0x9c, 0x08, 0x95, 0x62, 0x49, 0xf4, 0xbb, 0xdf, 0x05, 0x96,
	0x44, 0xba, 0xab, 0x0c, 0x26, 0x0f, 0x8f, 0x42, 0x2a, 0xec, 0x7c, 0x2d, 0xa7, 0x58, 0xe8, 0x03,
	0x5c, 0x06, 0x65, 0x44, 0xc3, 0x84, 0x91, 0xd0, 0xe7, 0x28, 0xe8, 0xa2, 0x08, 0xa7, 0xcd, 0x93,
	0xba, 0x19, 0x66, 0xb9, 0xdd, 0x34, 0xa5, 0x70, 0x9c, 0x1f, 0x26, 0x98, 0x3d, 0x1d, 0x08, 0x8f,
	0x87, 0xe7, 0x18, 0xf0, 0x18, 0x14, 0x15, 0xc3, 0xf4, 0xbe, 0x9c, 0x1e, 0xef, 0xc2, 0xc5, 0xe3,
	0xcd, 0x24, 0x7b, 0x4a, 0x95, 0xab, 0x59, 0x3d, 0x03, 0x53, 0x42, 0x22, 0xd9, 0x17, 0xfa, 0x45,
	0xce, 0xad, 0x2e, 0x8f, 0xe3, 0x0d, 0x8f, 0x87, 0x75, 0xb7, 0xdd, 0xd1, 0x7d, 0x5e, 0xd6, 0x0f,
	0x5b, 0x67, 0x3c, 0x5e, 0x19, 0x17, 0xe7, 0xca, 0x1e, 0xec, 0x23, 0x30, 0x3d, 0xe2, 0x04, 0x2d,
	0x30, 0xe3, 0xb6, 0xfd, 0xfd, 0x9d, 0xcd, 0x96, 0xbb, 0xbd, 0xd3, 0xda, 0xb4, 0x26, 0xe0, 0x1c,
	0x00, 0x6e, 0xdb, 0xef, 0xec, 0x37, 0x9b, 0xad, 0x4e, 0xc7, 0x32, 0x60, 0x09, 0x14, 0xdc, 0xb6,
	0xef, 0x6e, 0x6c, 0xb7, 0x2d, 0x73, 0xf5, 0xa3, 0x09, 0xc0, 0x68, 0xa9, 0x5e, 0x74, 0xe0, 0x3b,
	0x03, 0x94, 0xcf, 0xdb, 0x31, 0x78, 0xff, 0xaf, 0x76, 0xb2, 0x72, 0xef, 0x92, 0x59, 0x9c, 0x29,
	0xe7, 0xf1, 0xd0, 0xb9, 0xf9, 0xe6, 0xf3, 0xf7, 0xb7, 0xe6, 0x0d, 0xc7, 0x6e, 0x0c, 0x56, 0x1a,
	0x3c, 0x43, 0x3d, 0x24, 0x34, 0x0c, 0xb2, 0xb2, 0x75, 0xe3, 0x2e, 0x7c, 0x0d, 0x4a, 0x5b, 0x58,
	0x8e, 0x06, 0x09, 0xef, 0x8c, 0xbd, 0x50, 0x95, 0xdb, 0x63, 0xfa, 0xe2, 0x54, 0x34, 0x8f, 0xb2,
	0x33, 0xaf, 0x78, 0x44, 0x58, 0xaa, 0x17, 0x16, 0x13, 0xa1, 0xae, 0x7f, 0x6a, 0x1d, 0x7f, 0xab,
	0x4e, 0x1c, 0x9f, 0x54, 0x8d, 0x4f, 0x27, 0x55, 0xe3, 0xeb, 0x49, 0xd5, 0x38, 0x98, 0xd2, 0x7f,
	0xd8, 0xb5, 0x9f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x79, 0x41, 0x2b, 0x6f, 0xc6, 0x05, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// PlatformOSClient is the client API for PlatformOS service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type PlatformOSClient interface {
	//
	// PlatformFindCloudlet
	//
	// Similar to FindCloudlet, except uses a token for client data.
	// This API is only applicable for Platform Applications.
	PlatformFindCloudlet(ctx context.Context, in *PlatformFindCloudletRequest, opts ...grpc.CallOption) (*FindCloudletReply, error)
	GetFqdnList(ctx context.Context, in *FqdnListRequest, opts ...grpc.CallOption) (*FqdnListReply, error)
}

type platformOSClient struct {
	cc *grpc.ClientConn
}

func NewPlatformOSClient(cc *grpc.ClientConn) PlatformOSClient {
	return &platformOSClient{cc}
}

func (c *platformOSClient) PlatformFindCloudlet(ctx context.Context, in *PlatformFindCloudletRequest, opts ...grpc.CallOption) (*FindCloudletReply, error) {
	out := new(FindCloudletReply)
	err := c.cc.Invoke(ctx, "/distributed_match_engine.PlatformOS/PlatformFindCloudlet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *platformOSClient) GetFqdnList(ctx context.Context, in *FqdnListRequest, opts ...grpc.CallOption) (*FqdnListReply, error) {
	out := new(FqdnListReply)
	err := c.cc.Invoke(ctx, "/distributed_match_engine.PlatformOS/GetFqdnList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PlatformOSServer is the server API for PlatformOS service.
type PlatformOSServer interface {
	//
	// PlatformFindCloudlet
	//
	// Similar to FindCloudlet, except uses a token for client data.
	// This API is only applicable for Platform Applications.
	PlatformFindCloudlet(context.Context, *PlatformFindCloudletRequest) (*FindCloudletReply, error)
	GetFqdnList(context.Context, *FqdnListRequest) (*FqdnListReply, error)
}

// UnimplementedPlatformOSServer can be embedded to have forward compatible implementations.
type UnimplementedPlatformOSServer struct {
}

func (*UnimplementedPlatformOSServer) PlatformFindCloudlet(ctx context.Context, req *PlatformFindCloudletRequest) (*FindCloudletReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PlatformFindCloudlet not implemented")
}
func (*UnimplementedPlatformOSServer) GetFqdnList(ctx context.Context, req *FqdnListRequest) (*FqdnListReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFqdnList not implemented")
}

func RegisterPlatformOSServer(s *grpc.Server, srv PlatformOSServer) {
	s.RegisterService(&_PlatformOS_serviceDesc, srv)
}

func _PlatformOS_PlatformFindCloudlet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlatformFindCloudletRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformOSServer).PlatformFindCloudlet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/distributed_match_engine.PlatformOS/PlatformFindCloudlet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformOSServer).PlatformFindCloudlet(ctx, req.(*PlatformFindCloudletRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PlatformOS_GetFqdnList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FqdnListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformOSServer).GetFqdnList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/distributed_match_engine.PlatformOS/GetFqdnList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformOSServer).GetFqdnList(ctx, req.(*FqdnListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _PlatformOS_serviceDesc = grpc.ServiceDesc{
	ServiceName: "distributed_match_engine.PlatformOS",
	HandlerType: (*PlatformOSServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PlatformFindCloudlet",
			Handler:    _PlatformOS_PlatformFindCloudlet_Handler,
		},
		{
			MethodName: "GetFqdnList",
			Handler:    _PlatformOS_GetFqdnList_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "app-client-platos.proto",
}

func (m *PlatformFindCloudletRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlatformFindCloudletRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PlatformFindCloudletRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Tags) > 0 {
		for k := range m.Tags {
			v := m.Tags[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAppClientPlatos(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAppClientPlatos(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAppClientPlatos(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.ClientToken) > 0 {
		i -= len(m.ClientToken)
		copy(dAtA[i:], m.ClientToken)
		i = encodeVarintAppClientPlatos(dAtA, i, uint64(len(m.ClientToken)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.CarrierName) > 0 {
		i -= len(m.CarrierName)
		copy(dAtA[i:], m.CarrierName)
		i = encodeVarintAppClientPlatos(dAtA, i, uint64(len(m.CarrierName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SessionCookie) > 0 {
		i -= len(m.SessionCookie)
		copy(dAtA[i:], m.SessionCookie)
		i = encodeVarintAppClientPlatos(dAtA, i, uint64(len(m.SessionCookie)))
		i--
		dAtA[i] = 0x12
	}
	if m.Ver != 0 {
		i = encodeVarintAppClientPlatos(dAtA, i, uint64(m.Ver))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FqdnListRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FqdnListRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FqdnListRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Tags) > 0 {
		for k := range m.Tags {
			v := m.Tags[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAppClientPlatos(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAppClientPlatos(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAppClientPlatos(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.SessionCookie) > 0 {
		i -= len(m.SessionCookie)
		copy(dAtA[i:], m.SessionCookie)
		i = encodeVarintAppClientPlatos(dAtA, i, uint64(len(m.SessionCookie)))
		i--
		dAtA[i] = 0x12
	}
	if m.Ver != 0 {
		i = encodeVarintAppClientPlatos(dAtA, i, uint64(m.Ver))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AppFqdn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppFqdn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppFqdn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AndroidPackageName) > 0 {
		i -= len(m.AndroidPackageName)
		copy(dAtA[i:], m.AndroidPackageName)
		i = encodeVarintAppClientPlatos(dAtA, i, uint64(len(m.AndroidPackageName)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Fqdns) > 0 {
		for iNdEx := len(m.Fqdns) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Fqdns[iNdEx])
			copy(dAtA[i:], m.Fqdns[iNdEx])
			i = encodeVarintAppClientPlatos(dAtA, i, uint64(len(m.Fqdns[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.OrgName) > 0 {
		i -= len(m.OrgName)
		copy(dAtA[i:], m.OrgName)
		i = encodeVarintAppClientPlatos(dAtA, i, uint64(len(m.OrgName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AppVers) > 0 {
		i -= len(m.AppVers)
		copy(dAtA[i:], m.AppVers)
		i = encodeVarintAppClientPlatos(dAtA, i, uint64(len(m.AppVers)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AppName) > 0 {
		i -= len(m.AppName)
		copy(dAtA[i:], m.AppName)
		i = encodeVarintAppClientPlatos(dAtA, i, uint64(len(m.AppName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FqdnListReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FqdnListReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FqdnListReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Tags) > 0 {
		for k := range m.Tags {
			v := m.Tags[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAppClientPlatos(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAppClientPlatos(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAppClientPlatos(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa2
		}
	}
	if m.Status != 0 {
		i = encodeVarintAppClientPlatos(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x20
	}
	if len(m.AppFqdns) > 0 {
		for iNdEx := len(m.AppFqdns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AppFqdns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAppClientPlatos(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Ver != 0 {
		i = encodeVarintAppClientPlatos(dAtA, i, uint64(m.Ver))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintAppClientPlatos(dAtA []byte, offset int, v uint64) int {
	offset -= sovAppClientPlatos(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *PlatformFindCloudletRequest) Clone() *PlatformFindCloudletRequest {
	cp := &PlatformFindCloudletRequest{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *PlatformFindCloudletRequest) CopyInFields(src *PlatformFindCloudletRequest) int {
	updateListAction := "replace"
	changed := 0
	if m.Ver != src.Ver {
		m.Ver = src.Ver
		changed++
	}
	if m.SessionCookie != src.SessionCookie {
		m.SessionCookie = src.SessionCookie
		changed++
	}
	if m.CarrierName != src.CarrierName {
		m.CarrierName = src.CarrierName
		changed++
	}
	if m.ClientToken != src.ClientToken {
		m.ClientToken = src.ClientToken
		changed++
	}
	if src.Tags != nil {
		if updateListAction == "add" {
			for k0, v := range src.Tags {
				m.Tags[k0] = v
				changed++
			}
		} else if updateListAction == "remove" {
			for k0, _ := range src.Tags {
				if _, ok := m.Tags[k0]; ok {
					delete(m.Tags, k0)
					changed++
				}
			}
		} else {
			m.Tags = make(map[string]string)
			for k0, v := range src.Tags {
				m.Tags[k0] = v
			}
			changed++
		}
	} else if m.Tags != nil {
		m.Tags = nil
		changed++
	}
	return changed
}

func (m *PlatformFindCloudletRequest) DeepCopyIn(src *PlatformFindCloudletRequest) {
	m.Ver = src.Ver
	m.SessionCookie = src.SessionCookie
	m.CarrierName = src.CarrierName
	m.ClientToken = src.ClientToken
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k, v := range src.Tags {
			m.Tags[k] = v
		}
	} else {
		m.Tags = nil
	}
}

// Helper method to check that enums have valid values
func (m *PlatformFindCloudletRequest) ValidateEnums() error {
	return nil
}

func (s *PlatformFindCloudletRequest) ClearTagged(tags map[string]struct{}) {
}

func (m *FqdnListRequest) Clone() *FqdnListRequest {
	cp := &FqdnListRequest{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *FqdnListRequest) CopyInFields(src *FqdnListRequest) int {
	updateListAction := "replace"
	changed := 0
	if m.Ver != src.Ver {
		m.Ver = src.Ver
		changed++
	}
	if m.SessionCookie != src.SessionCookie {
		m.SessionCookie = src.SessionCookie
		changed++
	}
	if src.Tags != nil {
		if updateListAction == "add" {
			for k0, v := range src.Tags {
				m.Tags[k0] = v
				changed++
			}
		} else if updateListAction == "remove" {
			for k0, _ := range src.Tags {
				if _, ok := m.Tags[k0]; ok {
					delete(m.Tags, k0)
					changed++
				}
			}
		} else {
			m.Tags = make(map[string]string)
			for k0, v := range src.Tags {
				m.Tags[k0] = v
			}
			changed++
		}
	} else if m.Tags != nil {
		m.Tags = nil
		changed++
	}
	return changed
}

func (m *FqdnListRequest) DeepCopyIn(src *FqdnListRequest) {
	m.Ver = src.Ver
	m.SessionCookie = src.SessionCookie
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k, v := range src.Tags {
			m.Tags[k] = v
		}
	} else {
		m.Tags = nil
	}
}

// Helper method to check that enums have valid values
func (m *FqdnListRequest) ValidateEnums() error {
	return nil
}

func (s *FqdnListRequest) ClearTagged(tags map[string]struct{}) {
}

func (m *AppFqdn) Clone() *AppFqdn {
	cp := &AppFqdn{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *AppFqdn) AddFqdns(vals ...string) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.Fqdns {
		cur[v] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v]; found {
			continue // duplicate
		}
		m.Fqdns = append(m.Fqdns, v)
		changes++
	}
	return changes
}

func (m *AppFqdn) RemoveFqdns(vals ...string) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v] = struct{}{}
	}
	for i := len(m.Fqdns); i >= 0; i-- {
		if _, found := remove[m.Fqdns[i]]; found {
			m.Fqdns = append(m.Fqdns[:i], m.Fqdns[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *AppFqdn) CopyInFields(src *AppFqdn) int {
	updateListAction := "replace"
	changed := 0
	if m.AppName != src.AppName {
		m.AppName = src.AppName
		changed++
	}
	if m.AppVers != src.AppVers {
		m.AppVers = src.AppVers
		changed++
	}
	if m.OrgName != src.OrgName {
		m.OrgName = src.OrgName
		changed++
	}
	if src.Fqdns != nil {
		if updateListAction == "add" {
			changed += m.AddFqdns(src.Fqdns...)
		} else if updateListAction == "remove" {
			changed += m.RemoveFqdns(src.Fqdns...)
		} else {
			m.Fqdns = make([]string, 0)
			m.Fqdns = append(m.Fqdns, src.Fqdns...)
			changed++
		}
	} else if m.Fqdns != nil {
		m.Fqdns = nil
		changed++
	}
	if m.AndroidPackageName != src.AndroidPackageName {
		m.AndroidPackageName = src.AndroidPackageName
		changed++
	}
	return changed
}

func (m *AppFqdn) DeepCopyIn(src *AppFqdn) {
	m.AppName = src.AppName
	m.AppVers = src.AppVers
	m.OrgName = src.OrgName
	if src.Fqdns != nil {
		m.Fqdns = make([]string, len(src.Fqdns), len(src.Fqdns))
		for ii, s := range src.Fqdns {
			m.Fqdns[ii] = s
		}
	} else {
		m.Fqdns = nil
	}
	m.AndroidPackageName = src.AndroidPackageName
}

// Helper method to check that enums have valid values
func (m *AppFqdn) ValidateEnums() error {
	return nil
}

func (s *AppFqdn) ClearTagged(tags map[string]struct{}) {
}

func (m *FqdnListReply) Clone() *FqdnListReply {
	cp := &FqdnListReply{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *FqdnListReply) AddAppFqdns(vals ...*AppFqdn) int {
	changes := 0
	cur := make(map[string]struct{})
	for _, v := range m.AppFqdns {
		cur[v.String()] = struct{}{}
	}
	for _, v := range vals {
		if _, found := cur[v.String()]; found {
			continue // duplicate
		}
		m.AppFqdns = append(m.AppFqdns, v)
		changes++
	}
	return changes
}

func (m *FqdnListReply) RemoveAppFqdns(vals ...*AppFqdn) int {
	changes := 0
	remove := make(map[string]struct{})
	for _, v := range vals {
		remove[v.String()] = struct{}{}
	}
	for i := len(m.AppFqdns); i >= 0; i-- {
		if _, found := remove[m.AppFqdns[i].String()]; found {
			m.AppFqdns = append(m.AppFqdns[:i], m.AppFqdns[i+1:]...)
			changes++
		}
	}
	return changes
}

func (m *FqdnListReply) CopyInFields(src *FqdnListReply) int {
	updateListAction := "replace"
	changed := 0
	if m.Ver != src.Ver {
		m.Ver = src.Ver
		changed++
	}
	if src.AppFqdns != nil {
		if updateListAction == "add" {
			changed += m.AddAppFqdns(src.AppFqdns...)
		} else if updateListAction == "remove" {
			changed += m.RemoveAppFqdns(src.AppFqdns...)
		} else {
			m.AppFqdns = make([]*AppFqdn, 0)
			for k0, _ := range src.AppFqdns {
				m.AppFqdns = append(m.AppFqdns, src.AppFqdns[k0].Clone())
			}
			changed++
		}
	} else if m.AppFqdns != nil {
		m.AppFqdns = nil
		changed++
	}
	if m.Status != src.Status {
		m.Status = src.Status
		changed++
	}
	if src.Tags != nil {
		if updateListAction == "add" {
			for k0, v := range src.Tags {
				m.Tags[k0] = v
				changed++
			}
		} else if updateListAction == "remove" {
			for k0, _ := range src.Tags {
				if _, ok := m.Tags[k0]; ok {
					delete(m.Tags, k0)
					changed++
				}
			}
		} else {
			m.Tags = make(map[string]string)
			for k0, v := range src.Tags {
				m.Tags[k0] = v
			}
			changed++
		}
	} else if m.Tags != nil {
		m.Tags = nil
		changed++
	}
	return changed
}

func (m *FqdnListReply) DeepCopyIn(src *FqdnListReply) {
	m.Ver = src.Ver
	if src.AppFqdns != nil {
		m.AppFqdns = make([]*AppFqdn, len(src.AppFqdns), len(src.AppFqdns))
		for ii, s := range src.AppFqdns {
			var tmp_s AppFqdn
			tmp_s.DeepCopyIn(s)
			m.AppFqdns[ii] = &tmp_s
		}
	} else {
		m.AppFqdns = nil
	}
	m.Status = src.Status
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k, v := range src.Tags {
			m.Tags[k] = v
		}
	} else {
		m.Tags = nil
	}
}

// Helper method to check that enums have valid values
func (m *FqdnListReply) ValidateEnums() error {
	for _, e := range m.AppFqdns {
		if err := e.ValidateEnums(); err != nil {
			return err
		}
	}
	if _, ok := FqdnListReply_FLStatus_name[int32(m.Status)]; !ok {
		return errors.New("invalid Status")
	}
	return nil
}

func (s *FqdnListReply) ClearTagged(tags map[string]struct{}) {
	if s.AppFqdns != nil {
		for ii := 0; ii < len(s.AppFqdns); ii++ {
			s.AppFqdns[ii].ClearTagged(tags)
		}
	}
}

var FLStatusStrings = []string{
	"FL_UNDEFINED",
	"FL_SUCCESS",
	"FL_FAIL",
}

const (
	FLStatusFL_UNDEFINED uint64 = 1 << 0
	FLStatusFL_SUCCESS   uint64 = 1 << 1
	FLStatusFL_FAIL      uint64 = 1 << 2
)

var FqdnListReply_FLStatus_CamelName = map[int32]string{
	// FL_UNDEFINED -> FlUndefined
	0: "FlUndefined",
	// FL_SUCCESS -> FlSuccess
	1: "FlSuccess",
	// FL_FAIL -> FlFail
	2: "FlFail",
}
var FqdnListReply_FLStatus_CamelValue = map[string]int32{
	"FlUndefined": 0,
	"FlSuccess":   1,
	"FlFail":      2,
}

func ParseFqdnListReply_FLStatus(data interface{}) (FqdnListReply_FLStatus, error) {
	if val, ok := data.(FqdnListReply_FLStatus); ok {
		return val, nil
	} else if str, ok := data.(string); ok {
		val, ok := FqdnListReply_FLStatus_CamelValue[util.CamelCase(str)]
		if !ok {
			// may have omitted common prefix
			val, ok = FqdnListReply_FLStatus_CamelValue["Fl"+util.CamelCase(str)]
		}
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = FqdnListReply_FLStatus_CamelName[val]
			}
		}
		if !ok {
			return FqdnListReply_FLStatus(0), fmt.Errorf("Invalid FqdnListReply_FLStatus value %q", str)
		}
		return FqdnListReply_FLStatus(val), nil
	} else if ival, ok := data.(int32); ok {
		if _, ok := FqdnListReply_FLStatus_CamelName[ival]; ok {
			return FqdnListReply_FLStatus(ival), nil
		} else {
			return FqdnListReply_FLStatus(0), fmt.Errorf("Invalid FqdnListReply_FLStatus value %d", ival)
		}
	}
	return FqdnListReply_FLStatus(0), fmt.Errorf("Invalid FqdnListReply_FLStatus value %v", data)
}

func (e *FqdnListReply_FLStatus) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, err := ParseFqdnListReply_FLStatus(str)
	if err != nil {
		return err
	}
	*e = val
	return nil
}

func (e FqdnListReply_FLStatus) MarshalYAML() (interface{}, error) {
	str := proto.EnumName(FqdnListReply_FLStatus_CamelName, int32(e))
	str = strings.TrimPrefix(str, "Fl")
	return str, nil
}

// custom JSON encoding/decoding
func (e *FqdnListReply_FLStatus) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, err := ParseFqdnListReply_FLStatus(str)
		if err != nil {
			return &json.UnmarshalTypeError{
				Value: "string " + str,
				Type:  reflect.TypeOf(FqdnListReply_FLStatus(0)),
			}
		}
		*e = FqdnListReply_FLStatus(val)
		return nil
	}
	var ival int32
	err = json.Unmarshal(b, &ival)
	if err == nil {
		val, err := ParseFqdnListReply_FLStatus(ival)
		if err == nil {
			*e = val
			return nil
		}
	}
	return &json.UnmarshalTypeError{
		Value: "value " + string(b),
		Type:  reflect.TypeOf(FqdnListReply_FLStatus(0)),
	}
}

func (e FqdnListReply_FLStatus) MarshalJSON() ([]byte, error) {
	str := proto.EnumName(FqdnListReply_FLStatus_CamelName, int32(e))
	str = strings.TrimPrefix(str, "Fl")
	return json.Marshal(str)
}

var FLStatusCommonPrefix = "Fl"

func (m *PlatformFindCloudletRequest) IsValidArgsForPlatformFindCloudlet() error {
	return nil
}

func (m *FqdnListRequest) IsValidArgsForGetFqdnList() error {
	return nil
}

type MatchOptions struct {
	// Filter will ignore 0 or nil fields on the passed in object
	Filter bool
	// IgnoreBackend will ignore fields that were marked backend in .proto
	IgnoreBackend bool
	// Sort repeated (arrays) of Key objects so matching does not
	// fail due to order.
	SortArrayedKeys bool
}

type MatchOpt func(*MatchOptions)

func MatchFilter() MatchOpt {
	return func(opts *MatchOptions) {
		opts.Filter = true
	}
}

func MatchIgnoreBackend() MatchOpt {
	return func(opts *MatchOptions) {
		opts.IgnoreBackend = true
	}
}

func MatchSortArrayedKeys() MatchOpt {
	return func(opts *MatchOptions) {
		opts.SortArrayedKeys = true
	}
}

func applyMatchOptions(opts *MatchOptions, args ...MatchOpt) {
	for _, f := range args {
		f(opts)
	}
}

// DecodeHook for use with the mapstructure package.
// Allows decoding to handle protobuf enums that are
// represented as strings.
func EnumDecodeHook(from, to reflect.Type, data interface{}) (interface{}, error) {
	switch to {
	case reflect.TypeOf(LProto(0)):
		return ParseLProto(data)
	case reflect.TypeOf(HealthCheck(0)):
		return ParseHealthCheck(data)
	case reflect.TypeOf(CloudletState(0)):
		return ParseCloudletState(data)
	case reflect.TypeOf(MaintenanceState(0)):
		return ParseMaintenanceState(data)
	case reflect.TypeOf(ReplyStatus(0)):
		return ParseReplyStatus(data)
	case reflect.TypeOf(IDTypes(0)):
		return ParseIDTypes(data)
	case reflect.TypeOf(QosSessionProfile(0)):
		return ParseQosSessionProfile(data)
	case reflect.TypeOf(QosSessionProtocol(0)):
		return ParseQosSessionProtocol(data)
	}
	return data, nil
}

// GetEnumParseHelp gets end-user specific messages for
// enum parse errors.
// It returns the enum type name, a help message with
// valid values, and a bool that indicates if a type was matched.
func GetEnumParseHelp(t reflect.Type) (string, string, bool) {
	switch t {
	case reflect.TypeOf(LProto(0)):
		return "LProto", ", valid values are one of Unknown, Tcp, Udp, or 0, 1, 2", true
	case reflect.TypeOf(HealthCheck(0)):
		return "HealthCheck", ", valid values are one of Unknown, RootlbOffline, ServerFail, Ok, CloudletOffline, or 0, 1, 2, 3, 4", true
	case reflect.TypeOf(CloudletState(0)):
		return "CloudletState", ", valid values are one of Unknown, Errors, Ready, Offline, NotPresent, Init, Upgrade, NeedSync, or 0, 1, 2, 3, 4, 5, 6, 7", true
	case reflect.TypeOf(MaintenanceState(0)):
		return "MaintenanceState", ", valid values are one of NormalOperation, MaintenanceStart, FailoverRequested, FailoverDone, FailoverError, MaintenanceStartNoFailover, CrmRequested, CrmUnderMaintenance, CrmError, NormalOperationInit, UnderMaintenance, or 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 31", true
	case reflect.TypeOf(ReplyStatus(0)):
		return "ReplyStatus", ", valid values are one of Undefined, Success, Fail, or 0, 1, 2", true
	case reflect.TypeOf(IDTypes(0)):
		return "IDTypes", ", valid values are one of IdUndefined, Imei, Msisdn, Ipaddr, or 0, 1, 2, 3", true
	case reflect.TypeOf(QosSessionProfile(0)):
		return "QosSessionProfile", ", valid values are one of NoPriority, LowLatency, ThroughputDownS, ThroughputDownM, ThroughputDownL, or 0, 1, 2, 3, 4", true
	case reflect.TypeOf(QosSessionProtocol(0)):
		return "QosSessionProtocol", ", valid values are one of Tcp, Udp, Any, or 0, 1, 2", true
	}
	return "", "", false
}

var ShowMethodNames = map[string]struct{}{}

func IsShow(cmd string) bool {
	_, found := ShowMethodNames[cmd]
	return found
}

func (m *PlatformFindCloudletRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClientPlatos(uint64(m.Ver))
	}
	l = len(m.SessionCookie)
	if l > 0 {
		n += 1 + l + sovAppClientPlatos(uint64(l))
	}
	l = len(m.CarrierName)
	if l > 0 {
		n += 1 + l + sovAppClientPlatos(uint64(l))
	}
	l = len(m.ClientToken)
	if l > 0 {
		n += 1 + l + sovAppClientPlatos(uint64(l))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAppClientPlatos(uint64(len(k))) + 1 + len(v) + sovAppClientPlatos(uint64(len(v)))
			n += mapEntrySize + 2 + sovAppClientPlatos(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FqdnListRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClientPlatos(uint64(m.Ver))
	}
	l = len(m.SessionCookie)
	if l > 0 {
		n += 1 + l + sovAppClientPlatos(uint64(l))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAppClientPlatos(uint64(len(k))) + 1 + len(v) + sovAppClientPlatos(uint64(len(v)))
			n += mapEntrySize + 2 + sovAppClientPlatos(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AppFqdn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AppName)
	if l > 0 {
		n += 1 + l + sovAppClientPlatos(uint64(l))
	}
	l = len(m.AppVers)
	if l > 0 {
		n += 1 + l + sovAppClientPlatos(uint64(l))
	}
	l = len(m.OrgName)
	if l > 0 {
		n += 1 + l + sovAppClientPlatos(uint64(l))
	}
	if len(m.Fqdns) > 0 {
		for _, s := range m.Fqdns {
			l = len(s)
			n += 1 + l + sovAppClientPlatos(uint64(l))
		}
	}
	l = len(m.AndroidPackageName)
	if l > 0 {
		n += 1 + l + sovAppClientPlatos(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FqdnListReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovAppClientPlatos(uint64(m.Ver))
	}
	if len(m.AppFqdns) > 0 {
		for _, e := range m.AppFqdns {
			l = e.Size()
			n += 1 + l + sovAppClientPlatos(uint64(l))
		}
	}
	if m.Status != 0 {
		n += 1 + sovAppClientPlatos(uint64(m.Status))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAppClientPlatos(uint64(len(k))) + 1 + len(v) + sovAppClientPlatos(uint64(len(v)))
			n += mapEntrySize + 2 + sovAppClientPlatos(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovAppClientPlatos(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozAppClientPlatos(x uint64) (n int) {
	return sovAppClientPlatos(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *PlatformFindCloudletRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClientPlatos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlatformFindCloudletRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlatformFindCloudletRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClientPlatos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionCookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClientPlatos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClientPlatos
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClientPlatos
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionCookie = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CarrierName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClientPlatos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClientPlatos
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClientPlatos
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CarrierName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClientPlatos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClientPlatos
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClientPlatos
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClientPlatos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClientPlatos
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClientPlatos
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAppClientPlatos
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClientPlatos
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAppClientPlatos
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAppClientPlatos
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClientPlatos
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAppClientPlatos
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAppClientPlatos
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAppClientPlatos(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthAppClientPlatos
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClientPlatos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAppClientPlatos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FqdnListRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClientPlatos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FqdnListRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FqdnListRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClientPlatos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionCookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClientPlatos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClientPlatos
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClientPlatos
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionCookie = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClientPlatos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClientPlatos
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClientPlatos
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAppClientPlatos
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClientPlatos
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAppClientPlatos
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAppClientPlatos
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClientPlatos
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAppClientPlatos
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAppClientPlatos
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAppClientPlatos(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthAppClientPlatos
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClientPlatos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAppClientPlatos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppFqdn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClientPlatos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppFqdn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppFqdn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClientPlatos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClientPlatos
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClientPlatos
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppVers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClientPlatos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClientPlatos
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClientPlatos
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppVers = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrgName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClientPlatos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClientPlatos
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClientPlatos
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrgName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fqdns", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClientPlatos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClientPlatos
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClientPlatos
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fqdns = append(m.Fqdns, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AndroidPackageName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClientPlatos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppClientPlatos
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppClientPlatos
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AndroidPackageName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClientPlatos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAppClientPlatos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FqdnListReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppClientPlatos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FqdnListReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FqdnListReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClientPlatos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppFqdns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClientPlatos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClientPlatos
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClientPlatos
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppFqdns = append(m.AppFqdns, &AppFqdn{})
			if err := m.AppFqdns[len(m.AppFqdns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClientPlatos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= FqdnListReply_FLStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppClientPlatos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppClientPlatos
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppClientPlatos
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAppClientPlatos
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClientPlatos
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAppClientPlatos
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAppClientPlatos
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppClientPlatos
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAppClientPlatos
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAppClientPlatos
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAppClientPlatos(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthAppClientPlatos
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppClientPlatos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAppClientPlatos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAppClientPlatos(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAppClientPlatos
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAppClientPlatos
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAppClientPlatos
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAppClientPlatos
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupAppClientPlatos
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthAppClientPlatos
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthAppClientPlatos        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAppClientPlatos          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupAppClientPlatos = fmt.Errorf("proto: unexpected end of group")
)
