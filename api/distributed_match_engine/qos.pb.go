// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: qos.proto

package distributed_match_engine

import (
	context "context"
	"encoding/json"
	"errors"
	fmt "fmt"
	"github.com/edgexr/edge-cloud-platform/pkg/util"
	_ "github.com/gogo/googleapis/google/api"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	"strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type QosSessionProfile int32

const (
	// Specifies that no priority session should be created
	QosSessionProfile_QOS_NO_PRIORITY QosSessionProfile = 0
	// Corresponds to a specific set of network parameters for low latency that will be
	// negotiated with the network provider in advance
	QosSessionProfile_QOS_LOW_LATENCY QosSessionProfile = 1
	// Downlink traffic from AppInst to client is prioritized up to 20Mbps
	QosSessionProfile_QOS_THROUGHPUT_DOWN_S QosSessionProfile = 2
	// Downlink traffic from AppInst to client is prioritized up to 50Mbps
	QosSessionProfile_QOS_THROUGHPUT_DOWN_M QosSessionProfile = 3
	// Downlink traffic from AppInst to client is prioritized up to 100Mbps
	QosSessionProfile_QOS_THROUGHPUT_DOWN_L QosSessionProfile = 4
)

var QosSessionProfile_name = map[int32]string{
	0: "QOS_NO_PRIORITY",
	1: "QOS_LOW_LATENCY",
	2: "QOS_THROUGHPUT_DOWN_S",
	3: "QOS_THROUGHPUT_DOWN_M",
	4: "QOS_THROUGHPUT_DOWN_L",
}

var QosSessionProfile_value = map[string]int32{
	"QOS_NO_PRIORITY":       0,
	"QOS_LOW_LATENCY":       1,
	"QOS_THROUGHPUT_DOWN_S": 2,
	"QOS_THROUGHPUT_DOWN_M": 3,
	"QOS_THROUGHPUT_DOWN_L": 4,
}

func (x QosSessionProfile) String() string {
	return proto.EnumName(QosSessionProfile_name, int32(x))
}

func (QosSessionProfile) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_acb97775b1858998, []int{0}
}

type QosSessionProtocol int32

const (
	QosSessionProtocol_TCP QosSessionProtocol = 0
	QosSessionProtocol_UDP QosSessionProtocol = 1
	QosSessionProtocol_ANY QosSessionProtocol = 2
)

var QosSessionProtocol_name = map[int32]string{
	0: "TCP",
	1: "UDP",
	2: "ANY",
}

var QosSessionProtocol_value = map[string]int32{
	"TCP": 0,
	"UDP": 1,
	"ANY": 2,
}

func (x QosSessionProtocol) String() string {
	return proto.EnumName(QosSessionProtocol_name, int32(x))
}

func (QosSessionProtocol) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_acb97775b1858998, []int{1}
}

type QosPrioritySessionDeleteReply_DeleteStatus int32

const (
	QosPrioritySessionDeleteReply_QDEL_UNKNOWN   QosPrioritySessionDeleteReply_DeleteStatus = 0
	QosPrioritySessionDeleteReply_QDEL_DELETED   QosPrioritySessionDeleteReply_DeleteStatus = 1
	QosPrioritySessionDeleteReply_QDEL_NOT_FOUND QosPrioritySessionDeleteReply_DeleteStatus = 2
)

var QosPrioritySessionDeleteReply_DeleteStatus_name = map[int32]string{
	0: "QDEL_UNKNOWN",
	1: "QDEL_DELETED",
	2: "QDEL_NOT_FOUND",
}

var QosPrioritySessionDeleteReply_DeleteStatus_value = map[string]int32{
	"QDEL_UNKNOWN":   0,
	"QDEL_DELETED":   1,
	"QDEL_NOT_FOUND": 2,
}

func (x QosPrioritySessionDeleteReply_DeleteStatus) String() string {
	return proto.EnumName(QosPrioritySessionDeleteReply_DeleteStatus_name, int32(x))
}

func (QosPrioritySessionDeleteReply_DeleteStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_acb97775b1858998, []int{3, 0}
}

type QosPrioritySessionCreateRequest struct {
	//
	// API version
	//
	// _(hidden)_ Reserved for future use
	Ver uint32 `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	//
	// Session Cookie from RegisterClientRequest
	SessionCookie string `protobuf:"bytes,2,opt,name=session_cookie,json=sessionCookie,proto3" json:"session_cookie,omitempty"`
	//
	// _(optional)_ QOS Priority Session duration in seconds
	SessionDuration uint32 `protobuf:"varint,3,opt,name=session_duration,json=sessionDuration,proto3" json:"session_duration,omitempty"`
	//
	// IP address of mobile device
	IpUserEquipment string `protobuf:"bytes,4,opt,name=ip_user_equipment,json=ipUserEquipment,proto3" json:"ip_user_equipment,omitempty"`
	//
	// IP address of the application server
	IpApplicationServer string `protobuf:"bytes,5,opt,name=ip_application_server,json=ipApplicationServer,proto3" json:"ip_application_server,omitempty"`
	//
	// _(optional)_ A list of single ports or port ranges on the user equipment.
	PortUserEquipment string `protobuf:"bytes,6,opt,name=port_user_equipment,json=portUserEquipment,proto3" json:"port_user_equipment,omitempty"`
	//
	// _(optional)_ A list of single ports or port ranges on the application server
	PortApplicationServer string `protobuf:"bytes,7,opt,name=port_application_server,json=portApplicationServer,proto3" json:"port_application_server,omitempty"`
	//
	// _(optional)_ The used transport protocol for the uplink
	ProtocolIn QosSessionProtocol `protobuf:"varint,8,opt,name=protocol_in,json=protocolIn,proto3,enum=distributed_match_engine.QosSessionProtocol" json:"protocol_in,omitempty"`
	//
	// _(optional)_ The used transport protocol for the downlink
	ProtocolOut QosSessionProtocol `protobuf:"varint,9,opt,name=protocol_out,json=protocolOut,proto3,enum=distributed_match_engine.QosSessionProtocol" json:"protocol_out,omitempty"`
	//
	// QOS Priority Session profile name
	Profile QosSessionProfile `protobuf:"varint,10,opt,name=profile,proto3,enum=distributed_match_engine.QosSessionProfile" json:"profile,omitempty"`
	//
	//  _(optional)_ URI of the callback receiver. Allows asynchronous delivery of session related events.
	NotificationUri string `protobuf:"bytes,11,opt,name=notification_uri,json=notificationUri,proto3" json:"notification_uri,omitempty"`
	//
	// _(optional)_ Authentification token for callback API
	NotificationAuthToken string `protobuf:"bytes,12,opt,name=notification_auth_token,json=notificationAuthToken,proto3" json:"notification_auth_token,omitempty"`
	//
	// _(optional)_ Vendor specific data
	Tags                 map[string]string `protobuf:"bytes,100,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *QosPrioritySessionCreateRequest) Reset()         { *m = QosPrioritySessionCreateRequest{} }
func (m *QosPrioritySessionCreateRequest) String() string { return proto.CompactTextString(m) }
func (*QosPrioritySessionCreateRequest) ProtoMessage()    {}
func (*QosPrioritySessionCreateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_acb97775b1858998, []int{0}
}
func (m *QosPrioritySessionCreateRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QosPrioritySessionCreateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QosPrioritySessionCreateRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QosPrioritySessionCreateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QosPrioritySessionCreateRequest.Merge(m, src)
}
func (m *QosPrioritySessionCreateRequest) XXX_Size() int {
	return m.Size()
}
func (m *QosPrioritySessionCreateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QosPrioritySessionCreateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QosPrioritySessionCreateRequest proto.InternalMessageInfo

type QosPrioritySessionReply struct {
	//
	// API version
	//
	// _(hidden)_ Reserved for future use
	Ver uint32 `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	//
	// QOS Priority Session duration in seconds
	SessionDuration uint32 `protobuf:"varint,2,opt,name=session_duration,json=sessionDuration,proto3" json:"session_duration,omitempty"`
	//
	// QOS Priority Session profile name
	Profile QosSessionProfile `protobuf:"varint,3,opt,name=profile,proto3,enum=distributed_match_engine.QosSessionProfile" json:"profile,omitempty"`
	//
	// Session ID in UUID format
	SessionId string `protobuf:"bytes,4,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	//
	// Timestamp of session start in seconds since unix epoch
	StartedAt uint32 `protobuf:"varint,5,opt,name=started_at,json=startedAt,proto3" json:"started_at,omitempty"`
	//
	// Timestamp of session expiration if the session was not deleted in seconds since unix epoch
	ExpiresAt uint32 `protobuf:"varint,6,opt,name=expires_at,json=expiresAt,proto3" json:"expires_at,omitempty"`
	//
	// HTTP Status Code of call to operator's API server.
	HttpStatus uint32 `protobuf:"varint,7,opt,name=http_status,json=httpStatus,proto3" json:"http_status,omitempty"`
	//
	// _(optional)_ Vendor specific data
	Tags                 map[string]string `protobuf:"bytes,100,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *QosPrioritySessionReply) Reset()         { *m = QosPrioritySessionReply{} }
func (m *QosPrioritySessionReply) String() string { return proto.CompactTextString(m) }
func (*QosPrioritySessionReply) ProtoMessage()    {}
func (*QosPrioritySessionReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_acb97775b1858998, []int{1}
}
func (m *QosPrioritySessionReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QosPrioritySessionReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QosPrioritySessionReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QosPrioritySessionReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QosPrioritySessionReply.Merge(m, src)
}
func (m *QosPrioritySessionReply) XXX_Size() int {
	return m.Size()
}
func (m *QosPrioritySessionReply) XXX_DiscardUnknown() {
	xxx_messageInfo_QosPrioritySessionReply.DiscardUnknown(m)
}

var xxx_messageInfo_QosPrioritySessionReply proto.InternalMessageInfo

type QosPrioritySessionDeleteRequest struct {
	//
	// API version
	//
	// _(hidden)_ Reserved for future use
	Ver uint32 `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	//
	// Session Cookie from RegisterClientRequest
	SessionCookie string `protobuf:"bytes,2,opt,name=session_cookie,json=sessionCookie,proto3" json:"session_cookie,omitempty"`
	//
	// QOS Priority Session profile name
	Profile QosSessionProfile `protobuf:"varint,3,opt,name=profile,proto3,enum=distributed_match_engine.QosSessionProfile" json:"profile,omitempty"`
	//
	// QOS Priority Session ID to be deleted
	SessionId string `protobuf:"bytes,4,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	//
	// _(optional)_ Vendor specific data
	Tags                 map[string]string `protobuf:"bytes,100,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *QosPrioritySessionDeleteRequest) Reset()         { *m = QosPrioritySessionDeleteRequest{} }
func (m *QosPrioritySessionDeleteRequest) String() string { return proto.CompactTextString(m) }
func (*QosPrioritySessionDeleteRequest) ProtoMessage()    {}
func (*QosPrioritySessionDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_acb97775b1858998, []int{2}
}
func (m *QosPrioritySessionDeleteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QosPrioritySessionDeleteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QosPrioritySessionDeleteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QosPrioritySessionDeleteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QosPrioritySessionDeleteRequest.Merge(m, src)
}
func (m *QosPrioritySessionDeleteRequest) XXX_Size() int {
	return m.Size()
}
func (m *QosPrioritySessionDeleteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QosPrioritySessionDeleteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QosPrioritySessionDeleteRequest proto.InternalMessageInfo

type QosPrioritySessionDeleteReply struct {
	//
	// API version
	//
	// _(hidden)_ Reserved for future use
	Ver uint32 `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	// Status return.
	Status QosPrioritySessionDeleteReply_DeleteStatus `protobuf:"varint,2,opt,name=status,proto3,enum=distributed_match_engine.QosPrioritySessionDeleteReply_DeleteStatus" json:"status,omitempty"`
	//
	// _(optional)_ Vendor specific data
	Tags                 map[string]string `protobuf:"bytes,100,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *QosPrioritySessionDeleteReply) Reset()         { *m = QosPrioritySessionDeleteReply{} }
func (m *QosPrioritySessionDeleteReply) String() string { return proto.CompactTextString(m) }
func (*QosPrioritySessionDeleteReply) ProtoMessage()    {}
func (*QosPrioritySessionDeleteReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_acb97775b1858998, []int{3}
}
func (m *QosPrioritySessionDeleteReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QosPrioritySessionDeleteReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QosPrioritySessionDeleteReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QosPrioritySessionDeleteReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QosPrioritySessionDeleteReply.Merge(m, src)
}
func (m *QosPrioritySessionDeleteReply) XXX_Size() int {
	return m.Size()
}
func (m *QosPrioritySessionDeleteReply) XXX_DiscardUnknown() {
	xxx_messageInfo_QosPrioritySessionDeleteReply.DiscardUnknown(m)
}

var xxx_messageInfo_QosPrioritySessionDeleteReply proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("distributed_match_engine.QosSessionProfile", QosSessionProfile_name, QosSessionProfile_value)
	proto.RegisterEnum("distributed_match_engine.QosSessionProtocol", QosSessionProtocol_name, QosSessionProtocol_value)
	proto.RegisterEnum("distributed_match_engine.QosPrioritySessionDeleteReply_DeleteStatus", QosPrioritySessionDeleteReply_DeleteStatus_name, QosPrioritySessionDeleteReply_DeleteStatus_value)
	proto.RegisterType((*QosPrioritySessionCreateRequest)(nil), "distributed_match_engine.QosPrioritySessionCreateRequest")
	proto.RegisterMapType((map[string]string)(nil), "distributed_match_engine.QosPrioritySessionCreateRequest.TagsEntry")
	proto.RegisterType((*QosPrioritySessionReply)(nil), "distributed_match_engine.QosPrioritySessionReply")
	proto.RegisterMapType((map[string]string)(nil), "distributed_match_engine.QosPrioritySessionReply.TagsEntry")
	proto.RegisterType((*QosPrioritySessionDeleteRequest)(nil), "distributed_match_engine.QosPrioritySessionDeleteRequest")
	proto.RegisterMapType((map[string]string)(nil), "distributed_match_engine.QosPrioritySessionDeleteRequest.TagsEntry")
	proto.RegisterType((*QosPrioritySessionDeleteReply)(nil), "distributed_match_engine.QosPrioritySessionDeleteReply")
	proto.RegisterMapType((map[string]string)(nil), "distributed_match_engine.QosPrioritySessionDeleteReply.TagsEntry")
}

func init() { proto.RegisterFile("qos.proto", fileDescriptor_acb97775b1858998) }

var fileDescriptor_acb97775b1858998 = []byte{
	// 883 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x56, 0xcd, 0x6e, 0x23, 0x45,
	0x10, 0xce, 0x8c, 0xb3, 0x0e, 0xae, 0xfc, 0x75, 0x3a, 0x44, 0x3b, 0x44, 0xbb, 0xd9, 0x10, 0x09,
	0x11, 0x0c, 0xb2, 0xb5, 0x41, 0x62, 0x21, 0x9c, 0x8c, 0xc7, 0xcb, 0x46, 0x78, 0x67, 0xec, 0xf1,
	0x58, 0x51, 0x24, 0xa4, 0xd6, 0xac, 0xdd, 0x71, 0x5a, 0xf1, 0x4e, 0x4f, 0xba, 0x7b, 0x22, 0x7c,
	0x43, 0x3c, 0x00, 0x17, 0x9e, 0x81, 0x03, 0x47, 0x4e, 0xbc, 0xc2, 0x1e, 0x11, 0xbc, 0x00, 0x44,
	0x48, 0xbc, 0x06, 0xea, 0xf6, 0x38, 0xc4, 0xc4, 0x5e, 0x88, 0x13, 0x71, 0x6b, 0x7f, 0x55, 0xf5,
	0x55, 0x4d, 0xd5, 0x57, 0xdd, 0x86, 0xc2, 0x19, 0x97, 0xa5, 0x44, 0x70, 0xc5, 0xb1, 0xd3, 0x65,
	0x52, 0x09, 0xf6, 0x22, 0x55, 0xb4, 0x4b, 0x5e, 0x46, 0xaa, 0x73, 0x42, 0x68, 0xdc, 0x63, 0x31,
	0xdd, 0x7c, 0xd0, 0xe3, 0xbc, 0xd7, 0xa7, 0xe5, 0x28, 0x61, 0xe5, 0x28, 0x8e, 0xb9, 0x8a, 0x14,
	0xe3, 0x71, 0x16, 0xb7, 0xf3, 0x43, 0x1e, 0x1e, 0x35, 0xb9, 0x6c, 0x08, 0xc6, 0x05, 0x53, 0x83,
	0x16, 0x95, 0x92, 0xf1, 0xb8, 0x2a, 0x68, 0xa4, 0x68, 0x40, 0xcf, 0x52, 0x2a, 0x15, 0x46, 0x90,
	0x3b, 0xa7, 0xc2, 0xb1, 0xb6, 0xad, 0xdd, 0xe5, 0x40, 0x1f, 0xf1, 0x3b, 0xb0, 0x22, 0x87, 0x9e,
	0xa4, 0xc3, 0xf9, 0x29, 0xa3, 0x8e, 0xbd, 0x6d, 0xed, 0x16, 0x82, 0xe5, 0x0c, 0xad, 0x1a, 0x10,
	0xbf, 0x07, 0x68, 0xe4, 0xd6, 0x4d, 0x85, 0xc9, 0xeb, 0xe4, 0x0c, 0xcb, 0x6a, 0x86, 0xbb, 0x19,
	0x8c, 0x8b, 0xb0, 0xc6, 0x12, 0x92, 0x4a, 0x2a, 0x08, 0x3d, 0x4b, 0x59, 0xf2, 0x92, 0xc6, 0xca,
	0x99, 0x37, 0xa4, 0xab, 0x2c, 0x69, 0x4b, 0x2a, 0x6a, 0x23, 0x18, 0xef, 0xc1, 0x06, 0x4b, 0x48,
	0x94, 0x24, 0x7d, 0xd6, 0x31, 0xd1, 0x44, 0x52, 0xa1, 0x2b, 0xbc, 0x67, 0xfc, 0xd7, 0x59, 0x52,
	0xf9, 0xdb, 0xd6, 0x32, 0x26, 0x5c, 0x82, 0xf5, 0x84, 0x0b, 0xf5, 0xcf, 0x0c, 0x79, 0x13, 0xb1,
	0xa6, 0x4d, 0xe3, 0x39, 0x3e, 0x82, 0xfb, 0xc6, 0x7f, 0x42, 0x96, 0x05, 0x13, 0xb3, 0xa1, 0xcd,
	0xd7, 0xf3, 0x3c, 0x87, 0x45, 0xd3, 0xd8, 0x0e, 0xef, 0x13, 0x16, 0x3b, 0x6f, 0x6c, 0x5b, 0xbb,
	0x2b, 0x7b, 0x1f, 0x94, 0xa6, 0x4d, 0xa7, 0xd4, 0xe4, 0x32, 0xeb, 0x79, 0x23, 0x0b, 0x0b, 0x60,
	0x44, 0x70, 0x10, 0x63, 0x1f, 0x96, 0x2e, 0xe9, 0x78, 0xaa, 0x9c, 0xc2, 0x0c, 0x7c, 0x97, 0x05,
	0xf9, 0xa9, 0xc2, 0x35, 0x58, 0x48, 0x04, 0x3f, 0x66, 0x7d, 0xea, 0x80, 0xe1, 0x7a, 0xff, 0x3f,
	0x72, 0xe9, 0x90, 0x60, 0x14, 0xab, 0x27, 0x1b, 0x73, 0xc5, 0x8e, 0x47, 0xad, 0x49, 0x05, 0x73,
	0x16, 0x87, 0xd3, 0xba, 0x8a, 0xb7, 0x05, 0xd3, 0x9d, 0x1c, 0x73, 0x8d, 0x52, 0x75, 0x42, 0x14,
	0x3f, 0xa5, 0xb1, 0xb3, 0x34, 0xec, 0xe4, 0x55, 0x73, 0x25, 0x55, 0x27, 0xa1, 0x36, 0xe2, 0x43,
	0x98, 0x57, 0x51, 0x4f, 0x3a, 0xdd, 0xed, 0xdc, 0xee, 0xe2, 0x5e, 0xf5, 0xb5, 0x65, 0xbe, 0x4e,
	0xbe, 0xa5, 0x30, 0xea, 0xc9, 0x5a, 0xac, 0xc4, 0x20, 0x30, 0x84, 0x9b, 0x4f, 0xa0, 0x70, 0x09,
	0x69, 0x6d, 0x9f, 0xd2, 0x81, 0xd1, 0x76, 0x21, 0xd0, 0x47, 0xfc, 0x26, 0xdc, 0x3b, 0x8f, 0xfa,
	0xe9, 0x48, 0xd2, 0xc3, 0x1f, 0xfb, 0xf6, 0xc7, 0xd6, 0xce, 0xf7, 0x39, 0xb8, 0x7f, 0x3d, 0x59,
	0x40, 0x93, 0xfe, 0x60, 0xc2, 0x8e, 0x4c, 0x12, 0xbf, 0x3d, 0x59, 0xfc, 0x57, 0x86, 0x92, 0xbb,
	0xc5, 0x50, 0x1e, 0x02, 0x8c, 0x32, 0xb2, 0x6e, 0xb6, 0x3c, 0x85, 0x0c, 0x39, 0xe8, 0x1a, 0xb3,
	0x8a, 0x84, 0x66, 0x8c, 0x94, 0xd9, 0x95, 0xe5, 0xa0, 0x90, 0x21, 0x15, 0xa5, 0xcd, 0xf4, 0xab,
	0x84, 0x09, 0x2a, 0xb5, 0x39, 0x3f, 0x34, 0x67, 0x48, 0x45, 0xe1, 0x47, 0xb0, 0x78, 0xa2, 0x54,
	0x42, 0xa4, 0x8a, 0x54, 0x2a, 0xcd, 0x12, 0x2c, 0x07, 0xa0, 0xa1, 0x96, 0x41, 0xb0, 0x3f, 0x36,
	0xaf, 0x4f, 0x6f, 0x32, 0x2f, 0xd3, 0xc2, 0xbb, 0x9b, 0xd3, 0x2f, 0xf6, 0xa4, 0x3b, 0xcd, 0xa5,
	0x7d, 0x7a, 0x07, 0x77, 0xda, 0xff, 0x33, 0xab, 0x5b, 0x88, 0x7f, 0xec, 0x3b, 0xef, 0xae, 0xa9,
	0x7f, 0xda, 0xf0, 0x70, 0x7a, 0xb2, 0xc9, 0x2b, 0xf0, 0x25, 0xe4, 0x33, 0xb9, 0xd8, 0xa6, 0x55,
	0xee, 0x2c, 0xdf, 0xa1, 0xa5, 0x31, 0x3c, 0x0f, 0x85, 0x16, 0x64, 0x9c, 0xb8, 0x3d, 0xd6, 0xa3,
	0xca, 0xac, 0xdc, 0x77, 0xd6, 0xa1, 0xa7, 0xb0, 0x74, 0xb5, 0x4e, 0x8c, 0x60, 0xa9, 0xe9, 0xd6,
	0xea, 0xa4, 0xed, 0x7d, 0xe1, 0xf9, 0x87, 0x1e, 0x9a, 0xbb, 0x44, 0xdc, 0x5a, 0xbd, 0x16, 0xd6,
	0x5c, 0x64, 0x61, 0x0c, 0x2b, 0x06, 0xf1, 0xfc, 0x90, 0x3c, 0xf5, 0xdb, 0x9e, 0x8b, 0xec, 0xe2,
	0xb7, 0x16, 0xac, 0x5d, 0x53, 0x0e, 0x5e, 0x87, 0xd5, 0xa6, 0xdf, 0x22, 0x9e, 0x4f, 0x1a, 0xc1,
	0x81, 0x1f, 0x1c, 0x84, 0x47, 0x68, 0x6e, 0x04, 0xd6, 0xfd, 0x43, 0x52, 0xaf, 0x84, 0x35, 0xaf,
	0x7a, 0x84, 0x2c, 0xfc, 0x16, 0x6c, 0x68, 0x30, 0x7c, 0x16, 0xf8, 0xed, 0xcf, 0x9f, 0x35, 0xda,
	0x21, 0x71, 0xfd, 0x43, 0x8f, 0xb4, 0x90, 0x3d, 0xcd, 0xf4, 0x1c, 0xe5, 0xa6, 0x99, 0xea, 0x68,
	0xbe, 0x58, 0x06, 0x7c, 0xfd, 0x59, 0xc1, 0x0b, 0x90, 0x0b, 0xab, 0x0d, 0x34, 0xa7, 0x0f, 0x6d,
	0xb7, 0x81, 0x2c, 0x7d, 0xa8, 0x78, 0x47, 0xc8, 0xde, 0xfb, 0x3a, 0x07, 0xa8, 0x99, 0x46, 0x7d,
	0xa6, 0x06, 0xfe, 0xb1, 0x7e, 0x18, 0x59, 0x87, 0xe2, 0x1f, 0x2d, 0x70, 0xa6, 0x5d, 0xd5, 0xf8,
	0x93, 0x99, 0xaf, 0xf7, 0xcd, 0xc7, 0x37, 0xbe, 0x69, 0x76, 0xde, 0xfd, 0xe6, 0xd7, 0x3f, 0xbe,
	0xb3, 0xdf, 0xde, 0x79, 0x50, 0x3e, 0x7f, 0x5c, 0x3e, 0xe3, 0x32, 0xc9, 0x9c, 0xb2, 0xfd, 0xeb,
	0x18, 0xfe, 0x7d, 0xab, 0x88, 0x7f, 0x9a, 0x58, 0xf3, 0x70, 0xca, 0x37, 0xab, 0x79, 0x6c, 0x2b,
	0x37, 0x9f, 0xcc, 0x28, 0xd6, 0x7f, 0xab, 0xbc, 0x6b, 0x5c, 0xf7, 0xad, 0xe2, 0x67, 0xe8, 0xd5,
	0xef, 0x5b, 0x73, 0xaf, 0x2e, 0xb6, 0xac, 0x9f, 0x2f, 0xb6, 0xac, 0xdf, 0x2e, 0xb6, 0xac, 0x17,
	0x79, 0xf3, 0x37, 0xe0, 0xc3, 0xbf, 0x02, 0x00, 0x00, 0xff, 0xff, 0xef, 0xfe, 0x4f, 0xec, 0x35,
	0x0a, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// QualityOfServiceClient is the client API for QualityOfService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type QualityOfServiceClient interface {
	//
	// QosPrioritySessionCreate
	//
	// Creates a QOS priority session (latency or throughput priority) from the client
	// to the app inst by making a call to the operator's priority session API server.
	QosPrioritySessionCreate(ctx context.Context, in *QosPrioritySessionCreateRequest, opts ...grpc.CallOption) (*QosPrioritySessionReply, error)
	//
	// QosPrioritySessionDelete
	//
	// Deletes a previously created QOS priority session by making a call to the operator's
	// priority session API server.
	QosPrioritySessionDelete(ctx context.Context, in *QosPrioritySessionDeleteRequest, opts ...grpc.CallOption) (*QosPrioritySessionDeleteReply, error)
}

type qualityOfServiceClient struct {
	cc *grpc.ClientConn
}

func NewQualityOfServiceClient(cc *grpc.ClientConn) QualityOfServiceClient {
	return &qualityOfServiceClient{cc}
}

func (c *qualityOfServiceClient) QosPrioritySessionCreate(ctx context.Context, in *QosPrioritySessionCreateRequest, opts ...grpc.CallOption) (*QosPrioritySessionReply, error) {
	out := new(QosPrioritySessionReply)
	err := c.cc.Invoke(ctx, "/distributed_match_engine.QualityOfService/QosPrioritySessionCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qualityOfServiceClient) QosPrioritySessionDelete(ctx context.Context, in *QosPrioritySessionDeleteRequest, opts ...grpc.CallOption) (*QosPrioritySessionDeleteReply, error) {
	out := new(QosPrioritySessionDeleteReply)
	err := c.cc.Invoke(ctx, "/distributed_match_engine.QualityOfService/QosPrioritySessionDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// QualityOfServiceServer is the server API for QualityOfService service.
type QualityOfServiceServer interface {
	//
	// QosPrioritySessionCreate
	//
	// Creates a QOS priority session (latency or throughput priority) from the client
	// to the app inst by making a call to the operator's priority session API server.
	QosPrioritySessionCreate(context.Context, *QosPrioritySessionCreateRequest) (*QosPrioritySessionReply, error)
	//
	// QosPrioritySessionDelete
	//
	// Deletes a previously created QOS priority session by making a call to the operator's
	// priority session API server.
	QosPrioritySessionDelete(context.Context, *QosPrioritySessionDeleteRequest) (*QosPrioritySessionDeleteReply, error)
}

// UnimplementedQualityOfServiceServer can be embedded to have forward compatible implementations.
type UnimplementedQualityOfServiceServer struct {
}

func (*UnimplementedQualityOfServiceServer) QosPrioritySessionCreate(ctx context.Context, req *QosPrioritySessionCreateRequest) (*QosPrioritySessionReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QosPrioritySessionCreate not implemented")
}
func (*UnimplementedQualityOfServiceServer) QosPrioritySessionDelete(ctx context.Context, req *QosPrioritySessionDeleteRequest) (*QosPrioritySessionDeleteReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QosPrioritySessionDelete not implemented")
}

func RegisterQualityOfServiceServer(s *grpc.Server, srv QualityOfServiceServer) {
	s.RegisterService(&_QualityOfService_serviceDesc, srv)
}

func _QualityOfService_QosPrioritySessionCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QosPrioritySessionCreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QualityOfServiceServer).QosPrioritySessionCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/distributed_match_engine.QualityOfService/QosPrioritySessionCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QualityOfServiceServer).QosPrioritySessionCreate(ctx, req.(*QosPrioritySessionCreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QualityOfService_QosPrioritySessionDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QosPrioritySessionDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QualityOfServiceServer).QosPrioritySessionDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/distributed_match_engine.QualityOfService/QosPrioritySessionDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QualityOfServiceServer).QosPrioritySessionDelete(ctx, req.(*QosPrioritySessionDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _QualityOfService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "distributed_match_engine.QualityOfService",
	HandlerType: (*QualityOfServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "QosPrioritySessionCreate",
			Handler:    _QualityOfService_QosPrioritySessionCreate_Handler,
		},
		{
			MethodName: "QosPrioritySessionDelete",
			Handler:    _QualityOfService_QosPrioritySessionDelete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "qos.proto",
}

func (m *QosPrioritySessionCreateRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosPrioritySessionCreateRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QosPrioritySessionCreateRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Tags) > 0 {
		for k := range m.Tags {
			v := m.Tags[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintQos(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintQos(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintQos(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.NotificationAuthToken) > 0 {
		i -= len(m.NotificationAuthToken)
		copy(dAtA[i:], m.NotificationAuthToken)
		i = encodeVarintQos(dAtA, i, uint64(len(m.NotificationAuthToken)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.NotificationUri) > 0 {
		i -= len(m.NotificationUri)
		copy(dAtA[i:], m.NotificationUri)
		i = encodeVarintQos(dAtA, i, uint64(len(m.NotificationUri)))
		i--
		dAtA[i] = 0x5a
	}
	if m.Profile != 0 {
		i = encodeVarintQos(dAtA, i, uint64(m.Profile))
		i--
		dAtA[i] = 0x50
	}
	if m.ProtocolOut != 0 {
		i = encodeVarintQos(dAtA, i, uint64(m.ProtocolOut))
		i--
		dAtA[i] = 0x48
	}
	if m.ProtocolIn != 0 {
		i = encodeVarintQos(dAtA, i, uint64(m.ProtocolIn))
		i--
		dAtA[i] = 0x40
	}
	if len(m.PortApplicationServer) > 0 {
		i -= len(m.PortApplicationServer)
		copy(dAtA[i:], m.PortApplicationServer)
		i = encodeVarintQos(dAtA, i, uint64(len(m.PortApplicationServer)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.PortUserEquipment) > 0 {
		i -= len(m.PortUserEquipment)
		copy(dAtA[i:], m.PortUserEquipment)
		i = encodeVarintQos(dAtA, i, uint64(len(m.PortUserEquipment)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.IpApplicationServer) > 0 {
		i -= len(m.IpApplicationServer)
		copy(dAtA[i:], m.IpApplicationServer)
		i = encodeVarintQos(dAtA, i, uint64(len(m.IpApplicationServer)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.IpUserEquipment) > 0 {
		i -= len(m.IpUserEquipment)
		copy(dAtA[i:], m.IpUserEquipment)
		i = encodeVarintQos(dAtA, i, uint64(len(m.IpUserEquipment)))
		i--
		dAtA[i] = 0x22
	}
	if m.SessionDuration != 0 {
		i = encodeVarintQos(dAtA, i, uint64(m.SessionDuration))
		i--
		dAtA[i] = 0x18
	}
	if len(m.SessionCookie) > 0 {
		i -= len(m.SessionCookie)
		copy(dAtA[i:], m.SessionCookie)
		i = encodeVarintQos(dAtA, i, uint64(len(m.SessionCookie)))
		i--
		dAtA[i] = 0x12
	}
	if m.Ver != 0 {
		i = encodeVarintQos(dAtA, i, uint64(m.Ver))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QosPrioritySessionReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosPrioritySessionReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QosPrioritySessionReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Tags) > 0 {
		for k := range m.Tags {
			v := m.Tags[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintQos(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintQos(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintQos(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa2
		}
	}
	if m.HttpStatus != 0 {
		i = encodeVarintQos(dAtA, i, uint64(m.HttpStatus))
		i--
		dAtA[i] = 0x38
	}
	if m.ExpiresAt != 0 {
		i = encodeVarintQos(dAtA, i, uint64(m.ExpiresAt))
		i--
		dAtA[i] = 0x30
	}
	if m.StartedAt != 0 {
		i = encodeVarintQos(dAtA, i, uint64(m.StartedAt))
		i--
		dAtA[i] = 0x28
	}
	if len(m.SessionId) > 0 {
		i -= len(m.SessionId)
		copy(dAtA[i:], m.SessionId)
		i = encodeVarintQos(dAtA, i, uint64(len(m.SessionId)))
		i--
		dAtA[i] = 0x22
	}
	if m.Profile != 0 {
		i = encodeVarintQos(dAtA, i, uint64(m.Profile))
		i--
		dAtA[i] = 0x18
	}
	if m.SessionDuration != 0 {
		i = encodeVarintQos(dAtA, i, uint64(m.SessionDuration))
		i--
		dAtA[i] = 0x10
	}
	if m.Ver != 0 {
		i = encodeVarintQos(dAtA, i, uint64(m.Ver))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QosPrioritySessionDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosPrioritySessionDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QosPrioritySessionDeleteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Tags) > 0 {
		for k := range m.Tags {
			v := m.Tags[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintQos(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintQos(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintQos(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.SessionId) > 0 {
		i -= len(m.SessionId)
		copy(dAtA[i:], m.SessionId)
		i = encodeVarintQos(dAtA, i, uint64(len(m.SessionId)))
		i--
		dAtA[i] = 0x22
	}
	if m.Profile != 0 {
		i = encodeVarintQos(dAtA, i, uint64(m.Profile))
		i--
		dAtA[i] = 0x18
	}
	if len(m.SessionCookie) > 0 {
		i -= len(m.SessionCookie)
		copy(dAtA[i:], m.SessionCookie)
		i = encodeVarintQos(dAtA, i, uint64(len(m.SessionCookie)))
		i--
		dAtA[i] = 0x12
	}
	if m.Ver != 0 {
		i = encodeVarintQos(dAtA, i, uint64(m.Ver))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QosPrioritySessionDeleteReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QosPrioritySessionDeleteReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QosPrioritySessionDeleteReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Tags) > 0 {
		for k := range m.Tags {
			v := m.Tags[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintQos(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintQos(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintQos(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa2
		}
	}
	if m.Status != 0 {
		i = encodeVarintQos(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if m.Ver != 0 {
		i = encodeVarintQos(dAtA, i, uint64(m.Ver))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintQos(dAtA []byte, offset int, v uint64) int {
	offset -= sovQos(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *QosPrioritySessionCreateRequest) Clone() *QosPrioritySessionCreateRequest {
	cp := &QosPrioritySessionCreateRequest{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *QosPrioritySessionCreateRequest) CopyInFields(src *QosPrioritySessionCreateRequest) int {
	updateListAction := "replace"
	changed := 0
	if m.Ver != src.Ver {
		m.Ver = src.Ver
		changed++
	}
	if m.SessionCookie != src.SessionCookie {
		m.SessionCookie = src.SessionCookie
		changed++
	}
	if m.SessionDuration != src.SessionDuration {
		m.SessionDuration = src.SessionDuration
		changed++
	}
	if m.IpUserEquipment != src.IpUserEquipment {
		m.IpUserEquipment = src.IpUserEquipment
		changed++
	}
	if m.IpApplicationServer != src.IpApplicationServer {
		m.IpApplicationServer = src.IpApplicationServer
		changed++
	}
	if m.PortUserEquipment != src.PortUserEquipment {
		m.PortUserEquipment = src.PortUserEquipment
		changed++
	}
	if m.PortApplicationServer != src.PortApplicationServer {
		m.PortApplicationServer = src.PortApplicationServer
		changed++
	}
	if m.ProtocolIn != src.ProtocolIn {
		m.ProtocolIn = src.ProtocolIn
		changed++
	}
	if m.ProtocolOut != src.ProtocolOut {
		m.ProtocolOut = src.ProtocolOut
		changed++
	}
	if m.Profile != src.Profile {
		m.Profile = src.Profile
		changed++
	}
	if m.NotificationUri != src.NotificationUri {
		m.NotificationUri = src.NotificationUri
		changed++
	}
	if m.NotificationAuthToken != src.NotificationAuthToken {
		m.NotificationAuthToken = src.NotificationAuthToken
		changed++
	}
	if src.Tags != nil {
		if updateListAction == "add" {
			for k0, v := range src.Tags {
				m.Tags[k0] = v
				changed++
			}
		} else if updateListAction == "remove" {
			for k0, _ := range src.Tags {
				if _, ok := m.Tags[k0]; ok {
					delete(m.Tags, k0)
					changed++
				}
			}
		} else {
			m.Tags = make(map[string]string)
			for k0, v := range src.Tags {
				m.Tags[k0] = v
			}
			changed++
		}
	} else if m.Tags != nil {
		m.Tags = nil
		changed++
	}
	return changed
}

func (m *QosPrioritySessionCreateRequest) DeepCopyIn(src *QosPrioritySessionCreateRequest) {
	m.Ver = src.Ver
	m.SessionCookie = src.SessionCookie
	m.SessionDuration = src.SessionDuration
	m.IpUserEquipment = src.IpUserEquipment
	m.IpApplicationServer = src.IpApplicationServer
	m.PortUserEquipment = src.PortUserEquipment
	m.PortApplicationServer = src.PortApplicationServer
	m.ProtocolIn = src.ProtocolIn
	m.ProtocolOut = src.ProtocolOut
	m.Profile = src.Profile
	m.NotificationUri = src.NotificationUri
	m.NotificationAuthToken = src.NotificationAuthToken
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k, v := range src.Tags {
			m.Tags[k] = v
		}
	} else {
		m.Tags = nil
	}
}

// Helper method to check that enums have valid values
func (m *QosPrioritySessionCreateRequest) ValidateEnums() error {
	if _, ok := QosSessionProtocol_name[int32(m.ProtocolIn)]; !ok {
		return errors.New("invalid ProtocolIn")
	}
	if _, ok := QosSessionProtocol_name[int32(m.ProtocolOut)]; !ok {
		return errors.New("invalid ProtocolOut")
	}
	if _, ok := QosSessionProfile_name[int32(m.Profile)]; !ok {
		return errors.New("invalid Profile")
	}
	return nil
}

func (s *QosPrioritySessionCreateRequest) ClearTagged(tags map[string]struct{}) {
}

func (m *QosPrioritySessionReply) Clone() *QosPrioritySessionReply {
	cp := &QosPrioritySessionReply{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *QosPrioritySessionReply) CopyInFields(src *QosPrioritySessionReply) int {
	updateListAction := "replace"
	changed := 0
	if m.Ver != src.Ver {
		m.Ver = src.Ver
		changed++
	}
	if m.SessionDuration != src.SessionDuration {
		m.SessionDuration = src.SessionDuration
		changed++
	}
	if m.Profile != src.Profile {
		m.Profile = src.Profile
		changed++
	}
	if m.SessionId != src.SessionId {
		m.SessionId = src.SessionId
		changed++
	}
	if m.StartedAt != src.StartedAt {
		m.StartedAt = src.StartedAt
		changed++
	}
	if m.ExpiresAt != src.ExpiresAt {
		m.ExpiresAt = src.ExpiresAt
		changed++
	}
	if m.HttpStatus != src.HttpStatus {
		m.HttpStatus = src.HttpStatus
		changed++
	}
	if src.Tags != nil {
		if updateListAction == "add" {
			for k0, v := range src.Tags {
				m.Tags[k0] = v
				changed++
			}
		} else if updateListAction == "remove" {
			for k0, _ := range src.Tags {
				if _, ok := m.Tags[k0]; ok {
					delete(m.Tags, k0)
					changed++
				}
			}
		} else {
			m.Tags = make(map[string]string)
			for k0, v := range src.Tags {
				m.Tags[k0] = v
			}
			changed++
		}
	} else if m.Tags != nil {
		m.Tags = nil
		changed++
	}
	return changed
}

func (m *QosPrioritySessionReply) DeepCopyIn(src *QosPrioritySessionReply) {
	m.Ver = src.Ver
	m.SessionDuration = src.SessionDuration
	m.Profile = src.Profile
	m.SessionId = src.SessionId
	m.StartedAt = src.StartedAt
	m.ExpiresAt = src.ExpiresAt
	m.HttpStatus = src.HttpStatus
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k, v := range src.Tags {
			m.Tags[k] = v
		}
	} else {
		m.Tags = nil
	}
}

// Helper method to check that enums have valid values
func (m *QosPrioritySessionReply) ValidateEnums() error {
	if _, ok := QosSessionProfile_name[int32(m.Profile)]; !ok {
		return errors.New("invalid Profile")
	}
	return nil
}

func (s *QosPrioritySessionReply) ClearTagged(tags map[string]struct{}) {
}

func (m *QosPrioritySessionDeleteRequest) Clone() *QosPrioritySessionDeleteRequest {
	cp := &QosPrioritySessionDeleteRequest{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *QosPrioritySessionDeleteRequest) CopyInFields(src *QosPrioritySessionDeleteRequest) int {
	updateListAction := "replace"
	changed := 0
	if m.Ver != src.Ver {
		m.Ver = src.Ver
		changed++
	}
	if m.SessionCookie != src.SessionCookie {
		m.SessionCookie = src.SessionCookie
		changed++
	}
	if m.Profile != src.Profile {
		m.Profile = src.Profile
		changed++
	}
	if m.SessionId != src.SessionId {
		m.SessionId = src.SessionId
		changed++
	}
	if src.Tags != nil {
		if updateListAction == "add" {
			for k0, v := range src.Tags {
				m.Tags[k0] = v
				changed++
			}
		} else if updateListAction == "remove" {
			for k0, _ := range src.Tags {
				if _, ok := m.Tags[k0]; ok {
					delete(m.Tags, k0)
					changed++
				}
			}
		} else {
			m.Tags = make(map[string]string)
			for k0, v := range src.Tags {
				m.Tags[k0] = v
			}
			changed++
		}
	} else if m.Tags != nil {
		m.Tags = nil
		changed++
	}
	return changed
}

func (m *QosPrioritySessionDeleteRequest) DeepCopyIn(src *QosPrioritySessionDeleteRequest) {
	m.Ver = src.Ver
	m.SessionCookie = src.SessionCookie
	m.Profile = src.Profile
	m.SessionId = src.SessionId
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k, v := range src.Tags {
			m.Tags[k] = v
		}
	} else {
		m.Tags = nil
	}
}

// Helper method to check that enums have valid values
func (m *QosPrioritySessionDeleteRequest) ValidateEnums() error {
	if _, ok := QosSessionProfile_name[int32(m.Profile)]; !ok {
		return errors.New("invalid Profile")
	}
	return nil
}

func (s *QosPrioritySessionDeleteRequest) ClearTagged(tags map[string]struct{}) {
}

func (m *QosPrioritySessionDeleteReply) Clone() *QosPrioritySessionDeleteReply {
	cp := &QosPrioritySessionDeleteReply{}
	cp.DeepCopyIn(m)
	return cp
}

func (m *QosPrioritySessionDeleteReply) CopyInFields(src *QosPrioritySessionDeleteReply) int {
	updateListAction := "replace"
	changed := 0
	if m.Ver != src.Ver {
		m.Ver = src.Ver
		changed++
	}
	if m.Status != src.Status {
		m.Status = src.Status
		changed++
	}
	if src.Tags != nil {
		if updateListAction == "add" {
			for k0, v := range src.Tags {
				m.Tags[k0] = v
				changed++
			}
		} else if updateListAction == "remove" {
			for k0, _ := range src.Tags {
				if _, ok := m.Tags[k0]; ok {
					delete(m.Tags, k0)
					changed++
				}
			}
		} else {
			m.Tags = make(map[string]string)
			for k0, v := range src.Tags {
				m.Tags[k0] = v
			}
			changed++
		}
	} else if m.Tags != nil {
		m.Tags = nil
		changed++
	}
	return changed
}

func (m *QosPrioritySessionDeleteReply) DeepCopyIn(src *QosPrioritySessionDeleteReply) {
	m.Ver = src.Ver
	m.Status = src.Status
	if src.Tags != nil {
		m.Tags = make(map[string]string)
		for k, v := range src.Tags {
			m.Tags[k] = v
		}
	} else {
		m.Tags = nil
	}
}

// Helper method to check that enums have valid values
func (m *QosPrioritySessionDeleteReply) ValidateEnums() error {
	if _, ok := QosPrioritySessionDeleteReply_DeleteStatus_name[int32(m.Status)]; !ok {
		return errors.New("invalid Status")
	}
	return nil
}

func (s *QosPrioritySessionDeleteReply) ClearTagged(tags map[string]struct{}) {
}

var QosSessionProfileStrings = []string{
	"QOS_NO_PRIORITY",
	"QOS_LOW_LATENCY",
	"QOS_THROUGHPUT_DOWN_S",
	"QOS_THROUGHPUT_DOWN_M",
	"QOS_THROUGHPUT_DOWN_L",
}

const (
	QosSessionProfileQOS_NO_PRIORITY       uint64 = 1 << 0
	QosSessionProfileQOS_LOW_LATENCY       uint64 = 1 << 1
	QosSessionProfileQOS_THROUGHPUT_DOWN_S uint64 = 1 << 2
	QosSessionProfileQOS_THROUGHPUT_DOWN_M uint64 = 1 << 3
	QosSessionProfileQOS_THROUGHPUT_DOWN_L uint64 = 1 << 4
)

var QosSessionProfile_CamelName = map[int32]string{
	// QOS_NO_PRIORITY -> QosNoPriority
	0: "QosNoPriority",
	// QOS_LOW_LATENCY -> QosLowLatency
	1: "QosLowLatency",
	// QOS_THROUGHPUT_DOWN_S -> QosThroughputDownS
	2: "QosThroughputDownS",
	// QOS_THROUGHPUT_DOWN_M -> QosThroughputDownM
	3: "QosThroughputDownM",
	// QOS_THROUGHPUT_DOWN_L -> QosThroughputDownL
	4: "QosThroughputDownL",
}
var QosSessionProfile_CamelValue = map[string]int32{
	"QosNoPriority":      0,
	"QosLowLatency":      1,
	"QosThroughputDownS": 2,
	"QosThroughputDownM": 3,
	"QosThroughputDownL": 4,
}

func ParseQosSessionProfile(data interface{}) (QosSessionProfile, error) {
	if val, ok := data.(QosSessionProfile); ok {
		return val, nil
	} else if str, ok := data.(string); ok {
		val, ok := QosSessionProfile_CamelValue[util.CamelCase(str)]
		if !ok {
			// may have omitted common prefix
			val, ok = QosSessionProfile_CamelValue["Qos"+util.CamelCase(str)]
		}
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = QosSessionProfile_CamelName[val]
			}
		}
		if !ok {
			return QosSessionProfile(0), fmt.Errorf("Invalid QosSessionProfile value %q", str)
		}
		return QosSessionProfile(val), nil
	} else if ival, ok := data.(int32); ok {
		if _, ok := QosSessionProfile_CamelName[ival]; ok {
			return QosSessionProfile(ival), nil
		} else {
			return QosSessionProfile(0), fmt.Errorf("Invalid QosSessionProfile value %d", ival)
		}
	}
	return QosSessionProfile(0), fmt.Errorf("Invalid QosSessionProfile value %v", data)
}

func (e *QosSessionProfile) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, err := ParseQosSessionProfile(str)
	if err != nil {
		return err
	}
	*e = val
	return nil
}

func (e QosSessionProfile) MarshalYAML() (interface{}, error) {
	str := proto.EnumName(QosSessionProfile_CamelName, int32(e))
	str = strings.TrimPrefix(str, "Qos")
	return str, nil
}

// custom JSON encoding/decoding
func (e *QosSessionProfile) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, err := ParseQosSessionProfile(str)
		if err != nil {
			return &json.UnmarshalTypeError{
				Value: "string " + str,
				Type:  reflect.TypeOf(QosSessionProfile(0)),
			}
		}
		*e = QosSessionProfile(val)
		return nil
	}
	var ival int32
	err = json.Unmarshal(b, &ival)
	if err == nil {
		val, err := ParseQosSessionProfile(ival)
		if err == nil {
			*e = val
			return nil
		}
	}
	return &json.UnmarshalTypeError{
		Value: "value " + string(b),
		Type:  reflect.TypeOf(QosSessionProfile(0)),
	}
}

func (e QosSessionProfile) MarshalJSON() ([]byte, error) {
	str := proto.EnumName(QosSessionProfile_CamelName, int32(e))
	str = strings.TrimPrefix(str, "Qos")
	return json.Marshal(str)
}

var QosSessionProfileCommonPrefix = "Qos"

var QosSessionProtocolStrings = []string{
	"TCP",
	"UDP",
	"ANY",
}

const (
	QosSessionProtocolTCP uint64 = 1 << 0
	QosSessionProtocolUDP uint64 = 1 << 1
	QosSessionProtocolANY uint64 = 1 << 2
)

var QosSessionProtocol_CamelName = map[int32]string{
	// TCP -> Tcp
	0: "Tcp",
	// UDP -> Udp
	1: "Udp",
	// ANY -> Any
	2: "Any",
}
var QosSessionProtocol_CamelValue = map[string]int32{
	"Tcp": 0,
	"Udp": 1,
	"Any": 2,
}

func ParseQosSessionProtocol(data interface{}) (QosSessionProtocol, error) {
	if val, ok := data.(QosSessionProtocol); ok {
		return val, nil
	} else if str, ok := data.(string); ok {
		val, ok := QosSessionProtocol_CamelValue[util.CamelCase(str)]
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = QosSessionProtocol_CamelName[val]
			}
		}
		if !ok {
			return QosSessionProtocol(0), fmt.Errorf("Invalid QosSessionProtocol value %q", str)
		}
		return QosSessionProtocol(val), nil
	} else if ival, ok := data.(int32); ok {
		if _, ok := QosSessionProtocol_CamelName[ival]; ok {
			return QosSessionProtocol(ival), nil
		} else {
			return QosSessionProtocol(0), fmt.Errorf("Invalid QosSessionProtocol value %d", ival)
		}
	}
	return QosSessionProtocol(0), fmt.Errorf("Invalid QosSessionProtocol value %v", data)
}

func (e *QosSessionProtocol) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, err := ParseQosSessionProtocol(str)
	if err != nil {
		return err
	}
	*e = val
	return nil
}

func (e QosSessionProtocol) MarshalYAML() (interface{}, error) {
	str := proto.EnumName(QosSessionProtocol_CamelName, int32(e))
	return str, nil
}

// custom JSON encoding/decoding
func (e *QosSessionProtocol) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, err := ParseQosSessionProtocol(str)
		if err != nil {
			return &json.UnmarshalTypeError{
				Value: "string " + str,
				Type:  reflect.TypeOf(QosSessionProtocol(0)),
			}
		}
		*e = QosSessionProtocol(val)
		return nil
	}
	var ival int32
	err = json.Unmarshal(b, &ival)
	if err == nil {
		val, err := ParseQosSessionProtocol(ival)
		if err == nil {
			*e = val
			return nil
		}
	}
	return &json.UnmarshalTypeError{
		Value: "value " + string(b),
		Type:  reflect.TypeOf(QosSessionProtocol(0)),
	}
}

func (e QosSessionProtocol) MarshalJSON() ([]byte, error) {
	str := proto.EnumName(QosSessionProtocol_CamelName, int32(e))
	return json.Marshal(str)
}

var DeleteStatusStrings = []string{
	"QDEL_UNKNOWN",
	"QDEL_DELETED",
	"QDEL_NOT_FOUND",
}

const (
	DeleteStatusQDEL_UNKNOWN   uint64 = 1 << 0
	DeleteStatusQDEL_DELETED   uint64 = 1 << 1
	DeleteStatusQDEL_NOT_FOUND uint64 = 1 << 2
)

var QosPrioritySessionDeleteReply_DeleteStatus_CamelName = map[int32]string{
	// QDEL_UNKNOWN -> QdelUnknown
	0: "QdelUnknown",
	// QDEL_DELETED -> QdelDeleted
	1: "QdelDeleted",
	// QDEL_NOT_FOUND -> QdelNotFound
	2: "QdelNotFound",
}
var QosPrioritySessionDeleteReply_DeleteStatus_CamelValue = map[string]int32{
	"QdelUnknown":  0,
	"QdelDeleted":  1,
	"QdelNotFound": 2,
}

func ParseQosPrioritySessionDeleteReply_DeleteStatus(data interface{}) (QosPrioritySessionDeleteReply_DeleteStatus, error) {
	if val, ok := data.(QosPrioritySessionDeleteReply_DeleteStatus); ok {
		return val, nil
	} else if str, ok := data.(string); ok {
		val, ok := QosPrioritySessionDeleteReply_DeleteStatus_CamelValue[util.CamelCase(str)]
		if !ok {
			// may have omitted common prefix
			val, ok = QosPrioritySessionDeleteReply_DeleteStatus_CamelValue["Qdel"+util.CamelCase(str)]
		}
		if !ok {
			// may be int value instead of enum name
			ival, err := strconv.Atoi(str)
			val = int32(ival)
			if err == nil {
				_, ok = QosPrioritySessionDeleteReply_DeleteStatus_CamelName[val]
			}
		}
		if !ok {
			return QosPrioritySessionDeleteReply_DeleteStatus(0), fmt.Errorf("Invalid QosPrioritySessionDeleteReply_DeleteStatus value %q", str)
		}
		return QosPrioritySessionDeleteReply_DeleteStatus(val), nil
	} else if ival, ok := data.(int32); ok {
		if _, ok := QosPrioritySessionDeleteReply_DeleteStatus_CamelName[ival]; ok {
			return QosPrioritySessionDeleteReply_DeleteStatus(ival), nil
		} else {
			return QosPrioritySessionDeleteReply_DeleteStatus(0), fmt.Errorf("Invalid QosPrioritySessionDeleteReply_DeleteStatus value %d", ival)
		}
	}
	return QosPrioritySessionDeleteReply_DeleteStatus(0), fmt.Errorf("Invalid QosPrioritySessionDeleteReply_DeleteStatus value %v", data)
}

func (e *QosPrioritySessionDeleteReply_DeleteStatus) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	err := unmarshal(&str)
	if err != nil {
		return err
	}
	val, err := ParseQosPrioritySessionDeleteReply_DeleteStatus(str)
	if err != nil {
		return err
	}
	*e = val
	return nil
}

func (e QosPrioritySessionDeleteReply_DeleteStatus) MarshalYAML() (interface{}, error) {
	str := proto.EnumName(QosPrioritySessionDeleteReply_DeleteStatus_CamelName, int32(e))
	str = strings.TrimPrefix(str, "Qdel")
	return str, nil
}

// custom JSON encoding/decoding
func (e *QosPrioritySessionDeleteReply_DeleteStatus) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err == nil {
		val, err := ParseQosPrioritySessionDeleteReply_DeleteStatus(str)
		if err != nil {
			return &json.UnmarshalTypeError{
				Value: "string " + str,
				Type:  reflect.TypeOf(QosPrioritySessionDeleteReply_DeleteStatus(0)),
			}
		}
		*e = QosPrioritySessionDeleteReply_DeleteStatus(val)
		return nil
	}
	var ival int32
	err = json.Unmarshal(b, &ival)
	if err == nil {
		val, err := ParseQosPrioritySessionDeleteReply_DeleteStatus(ival)
		if err == nil {
			*e = val
			return nil
		}
	}
	return &json.UnmarshalTypeError{
		Value: "value " + string(b),
		Type:  reflect.TypeOf(QosPrioritySessionDeleteReply_DeleteStatus(0)),
	}
}

func (e QosPrioritySessionDeleteReply_DeleteStatus) MarshalJSON() ([]byte, error) {
	str := proto.EnumName(QosPrioritySessionDeleteReply_DeleteStatus_CamelName, int32(e))
	str = strings.TrimPrefix(str, "Qdel")
	return json.Marshal(str)
}

var DeleteStatusCommonPrefix = "Qdel"

func (m *QosPrioritySessionCreateRequest) IsValidArgsForQosPrioritySessionCreate() error {
	return nil
}

func (m *QosPrioritySessionDeleteRequest) IsValidArgsForQosPrioritySessionDelete() error {
	return nil
}

func (m *QosPrioritySessionCreateRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovQos(uint64(m.Ver))
	}
	l = len(m.SessionCookie)
	if l > 0 {
		n += 1 + l + sovQos(uint64(l))
	}
	if m.SessionDuration != 0 {
		n += 1 + sovQos(uint64(m.SessionDuration))
	}
	l = len(m.IpUserEquipment)
	if l > 0 {
		n += 1 + l + sovQos(uint64(l))
	}
	l = len(m.IpApplicationServer)
	if l > 0 {
		n += 1 + l + sovQos(uint64(l))
	}
	l = len(m.PortUserEquipment)
	if l > 0 {
		n += 1 + l + sovQos(uint64(l))
	}
	l = len(m.PortApplicationServer)
	if l > 0 {
		n += 1 + l + sovQos(uint64(l))
	}
	if m.ProtocolIn != 0 {
		n += 1 + sovQos(uint64(m.ProtocolIn))
	}
	if m.ProtocolOut != 0 {
		n += 1 + sovQos(uint64(m.ProtocolOut))
	}
	if m.Profile != 0 {
		n += 1 + sovQos(uint64(m.Profile))
	}
	l = len(m.NotificationUri)
	if l > 0 {
		n += 1 + l + sovQos(uint64(l))
	}
	l = len(m.NotificationAuthToken)
	if l > 0 {
		n += 1 + l + sovQos(uint64(l))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovQos(uint64(len(k))) + 1 + len(v) + sovQos(uint64(len(v)))
			n += mapEntrySize + 2 + sovQos(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QosPrioritySessionReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovQos(uint64(m.Ver))
	}
	if m.SessionDuration != 0 {
		n += 1 + sovQos(uint64(m.SessionDuration))
	}
	if m.Profile != 0 {
		n += 1 + sovQos(uint64(m.Profile))
	}
	l = len(m.SessionId)
	if l > 0 {
		n += 1 + l + sovQos(uint64(l))
	}
	if m.StartedAt != 0 {
		n += 1 + sovQos(uint64(m.StartedAt))
	}
	if m.ExpiresAt != 0 {
		n += 1 + sovQos(uint64(m.ExpiresAt))
	}
	if m.HttpStatus != 0 {
		n += 1 + sovQos(uint64(m.HttpStatus))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovQos(uint64(len(k))) + 1 + len(v) + sovQos(uint64(len(v)))
			n += mapEntrySize + 2 + sovQos(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QosPrioritySessionDeleteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovQos(uint64(m.Ver))
	}
	l = len(m.SessionCookie)
	if l > 0 {
		n += 1 + l + sovQos(uint64(l))
	}
	if m.Profile != 0 {
		n += 1 + sovQos(uint64(m.Profile))
	}
	l = len(m.SessionId)
	if l > 0 {
		n += 1 + l + sovQos(uint64(l))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovQos(uint64(len(k))) + 1 + len(v) + sovQos(uint64(len(v)))
			n += mapEntrySize + 2 + sovQos(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QosPrioritySessionDeleteReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovQos(uint64(m.Ver))
	}
	if m.Status != 0 {
		n += 1 + sovQos(uint64(m.Status))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovQos(uint64(len(k))) + 1 + len(v) + sovQos(uint64(len(v)))
			n += mapEntrySize + 2 + sovQos(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovQos(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozQos(x uint64) (n int) {
	return sovQos(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *QosPrioritySessionCreateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosPrioritySessionCreateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosPrioritySessionCreateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionCookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQos
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionCookie = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionDuration", wireType)
			}
			m.SessionDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionDuration |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpUserEquipment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQos
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpUserEquipment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpApplicationServer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQos
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpApplicationServer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortUserEquipment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQos
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortUserEquipment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortApplicationServer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQos
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortApplicationServer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolIn", wireType)
			}
			m.ProtocolIn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProtocolIn |= QosSessionProtocol(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolOut", wireType)
			}
			m.ProtocolOut = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProtocolOut |= QosSessionProtocol(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Profile", wireType)
			}
			m.Profile = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Profile |= QosSessionProfile(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotificationUri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQos
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NotificationUri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotificationAuthToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQos
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NotificationAuthToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQos
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowQos
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowQos
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthQos
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthQos
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowQos
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthQos
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthQos
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipQos(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthQos
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosPrioritySessionReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosPrioritySessionReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosPrioritySessionReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionDuration", wireType)
			}
			m.SessionDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionDuration |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Profile", wireType)
			}
			m.Profile = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Profile |= QosSessionProfile(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQos
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartedAt", wireType)
			}
			m.StartedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartedAt |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiresAt", wireType)
			}
			m.ExpiresAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpiresAt |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpStatus", wireType)
			}
			m.HttpStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HttpStatus |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQos
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowQos
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowQos
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthQos
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthQos
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowQos
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthQos
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthQos
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipQos(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthQos
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosPrioritySessionDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosPrioritySessionDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosPrioritySessionDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionCookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQos
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionCookie = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Profile", wireType)
			}
			m.Profile = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Profile |= QosSessionProfile(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQos
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQos
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowQos
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowQos
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthQos
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthQos
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowQos
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthQos
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthQos
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipQos(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthQos
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QosPrioritySessionDeleteReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QosPrioritySessionDeleteReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QosPrioritySessionDeleteReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= QosPrioritySessionDeleteReply_DeleteStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQos
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQos
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowQos
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowQos
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthQos
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthQos
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowQos
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthQos
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthQos
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipQos(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthQos
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipQos(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowQos
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQos
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQos
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthQos
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupQos
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthQos
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthQos        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowQos          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupQos = fmt.Errorf("proto: unexpected end of group")
)
