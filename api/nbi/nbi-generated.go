// Package nbi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.3.0 DO NOT EDIT.
package nbi

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	strictecho "github.com/oapi-codegen/runtime/strictmiddleware/echo"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	OpenIdScopes = "openId.Scopes"
)

// Defines values for AppInstanceInfoStatus.
const (
	AppInstanceInfoStatusFailed        AppInstanceInfoStatus = "failed"
	AppInstanceInfoStatusInstantiating AppInstanceInfoStatus = "instantiating"
	AppInstanceInfoStatusReady         AppInstanceInfoStatus = "ready"
	AppInstanceInfoStatusTerminating   AppInstanceInfoStatus = "terminating"
	AppInstanceInfoStatusUnknown       AppInstanceInfoStatus = "unknown"
)

// Defines values for AppManifestAppRepoAuthType.
const (
	DOCKER     AppManifestAppRepoAuthType = "DOCKER"
	HTTPBASIC  AppManifestAppRepoAuthType = "HTTP_BASIC"
	HTTPBEARER AppManifestAppRepoAuthType = "HTTP_BEARER"
	NONE       AppManifestAppRepoAuthType = "NONE"
)

// Defines values for AppManifestAppRepoType.
const (
	PRIVATEREPO AppManifestAppRepoType = "PRIVATEREPO"
	PUBLICREPO  AppManifestAppRepoType = "PUBLICREPO"
)

// Defines values for AppManifestComponentSpecNetworkInterfacesProtocol.
const (
	ANY AppManifestComponentSpecNetworkInterfacesProtocol = "ANY"
	TCP AppManifestComponentSpecNetworkInterfacesProtocol = "TCP"
	UDP AppManifestComponentSpecNetworkInterfacesProtocol = "UDP"
)

// Defines values for AppManifestComponentSpecNetworkInterfacesVisibilityType.
const (
	VISIBILITYEXTERNAL AppManifestComponentSpecNetworkInterfacesVisibilityType = "VISIBILITY_EXTERNAL"
	VISIBILITYINTERNAL AppManifestComponentSpecNetworkInterfacesVisibilityType = "VISIBILITY_INTERNAL"
)

// Defines values for AppManifestPackageType.
const (
	CONTAINER AppManifestPackageType = "CONTAINER"
	HELM      AppManifestPackageType = "HELM"
	OVA       AppManifestPackageType = "OVA"
	QCOW2     AppManifestPackageType = "QCOW2"
)

// Defines values for ContainerResourcesInfraKind.
const (
	Container ContainerResourcesInfraKind = "container"
)

// Defines values for DockerComposeResourcesInfraKind.
const (
	DockerCompose DockerComposeResourcesInfraKind = "dockerCompose"
)

// Defines values for EdgeCloudZoneStatus.
const (
	EdgeCloudZoneStatusActive   EdgeCloudZoneStatus = "active"
	EdgeCloudZoneStatusInactive EdgeCloudZoneStatus = "inactive"
	EdgeCloudZoneStatusUnknown  EdgeCloudZoneStatus = "unknown"
)

// Defines values for K8sNetworkingAdditionalNetworksInterfaceType.
const (
	Interface K8sNetworkingAdditionalNetworksInterfaceType = "interface"
	Netdevice K8sNetworkingAdditionalNetworksInterfaceType = "netdevice"
	VfioPci   K8sNetworkingAdditionalNetworksInterfaceType = "vfio-pci"
)

// Defines values for KubernetesResourcesInfraKind.
const (
	Kubernetes KubernetesResourcesInfraKind = "kubernetes"
)

// Defines values for OperatingSystemArchitecture.
const (
	X86   OperatingSystemArchitecture = "x86"
	X8664 OperatingSystemArchitecture = "x86_64"
)

// Defines values for OperatingSystemFamily.
const (
	OperatingSystemFamilyCOREOS  OperatingSystemFamily = "COREOS"
	OperatingSystemFamilyOTHER   OperatingSystemFamily = "OTHER"
	OperatingSystemFamilyRHEL    OperatingSystemFamily = "RHEL"
	OperatingSystemFamilyUBUNTU  OperatingSystemFamily = "UBUNTU"
	OperatingSystemFamilyWINDOWS OperatingSystemFamily = "WINDOWS"
)

// Defines values for OperatingSystemLicense.
const (
	OperatingSystemLicenseOSLICENSETYPEFREE     OperatingSystemLicense = "OS_LICENSE_TYPE_FREE"
	OperatingSystemLicenseOSLICENSETYPEONDEMAND OperatingSystemLicense = "OS_LICENSE_TYPE_ON_DEMAND"
	OperatingSystemLicenseOTHER                 OperatingSystemLicense = "OTHER"
)

// Defines values for OperatingSystemVersion.
const (
	OSMSWINDOWS2022        OperatingSystemVersion = "OS_MS_WINDOWS_2022"
	OSVERSIONRHEL8         OperatingSystemVersion = "OS_VERSION_RHEL_8"
	OSVERSIONUBUNTU2204LTS OperatingSystemVersion = "OS_VERSION_UBUNTU_2204_LTS"
	OTHER                  OperatingSystemVersion = "OTHER"
)

// Defines values for VmResourcesInfraKind.
const (
	VirtualMachine VmResourcesInfraKind = "virtualMachine"
)

// AccessEndpoint Application Endpoint for an especific instance that is
// running in an specific Edge Cloud Zone.
type AccessEndpoint struct {
	// Fqdn Full qualified domain name of an application instance
	Fqdn *Fqdn `json:"fqdn,omitempty"`

	// Ipv4Addresses IP version 4 of an application instance
	Ipv4Addresses *[]Ipv4Addr `json:"ipv4Addresses,omitempty"`

	// Ipv6Addresses IP version 6 of an application instance.
	Ipv6Addresses *[]Ipv6Addr `json:"ipv6Addresses,omitempty"`

	// Port Port to stablish the connection
	Port  Port `json:"port"`
	union json.RawMessage
}

// AccessEndpoint0 defines model for .
type AccessEndpoint0 = interface{}

// AccessEndpoint1 defines model for .
type AccessEndpoint1 = interface{}

// AccessEndpoint2 defines model for .
type AccessEndpoint2 = interface{}

// AdditionalStorage Additional storage for the application.
type AdditionalStorage = []struct {
	// MountPoint Location of additional storage resource.
	MountPoint string `json:"mountPoint"`

	// Name Name of additional storage resource.
	Name *string `json:"name,omitempty"`

	// StorageSize Additional persistent volume for the application.
	StorageSize string `json:"storageSize"`
}

// AppId A globally unique identifier associated with the application.
// Edge Cloud Platform generates this identifier when the
// Application is submitted.
type AppId = openapi_types.UUID

// AppInstanceId A globally unique identifier associated with a running
// instance of an application.
// Edge Cloud Platform generates this identifier when the
// instantiation in the Edge Cloud Zone is successful.
type AppInstanceId = openapi_types.UUID

// AppInstanceInfo Information about the application instance.
type AppInstanceInfo struct {
	// AppInstanceId A globally unique identifier associated with a running
	// instance of an application.
	// Edge Cloud Platform generates this identifier when the
	// instantiation in the Edge Cloud Zone is successful.
	AppInstanceId *AppInstanceId `json:"appInstanceId,omitempty"`

	// ComponentEndpointInfo Information about the IP and Port exposed by the
	// Edge Cloud Platform.
	// Application Client shall use these access points to reach this
	// application instance
	ComponentEndpointInfo *[]struct {
		// AccessPoints Application Endpoint for an especific instance that is
		// running in an specific Edge Cloud Zone.
		AccessPoints AccessEndpoint `json:"accessPoints"`

		// InterfaceId This is the interface Identifier that Application Provider
		// defines when application is being submitted.
		InterfaceId string `json:"interfaceId"`
	} `json:"componentEndpointInfo,omitempty"`

	// EdgeCloudZone An Edge Cloud Zone, uniquely identified by a
	// combination of the value of the Edge Cloud Zone Id object
	// and the value of the Edge Cloud Provider
	// object. This value is used to identify an Edge Cloud zone
	// between Edge Clouds from different Edge Cloud Providers.
	EdgeCloudZone *EdgeCloudZone `json:"edgeCloudZone,omitempty"`

	// Status Status of the application instance (default is 'unknown')
	Status *AppInstanceInfoStatus `json:"status,omitempty"`
}

// AppInstanceInfoStatus Status of the application instance (default is 'unknown')
type AppInstanceInfoStatus string

// AppManifest Application information and requirements provided by the
// Application Provider
type AppManifest struct {
	// AppId A globally unique identifier associated with the application.
	// Edge Cloud Platform generates this identifier when the
	// Application is submitted.
	AppId *AppId `json:"appId,omitempty"`

	// AppRepo Repository where Application Provider stores the application image
	AppRepo struct {
		// AuthType The credentials can also be formatted as a Basic
		// auth or Bearer auth in HTTP "Authorization" header.
		AuthType *AppManifestAppRepoAuthType `json:"authType,omitempty"`

		// Checksum MD5 checksum for VM and file-based images, sha256
		// digest for containers
		Checksum *string `json:"checksum,omitempty"`

		// Credentials Password or personal access token created by
		// developer to acces the app repository. API users can generate
		// a personal access token e.g. docker clients to use them as
		// password.
		Credentials *string `json:"credentials,omitempty"`

		// ImagePath A Uniform Resource Identifier (URI) as per RFC 3986,
		// identifies the endpoint within an Edge Cloud Zone where the user
		// equipment may connect to the selected application instance
		ImagePath Uri `json:"imagePath"`

		// Type Application repository and image URI information.
		// PUBLICREPO is used of public urls like github, helm repo etc.
		// PRIVATEREPO  is used for private repo managed by the application
		// developer. Private repo can be accessed by using the app
		// developer provided userName and password. Password is
		// recommended to be the personal access token created by developer
		// e.g. in Github repo.
		Type AppManifestAppRepoType `json:"type"`

		// UserName Username to acces the Helm chart, docker-compose
		// file or VM image repository
		UserName *string `json:"userName,omitempty"`
	} `json:"appRepo"`

	// ComponentSpec Information defined in "appRepo" point to the application
	// descriptor e.g. Helm chart, docker-compose yaml file etc.
	// The descriptor may contain one or more containers and their
	// associated meta-data. A component refers to additional details
	// about these containers to expose the instances of the containers
	// to external client applications. App provider can define one or
	// more components (via the associated network port) in componentSpec
	// corresponding to the containers in helm charts or docker-compose
	// yaml file as part of app descriptors.
	ComponentSpec []struct {
		// ComponentName Component name must be unique with an application
		ComponentName string `json:"componentName"`

		// NetworkInterfaces Each application component exposes some ports
		// either for external users or for inter component
		// communication.
		// Application provider is required to specify which ports are
		// to be exposed and the type of traffic that will flow through
		// these ports.The underlying platform may assign a dynamic port
		// against the "extPort" that the application clients will use
		// to connect with edge application instance.
		NetworkInterfaces []struct {
			// InterfaceId Each Port and corresponding traffic protocol
			// exposed by the component is identified by a name.
			// Application client on user device requires this to
			// uniquley idenify the interface.
			InterfaceId string `json:"interfaceId"`

			// Port Port number exposed by the component.
			// Edge Cloud Provider may generate a dynamic port
			// towards the component instance which forwards
			// external traffic to the component port.
			Port int32 `json:"port"`

			// Protocol Defines the IP transport communication
			// protocol i.e., TCP, UDP or ANY
			Protocol AppManifestComponentSpecNetworkInterfacesProtocol `json:"protocol"`

			// VisibilityType Defines whether the interface is exposed
			// to outer world or not i.e., external, or internal.
			// If this is set to "external", then it is  exposed
			// to external applications otherwise it is exposed
			// internally to edge application components within
			// edge cloud. When exposed to external world,
			// an external dynamic port is assigned for UC traffic
			// and mapped to the extPort
			VisibilityType AppManifestComponentSpecNetworkInterfacesVisibilityType `json:"visibilityType"`
		} `json:"networkInterfaces"`
	} `json:"componentSpec"`

	// Name Name of the application.
	Name string `json:"name"`

	// OperatingSystem Information about the Operating System of the application image
	OperatingSystem *OperatingSystem `json:"operatingSystem,omitempty"`

	// PackageType Format of the application image package
	PackageType AppManifestPackageType `json:"packageType"`

	// RequiredResources Fundamental hardware requirements to be provisioned by the
	// Application Provider.
	RequiredResources RequiredResources `json:"requiredResources"`

	// Version Application version information
	Version string `json:"version"`
}

// AppManifestAppRepoAuthType The credentials can also be formatted as a Basic
// auth or Bearer auth in HTTP "Authorization" header.
type AppManifestAppRepoAuthType string

// AppManifestAppRepoType Application repository and image URI information.
// PUBLICREPO is used of public urls like github, helm repo etc.
// PRIVATEREPO  is used for private repo managed by the application
// developer. Private repo can be accessed by using the app
// developer provided userName and password. Password is
// recommended to be the personal access token created by developer
// e.g. in Github repo.
type AppManifestAppRepoType string

// AppManifestComponentSpecNetworkInterfacesProtocol Defines the IP transport communication
// protocol i.e., TCP, UDP or ANY
type AppManifestComponentSpecNetworkInterfacesProtocol string

// AppManifestComponentSpecNetworkInterfacesVisibilityType Defines whether the interface is exposed
// to outer world or not i.e., external, or internal.
// If this is set to "external", then it is  exposed
// to external applications otherwise it is exposed
// internally to edge application components within
// edge cloud. When exposed to external world,
// an external dynamic port is assigned for UC traffic
// and mapped to the extPort
type AppManifestComponentSpecNetworkInterfacesVisibilityType string

// AppManifestPackageType Format of the application image package
type AppManifestPackageType string

// AppZones Collection of Edge Cloud Zones where the Application Provider wants to
// instantiate the application.
type AppZones = []EdgeCloudZone

// ContainerResources Container Infrastructure Definition
type ContainerResources struct {
	// Gpu Information about the supported GPUs
	Gpu *GpuInfo `json:"gpu,omitempty"`

	// InfraKind Type of infrastructure for the application.
	InfraKind ContainerResourcesInfraKind `json:"infraKind"`

	// Memory Memory in mega bytes
	Memory int `json:"memory"`

	// NumCPU Number of vcpus in whole (i.e 1), decimal (i.e 0.500) up to
	// millivcpu, or millivcpu (i.e 500m) format.
	NumCPU Vcpu `json:"numCPU"`

	// Storage Additional storage for the application.
	Storage *AdditionalStorage `json:"storage,omitempty"`
}

// ContainerResourcesInfraKind Type of infrastructure for the application.
type ContainerResourcesInfraKind string

// DockerComposeResources Definition of Docker Compose Infrastructure
type DockerComposeResources struct {
	// Gpu Information about the supported GPUs
	Gpu *GpuInfo `json:"gpu,omitempty"`

	// InfraKind Type of infrastructure for the application.
	InfraKind DockerComposeResourcesInfraKind `json:"infraKind"`

	// Memory Memory in mega bytes
	Memory int `json:"memory"`

	// NumCPU Number of vcpus in whole (i.e 1)
	NumCPU int `json:"numCPU"`

	// Storage Additional storage for the application.
	Storage *AdditionalStorage `json:"storage,omitempty"`
}

// DockerComposeResourcesInfraKind Type of infrastructure for the application.
type DockerComposeResourcesInfraKind string

// EdgeCloudProvider Human readable name of the Edge Cloud Provider.
type EdgeCloudProvider = string

// EdgeCloudRegion Human readable name of the geographical Edge Cloud Region of
// the Edge Cloud. Defined by the Edge Cloud Provider.
type EdgeCloudRegion = string

// EdgeCloudZone An Edge Cloud Zone, uniquely identified by a
// combination of the value of the Edge Cloud Zone Id object
// and the value of the Edge Cloud Provider
// object. This value is used to identify an Edge Cloud zone
// between Edge Clouds from different Edge Cloud Providers.
type EdgeCloudZone struct {
	// EdgeCloudKubernetesClusterRef A global unique identifier associated with a Kubernetes cluster
	// infrastructure.
	EdgeCloudKubernetesClusterRef *KubernetesClusterRef `json:"edgeCloudKubernetesClusterRef,omitempty"`

	// EdgeCloudProvider Human readable name of the Edge Cloud Provider.
	EdgeCloudProvider EdgeCloudProvider `json:"edgeCloudProvider"`

	// EdgeCloudRegion Human readable name of the geographical Edge Cloud Region of
	// the Edge Cloud. Defined by the Edge Cloud Provider.
	EdgeCloudRegion *EdgeCloudRegion `json:"edgeCloudRegion,omitempty"`

	// EdgeCloudZoneId Unique identifier created by the Edge Cloud Platform to identify an
	// Edge Cloud Zone within an Edge Cloud.
	EdgeCloudZoneId EdgeCloudZoneId `json:"edgeCloudZoneId"`

	// EdgeCloudZoneName Human readable name of the geographical zone of
	// the Edge Cloud. Defined by the Edge Cloud Provider.
	EdgeCloudZoneName EdgeCloudZoneName `json:"edgeCloudZoneName"`

	// EdgeCloudZoneStatus Status of the Edge Cloud Zone (default is 'unknown')
	EdgeCloudZoneStatus *EdgeCloudZoneStatus `json:"edgeCloudZoneStatus,omitempty"`
}

// EdgeCloudZoneId Unique identifier created by the Edge Cloud Platform to identify an
// Edge Cloud Zone within an Edge Cloud.
type EdgeCloudZoneId = openapi_types.UUID

// EdgeCloudZoneName Human readable name of the geographical zone of
// the Edge Cloud. Defined by the Edge Cloud Provider.
type EdgeCloudZoneName = string

// EdgeCloudZoneStatus Status of the Edge Cloud Zone (default is 'unknown')
type EdgeCloudZoneStatus string

// EdgeCloudZones A collection of Edge Cloud Zones where the Application Provider can
// instantiate an Application Instance.
type EdgeCloudZones = []EdgeCloudZone

// ErrorInfo Information about the error
type ErrorInfo struct {
	// Code Code given to this error
	Code string `json:"code"`

	// Message Detailed error description
	Message string `json:"message"`

	// Status HTTP status code returned along with this error response
	Status int `json:"status"`
}

// Fqdn Full qualified domain name of an application instance
type Fqdn = string

// GpuInfo Information about the supported GPUs
type GpuInfo struct {
	// GpuMemory GPU memory in mega bytes
	GpuMemory int `json:"gpuMemory"`

	// NumGPU Number of GPUs
	NumGPU int `json:"numGPU"`
}

// Ipv4Addr IP of the device. A single IPv4 address may be specified in
// dotted-quad form 1.2.3.4. Only this exact IP number will match the flow
// control rule.
type Ipv4Addr = string

// Ipv6Addr IP of the device. A single IPv6 address, following IETF 5952
// format, may be specified like 2001:db8:85a3:8d3:1319:8a2e:370:7344
type Ipv6Addr = string

// K8sAddons Addons for the Kubernetes cluster.
// Additional addons should be defined in application the helm chart
// (Service Mesh, Serverless, AI).
type K8sAddons struct {
	// Ingress Enable ingress for Kubernetes cluster.
	Ingress *bool `json:"ingress,omitempty"`

	// Monitoring Enable monitoring for Kubernetes cluster.
	Monitoring *bool `json:"monitoring,omitempty"`
}

// K8sNetworking Kubernetes networking definition
type K8sNetworking struct {
	// AdditionalNetworks Additional Networks for the Kubernetes cluster.
	AdditionalNetworks *[]struct {
		// InterfaceType Type of additional Interface:
		// netdevice: (SR-IOV) A regular kernel network device in the
		//            Network Namespace (netns) of the container
		// vfio-pci: (SR-IOV) A PCI network interface directly mounted
		//           in the container
		// interface: Additional interface to be used by cni plugins
		//            such as macvlan, ipvlan
		// Note: The use of SR-IOV interfaces automatically
		// configure the required kernel parameters for the nodes.
		InterfaceType *K8sNetworkingAdditionalNetworksInterfaceType `json:"interfaceType,omitempty"`

		// Name Additional Network Name
		Name *string `json:"name,omitempty"`
	} `json:"additionalNetworks,omitempty"`

	// PrimaryNetwork Definition of Kubernetes primary Network
	PrimaryNetwork *struct {
		// Provider CNI provider name
		Provider *string `json:"provider,omitempty"`

		// Version CNI provider version
		Version *string `json:"version,omitempty"`
	} `json:"primaryNetwork,omitempty"`
}

// K8sNetworkingAdditionalNetworksInterfaceType Type of additional Interface:
// netdevice: (SR-IOV) A regular kernel network device in the
//
//	Network Namespace (netns) of the container
//
// vfio-pci: (SR-IOV) A PCI network interface directly mounted
//
//	in the container
//
// interface: Additional interface to be used by cni plugins
//
//	such as macvlan, ipvlan
//
// Note: The use of SR-IOV interfaces automatically
// configure the required kernel parameters for the nodes.
type K8sNetworkingAdditionalNetworksInterfaceType string

// KubernetesClusterRef A global unique identifier associated with a Kubernetes cluster
// infrastructure.
type KubernetesClusterRef = openapi_types.UUID

// KubernetesResources Definition of Kubernetes Cluster Infrastructure.
type KubernetesResources struct {
	// AdditionalStorage Amount of persistent storage allocated to the Kubernetes PVC.
	AdditionalStorage *string `json:"additionalStorage,omitempty"`

	// Addons Addons for the Kubernetes cluster.
	// Additional addons should be defined in application the helm chart
	// (Service Mesh, Serverless, AI).
	Addons *K8sAddons `json:"addons,omitempty"`

	// ApplicationResources Application resources define the resources pool required
	// by the application to be executed in a Kubernetes clusters.
	ApplicationResources struct {
		// CpuPool CPU Pool refers to the amount of application' resources
		// that is executed in nodes with CPU only. That means the part
		// of application that doesn't require GPU or other kind of
		// acceleration.
		// CPU pool is not mandatory when the application is executed
		// exclusively in a GPU pool.
		// A CPU pool is composed by CPU and memory.
		CpuPool *struct {
			// Memory Total memory in mega bytes of CPU pool.
			Memory int `json:"memory"`

			// NumCPU Total number of vcpus in whole (i.e 1) of CPU pool.
			NumCPU int `json:"numCPU"`

			// Topology CPU pool topology defines an application's CPU-based
			// architecture.
			// When deploying for high availability or redundancy, it
			// allows for clustering with a configurable number of nodes
			// and minimum CPU/memory resource per Kubernetes node
			// requirements.
			Topology struct {
				// MinNodeCpu Minimum number of vcpus in whole (i.e 1) per cluster
				// node in CPU pool.
				MinNodeCpu int `json:"minNodeCpu"`

				// MinNodeMemory Minimum memory in mega bytes per cluster node in
				// CPU pool.
				MinNodeMemory int `json:"minNodeMemory"`

				// MinNumberOfNodes Minimum number of worker nodes required by the
				// application.
				MinNumberOfNodes int `json:"minNumberOfNodes"`
			} `json:"topology"`
		} `json:"cpuPool,omitempty"`

		// GpuPool GPU Pool refers to the amount of resources of the application
		// that is executed in nodes with GPU.
		// GPU Pool is not mandatory when the application is executed
		// exclusively in a CPU pool.
		// A GPU pool is composed by memory, CPU and GPU memory
		GpuPool *struct {
			// GpuMemory Total GPU memory in giga bytes of GPU pool.
			GpuMemory int `json:"gpuMemory"`

			// Memory Total memory in mega bytes of GPU pool.
			Memory int `json:"memory"`

			// NumCPU Total Number of vcpus in whole (i.e 1) of GPU pool.
			NumCPU int `json:"numCPU"`

			// Topology GPU pool topology defines an application's GPU-based
			// architecture.
			// When deploying for high availability or redundancy, it
			// allows for clustering with a configurable number of nodes
			// and minimum CPU/memory/GPU memory resource per Kubernetes
			// node requirements.
			Topology struct {
				// MinNodeCpu Minimum number of vcpus in whole (i.e 1) per cluster
				// node in GPU pool.
				MinNodeCpu int `json:"minNodeCpu"`

				// MinNodeGpuMemory Minimum memory in giga bytes per cluster node in GPU pool.
				MinNodeGpuMemory int `json:"minNodeGpuMemory"`

				// MinNodeMemory Minimum memory in mega bytes per cluster node in
				// GPU pool.
				MinNodeMemory int `json:"minNodeMemory"`

				// MinNumberOfNodes Minimum number of worker nodes with GPU required by
				// the application.
				MinNumberOfNodes int `json:"minNumberOfNodes"`
			} `json:"topology"`
		} `json:"gpuPool,omitempty"`
	} `json:"applicationResources"`

	// InfraKind Type of infrastructure for the application.
	InfraKind KubernetesResourcesInfraKind `json:"infraKind"`

	// IsStandalone Define if the Kubernetes clusters can be reused by other
	// applications.
	IsStandalone bool `json:"isStandalone"`

	// KubernetesClusterRef A global unique identifier associated with a Kubernetes cluster
	// infrastructure.
	KubernetesClusterRef *KubernetesClusterRef `json:"kubernetesClusterRef,omitempty"`

	// Networking Kubernetes networking definition
	Networking *K8sNetworking `json:"networking,omitempty"`

	// Version Minimum Kubernetes Version.
	Version *string `json:"version,omitempty"`
}

// KubernetesResourcesInfraKind Type of infrastructure for the application.
type KubernetesResourcesInfraKind string

// OperatingSystem Information about the Operating System of the application image
type OperatingSystem struct {
	// Architecture Type of the OS Architecture
	Architecture OperatingSystemArchitecture `json:"architecture"`

	// Family Family to which OS belongs
	Family OperatingSystemFamily `json:"family"`

	// License License needed to activate the OS
	License OperatingSystemLicense `json:"license"`

	// Version Version of the OS
	Version OperatingSystemVersion `json:"version"`
}

// OperatingSystemArchitecture Type of the OS Architecture
type OperatingSystemArchitecture string

// OperatingSystemFamily Family to which OS belongs
type OperatingSystemFamily string

// OperatingSystemLicense License needed to activate the OS
type OperatingSystemLicense string

// OperatingSystemVersion Version of the OS
type OperatingSystemVersion string

// Port Port to stablish the connection
type Port = int

// RequiredResources Fundamental hardware requirements to be provisioned by the
// Application Provider.
type RequiredResources struct {
	union json.RawMessage
}

// SubmittedApp Information about the submitted app
type SubmittedApp struct {
	// AppId A globally unique identifier associated with the application.
	// Edge Cloud Platform generates this identifier when the
	// Application is submitted.
	AppId *AppId `json:"appId,omitempty"`
}

// Uri A Uniform Resource Identifier (URI) as per RFC 3986,
// identifies the endpoint within an Edge Cloud Zone where the user
// equipment may connect to the selected application instance
type Uri = string

// Vcpu Number of vcpus in whole (i.e 1), decimal (i.e 0.500) up to
// millivcpu, or millivcpu (i.e 500m) format.
type Vcpu = string

// VmResources Definition of Virtual Machine Infrastructure
type VmResources struct {
	// AdditionalStorages Additional storage for the application.
	AdditionalStorages *AdditionalStorage `json:"additionalStorages,omitempty"`

	// Gpu Information about the supported GPUs
	Gpu *GpuInfo `json:"gpu,omitempty"`

	// InfraKind Type of infrastructure for the application.
	InfraKind VmResourcesInfraKind `json:"infraKind"`

	// Memory Memory in mega bytes
	Memory int `json:"memory"`

	// NumCPU Number of vcpus in whole (i.e 1)
	NumCPU int `json:"numCPU"`
}

// VmResourcesInfraKind Type of infrastructure for the application.
type VmResourcesInfraKind string

// XCorrelator defines model for x-correlator.
type XCorrelator = string

// N400 Information about the error
type N400 = ErrorInfo

// N401 Information about the error
type N401 = ErrorInfo

// N403 Information about the error
type N403 = ErrorInfo

// N404 Information about the error
type N404 = ErrorInfo

// N500 Information about the error
type N500 = ErrorInfo

// N501 Information about the error
type N501 = ErrorInfo

// N503 Information about the error
type N503 = ErrorInfo

// GetAppInstanceParams defines parameters for GetAppInstance.
type GetAppInstanceParams struct {
	// AppId A globally unique identifier associated with
	// the application.
	// Edge Cloud Provider generates this identifier when the
	// application is submitted.
	AppId *AppId `form:"appId,omitempty" json:"appId,omitempty"`

	// AppInstanceId A globally unique identifier associated with a running
	// instance of an application within an specific Edge Cloud Zone.
	// Edge Cloud Provider generates this identifier.
	AppInstanceId *AppInstanceId `form:"appInstanceId,omitempty" json:"appInstanceId,omitempty"`

	// Region Human readable name of the geographical Edge Cloud Region of
	// the Edge Cloud. Defined by the Edge Cloud Provider.
	Region *EdgeCloudRegion `form:"region,omitempty" json:"region,omitempty"`

	// XCorrelator Correlation id for the different services
	XCorrelator *XCorrelator `json:"x-correlator,omitempty"`
}

// CreateAppInstanceJSONBody defines parameters for CreateAppInstance.
type CreateAppInstanceJSONBody struct {
	// AppId A globally unique identifier associated with the application.
	// Edge Cloud Platform generates this identifier when the
	// Application is submitted.
	AppId *AppId `json:"appId,omitempty"`

	// AppZones Collection of Edge Cloud Zones where the Application Provider wants to
	// instantiate the application.
	AppZones *AppZones `json:"appZones,omitempty"`
}

// CreateAppInstanceParams defines parameters for CreateAppInstance.
type CreateAppInstanceParams struct {
	// XCorrelator Correlation id for the different services
	XCorrelator *XCorrelator `json:"x-correlator,omitempty"`
}

// DeleteAppInstanceParams defines parameters for DeleteAppInstance.
type DeleteAppInstanceParams struct {
	// XCorrelator Correlation id for the different services
	XCorrelator *XCorrelator `json:"x-correlator,omitempty"`
}

// GetAppsParams defines parameters for GetApps.
type GetAppsParams struct {
	// XCorrelator Correlation id for the different services
	XCorrelator *XCorrelator `json:"x-correlator,omitempty"`
}

// SubmitAppParams defines parameters for SubmitApp.
type SubmitAppParams struct {
	// XCorrelator Correlation id for the different services
	XCorrelator *XCorrelator `json:"x-correlator,omitempty"`
}

// DeleteAppParams defines parameters for DeleteApp.
type DeleteAppParams struct {
	// XCorrelator Correlation id for the different services
	XCorrelator *XCorrelator `json:"x-correlator,omitempty"`
}

// GetAppParams defines parameters for GetApp.
type GetAppParams struct {
	// XCorrelator Correlation id for the different services
	XCorrelator *XCorrelator `json:"x-correlator,omitempty"`
}

// GetEdgeCloudZonesParams defines parameters for GetEdgeCloudZones.
type GetEdgeCloudZonesParams struct {
	// Region Human readable name of the geographical Edge Cloud Region of
	// the Edge Cloud. Defined by the Edge Cloud Provider.
	Region *EdgeCloudRegion `form:"region,omitempty" json:"region,omitempty"`

	// Status Human readable status of the Edge Cloud Zone
	Status *EdgeCloudZoneStatus `form:"status,omitempty" json:"status,omitempty"`

	// XCorrelator Correlation id for the different services
	XCorrelator *XCorrelator `json:"x-correlator,omitempty"`
}

// CreateAppInstanceJSONRequestBody defines body for CreateAppInstance for application/json ContentType.
type CreateAppInstanceJSONRequestBody CreateAppInstanceJSONBody

// SubmitAppJSONRequestBody defines body for SubmitApp for application/json ContentType.
type SubmitAppJSONRequestBody = AppManifest

// AsAccessEndpoint0 returns the union data inside the AccessEndpoint as a AccessEndpoint0
func (t AccessEndpoint) AsAccessEndpoint0() (AccessEndpoint0, error) {
	var body AccessEndpoint0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAccessEndpoint0 overwrites any union data inside the AccessEndpoint as the provided AccessEndpoint0
func (t *AccessEndpoint) FromAccessEndpoint0(v AccessEndpoint0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAccessEndpoint0 performs a merge with any union data inside the AccessEndpoint, using the provided AccessEndpoint0
func (t *AccessEndpoint) MergeAccessEndpoint0(v AccessEndpoint0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAccessEndpoint1 returns the union data inside the AccessEndpoint as a AccessEndpoint1
func (t AccessEndpoint) AsAccessEndpoint1() (AccessEndpoint1, error) {
	var body AccessEndpoint1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAccessEndpoint1 overwrites any union data inside the AccessEndpoint as the provided AccessEndpoint1
func (t *AccessEndpoint) FromAccessEndpoint1(v AccessEndpoint1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAccessEndpoint1 performs a merge with any union data inside the AccessEndpoint, using the provided AccessEndpoint1
func (t *AccessEndpoint) MergeAccessEndpoint1(v AccessEndpoint1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAccessEndpoint2 returns the union data inside the AccessEndpoint as a AccessEndpoint2
func (t AccessEndpoint) AsAccessEndpoint2() (AccessEndpoint2, error) {
	var body AccessEndpoint2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAccessEndpoint2 overwrites any union data inside the AccessEndpoint as the provided AccessEndpoint2
func (t *AccessEndpoint) FromAccessEndpoint2(v AccessEndpoint2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAccessEndpoint2 performs a merge with any union data inside the AccessEndpoint, using the provided AccessEndpoint2
func (t *AccessEndpoint) MergeAccessEndpoint2(v AccessEndpoint2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t AccessEndpoint) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.Fqdn != nil {
		object["fqdn"], err = json.Marshal(t.Fqdn)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'fqdn': %w", err)
		}
	}

	if t.Ipv4Addresses != nil {
		object["ipv4Addresses"], err = json.Marshal(t.Ipv4Addresses)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ipv4Addresses': %w", err)
		}
	}

	if t.Ipv6Addresses != nil {
		object["ipv6Addresses"], err = json.Marshal(t.Ipv6Addresses)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ipv6Addresses': %w", err)
		}
	}

	object["port"], err = json.Marshal(t.Port)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'port': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *AccessEndpoint) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["fqdn"]; found {
		err = json.Unmarshal(raw, &t.Fqdn)
		if err != nil {
			return fmt.Errorf("error reading 'fqdn': %w", err)
		}
	}

	if raw, found := object["ipv4Addresses"]; found {
		err = json.Unmarshal(raw, &t.Ipv4Addresses)
		if err != nil {
			return fmt.Errorf("error reading 'ipv4Addresses': %w", err)
		}
	}

	if raw, found := object["ipv6Addresses"]; found {
		err = json.Unmarshal(raw, &t.Ipv6Addresses)
		if err != nil {
			return fmt.Errorf("error reading 'ipv6Addresses': %w", err)
		}
	}

	if raw, found := object["port"]; found {
		err = json.Unmarshal(raw, &t.Port)
		if err != nil {
			return fmt.Errorf("error reading 'port': %w", err)
		}
	}

	return err
}

// AsKubernetesResources returns the union data inside the RequiredResources as a KubernetesResources
func (t RequiredResources) AsKubernetesResources() (KubernetesResources, error) {
	var body KubernetesResources
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromKubernetesResources overwrites any union data inside the RequiredResources as the provided KubernetesResources
func (t *RequiredResources) FromKubernetesResources(v KubernetesResources) error {
	v.InfraKind = "kubernetes"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeKubernetesResources performs a merge with any union data inside the RequiredResources, using the provided KubernetesResources
func (t *RequiredResources) MergeKubernetesResources(v KubernetesResources) error {
	v.InfraKind = "kubernetes"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVmResources returns the union data inside the RequiredResources as a VmResources
func (t RequiredResources) AsVmResources() (VmResources, error) {
	var body VmResources
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVmResources overwrites any union data inside the RequiredResources as the provided VmResources
func (t *RequiredResources) FromVmResources(v VmResources) error {
	v.InfraKind = "virtualMachine"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVmResources performs a merge with any union data inside the RequiredResources, using the provided VmResources
func (t *RequiredResources) MergeVmResources(v VmResources) error {
	v.InfraKind = "virtualMachine"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsContainerResources returns the union data inside the RequiredResources as a ContainerResources
func (t RequiredResources) AsContainerResources() (ContainerResources, error) {
	var body ContainerResources
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContainerResources overwrites any union data inside the RequiredResources as the provided ContainerResources
func (t *RequiredResources) FromContainerResources(v ContainerResources) error {
	v.InfraKind = "container"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContainerResources performs a merge with any union data inside the RequiredResources, using the provided ContainerResources
func (t *RequiredResources) MergeContainerResources(v ContainerResources) error {
	v.InfraKind = "container"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDockerComposeResources returns the union data inside the RequiredResources as a DockerComposeResources
func (t RequiredResources) AsDockerComposeResources() (DockerComposeResources, error) {
	var body DockerComposeResources
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDockerComposeResources overwrites any union data inside the RequiredResources as the provided DockerComposeResources
func (t *RequiredResources) FromDockerComposeResources(v DockerComposeResources) error {
	v.InfraKind = "dockerCompose"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDockerComposeResources performs a merge with any union data inside the RequiredResources, using the provided DockerComposeResources
func (t *RequiredResources) MergeDockerComposeResources(v DockerComposeResources) error {
	v.InfraKind = "dockerCompose"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RequiredResources) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"infraKind"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t RequiredResources) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "container":
		return t.AsContainerResources()
	case "dockerCompose":
		return t.AsDockerComposeResources()
	case "kubernetes":
		return t.AsKubernetesResources()
	case "virtualMachine":
		return t.AsVmResources()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t RequiredResources) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RequiredResources) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAppInstance request
	GetAppInstance(ctx context.Context, params *GetAppInstanceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAppInstanceWithBody request with any body
	CreateAppInstanceWithBody(ctx context.Context, params *CreateAppInstanceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAppInstance(ctx context.Context, params *CreateAppInstanceParams, body CreateAppInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAppInstance request
	DeleteAppInstance(ctx context.Context, appInstanceId AppInstanceId, params *DeleteAppInstanceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApps request
	GetApps(ctx context.Context, params *GetAppsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SubmitAppWithBody request with any body
	SubmitAppWithBody(ctx context.Context, params *SubmitAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SubmitApp(ctx context.Context, params *SubmitAppParams, body SubmitAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApp request
	DeleteApp(ctx context.Context, appId AppId, params *DeleteAppParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApp request
	GetApp(ctx context.Context, appId AppId, params *GetAppParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEdgeCloudZones request
	GetEdgeCloudZones(ctx context.Context, params *GetEdgeCloudZonesParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetAppInstance(ctx context.Context, params *GetAppInstanceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppInstanceRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAppInstanceWithBody(ctx context.Context, params *CreateAppInstanceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAppInstanceRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAppInstance(ctx context.Context, params *CreateAppInstanceParams, body CreateAppInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAppInstanceRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAppInstance(ctx context.Context, appInstanceId AppInstanceId, params *DeleteAppInstanceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAppInstanceRequest(c.Server, appInstanceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApps(ctx context.Context, params *GetAppsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SubmitAppWithBody(ctx context.Context, params *SubmitAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSubmitAppRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SubmitApp(ctx context.Context, params *SubmitAppParams, body SubmitAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSubmitAppRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApp(ctx context.Context, appId AppId, params *DeleteAppParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAppRequest(c.Server, appId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApp(ctx context.Context, appId AppId, params *GetAppParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppRequest(c.Server, appId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEdgeCloudZones(ctx context.Context, params *GetEdgeCloudZonesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEdgeCloudZonesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetAppInstanceRequest generates requests for GetAppInstance
func NewGetAppInstanceRequest(server string, params *GetAppInstanceParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/appinstances")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AppId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "appId", runtime.ParamLocationQuery, *params.AppId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AppInstanceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "appInstanceId", runtime.ParamLocationQuery, *params.AppInstanceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Region != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "region", runtime.ParamLocationQuery, *params.Region); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XCorrelator != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-correlator", runtime.ParamLocationHeader, *params.XCorrelator)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-correlator", headerParam0)
		}

	}

	return req, nil
}

// NewCreateAppInstanceRequest calls the generic CreateAppInstance builder with application/json body
func NewCreateAppInstanceRequest(server string, params *CreateAppInstanceParams, body CreateAppInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAppInstanceRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateAppInstanceRequestWithBody generates requests for CreateAppInstance with any type of body
func NewCreateAppInstanceRequestWithBody(server string, params *CreateAppInstanceParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/appinstances")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XCorrelator != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-correlator", runtime.ParamLocationHeader, *params.XCorrelator)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-correlator", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteAppInstanceRequest generates requests for DeleteAppInstance
func NewDeleteAppInstanceRequest(server string, appInstanceId AppInstanceId, params *DeleteAppInstanceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "appInstanceId", runtime.ParamLocationPath, appInstanceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/appinstances/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XCorrelator != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-correlator", runtime.ParamLocationHeader, *params.XCorrelator)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-correlator", headerParam0)
		}

	}

	return req, nil
}

// NewGetAppsRequest generates requests for GetApps
func NewGetAppsRequest(server string, params *GetAppsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XCorrelator != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-correlator", runtime.ParamLocationHeader, *params.XCorrelator)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-correlator", headerParam0)
		}

	}

	return req, nil
}

// NewSubmitAppRequest calls the generic SubmitApp builder with application/json body
func NewSubmitAppRequest(server string, params *SubmitAppParams, body SubmitAppJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSubmitAppRequestWithBody(server, params, "application/json", bodyReader)
}

// NewSubmitAppRequestWithBody generates requests for SubmitApp with any type of body
func NewSubmitAppRequestWithBody(server string, params *SubmitAppParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XCorrelator != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-correlator", runtime.ParamLocationHeader, *params.XCorrelator)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-correlator", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteAppRequest generates requests for DeleteApp
func NewDeleteAppRequest(server string, appId AppId, params *DeleteAppParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "appId", runtime.ParamLocationPath, appId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XCorrelator != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-correlator", runtime.ParamLocationHeader, *params.XCorrelator)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-correlator", headerParam0)
		}

	}

	return req, nil
}

// NewGetAppRequest generates requests for GetApp
func NewGetAppRequest(server string, appId AppId, params *GetAppParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "appId", runtime.ParamLocationPath, appId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XCorrelator != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-correlator", runtime.ParamLocationHeader, *params.XCorrelator)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-correlator", headerParam0)
		}

	}

	return req, nil
}

// NewGetEdgeCloudZonesRequest generates requests for GetEdgeCloudZones
func NewGetEdgeCloudZonesRequest(server string, params *GetEdgeCloudZonesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/edge-cloud-zones")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Region != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "region", runtime.ParamLocationQuery, *params.Region); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XCorrelator != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-correlator", runtime.ParamLocationHeader, *params.XCorrelator)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-correlator", headerParam0)
		}

	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAppInstanceWithResponse request
	GetAppInstanceWithResponse(ctx context.Context, params *GetAppInstanceParams, reqEditors ...RequestEditorFn) (*GetAppInstanceResponse, error)

	// CreateAppInstanceWithBodyWithResponse request with any body
	CreateAppInstanceWithBodyWithResponse(ctx context.Context, params *CreateAppInstanceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAppInstanceResponse, error)

	CreateAppInstanceWithResponse(ctx context.Context, params *CreateAppInstanceParams, body CreateAppInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAppInstanceResponse, error)

	// DeleteAppInstanceWithResponse request
	DeleteAppInstanceWithResponse(ctx context.Context, appInstanceId AppInstanceId, params *DeleteAppInstanceParams, reqEditors ...RequestEditorFn) (*DeleteAppInstanceResponse, error)

	// GetAppsWithResponse request
	GetAppsWithResponse(ctx context.Context, params *GetAppsParams, reqEditors ...RequestEditorFn) (*GetAppsResponse, error)

	// SubmitAppWithBodyWithResponse request with any body
	SubmitAppWithBodyWithResponse(ctx context.Context, params *SubmitAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SubmitAppResponse, error)

	SubmitAppWithResponse(ctx context.Context, params *SubmitAppParams, body SubmitAppJSONRequestBody, reqEditors ...RequestEditorFn) (*SubmitAppResponse, error)

	// DeleteAppWithResponse request
	DeleteAppWithResponse(ctx context.Context, appId AppId, params *DeleteAppParams, reqEditors ...RequestEditorFn) (*DeleteAppResponse, error)

	// GetAppWithResponse request
	GetAppWithResponse(ctx context.Context, appId AppId, params *GetAppParams, reqEditors ...RequestEditorFn) (*GetAppResponse, error)

	// GetEdgeCloudZonesWithResponse request
	GetEdgeCloudZonesWithResponse(ctx context.Context, params *GetEdgeCloudZonesParams, reqEditors ...RequestEditorFn) (*GetEdgeCloudZonesResponse, error)
}

type GetAppInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AppInstaceInfo *[]AppInstanceInfo `json:"appInstaceInfo,omitempty"`
	}
	JSON401 *N401
	JSON403 *N403
	JSON404 *N404
	JSON500 *N500
	JSON503 *N503
}

// Status returns HTTPResponse.Status
func (r GetAppInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAppInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		AppInstaces *[]AppInstanceInfo `json:"appInstaces,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
	JSON403 *N403
	JSON409 *ErrorInfo
	JSON500 *N500
	JSON501 *N501
	JSON503 *N503
}

// Status returns HTTPResponse.Status
func (r CreateAppInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAppInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAppInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
	JSON500      *N500
	JSON503      *N503
}

// Status returns HTTPResponse.Status
func (r DeleteAppInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAppInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AppManifest
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
	JSON500      *N500
	JSON503      *N503
}

// Status returns HTTPResponse.Status
func (r GetAppsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SubmitAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SubmittedApp
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON409      *ErrorInfo
	JSON500      *N500
	JSON501      *N501
	JSON503      *N503
}

// Status returns HTTPResponse.Status
func (r SubmitAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SubmitAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
	JSON409      *ErrorInfo
	JSON500      *N500
	JSON503      *N503
}

// Status returns HTTPResponse.Status
func (r DeleteAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AppManifest Application information and requirements provided by the
		// Application Provider
		AppManifest *AppManifest `json:"appManifest,omitempty"`
	}
	JSON401 *N401
	JSON403 *N403
	JSON404 *N404
	JSON500 *N500
	JSON503 *N503
}

// Status returns HTTPResponse.Status
func (r GetAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEdgeCloudZonesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EdgeCloudZones
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
	JSON500      *N500
	JSON503      *N503
}

// Status returns HTTPResponse.Status
func (r GetEdgeCloudZonesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEdgeCloudZonesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAppInstanceWithResponse request returning *GetAppInstanceResponse
func (c *ClientWithResponses) GetAppInstanceWithResponse(ctx context.Context, params *GetAppInstanceParams, reqEditors ...RequestEditorFn) (*GetAppInstanceResponse, error) {
	rsp, err := c.GetAppInstance(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppInstanceResponse(rsp)
}

// CreateAppInstanceWithBodyWithResponse request with arbitrary body returning *CreateAppInstanceResponse
func (c *ClientWithResponses) CreateAppInstanceWithBodyWithResponse(ctx context.Context, params *CreateAppInstanceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAppInstanceResponse, error) {
	rsp, err := c.CreateAppInstanceWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAppInstanceResponse(rsp)
}

func (c *ClientWithResponses) CreateAppInstanceWithResponse(ctx context.Context, params *CreateAppInstanceParams, body CreateAppInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAppInstanceResponse, error) {
	rsp, err := c.CreateAppInstance(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAppInstanceResponse(rsp)
}

// DeleteAppInstanceWithResponse request returning *DeleteAppInstanceResponse
func (c *ClientWithResponses) DeleteAppInstanceWithResponse(ctx context.Context, appInstanceId AppInstanceId, params *DeleteAppInstanceParams, reqEditors ...RequestEditorFn) (*DeleteAppInstanceResponse, error) {
	rsp, err := c.DeleteAppInstance(ctx, appInstanceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAppInstanceResponse(rsp)
}

// GetAppsWithResponse request returning *GetAppsResponse
func (c *ClientWithResponses) GetAppsWithResponse(ctx context.Context, params *GetAppsParams, reqEditors ...RequestEditorFn) (*GetAppsResponse, error) {
	rsp, err := c.GetApps(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppsResponse(rsp)
}

// SubmitAppWithBodyWithResponse request with arbitrary body returning *SubmitAppResponse
func (c *ClientWithResponses) SubmitAppWithBodyWithResponse(ctx context.Context, params *SubmitAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SubmitAppResponse, error) {
	rsp, err := c.SubmitAppWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSubmitAppResponse(rsp)
}

func (c *ClientWithResponses) SubmitAppWithResponse(ctx context.Context, params *SubmitAppParams, body SubmitAppJSONRequestBody, reqEditors ...RequestEditorFn) (*SubmitAppResponse, error) {
	rsp, err := c.SubmitApp(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSubmitAppResponse(rsp)
}

// DeleteAppWithResponse request returning *DeleteAppResponse
func (c *ClientWithResponses) DeleteAppWithResponse(ctx context.Context, appId AppId, params *DeleteAppParams, reqEditors ...RequestEditorFn) (*DeleteAppResponse, error) {
	rsp, err := c.DeleteApp(ctx, appId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAppResponse(rsp)
}

// GetAppWithResponse request returning *GetAppResponse
func (c *ClientWithResponses) GetAppWithResponse(ctx context.Context, appId AppId, params *GetAppParams, reqEditors ...RequestEditorFn) (*GetAppResponse, error) {
	rsp, err := c.GetApp(ctx, appId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppResponse(rsp)
}

// GetEdgeCloudZonesWithResponse request returning *GetEdgeCloudZonesResponse
func (c *ClientWithResponses) GetEdgeCloudZonesWithResponse(ctx context.Context, params *GetEdgeCloudZonesParams, reqEditors ...RequestEditorFn) (*GetEdgeCloudZonesResponse, error) {
	rsp, err := c.GetEdgeCloudZones(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEdgeCloudZonesResponse(rsp)
}

// ParseGetAppInstanceResponse parses an HTTP response from a GetAppInstanceWithResponse call
func ParseGetAppInstanceResponse(rsp *http.Response) (*GetAppInstanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AppInstaceInfo *[]AppInstanceInfo `json:"appInstaceInfo,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest N503
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCreateAppInstanceResponse parses an HTTP response from a CreateAppInstanceWithResponse call
func ParseCreateAppInstanceResponse(rsp *http.Response) (*CreateAppInstanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAppInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			AppInstaces *[]AppInstanceInfo `json:"appInstaces,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest N501
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest N503
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDeleteAppInstanceResponse parses an HTTP response from a DeleteAppInstanceWithResponse call
func ParseDeleteAppInstanceResponse(rsp *http.Response) (*DeleteAppInstanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAppInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest N503
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetAppsResponse parses an HTTP response from a GetAppsWithResponse call
func ParseGetAppsResponse(rsp *http.Response) (*GetAppsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AppManifest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest N503
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSubmitAppResponse parses an HTTP response from a SubmitAppWithResponse call
func ParseSubmitAppResponse(rsp *http.Response) (*SubmitAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SubmitAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SubmittedApp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest N501
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest N503
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDeleteAppResponse parses an HTTP response from a DeleteAppWithResponse call
func ParseDeleteAppResponse(rsp *http.Response) (*DeleteAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest N503
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetAppResponse parses an HTTP response from a GetAppWithResponse call
func ParseGetAppResponse(rsp *http.Response) (*GetAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AppManifest Application information and requirements provided by the
			// Application Provider
			AppManifest *AppManifest `json:"appManifest,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest N503
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetEdgeCloudZonesResponse parses an HTTP response from a GetEdgeCloudZonesWithResponse call
func ParseGetEdgeCloudZonesResponse(rsp *http.Response) (*GetEdgeCloudZonesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEdgeCloudZonesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EdgeCloudZones
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest N503
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Retrieve the information of Application Instances for a given App
	// (GET /appinstances)
	GetAppInstance(ctx echo.Context, params GetAppInstanceParams) error
	// Instantiation of an Application
	// (POST /appinstances)
	CreateAppInstance(ctx echo.Context, params CreateAppInstanceParams) error
	// Terminate an Application Instance
	// (DELETE /appinstances/{appInstanceId})
	DeleteAppInstance(ctx echo.Context, appInstanceId AppInstanceId, params DeleteAppInstanceParams) error
	// Retrieve a list of existing Applications
	// (GET /apps)
	GetApps(ctx echo.Context, params GetAppsParams) error
	// Submit application metadata to the Edge Cloud Provider.
	// (POST /apps)
	SubmitApp(ctx echo.Context, params SubmitAppParams) error
	// Delete an Application from an Edge Cloud Provider
	// (DELETE /apps/{appId})
	DeleteApp(ctx echo.Context, appId AppId, params DeleteAppParams) error
	// Retrieve the information of an Application
	// (GET /apps/{appId})
	GetApp(ctx echo.Context, appId AppId, params GetAppParams) error
	// Retrieve a list of the operators Edge Cloud Zones and their status
	// (GET /edge-cloud-zones)
	GetEdgeCloudZones(ctx echo.Context, params GetEdgeCloudZonesParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetAppInstance converts echo context to params.
func (w *ServerInterfaceWrapper) GetAppInstance(ctx echo.Context) error {
	var err error

	ctx.Set(OpenIdScopes, []string{"edge-application-management:instances:read"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAppInstanceParams
	// ------------- Optional query parameter "appId" -------------

	err = runtime.BindQueryParameter("form", true, false, "appId", ctx.QueryParams(), &params.AppId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter appId: %s", err))
	}

	// ------------- Optional query parameter "appInstanceId" -------------

	err = runtime.BindQueryParameter("form", true, false, "appInstanceId", ctx.QueryParams(), &params.AppInstanceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter appInstanceId: %s", err))
	}

	// ------------- Optional query parameter "region" -------------

	err = runtime.BindQueryParameter("form", true, false, "region", ctx.QueryParams(), &params.Region)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter region: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "x-correlator" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-correlator")]; found {
		var XCorrelator XCorrelator
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-correlator, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-correlator", valueList[0], &XCorrelator, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-correlator: %s", err))
		}

		params.XCorrelator = &XCorrelator
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAppInstance(ctx, params)
	return err
}

// CreateAppInstance converts echo context to params.
func (w *ServerInterfaceWrapper) CreateAppInstance(ctx echo.Context) error {
	var err error

	ctx.Set(OpenIdScopes, []string{"edge-application-management:instances:write"})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateAppInstanceParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "x-correlator" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-correlator")]; found {
		var XCorrelator XCorrelator
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-correlator, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-correlator", valueList[0], &XCorrelator, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-correlator: %s", err))
		}

		params.XCorrelator = &XCorrelator
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateAppInstance(ctx, params)
	return err
}

// DeleteAppInstance converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteAppInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "appInstanceId" -------------
	var appInstanceId AppInstanceId

	err = runtime.BindStyledParameterWithOptions("simple", "appInstanceId", ctx.Param("appInstanceId"), &appInstanceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter appInstanceId: %s", err))
	}

	ctx.Set(OpenIdScopes, []string{"edge-application-management:instances:delete"})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteAppInstanceParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "x-correlator" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-correlator")]; found {
		var XCorrelator XCorrelator
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-correlator, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-correlator", valueList[0], &XCorrelator, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-correlator: %s", err))
		}

		params.XCorrelator = &XCorrelator
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteAppInstance(ctx, appInstanceId, params)
	return err
}

// GetApps converts echo context to params.
func (w *ServerInterfaceWrapper) GetApps(ctx echo.Context) error {
	var err error

	ctx.Set(OpenIdScopes, []string{"edge-application-management:apps:read"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAppsParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "x-correlator" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-correlator")]; found {
		var XCorrelator XCorrelator
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-correlator, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-correlator", valueList[0], &XCorrelator, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-correlator: %s", err))
		}

		params.XCorrelator = &XCorrelator
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApps(ctx, params)
	return err
}

// SubmitApp converts echo context to params.
func (w *ServerInterfaceWrapper) SubmitApp(ctx echo.Context) error {
	var err error

	ctx.Set(OpenIdScopes, []string{"edge-application-management:apps:write"})

	// Parameter object where we will unmarshal all parameters from the context
	var params SubmitAppParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "x-correlator" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-correlator")]; found {
		var XCorrelator XCorrelator
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-correlator, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-correlator", valueList[0], &XCorrelator, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-correlator: %s", err))
		}

		params.XCorrelator = &XCorrelator
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SubmitApp(ctx, params)
	return err
}

// DeleteApp converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteApp(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "appId" -------------
	var appId AppId

	err = runtime.BindStyledParameterWithOptions("simple", "appId", ctx.Param("appId"), &appId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter appId: %s", err))
	}

	ctx.Set(OpenIdScopes, []string{"edge-application-management:apps:delete"})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteAppParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "x-correlator" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-correlator")]; found {
		var XCorrelator XCorrelator
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-correlator, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-correlator", valueList[0], &XCorrelator, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-correlator: %s", err))
		}

		params.XCorrelator = &XCorrelator
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteApp(ctx, appId, params)
	return err
}

// GetApp converts echo context to params.
func (w *ServerInterfaceWrapper) GetApp(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "appId" -------------
	var appId AppId

	err = runtime.BindStyledParameterWithOptions("simple", "appId", ctx.Param("appId"), &appId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter appId: %s", err))
	}

	ctx.Set(OpenIdScopes, []string{"edge-application-management:apps:read"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAppParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "x-correlator" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-correlator")]; found {
		var XCorrelator XCorrelator
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-correlator, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-correlator", valueList[0], &XCorrelator, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-correlator: %s", err))
		}

		params.XCorrelator = &XCorrelator
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApp(ctx, appId, params)
	return err
}

// GetEdgeCloudZones converts echo context to params.
func (w *ServerInterfaceWrapper) GetEdgeCloudZones(ctx echo.Context) error {
	var err error

	ctx.Set(OpenIdScopes, []string{"edge-application-management:edge-cloud-zones:read"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetEdgeCloudZonesParams
	// ------------- Optional query parameter "region" -------------

	err = runtime.BindQueryParameter("form", true, false, "region", ctx.QueryParams(), &params.Region)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter region: %s", err))
	}

	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", true, false, "status", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter status: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "x-correlator" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-correlator")]; found {
		var XCorrelator XCorrelator
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-correlator, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-correlator", valueList[0], &XCorrelator, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-correlator: %s", err))
		}

		params.XCorrelator = &XCorrelator
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEdgeCloudZones(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/appinstances", wrapper.GetAppInstance)
	router.POST(baseURL+"/appinstances", wrapper.CreateAppInstance)
	router.DELETE(baseURL+"/appinstances/:appInstanceId", wrapper.DeleteAppInstance)
	router.GET(baseURL+"/apps", wrapper.GetApps)
	router.POST(baseURL+"/apps", wrapper.SubmitApp)
	router.DELETE(baseURL+"/apps/:appId", wrapper.DeleteApp)
	router.GET(baseURL+"/apps/:appId", wrapper.GetApp)
	router.GET(baseURL+"/edge-cloud-zones", wrapper.GetEdgeCloudZones)

}

type N400ResponseHeaders struct {
	XCorrelator openapi_types.UUID
}
type N400JSONResponse struct {
	Body ErrorInfo

	Headers N400ResponseHeaders
}

type N401ResponseHeaders struct {
	XCorrelator openapi_types.UUID
}
type N401JSONResponse struct {
	Body ErrorInfo

	Headers N401ResponseHeaders
}

type N403ResponseHeaders struct {
	XCorrelator openapi_types.UUID
}
type N403JSONResponse struct {
	Body ErrorInfo

	Headers N403ResponseHeaders
}

type N404ResponseHeaders struct {
	XCorrelator openapi_types.UUID
}
type N404JSONResponse struct {
	Body ErrorInfo

	Headers N404ResponseHeaders
}

type N500ResponseHeaders struct {
	XCorrelator openapi_types.UUID
}
type N500JSONResponse struct {
	Body ErrorInfo

	Headers N500ResponseHeaders
}

type N501ResponseHeaders struct {
	XCorrelator openapi_types.UUID
}
type N501JSONResponse struct {
	Body ErrorInfo

	Headers N501ResponseHeaders
}

type N503ResponseHeaders struct {
	XCorrelator openapi_types.UUID
}
type N503JSONResponse struct {
	Body ErrorInfo

	Headers N503ResponseHeaders
}

type GetAppInstanceRequestObject struct {
	Params GetAppInstanceParams
}

type GetAppInstanceResponseObject interface {
	VisitGetAppInstanceResponse(w http.ResponseWriter) error
}

type GetAppInstance200ResponseHeaders struct {
	XCorrelator openapi_types.UUID
}

type GetAppInstance200JSONResponse struct {
	Body struct {
		AppInstaceInfo *[]AppInstanceInfo `json:"appInstaceInfo,omitempty"`
	}
	Headers GetAppInstance200ResponseHeaders
}

func (response GetAppInstance200JSONResponse) VisitGetAppInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("x-correlator", fmt.Sprint(response.Headers.XCorrelator))
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetAppInstance401JSONResponse struct{ N401JSONResponse }

func (response GetAppInstance401JSONResponse) VisitGetAppInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("x-correlator", fmt.Sprint(response.Headers.XCorrelator))
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetAppInstance403JSONResponse struct{ N403JSONResponse }

func (response GetAppInstance403JSONResponse) VisitGetAppInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("x-correlator", fmt.Sprint(response.Headers.XCorrelator))
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetAppInstance404JSONResponse struct{ N404JSONResponse }

func (response GetAppInstance404JSONResponse) VisitGetAppInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("x-correlator", fmt.Sprint(response.Headers.XCorrelator))
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetAppInstance500JSONResponse struct{ N500JSONResponse }

func (response GetAppInstance500JSONResponse) VisitGetAppInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("x-correlator", fmt.Sprint(response.Headers.XCorrelator))
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetAppInstance503JSONResponse struct{ N503JSONResponse }

func (response GetAppInstance503JSONResponse) VisitGetAppInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("x-correlator", fmt.Sprint(response.Headers.XCorrelator))
	w.WriteHeader(503)

	return json.NewEncoder(w).Encode(response.Body)
}

type CreateAppInstanceRequestObject struct {
	Params CreateAppInstanceParams
	Body   *CreateAppInstanceJSONRequestBody
}

type CreateAppInstanceResponseObject interface {
	VisitCreateAppInstanceResponse(w http.ResponseWriter) error
}

type CreateAppInstance202ResponseHeaders struct {
	Location    string
	XCorrelator openapi_types.UUID
}

type CreateAppInstance202JSONResponse struct {
	Body struct {
		AppInstaces *[]AppInstanceInfo `json:"appInstaces,omitempty"`
	}
	Headers CreateAppInstance202ResponseHeaders
}

func (response CreateAppInstance202JSONResponse) VisitCreateAppInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Location", fmt.Sprint(response.Headers.Location))
	w.Header().Set("x-correlator", fmt.Sprint(response.Headers.XCorrelator))
	w.WriteHeader(202)

	return json.NewEncoder(w).Encode(response.Body)
}

type CreateAppInstance400JSONResponse struct{ N400JSONResponse }

func (response CreateAppInstance400JSONResponse) VisitCreateAppInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("x-correlator", fmt.Sprint(response.Headers.XCorrelator))
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response.Body)
}

type CreateAppInstance401JSONResponse struct{ N401JSONResponse }

func (response CreateAppInstance401JSONResponse) VisitCreateAppInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("x-correlator", fmt.Sprint(response.Headers.XCorrelator))
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response.Body)
}

type CreateAppInstance403JSONResponse struct{ N403JSONResponse }

func (response CreateAppInstance403JSONResponse) VisitCreateAppInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("x-correlator", fmt.Sprint(response.Headers.XCorrelator))
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response.Body)
}

type CreateAppInstance409JSONResponse ErrorInfo

func (response CreateAppInstance409JSONResponse) VisitCreateAppInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(409)

	return json.NewEncoder(w).Encode(response)
}

type CreateAppInstance500JSONResponse struct{ N500JSONResponse }

func (response CreateAppInstance500JSONResponse) VisitCreateAppInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("x-correlator", fmt.Sprint(response.Headers.XCorrelator))
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response.Body)
}

type CreateAppInstance501JSONResponse struct{ N501JSONResponse }

func (response CreateAppInstance501JSONResponse) VisitCreateAppInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("x-correlator", fmt.Sprint(response.Headers.XCorrelator))
	w.WriteHeader(501)

	return json.NewEncoder(w).Encode(response.Body)
}

type CreateAppInstance503JSONResponse struct{ N503JSONResponse }

func (response CreateAppInstance503JSONResponse) VisitCreateAppInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("x-correlator", fmt.Sprint(response.Headers.XCorrelator))
	w.WriteHeader(503)

	return json.NewEncoder(w).Encode(response.Body)
}

type DeleteAppInstanceRequestObject struct {
	AppInstanceId AppInstanceId `json:"appInstanceId"`
	Params        DeleteAppInstanceParams
}

type DeleteAppInstanceResponseObject interface {
	VisitDeleteAppInstanceResponse(w http.ResponseWriter) error
}

type DeleteAppInstance202ResponseHeaders struct {
	XCorrelator openapi_types.UUID
}

type DeleteAppInstance202Response struct {
	Headers DeleteAppInstance202ResponseHeaders
}

func (response DeleteAppInstance202Response) VisitDeleteAppInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("x-correlator", fmt.Sprint(response.Headers.XCorrelator))
	w.WriteHeader(202)
	return nil
}

type DeleteAppInstance204Response struct {
}

func (response DeleteAppInstance204Response) VisitDeleteAppInstanceResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type DeleteAppInstance400JSONResponse struct{ N400JSONResponse }

func (response DeleteAppInstance400JSONResponse) VisitDeleteAppInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("x-correlator", fmt.Sprint(response.Headers.XCorrelator))
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response.Body)
}

type DeleteAppInstance401JSONResponse struct{ N401JSONResponse }

func (response DeleteAppInstance401JSONResponse) VisitDeleteAppInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("x-correlator", fmt.Sprint(response.Headers.XCorrelator))
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response.Body)
}

type DeleteAppInstance403JSONResponse struct{ N403JSONResponse }

func (response DeleteAppInstance403JSONResponse) VisitDeleteAppInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("x-correlator", fmt.Sprint(response.Headers.XCorrelator))
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response.Body)
}

type DeleteAppInstance404JSONResponse struct{ N404JSONResponse }

func (response DeleteAppInstance404JSONResponse) VisitDeleteAppInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("x-correlator", fmt.Sprint(response.Headers.XCorrelator))
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response.Body)
}

type DeleteAppInstance500JSONResponse struct{ N500JSONResponse }

func (response DeleteAppInstance500JSONResponse) VisitDeleteAppInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("x-correlator", fmt.Sprint(response.Headers.XCorrelator))
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response.Body)
}

type DeleteAppInstance503JSONResponse struct{ N503JSONResponse }

func (response DeleteAppInstance503JSONResponse) VisitDeleteAppInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("x-correlator", fmt.Sprint(response.Headers.XCorrelator))
	w.WriteHeader(503)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetAppsRequestObject struct {
	Params GetAppsParams
}

type GetAppsResponseObject interface {
	VisitGetAppsResponse(w http.ResponseWriter) error
}

type GetApps200ResponseHeaders struct {
	XCorrelator openapi_types.UUID
}

type GetApps200JSONResponse struct {
	Body    []AppManifest
	Headers GetApps200ResponseHeaders
}

func (response GetApps200JSONResponse) VisitGetAppsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("x-correlator", fmt.Sprint(response.Headers.XCorrelator))
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetApps401JSONResponse struct{ N401JSONResponse }

func (response GetApps401JSONResponse) VisitGetAppsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("x-correlator", fmt.Sprint(response.Headers.XCorrelator))
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetApps403JSONResponse struct{ N403JSONResponse }

func (response GetApps403JSONResponse) VisitGetAppsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("x-correlator", fmt.Sprint(response.Headers.XCorrelator))
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetApps404JSONResponse struct{ N404JSONResponse }

func (response GetApps404JSONResponse) VisitGetAppsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("x-correlator", fmt.Sprint(response.Headers.XCorrelator))
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetApps500JSONResponse struct{ N500JSONResponse }

func (response GetApps500JSONResponse) VisitGetAppsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("x-correlator", fmt.Sprint(response.Headers.XCorrelator))
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetApps503JSONResponse struct{ N503JSONResponse }

func (response GetApps503JSONResponse) VisitGetAppsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("x-correlator", fmt.Sprint(response.Headers.XCorrelator))
	w.WriteHeader(503)

	return json.NewEncoder(w).Encode(response.Body)
}

type SubmitAppRequestObject struct {
	Params SubmitAppParams
	Body   *SubmitAppJSONRequestBody
}

type SubmitAppResponseObject interface {
	VisitSubmitAppResponse(w http.ResponseWriter) error
}

type SubmitApp201ResponseHeaders struct {
	XCorrelator openapi_types.UUID
}

type SubmitApp201JSONResponse struct {
	Body    SubmittedApp
	Headers SubmitApp201ResponseHeaders
}

func (response SubmitApp201JSONResponse) VisitSubmitAppResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("x-correlator", fmt.Sprint(response.Headers.XCorrelator))
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response.Body)
}

type SubmitApp400JSONResponse struct{ N400JSONResponse }

func (response SubmitApp400JSONResponse) VisitSubmitAppResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("x-correlator", fmt.Sprint(response.Headers.XCorrelator))
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response.Body)
}

type SubmitApp401JSONResponse struct{ N401JSONResponse }

func (response SubmitApp401JSONResponse) VisitSubmitAppResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("x-correlator", fmt.Sprint(response.Headers.XCorrelator))
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response.Body)
}

type SubmitApp403JSONResponse struct{ N403JSONResponse }

func (response SubmitApp403JSONResponse) VisitSubmitAppResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("x-correlator", fmt.Sprint(response.Headers.XCorrelator))
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response.Body)
}

type SubmitApp409JSONResponse ErrorInfo

func (response SubmitApp409JSONResponse) VisitSubmitAppResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(409)

	return json.NewEncoder(w).Encode(response)
}

type SubmitApp500JSONResponse struct{ N500JSONResponse }

func (response SubmitApp500JSONResponse) VisitSubmitAppResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("x-correlator", fmt.Sprint(response.Headers.XCorrelator))
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response.Body)
}

type SubmitApp501JSONResponse struct{ N501JSONResponse }

func (response SubmitApp501JSONResponse) VisitSubmitAppResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("x-correlator", fmt.Sprint(response.Headers.XCorrelator))
	w.WriteHeader(501)

	return json.NewEncoder(w).Encode(response.Body)
}

type SubmitApp503JSONResponse struct{ N503JSONResponse }

func (response SubmitApp503JSONResponse) VisitSubmitAppResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("x-correlator", fmt.Sprint(response.Headers.XCorrelator))
	w.WriteHeader(503)

	return json.NewEncoder(w).Encode(response.Body)
}

type DeleteAppRequestObject struct {
	AppId  AppId `json:"appId"`
	Params DeleteAppParams
}

type DeleteAppResponseObject interface {
	VisitDeleteAppResponse(w http.ResponseWriter) error
}

type DeleteApp202ResponseHeaders struct {
	XCorrelator openapi_types.UUID
}

type DeleteApp202Response struct {
	Headers DeleteApp202ResponseHeaders
}

func (response DeleteApp202Response) VisitDeleteAppResponse(w http.ResponseWriter) error {
	w.Header().Set("x-correlator", fmt.Sprint(response.Headers.XCorrelator))
	w.WriteHeader(202)
	return nil
}

type DeleteApp204Response struct {
}

func (response DeleteApp204Response) VisitDeleteAppResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type DeleteApp400JSONResponse struct{ N400JSONResponse }

func (response DeleteApp400JSONResponse) VisitDeleteAppResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("x-correlator", fmt.Sprint(response.Headers.XCorrelator))
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response.Body)
}

type DeleteApp401JSONResponse struct{ N401JSONResponse }

func (response DeleteApp401JSONResponse) VisitDeleteAppResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("x-correlator", fmt.Sprint(response.Headers.XCorrelator))
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response.Body)
}

type DeleteApp403JSONResponse struct{ N403JSONResponse }

func (response DeleteApp403JSONResponse) VisitDeleteAppResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("x-correlator", fmt.Sprint(response.Headers.XCorrelator))
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response.Body)
}

type DeleteApp404JSONResponse struct{ N404JSONResponse }

func (response DeleteApp404JSONResponse) VisitDeleteAppResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("x-correlator", fmt.Sprint(response.Headers.XCorrelator))
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response.Body)
}

type DeleteApp409JSONResponse ErrorInfo

func (response DeleteApp409JSONResponse) VisitDeleteAppResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(409)

	return json.NewEncoder(w).Encode(response)
}

type DeleteApp500JSONResponse struct{ N500JSONResponse }

func (response DeleteApp500JSONResponse) VisitDeleteAppResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("x-correlator", fmt.Sprint(response.Headers.XCorrelator))
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response.Body)
}

type DeleteApp503JSONResponse struct{ N503JSONResponse }

func (response DeleteApp503JSONResponse) VisitDeleteAppResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("x-correlator", fmt.Sprint(response.Headers.XCorrelator))
	w.WriteHeader(503)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetAppRequestObject struct {
	AppId  AppId `json:"appId"`
	Params GetAppParams
}

type GetAppResponseObject interface {
	VisitGetAppResponse(w http.ResponseWriter) error
}

type GetApp200ResponseHeaders struct {
	XCorrelator openapi_types.UUID
}

type GetApp200JSONResponse struct {
	Body struct {
		// AppManifest Application information and requirements provided by the
		// Application Provider
		AppManifest *AppManifest `json:"appManifest,omitempty"`
	}
	Headers GetApp200ResponseHeaders
}

func (response GetApp200JSONResponse) VisitGetAppResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("x-correlator", fmt.Sprint(response.Headers.XCorrelator))
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetApp401JSONResponse struct{ N401JSONResponse }

func (response GetApp401JSONResponse) VisitGetAppResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("x-correlator", fmt.Sprint(response.Headers.XCorrelator))
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetApp403JSONResponse struct{ N403JSONResponse }

func (response GetApp403JSONResponse) VisitGetAppResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("x-correlator", fmt.Sprint(response.Headers.XCorrelator))
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetApp404JSONResponse struct{ N404JSONResponse }

func (response GetApp404JSONResponse) VisitGetAppResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("x-correlator", fmt.Sprint(response.Headers.XCorrelator))
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetApp500JSONResponse struct{ N500JSONResponse }

func (response GetApp500JSONResponse) VisitGetAppResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("x-correlator", fmt.Sprint(response.Headers.XCorrelator))
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetApp503JSONResponse struct{ N503JSONResponse }

func (response GetApp503JSONResponse) VisitGetAppResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("x-correlator", fmt.Sprint(response.Headers.XCorrelator))
	w.WriteHeader(503)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetEdgeCloudZonesRequestObject struct {
	Params GetEdgeCloudZonesParams
}

type GetEdgeCloudZonesResponseObject interface {
	VisitGetEdgeCloudZonesResponse(w http.ResponseWriter) error
}

type GetEdgeCloudZones200ResponseHeaders struct {
	XCorrelator openapi_types.UUID
}

type GetEdgeCloudZones200JSONResponse struct {
	Body    EdgeCloudZones
	Headers GetEdgeCloudZones200ResponseHeaders
}

func (response GetEdgeCloudZones200JSONResponse) VisitGetEdgeCloudZonesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("x-correlator", fmt.Sprint(response.Headers.XCorrelator))
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetEdgeCloudZones401JSONResponse struct{ N401JSONResponse }

func (response GetEdgeCloudZones401JSONResponse) VisitGetEdgeCloudZonesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("x-correlator", fmt.Sprint(response.Headers.XCorrelator))
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetEdgeCloudZones403JSONResponse struct{ N403JSONResponse }

func (response GetEdgeCloudZones403JSONResponse) VisitGetEdgeCloudZonesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("x-correlator", fmt.Sprint(response.Headers.XCorrelator))
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetEdgeCloudZones404JSONResponse struct{ N404JSONResponse }

func (response GetEdgeCloudZones404JSONResponse) VisitGetEdgeCloudZonesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("x-correlator", fmt.Sprint(response.Headers.XCorrelator))
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetEdgeCloudZones500JSONResponse struct{ N500JSONResponse }

func (response GetEdgeCloudZones500JSONResponse) VisitGetEdgeCloudZonesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("x-correlator", fmt.Sprint(response.Headers.XCorrelator))
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetEdgeCloudZones503JSONResponse struct{ N503JSONResponse }

func (response GetEdgeCloudZones503JSONResponse) VisitGetEdgeCloudZonesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("x-correlator", fmt.Sprint(response.Headers.XCorrelator))
	w.WriteHeader(503)

	return json.NewEncoder(w).Encode(response.Body)
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// Retrieve the information of Application Instances for a given App
	// (GET /appinstances)
	GetAppInstance(ctx context.Context, request GetAppInstanceRequestObject) (GetAppInstanceResponseObject, error)
	// Instantiation of an Application
	// (POST /appinstances)
	CreateAppInstance(ctx context.Context, request CreateAppInstanceRequestObject) (CreateAppInstanceResponseObject, error)
	// Terminate an Application Instance
	// (DELETE /appinstances/{appInstanceId})
	DeleteAppInstance(ctx context.Context, request DeleteAppInstanceRequestObject) (DeleteAppInstanceResponseObject, error)
	// Retrieve a list of existing Applications
	// (GET /apps)
	GetApps(ctx context.Context, request GetAppsRequestObject) (GetAppsResponseObject, error)
	// Submit application metadata to the Edge Cloud Provider.
	// (POST /apps)
	SubmitApp(ctx context.Context, request SubmitAppRequestObject) (SubmitAppResponseObject, error)
	// Delete an Application from an Edge Cloud Provider
	// (DELETE /apps/{appId})
	DeleteApp(ctx context.Context, request DeleteAppRequestObject) (DeleteAppResponseObject, error)
	// Retrieve the information of an Application
	// (GET /apps/{appId})
	GetApp(ctx context.Context, request GetAppRequestObject) (GetAppResponseObject, error)
	// Retrieve a list of the operators Edge Cloud Zones and their status
	// (GET /edge-cloud-zones)
	GetEdgeCloudZones(ctx context.Context, request GetEdgeCloudZonesRequestObject) (GetEdgeCloudZonesResponseObject, error)
}

type StrictHandlerFunc = strictecho.StrictEchoHandlerFunc
type StrictMiddlewareFunc = strictecho.StrictEchoMiddlewareFunc

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
}

// GetAppInstance operation middleware
func (sh *strictHandler) GetAppInstance(ctx echo.Context, params GetAppInstanceParams) error {
	var request GetAppInstanceRequestObject

	request.Params = params

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetAppInstance(ctx.Request().Context(), request.(GetAppInstanceRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetAppInstance")
	}

	response, err := handler(ctx, request)

	if err != nil {
		return err
	} else if validResponse, ok := response.(GetAppInstanceResponseObject); ok {
		return validResponse.VisitGetAppInstanceResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// CreateAppInstance operation middleware
func (sh *strictHandler) CreateAppInstance(ctx echo.Context, params CreateAppInstanceParams) error {
	var request CreateAppInstanceRequestObject

	request.Params = params

	var body CreateAppInstanceJSONRequestBody
	if err := ctx.Bind(&body); err != nil {
		return err
	}
	request.Body = &body

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.CreateAppInstance(ctx.Request().Context(), request.(CreateAppInstanceRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CreateAppInstance")
	}

	response, err := handler(ctx, request)

	if err != nil {
		return err
	} else if validResponse, ok := response.(CreateAppInstanceResponseObject); ok {
		return validResponse.VisitCreateAppInstanceResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// DeleteAppInstance operation middleware
func (sh *strictHandler) DeleteAppInstance(ctx echo.Context, appInstanceId AppInstanceId, params DeleteAppInstanceParams) error {
	var request DeleteAppInstanceRequestObject

	request.AppInstanceId = appInstanceId
	request.Params = params

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteAppInstance(ctx.Request().Context(), request.(DeleteAppInstanceRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteAppInstance")
	}

	response, err := handler(ctx, request)

	if err != nil {
		return err
	} else if validResponse, ok := response.(DeleteAppInstanceResponseObject); ok {
		return validResponse.VisitDeleteAppInstanceResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetApps operation middleware
func (sh *strictHandler) GetApps(ctx echo.Context, params GetAppsParams) error {
	var request GetAppsRequestObject

	request.Params = params

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetApps(ctx.Request().Context(), request.(GetAppsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetApps")
	}

	response, err := handler(ctx, request)

	if err != nil {
		return err
	} else if validResponse, ok := response.(GetAppsResponseObject); ok {
		return validResponse.VisitGetAppsResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// SubmitApp operation middleware
func (sh *strictHandler) SubmitApp(ctx echo.Context, params SubmitAppParams) error {
	var request SubmitAppRequestObject

	request.Params = params

	var body SubmitAppJSONRequestBody
	if err := ctx.Bind(&body); err != nil {
		return err
	}
	request.Body = &body

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.SubmitApp(ctx.Request().Context(), request.(SubmitAppRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "SubmitApp")
	}

	response, err := handler(ctx, request)

	if err != nil {
		return err
	} else if validResponse, ok := response.(SubmitAppResponseObject); ok {
		return validResponse.VisitSubmitAppResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// DeleteApp operation middleware
func (sh *strictHandler) DeleteApp(ctx echo.Context, appId AppId, params DeleteAppParams) error {
	var request DeleteAppRequestObject

	request.AppId = appId
	request.Params = params

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteApp(ctx.Request().Context(), request.(DeleteAppRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteApp")
	}

	response, err := handler(ctx, request)

	if err != nil {
		return err
	} else if validResponse, ok := response.(DeleteAppResponseObject); ok {
		return validResponse.VisitDeleteAppResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetApp operation middleware
func (sh *strictHandler) GetApp(ctx echo.Context, appId AppId, params GetAppParams) error {
	var request GetAppRequestObject

	request.AppId = appId
	request.Params = params

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetApp(ctx.Request().Context(), request.(GetAppRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetApp")
	}

	response, err := handler(ctx, request)

	if err != nil {
		return err
	} else if validResponse, ok := response.(GetAppResponseObject); ok {
		return validResponse.VisitGetAppResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetEdgeCloudZones operation middleware
func (sh *strictHandler) GetEdgeCloudZones(ctx echo.Context, params GetEdgeCloudZonesParams) error {
	var request GetEdgeCloudZonesRequestObject

	request.Params = params

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetEdgeCloudZones(ctx.Request().Context(), request.(GetEdgeCloudZonesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetEdgeCloudZones")
	}

	response, err := handler(ctx, request)

	if err != nil {
		return err
	} else if validResponse, ok := response.(GetEdgeCloudZonesResponseObject); ok {
		return validResponse.VisitGetEdgeCloudZonesResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}
